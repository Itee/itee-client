<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>Itee-Client Source: sources/loaders/TBinaryReader.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.dark.css">

	<link type="text/css" rel="stylesheet" href="styles/site.cyborg.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top ">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">Itee-Client</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="modules.list.html" class="dropdown-toggle" data-toggle="dropdown">Modules<b class="caret"></b></a>
				<ul class="dropdown-menu inline">
					<li><a href="module-Config-EsLint.html">Config-EsLint</a></li><li><a href="module-Config-JsDoc.html">Config-JsDoc</a></li><li><a href="module-Config-Karma-Benchs.html">Config-Karma-Benchs</a></li><li><a href="module-Config-Karma-Units.html">Config-Karma-Units</a></li><li><a href="module-Config-Rollup.html">Config-Rollup</a></li><li><a href="module-configs_Rollup-Test.html">configs/Rollup-Test</a></li><li><a href="module-InputDevice.html">InputDevice</a></li><li><a href="module-Loaders.html">Loaders</a></li><li><a href="module-Managers.html">Managers</a></li><li><a href="module-WebAPI.html">WebAPI</a></li><li><a href="module-WebAPI_Messages.html">WebAPI/Messages</a></li><li><a href="module-Workers.html">Workers</a></li><li><a href="module-Workers_Messages.html">Workers/Messages</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu inline">
					<li><a href="AbstractWorker.html">AbstractWorker</a></li><li><a href="IdGenerator.html">IdGenerator</a></li><li><a href="TAbstractFactory.html">TAbstractFactory</a></li><li><a href="TBinaryReader.html">TBinaryReader</a></li><li><a href="TBinaryWriter.html">TBinaryWriter</a></li><li><a href="TCloningFactory.html">TCloningFactory</a></li><li><a href="TDataBaseManager.html">TDataBaseManager</a></li><li><a href="TIdFactory.html">TIdFactory</a></li><li><a href="TInstancingFactory.html">TInstancingFactory</a></li><li><a href="TKeyboardController.html">TKeyboardController</a></li><li><a href="TMouseController.html">TMouseController</a></li><li><a href="TStore.html">TStore</a></li><li><a href="WebAPI.html">WebAPI</a></li><li><a href="WebAPIMessage.html">WebAPIMessage</a></li><li><a href="WebAPIMessageData.html">WebAPIMessageData</a></li><li><a href="WebAPIMessageError.html">WebAPIMessageError</a></li><li><a href="WebAPIMessageEvent.html">WebAPIMessageEvent</a></li><li><a href="WebAPIMessageProgress.html">WebAPIMessageProgress</a></li><li><a href="WebAPIMessageReady.html">WebAPIMessageReady</a></li><li><a href="WebAPIMessageRequest.html">WebAPIMessageRequest</a></li><li><a href="WebAPIMessageResponse.html">WebAPIMessageResponse</a></li><li><a href="WorkerMessage.html">WorkerMessage</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Global<b class="caret"></b></a>
				<ul class="dropdown-menu inline">
					<li><a href="global.html#Byte">Byte</a></li><li><a href="global.html#Endianness">Endianness</a></li><li><a href="global.html#Enum">Enum</a></li><li><a href="global.html#FileFormat">FileFormat</a></li><li><a href="global.html#HttpStatusCode">HttpStatusCode</a></li><li><a href="global.html#HttpVerb">HttpVerb</a></li><li><a href="global.html#Keys">Keys</a></li><li><a href="global.html#MimeType">MimeType</a></li><li><a href="global.html#Mouse">Mouse</a></li><li><a href="global.html#RequestType">RequestType</a></li><li><a href="global.html#ResponseType">ResponseType</a></li><li><a href="global.html#TIdFactoryType">TIdFactoryType</a></li>
				</ul>
			</li>
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			

		<h1 class="page-title">Source: sources/loaders/TBinaryReader.js</h1>
    
<section>
    <article>
        <pre
            class="sunlight-highlight-javascript linenums">import { toEnum } from 'itee-utils'
import {
    isNotArrayBuffer,
    isNotBoolean,
    isNotNumber,
    isNull,
    isUndefined
}                 from 'itee-validators'

/* eslint-env browser */

/**
 * @typedef {Enum} Endianness
 * @property {Boolean} Little=true - The Little endianess
 * @property {Number} Big=false - The Big endianess
 *
 * @constant
 * @type {Endianness}
 * @description Endianness enum allow semantic usage.
 */
const Endianness = toEnum( {
    Little: true,
    Big:    false
} )

/**
 * @typedef {Enum} Byte
 * @property {Number} One=1 - Octet
 * @property {Number} Two=2 - Doublet
 * @property {Number} Four=4 - Quadlet
 * @property {Number} Height=8 - Octlet
 *
 * @constant
 * @type {Byte}
 * @description Byte allow semantic meaning of quantity of bytes based on power of two.
 */
const Byte = toEnum( {
    One:   1,
    Two:   2,
    Four:  4,
    Eight: 8
} )


/**
 * @class
 * @classdesc TBinaryReader is design to perform fast binary read/write
 *
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 */
class TBinaryReader {

    /**
     * @constructor
     * @param [parameters]
     * @param parameters.buffer
     * @param parameters.offset
     * @param parameters.length
     * @param parameters.endianness
     */
    constructor ( parameters = {} ) {

        const _parameters = {
            ...{
                buffer:     new ArrayBuffer( 0 ),
                offset:     0,
                length:     0,
                endianness: Endianness.Little
            },
            ...parameters
        }

        this.buffer = _parameters.buffer
        //        this.offset     = _parameters.offset
        //        this.length     = _parameters.length
        this.endianness = _parameters.endianness

        // For bit reading use same approche than byte
        this._bits = {
            buffer: null,
            offset: 0,
            length: 0
        }

        this._updateDataView()

    }

    /**
     *
     * @returns {*}
     */
    get buffer () {
        return this._buffer
    }

    set buffer ( value ) {

        const memberName = 'Buffer'
        const expect     = 'Expect an instance of ArrayBuffer.'

        if ( isNull( value ) ) { throw new TypeError( `${ memberName } cannot be null ! ${ expect }` ) }
        if ( isUndefined( value ) ) { throw new TypeError( `${ memberName } cannot be undefined ! ${ expect }` ) }
        if ( isNotArrayBuffer( value ) ) { throw new TypeError( `${ memberName } cannot be an instance of ${ value.constructor.name } ! ${ expect }` ) }

        this._buffer = value
        this._offset = 0
        this._length = value.byteLength

        this._updateDataView()

    }

    /**
     *
     * @returns {*}
     */
    get offset () {
        return this._offset
    }

    set offset ( value ) {

        const memberName = 'Offset'
        const expect     = 'Expect a number.'

        if ( isNull( value ) ) { throw new TypeError( `${ memberName } cannot be null ! ${ expect }` ) }
        if ( isUndefined( value ) ) { throw new TypeError( `${ memberName } cannot be undefined ! ${ expect }` ) }
        if ( isNotNumber( value ) ) { throw new TypeError( `${ memberName } cannot be an instance of ${ value.constructor.name } ! ${ expect }` ) }

        this._offset = value

        this._updateDataView()

    }

    get length () {
        return this._length
    }

    /**
     *
     * @param value
     */
    set length ( value ) {

        const memberName = 'Length'
        const expect     = 'Expect a number.'

        if ( isNull( value ) ) { throw new TypeError( `${ memberName } cannot be null ! ${ expect }` ) }
        if ( isUndefined( value ) ) { throw new TypeError( `${ memberName } cannot be undefined ! ${ expect }` ) }
        if ( isNotNumber( value ) ) { throw new TypeError( `${ memberName } cannot be an instance of ${ value.constructor.name } ! ${ expect }` ) }

        this._length = value

        this._updateDataView()

    }

    /**
     *
     * @returns {*}
     */
    get endianness () {
        return this._endianness
    }

    set endianness ( value ) {

        const memberName = 'Endianness'
        const expect     = 'Expect a boolean.'

        if ( isNull( value ) ) { throw new TypeError( `${ memberName } cannot be null ! ${ expect }` ) }
        if ( isUndefined( value ) ) { throw new TypeError( `${ memberName } cannot be undefined ! ${ expect }` ) }
        if ( isNotBoolean( value ) ) { throw new TypeError( `${ memberName } cannot be an instance of ${ value.constructor.name } ! ${ expect }` ) }

        this._endianness = value
    }

    /**
     *
     * @param buffer
     * @param offset
     * @param length
     * @returns {TBinaryReader}
     */
    setBuffer ( buffer, offset, length ) {

        this.buffer = buffer
        this.offset = offset || 0
        this.length = length || buffer.byteLength

        return this

    }

    /**
     *
     * @param value
     * @returns {TBinaryReader}
     */
    setOffset ( value ) {

        this.offset = value
        return this

    }

    /**
     *
     * @param value
     * @returns {TBinaryReader}
     */
    setLength ( value ) {

        this.length = value
        return this

    }

    /**
     *
     * @param endianness
     * @returns {TBinaryReader}
     */
    setEndianness ( endianness ) {

        this.endianness = endianness
        return this

    }

    /**
     *
     * @param increment
     * @returns {*}
     * @private
     */
    _getAndUpdateOffsetBy ( increment ) {

        const currentOffset = this._offset
        this._offset += increment

        return currentOffset

    }

    /**
     *
     * @private
     */
    _updateDataView () {

        this._dataView = new DataView( this._buffer, this._offset, this._length )

    }

    /**
     *
     * @returns {boolean}
     */
    isEndOfFile () {

        return ( this._offset === this._length )

    }

    // Bits

    _isNullBitBuffer () {

        return this._bits.buffer === null

    }
    _nextBit () {
        this._bits.offset += 1
    }
    _isEndOfBitBuffer () {

        return this._bits.offset === this._bits.length

    }
    _isOutOfRangeBitOffset ( offset ) {
        return offset > this._bits.length
    }
    _readBit8 () {
        this._bits.buffer = this.getUint8()
        this._bits.length = 8
        this._bits.offset = 0
    }
    _readBit16 () {
        this._bits.buffer = this.getUint16()
        this._bits.length = 16
        this._bits.offset = 0
    }
    _readBit32 () {
        this._bits.buffer = this.getUint32()
        this._bits.length = 32
        this._bits.offset = 0
    }
    _getBitAt ( bitOffset ) {

        return ( this._bits.buffer &amp; ( 1 &lt;&lt; bitOffset ) ) === 0 ? 0 : 1

    }
    _resetBits () {
        this._bits.buffer = null
        this._bits.length = 0
        this._bits.offset = 0
    }

    skipBitOffsetTo ( bitOffset ) {
        //todo is positive bitoffset

        // In case we start directly by a skip offset try to determine which kind of data is expected
        if ( this._isNullBitBuffer() ) {

            if ( bitOffset &lt;= 8 ) {

                this._readBit8()

            } else if ( 8 &lt; bitOffset &amp;&amp; bitOffset &lt;= 16 ) {

                this._readBit16()

            } else if ( 16 &lt; bitOffset &amp;&amp; bitOffset &lt;= 32 ) {

                this._readBit32()

            } else {

                throw new RangeError( 'You cannot skip more than 32 bits. Please use skipOffsetOf instead !' )

            }

        } else if ( this._isOutOfRangeBitOffset( bitOffset ) ) { throw new RangeError( 'Bit offset is out of range of the current bits field.' ) }

        this._bits.offset = bitOffset
        if ( this._isEndOfBitBuffer() ) {
            this._resetBits()
        }

    }

    skipBitOffsetOf ( nBits ) {

        this.skipBitOffsetTo( this._bits.offset + nBits )

    }

    getBit8 ( moveNext = true ) {

        if ( this._isNullBitBuffer() ) {
            this._readBit8()
        }

        const bitValue = this._getBitAt( this._bits.offset )

        if ( moveNext ) {
            this._nextBit()
            if ( this._isEndOfBitBuffer() ) {
                this._resetBits()
            }
        }

        return bitValue

    }

    getBits8 ( numberOfBitToRead, moveNext = true ) {

        const currentOffset = this._bits.offset

        let bits = 0

        // In last turn avoid bits reset if move next is false,
        // else the skipBitOffset will be based on reseted/null bit buffer
        for ( let i = 0 ; i &lt; numberOfBitToRead ; i++ ) {
            if ( i === numberOfBitToRead - 1 ) {
                bits |= ( this.getBit8( moveNext ) &lt;&lt; i )
            } else {
                bits |= ( this.getBit8() &lt;&lt; i )
            }
        }

        if ( !moveNext ) {
            this.skipBitOffsetTo( currentOffset )
        }

        return bits

    }

    getBit16 ( moveNext = true ) {

        if ( this._isNullBitBuffer() ) {
            this._readBit16()
        }

        const bitValue = this._getBitAt( this._bits.offset )

        if ( moveNext ) {
            this._nextBit()
            if ( this._isEndOfBitBuffer() ) {
                this._resetBits()
            }
        }

        return bitValue

    }

    getBits16 ( numberOfBitToRead, moveNext = true ) {

        const currentOffset = this._bits.offset

        let bits = 0

        // In last turn avoid bits reset if move next is false,
        // else the skipBitOffset will be based on reseted/null bit buffer
        for ( let i = 0 ; i &lt; numberOfBitToRead ; i++ ) {
            if ( i === numberOfBitToRead - 1 ) {
                bits |= ( this.getBit16( moveNext ) &lt;&lt; i )
            } else {
                bits |= ( this.getBit16() &lt;&lt; i )
            }
        }

        if ( !moveNext ) {
            this.skipBitOffsetTo( currentOffset )
        }

        return bits

    }

    getBit32 ( moveNext = true ) {

        if ( this._isNullBitBuffer() ) {
            this._readBit32()
        }

        const bitValue = this._getBitAt( this._bits.offset )

        if ( moveNext ) {
            this._nextBit()
            if ( this._isEndOfBitBuffer() ) {
                this._resetBits()
            }
        }

        return bitValue

    }

    getBits32 ( numberOfBitToRead, moveNext = true ) {

        const currentOffset = this._bits.offset

        let bits = 0

        // In last turn avoid bits reset if move next is false,
        // else the skipBitOffset will be based on reseted/null bit buffer
        for ( let i = 0 ; i &lt; numberOfBitToRead ; i++ ) {
            if ( i === numberOfBitToRead - 1 ) {
                bits |= ( this.getBit32( moveNext ) &lt;&lt; i )
            } else {
                bits |= ( this.getBit32() &lt;&lt; i )
            }
        }

        if ( !moveNext ) {
            this.skipBitOffsetTo( currentOffset )
        }

        return bits

    }

    // Bytes

    /**
     *
     * @param offset
     */
    skipOffsetTo ( offset ) {

        this._offset = offset

    }

    /**
     *
     * @param nBytes
     */
    skipOffsetOf ( nBytes ) {

        this._offset += nBytes

    }

    /**
     *
     * @returns {boolean}
     */
    getBoolean ( moveNext = true ) {

        return ( ( this.getUint8( moveNext ) &amp; 1 ) === 1 )

    }

    /**
     *
     * @param length
     * @param moveNext
     * @returns {Array}
     */
    getBooleanArray ( length, moveNext = true ) {

        const currentOffset = this._offset
        const array         = []

        for ( let i = 0 ; i &lt; length ; i++ ) {

            array.push( this.getBoolean() )

        }

        if ( !moveNext ) {
            this._offset = currentOffset
        }

        return array

    }

    /**
     *
     * @returns {number}
     */
    getInt8 ( moveNext = true ) {

        const offset = ( moveNext ) ? this._getAndUpdateOffsetBy( Byte.One ) : this._offset
        return this._dataView.getInt8( offset )

    }

    /**
     *
     * @param length
     * @param moveNext
     * @returns {Array}
     */
    getInt8Array ( length, moveNext = true ) {

        const currentOffset = this._offset
        const array         = []

        for ( let i = 0 ; i &lt; length ; i++ ) {

            array.push( this.getInt8() )

        }

        if ( !moveNext ) {
            this._offset = currentOffset
        }

        return array

    }

    /**
     *
     * @returns {number}
     */
    getUint8 ( moveNext = true ) {

        const offset = ( moveNext ) ? this._getAndUpdateOffsetBy( Byte.One ) : this._offset
        return this._dataView.getUint8( offset )

    }

    /**
     *
     * @param length
     * @param moveNext
     * @returns {Array}
     */
    getUint8Array ( length, moveNext = true ) {

        const currentOffset = this._offset
        const array         = []

        for ( let i = 0 ; i &lt; length ; i++ ) {

            array.push( this.getUint8() )

        }

        if ( !moveNext ) {
            this._offset = currentOffset
        }

        return array

    }

    /**
     *
     * @returns {number}
     */
    getInt16 ( moveNext = true ) {

        const offset = ( moveNext ) ? this._getAndUpdateOffsetBy( Byte.Two ) : this._offset
        return this._dataView.getInt16( offset, this._endianness )

    }

    /**
     *
     * @param length
     * @param moveNext
     * @returns {Array}
     */
    getInt16Array ( length, moveNext = true ) {

        const currentOffset = this._offset
        const array         = []

        for ( let i = 0 ; i &lt; length ; i++ ) {

            array.push( this.getInt16() )

        }

        if ( !moveNext ) {
            this._offset = currentOffset
        }

        return array

    }

    /**
     *
     * @returns {number}
     */
    getUint16 ( moveNext = true ) {

        const offset = ( moveNext ) ? this._getAndUpdateOffsetBy( Byte.Two ) : this._offset
        return this._dataView.getUint16( offset, this._endianness )

    }

    /**
     *
     * @param length
     * @param moveNext
     * @returns {Array}
     */
    getUint16Array ( length, moveNext = true ) {

        const currentOffset = this._offset
        const array         = []

        for ( let i = 0 ; i &lt; length ; i++ ) {

            array.push( this.getUint16() )

        }

        if ( !moveNext ) {
            this._offset = currentOffset
        }

        return array

    }

    /**
     *
     * @returns {number}
     */
    getInt32 ( moveNext = true ) {

        const offset = ( moveNext ) ? this._getAndUpdateOffsetBy( Byte.Four ) : this._offset
        return this._dataView.getInt32( offset, this._endianness )

    }

    /**
     *
     * @param length
     * @param moveNext
     * @returns {Array}
     */
    getInt32Array ( length, moveNext = true ) {

        const currentOffset = this._offset
        const array         = []

        for ( let i = 0 ; i &lt; length ; i++ ) {

            array.push( this.getInt32() )

        }

        if ( !moveNext ) {
            this._offset = currentOffset
        }

        return array

    }

    /**
     *
     * @returns {number}
     */
    getUint32 ( moveNext = true ) {

        const offset = ( moveNext ) ? this._getAndUpdateOffsetBy( Byte.Four ) : this._offset
        return this._dataView.getUint32( offset, this._endianness )

    }

    /**
     *
     * @param length
     * @param moveNext
     * @returns {Array}
     */
    getUint32Array ( length, moveNext = true ) {

        const currentOffset = this._offset
        const array         = []

        for ( let i = 0 ; i &lt; length ; i++ ) {

            array.push( this.getUint32() )

        }

        if ( !moveNext ) {
            this._offset = currentOffset
        }

        return array

    }

    /**
     *
     * @returns {number}
     */
    getInt64 ( moveNext = true ) {

        // From THREE.FBXLoader
        // JavaScript doesn't support 64-bit integer so attempting to calculate by ourselves.
        // 1 &lt;&lt; 32 will return 1 so using multiply operation instead here.
        // There'd be a possibility that this method returns wrong value if the value
        // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
        // TODO: safely handle 64-bit integer

        let low  = null
        let high = null

        if ( this._endianness === Endianness.Little ) {

            if ( moveNext ) {
                low  = this.getUint32()
                high = this.getUint32()
            } else {
                const currentOffset = this._offset
                low                 = this.getUint32()
                high                = this.getUint32()
                this.skipOffsetTo( currentOffset )
            }

        } else {

            if ( moveNext ) {
                high = this.getUint32()
                low  = this.getUint32()
            } else {
                const currentOffset = this._offset
                high                = this.getUint32()
                low                 = this.getUint32()
                this.skipOffsetTo( currentOffset )
            }

        }

        // calculate negative value
        if ( high &amp; 0x80000000 ) {

            high = ~high &amp; 0xFFFFFFFF
            low  = ~low &amp; 0xFFFFFFFF

            if ( low === 0xFFFFFFFF ) {
                high = ( high + 1 ) &amp; 0xFFFFFFFF
            }

            low = ( low + 1 ) &amp; 0xFFFFFFFF

            return -( high * 0x100000000 + low )

        }

        return high * 0x100000000 + low

    }

    /**
     *
     * @param length
     * @param moveNext
     * @returns {Array}
     */
    getInt64Array ( length, moveNext = true ) {

        const currentOffset = this._offset
        const array         = []

        for ( let i = 0 ; i &lt; length ; i++ ) {

            array.push( this.getInt64() )

        }

        if ( !moveNext ) {
            this._offset = currentOffset
        }

        return array

    }

    /**
     *
     * @returns {number}
     */
    getUint64 ( moveNext = true ) {
        // Note: see getInt64() comment

        let low  = null
        let high = null

        if ( this._endianness === Endianness.Little ) {

            if ( moveNext ) {
                low  = this.getUint32()
                high = this.getUint32()
            } else {
                const currentOffset = this._offset
                low                 = this.getUint32()
                high                = this.getUint32()
                this.skipOffsetTo( currentOffset )
            }

        } else {

            if ( moveNext ) {
                high = this.getUint32()
                low  = this.getUint32()
            } else {
                const currentOffset = this._offset
                high                = this.getUint32()
                low                 = this.getUint32()
                this.skipOffsetTo( currentOffset )
            }

        }

        return high * 0x100000000 + low

    }

    /**
     *
     * @param length
     * @param moveNext
     * @returns {Array}
     */
    getUint64Array ( length, moveNext = true ) {

        const currentOffset = this._offset
        const array         = []

        for ( let i = 0 ; i &lt; length ; i++ ) {

            array.push( this.getUint64() )

        }

        if ( !moveNext ) {
            this._offset = currentOffset
        }

        return array

    }

    /**
     *
     * @returns {number}
     */
    getFloat32 ( moveNext = true ) {

        const offset = ( moveNext ) ? this._getAndUpdateOffsetBy( Byte.Four ) : this._offset
        return this._dataView.getFloat32( offset, this._endianness )

    }

    /**
     *
     * @param length
     * @param moveNext
     * @returns {Array}
     */
    getFloat32Array ( length, moveNext = true ) {

        const currentOffset = this._offset
        const array         = []

        for ( let i = 0 ; i &lt; length ; i++ ) {

            array.push( this.getFloat32() )

        }

        if ( !moveNext ) {
            this._offset = currentOffset
        }

        return array

    }

    /**
     *
     * @return {number}
     */
    getFloat64 ( moveNext = true ) {

        const offset = ( moveNext ) ? this._getAndUpdateOffsetBy( Byte.Eight ) : this._offset
        return this._dataView.getFloat64( offset, this._endianness )

    }

    /**
     *
     * @param length
     * @param moveNext
     * @returns {Array}
     */
    getFloat64Array ( length, moveNext = true ) {

        const currentOffset = this._offset
        const array         = []

        for ( let i = 0 ; i &lt; length ; i++ ) {

            array.push( this.getFloat64() )

        }

        if ( !moveNext ) {
            this._offset = currentOffset
        }

        return array

    }

    /**
     *
     * @returns {string}
     */
    getChar ( moveNext = true ) {

        return String.fromCharCode( this.getUint8( moveNext ) )

    }

    /**
     *
     * @param length
     * @param moveNext
     * @return {string}
     */
    getString ( length, moveNext = true ) {

        const currentOffset = this._offset
        let string          = ''

        for ( let i = 0 ; i &lt; length ; i++ ) {
            string += String.fromCharCode( this.getUint8() )
        }

        if ( !moveNext ) {
            this._offset = currentOffset
        }

        return string

    }

    /**
     *
     * @param size
     * @returns {ArrayBuffer}
     */
    getArrayBuffer ( size ) {

        const offset = this._getAndUpdateOffsetBy( size )
        return this._dataView.buffer.slice( offset, offset + size )

    }

}

export {
    TBinaryReader,
    Endianness,
    Byte
}
</pre>
    </article>
</section>





		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>


	<span class="copyright">
	Copyright 2015-Present <a href="https://github.com/Itee">Itee</a> (Tristan Valcke)
	</span>

<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.11</a>
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : true,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>
