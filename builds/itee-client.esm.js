console.log('Itee.Client v7.4.4 - EsModule')
import { toEnum } from 'itee-utils';
import { isString, isFunction, isNull, isUndefined, isNotObject, isNotBoolean, isNotArray, isNotUndefined, isNotArrayBuffer, isNotNumber, isNotString, isEmptyString, isBlankString, isNumberPositive, isNumberNegative, isZero, isArray, isNotEmptyArray, isArrayOfSingleElement, isObject, isNotEmptyObject, isNotEmptyString, isNotBlankString, isEmptyObject, isNotDefined, isDefined, isFalse, isArrayBuffer } from 'itee-validators';
import { DefaultLogger, TLogger } from 'itee-core';

/**
 * A freezed javascript object used like an enum.
 * @typedef {object} Enum
 * @constant
 * @example
 * var Meal = toEnum( {
 *     Food: 'Tartiflette',
 *     Drink: 'Saint-Emilion',
 *     Dessert: 'Mousse au chocolat'
 * } )
 *
 * if( Foo.includes('Tartiflette') {
 *     // Happy
 * }
 *
 * var myDrink = 'coke'
 * if( myDrink === Meal.Drink ) {
 *
 * } else {
 *     // Your life is a pain
 * }
 *
 * var MealTypes = Meal.types
 * // ['Tartiflette', 'Saint-Emilion', 'Mousse au chocolat' ]
 *
 */

/**
 * @typedef {Enum} FileFormat
 * @property {String} Asc="asc" - The ascii file format
 * @property {String} Dae="dae" - The dae file format
 * @property {String} Dbf="dbf" - The dbf file format
 * @property {String} Fbx="fbx" - The fbx file format
 * @property {String} Mtl="mtl" - The material file format
 * @property {String} Json="json" - The json file format
 * @property {String} Obj="obj" - The object file format
 * @property {String} Shp="shp" - The shape file format
 * @property {String} Stl="stl" - The stereolithographie file format
 *
 * @constant
 * @type {FileFormat}
 * @description The FileFormat Enum give some commonly used file format in 3d context
 */
const FileFormat = toEnum( {
    Asc:  { value: 'asc' },
    Dae:  { value: 'dae' },
    Dbf:  { value: 'dbf' },
    Fbx:  { value: 'fbx' },
    Mtl:  { value: 'mtl' },
    Json: { value: 'json' },
    Obj:  { value: 'obj' },
    Shp:  { value: 'shp' },
    Stl:  { value: 'stl' }
} );

/**
 * @typedef {Enum} HttpStatusCode
 * @property {number} Continue=100 - Waiting for the continuation of the request.
 * @property {number} SwitchingProtocols=101 - The requester has asked the server to switch protocols and the server has agreed to do so.
 * @property {number} Processing=102 - WebDAV: Processing in progress (prevents the client from exceeding the limited waiting time).
 * @property {number} Ok=200 - Query successfully processed.
 * @property {number} Created=201 - Query successfully processed and a document was created.
 * @property {number} Accepted=202 - Query processed, but without guarantee of result.
 * @property {number} NonAuthoritativeInformation=203 - Information returned, but generated by an uncertified source.
 * @property {number} NoContent=204 - Query successfully processed but no information returned.
 * @property {number} ResetContent=205 - Query successfully processed, the current page can be cleared.
 * @property {number} PartialContent=206 - Only part of the resource has been transmitted.
 * @property {number} MultiStatus=207 - WebDAV: Multiple Response.
 * @property {number} AlreadyReported=208 - WebDAV: The document was previously sent to this collection.
 * @property {number} ContentDifferent=210 - WebDAV: The copy of the client-side resource differs from that of the server (content or properties).
 * @property {number} IMUsed=226 - The server has completed the request for the resource, and the response is a representation of the result of one or more instance manipulations applied to the
 *     current instance.
 * @property {number} MultipleChoices=300 - The requested URI refers to multiple resources.
 * @property {number} MovedPermanently=301 - Document moved permanently.
 * @property {number} Found=302 - Document moved temporarily.
 * @property {number} SeeOther=303 - The answer to this query is elsewhere.
 * @property {number} NotModified=304 - Document not modified since the last request.
 * @property {number} UseProxy=305 - The request must be re-addressed to the proxy.
 * @property {number} Unused=306 - Code used by an older version of RFC 2616, now reserved.
 * @property {number} TemporaryRedirect=307 - The request must be temporarily redirected to the specified URI.
 * @property {number} PermanentRedirect=308 - The request must be redirected permanently to the specified URI.
 * @property {number} TooManyRedirects=310 - The request must be redirected too many times, or is the victim of a redirection loop.
 * @property {number} BadRequest=400 - The syntax of the query is wrong.
 * @property {number} Unauthorized=401 - Authentication is required to access the resource.
 * @property {number} PaymentRequired=402 - Payment required to access the resource.
 * @property {number} Forbidden=403 - The server understood the request, but refuses to execute it. Unlike error 401, authenticating will not make any difference. On servers where authentication is
 *     required, this usually means that authentication has been accepted but access rights do not allow the client to access the resource.
 * @property {number} NotFound=404 - Resource not found.
 * @property {number} MethodNotAllowed=405 - Unauthorized request method.
 * @property {number} NotAcceptable=406 - The requested resource is not available in a format that would respect the "Accept" headers of the request.
 * @property {number} ProxyAuthenticationRequired=407 - Access to the authorized resource by identification with the proxy.
 * @property {number} RequestTimeOut=408 - Waiting time for an elapsed client request.
 * @property {number} Conflict=409 - The request can not be processed in the current state.
 * @property {number} Gone=410 - The resource is no longer available and no redirection address is known.
 * @property {number} LengthRequired=411 - The length of the request has not been specified.
 * @property {number} PreconditionFailed=412 - Preconditions sent by the query unverified.
 * @property {number} RequestEntityTooLarge=413 - Abandoned processing due to excessive request
 * @property {number} RequestURITooLong=414 - URI too long
 * @property {number} UnsupportedMediaType=415 - Unsupported query format for a given method and resource.
 * @property {number} RequestRangeUnsatisfiable=416 - Invalid "range" request header fields.
 * @property {number} ExpectationFailed=417 - Expected behavior and defined in the header of the unsatisfactory request.
 * @property {number} ImATeapot=418 - "I am a teapot". This code is defined in RFC 2324 dated April 1, 1998, Hyper Text Coffee Pot Control Protocol.
 * @property {number} BadMapping=421 - The request was sent to a server that is not able to produce a response (for example, because a connection has been reused).
 * @property {number} UnprocessableEntity=422 - WebDAV: The entity provided with the request is incomprehensible or incomplete.
 * @property {number} Locked=423 - WebDAV: The operation can not take place because the resource is locked.
 * @property {number} MethodFailure=424 - WebDAV: A method of the transaction failed.
 * @property {number} UnorderedCollection=425 - WebDAV RFC 3648. This code is defined in the WebDAV Advanced Collections Protocol draft , but is absent from the Web Distributed Authoring and
 *     Versioning (WebDAV) Ordered Collections Protocol.
 * @property {number} UpgradeRequired=426 - RFC 2817 The client should change protocol, for example to TLS / 1.0 .
 * @property {number} PreconditionRequired=428 - RFC 6585 The request must be conditional.
 * @property {number} TooManyRequests=429 - RFC 6585 The client has issued too many requests within a given time.
 * @property {number} RequestHeaderFieldsTooLarge=431 - RFC 6585 HTTP headers issued exceed the maximum size allowed by the server.
 * @property {number} NoResponse=444 - Indicates that the server did not return any information to the client and closed the connection.
 * @property {number} RetryWith=449 - Code defined by Microsoft . The request should be returned after performing an action.
 * @property {number} BlockedByWindowsParentalControls=450 - Code defined by Microsoft. This error is generated when Windows Parental Control tools are enabled and block access to the page.
 * @property {number} UnavailableForLegalReasons=451 - This error code indicates that the requested resource is inaccessible for legal reasons
 * @property {number} UnrecoverableError=456 - WebDAV: Fatal error.
 * @property {number} SSLCertificateError=495 - An extension of the 400 Bad Request error, used when the client provided an invalid certificate.
 * @property {number} SSLCertificateRequired=496 - An extension of the 400 Bad Request error, used when a required client certificate is not provided.
 * @property {number} HTTPRequestSentToHTTPSPort=497 - An extension of the 400 Bad Request error, used when the client sends an HTTP request to port 443 normally intended for HTTPS requests.
 * @property {number} ClientClosedRequest=499 - The client closed the connection before receiving the response. This error occurs when the processing is too long on the server side.
 * @property {number} InternalServerError=500 - Internal server error.
 * @property {number} NotImplemented=501 - Functionality claimed not supported by the server.
 * @property {number} BadGateway=502 - Wrong response sent to an intermediate server by another server.
 * @property {number} ServiceUnavailable=503 - Service temporarily unavailable or under maintenance.
 * @property {number} GatewayTimeOut=504 - Waiting time for a response from a server to an intermediate server that has elapsed.
 * @property {number} HTTPVersionNotSupported=505 - HTTP version not managed by the server.
 * @property {number} VariantAlsoNegotiates=506 - RFC 2295: Negotiation Error. Transparent content negociation.
 * @property {number} InsufficientStorage=507 - WebDAV: Insufficient space to modify properties or build the collection.
 * @property {number} LoopDetected=508 - WebDAV: Loop in a Resource Match
 * @property {number} BandwidthLimitExceeded=509 - Used by many servers to indicate a quota overrun.
 * @property {number} NotExtended=510 - RFC 2774: The request does not respect the policy for accessing extended HTTP resources.
 * @property {number} NetworkAuthenticationRequired=511 - RFC 6585: The client must authenticate to access the network. Used by captive portals to redirect clients to the authentication page.
 * @property {number} UnknownError=520 - Error 520 is used as a wildcard response when the origin server returns an unexpected result.
 * @property {number} WebServerIsDown=521 - The server has refused the connection from Cloudflare.
 * @property {number} ConnectionTimedOut=522 - Cloudflare could not negotiate a TCP handshake with the origin server.
 * @property {number} OriginIsUnreachable=523 - Cloudflare failed to reach the origin server. This can occur if DNS server name resolution fails.
 * @property {number} ATimeoutOccured=524 - Cloudflare established a TCP connection with the origin server but did not receive an HTTP response before the login timeout.
 * @property {number} SSLHandshakeFailed=525 - Cloudflare could not negotiate SSL / TLS handshake with the origin server.
 * @property {number} InvalidSSLCertificate=526 - Cloudflare could not validate the SSL certificate presented by the origin server.
 * @property {number} RailgunError=527 - Error 527 indicates that the request has timed out or failed after the WAN connection was established.
 *
 * @constant
 * @type {HttpStatusCode}
 * @description HttpStatusCode contains all http status code available to check and process correctly server response.
 * @see {@link https://en.wikipedia.org/wiki/List_of_HTTP_status_codes} for further information.
 */
const HttpStatusCode = toEnum( {

    // 100
    Continue:           { value: 100 },
    SwitchingProtocols: { value: 101 },
    Processing:         { value: 102 },

    // 200
    Ok:                          { value: 200 },
    Created:                     { value: 201 },
    Accepted:                    { value: 202 },
    NonAuthoritativeInformation: { value: 203 },
    NoContent:                   { value: 204 },
    ResetContent:                { value: 205 },
    PartialContent:              { value: 206 },
    MultiStatus:                 { value: 207 },
    AlreadyReported:             { value: 208 },
    ContentDifferent:            { value: 210 },
    IMUsed:                      { value: 226 },

    // 300
    MultipleChoices:   { value: 300 },
    MovedPermanently:  { value: 301 },
    Found:             { value: 302 },
    SeeOther:          { value: 303 },
    NotModified:       { value: 304 },
    UseProxy:          { value: 305 },
    Unused:            { value: 306 },
    TemporaryRedirect: { value: 307 },
    PermanentRedirect: { value: 308 },
    TooManyRedirects:  { value: 310 },

    // 400
    BadRequest:                       { value: 400 },
    Unauthorized:                     { value: 401 },
    PaymentRequired:                  { value: 402 },
    Forbidden:                        { value: 403 },
    NotFound:                         { value: 404 },
    MethodNotAllowed:                 { value: 405 },
    NotAcceptable:                    { value: 406 },
    ProxyAuthenticationRequired:      { value: 407 },
    RequestTimeOut:                   { value: 408 },
    Conflict:                         { value: 409 },
    Gone:                             { value: 410 },
    LengthRequired:                   { value: 411 },
    PreconditionFailed:               { value: 412 },
    RequestEntityTooLarge:            { value: 413 },
    RequestRangeUnsatisfiable:        { value: 416 },
    ExpectationFailed:                { value: 417 },
    ImATeapot:                        { value: 418 },
    BadMapping:                       { value: 421 },
    UnprocessableEntity:              { value: 422 },
    Locked:                           { value: 423 },
    MethodFailure:                    { value: 424 },
    UnorderedCollection:              { value: 425 },
    UpgradeRequired:                  { value: 426 },
    PreconditionRequired:             { value: 428 },
    TooManyRequests:                  { value: 429 },
    RequestHeaderFieldsTooLarge:      { value: 431 },
    NoResponse:                       { value: 444 },
    RetryWith:                        { value: 449 },
    BlockedByWindowsParentalControls: { value: 450 },
    UnavailableForLegalReasons:       { value: 451 },
    UnrecoverableError:               { value: 456 },
    SSLCertificateError:              { value: 495 },
    SSLCertificateRequired:           { value: 496 },
    HTTPRequestSentToHTTPSPort:       { value: 497 },
    ClientClosedRequest:              { value: 499 },

    // 500
    InternalServerError:           { value: 500 },
    NotImplemented:                { value: 501 },
    BadGateway:                    { value: 502 },
    ServiceUnavailable:            { value: 503 },
    GatewayTimeOut:                { value: 504 },
    HTTPVersionNotSupported:       { value: 505 },
    VariantAlsoNegotiates:         { value: 506 },
    InsufficientStorage:           { value: 507 },
    LoopDetected:                  { value: 508 },
    BandwidthLimitExceeded:        { value: 509 },
    NotExtended:                   { value: 510 },
    NetworkAuthenticationRequired: { value: 511 },
    UnknownError:                  { value: 520 },
    WebServerIsDown:               { value: 521 },
    ConnectionTimedOut:            { value: 522 },
    OriginIsUnreachable:           { value: 523 },
    ATimeoutOccured:               { value: 524 },
    SSLHandshakeFailed:            { value: 525 },
    InvalidSSLCertificate:         { value: 526 },
    RailgunError:                  { value: 527 }

} );

/**
 * @typedef {Enum} HttpVerb
 * @property {String} Create="PUT" - Corresponding to the create http verb for an itee server, namely "PUT".
 * @property {String} Read="POST" - Corresponding to the read http verb for an itee server, namely "POST".
 * @property {String} Update="PATCH" - Corresponding to the update http verb for an itee server, namely "PATCH".
 * @property {String} Delete="DELETE" - Corresponding to the delete http verb for an itee server, namely "DELETE".
 *
 * @constant
 * @type {HttpVerb}
 * @description HttpVerb contains the CRUD actions with corresponding http verb to request an itee server.
 * @see {@link https://en.wikipedia.org/wiki/Create,_read,_update_and_delete} for further information.
 */
const HttpVerb = toEnum( {
    Create: { value: 'PUT' },
    Read:   { value: 'POST' },
    Update: { value: 'PATCH' },
    Delete: { value: 'DELETE' }
} );

/**
 * @typedef {Enum} Keys
 * @property {Number} BACKSPACE=8 - The backspace key code
 * @property {Number} TAB=9 - The tab key code
 * @property {Number} ENTER=13 - The enter key code
 * @property {Number} Etc...=* - All the rest
 *
 * @constant
 * @type {Keys}
 * @description Keys contains common keyboard key values, this allow to write semantic code instead of integer when dealing with key codes.
 */
const Keys = toEnum( {
    BACKSPACE:            { value: 8 },
    TAB:                  { value: 9 },
    ENTER:                { value: 13 },
    SHIFT:                { value: 16 },
    CTRL:                 { value: 17 },
    ALT:                  { value: 18 },
    PAUSE:                { value: 19 },
    CAPS_LOCK:            { value: 20 },
    ESCAPE:               { value: 27 },
    SPACE:                { value: 32 },
    PAGE_UP:              { value: 33 },
    PAGE_DOWN:            { value: 34 },
    END:                  { value: 35 },
    HOME:                 { value: 36 },
    LEFT_ARROW:           { value: 37 },
    UP_ARROW:             { value: 38 },
    RIGHT_ARROW:          { value: 39 },
    DOWN_ARROW:           { value: 40 },
    INSERT:               { value: 45 },
    DELETE:               { value: 46 },
    ZERO:                 { value: 48 },
    ONE:                  { value: 49 },
    TWO:                  { value: 50 },
    THREE:                { value: 51 },
    FOUR:                 { value: 52 },
    FIVE:                 { value: 53 },
    SIX:                  { value: 54 },
    SEVEN:                { value: 55 },
    HEIGHT:               { value: 56 },
    NINE:                 { value: 57 },
    A:                    { value: 65 },
    B:                    { value: 66 },
    C:                    { value: 67 },
    D:                    { value: 68 },
    E:                    { value: 69 },
    F:                    { value: 70 },
    G:                    { value: 71 },
    H:                    { value: 72 },
    I:                    { value: 73 },
    J:                    { value: 74 },
    K:                    { value: 75 },
    L:                    { value: 76 },
    M:                    { value: 77 },
    N:                    { value: 78 },
    O:                    { value: 79 },
    P:                    { value: 80 },
    Q:                    { value: 81 },
    R:                    { value: 82 },
    S:                    { value: 83 },
    T:                    { value: 84 },
    U:                    { value: 85 },
    V:                    { value: 86 },
    W:                    { value: 87 },
    X:                    { value: 88 },
    Y:                    { value: 89 },
    Z:                    { value: 90 },
    LEFT_WINDOW_KEY:      { value: 91 },
    RIGHT_WINDOW_KEY:     { value: 92 },
    SELECT_KEY:           { value: 93 },
    NUMPAD_0:             { value: 96 },
    NUMPAD_1:             { value: 97 },
    NUMPAD_2:             { value: 98 },
    NUMPAD_3:             { value: 99 },
    NUMPAD_4:             { value: 100 },
    NUMPAD_5:             { value: 101 },
    NUMPAD_6:             { value: 102 },
    NUMPAD_7:             { value: 103 },
    NUMPAD_8:             { value: 104 },
    NUMPAD_9:             { value: 105 },
    MULTIPLY:             { value: 106 },
    ADD:                  { value: 107 },
    SUBSTRACT:            { value: 109 },
    DECIMAL_POINT:        { value: 110 },
    DIVIDE:               { value: 111 },
    F1:                   { value: 112 },
    F2:                   { value: 113 },
    F3:                   { value: 114 },
    F4:                   { value: 115 },
    F5:                   { value: 116 },
    F6:                   { value: 117 },
    F7:                   { value: 118 },
    F8:                   { value: 119 },
    F9:                   { value: 120 },
    F10:                  { value: 121 },
    F11:                  { value: 122 },
    F12:                  { value: 123 },
    NUM_LOCK:             { value: 144 },
    SCROLL_LOCK:          { value: 145 },
    SEMICOLON:            { value: 186 },
    EQUAL:                { value: 187 },
    COMMA:                { value: 188 },
    DASH:                 { value: 189 },
    PERIODE:              { value: 190 },
    SLASH:                { value: 191 },
    GRAVE_ACCENT:         { value: 192 },
    OPEN_SQUARE_BRACKET:  { value: 219 },
    BACKSLASH:            { value: 220 },
    CLOSE_SQUARE_BRACKET: { value: 221 },
    SINGLE_QUOTE:         { value: 222 }
} );

/**
 * @typedef {Enum} MimeType
 * @property {Number} ...
 *
 * @constant
 * @type {MimeType}
 * @description Todo...
 */
const MimeType = toEnum( {} );

/**
 * @typedef {Enum} Mouse
 * @property {Number} Wheel=-1 - The enter key code
 * @property {Number} Left=0 - The enter key code
 * @property {Number} Middle=1 - The enter key code
 * @property {Number} Right=2 - The enter key code
 *
 * @constant
 * @type {Mouse}
 * @description This Mouse Enum expose 4 common state of mouse button values (Wheel, Left, Middle and Right), this allow to write semantic code instead of integer when dealing with mouse button codes.
 */
const Mouse = toEnum( {
    Wheel:  { value: -1 },
    Left:   { value: 0 },
    Middle: { value: 1 },
    Right:  { value: 2 }
} );

/**
 * @typedef {Enum} ResponseType
 * @property {String} ArrayBuffer="arraybuffer" - The "arraybuffer" server response type.
 * @property {String} Blob="blob" - The "blob" server response type.
 * @property {String} Document="document" - The "document" server response type.
 * @property {String} Json="json" - The "json" server response type.
 * @property {String} DOMString="text" - The "text" server response type.
 * @property {String} Default="text" - The "" server response type ( equivalent to DOMString ).
 *
 * @constant
 * @type {ResponseType}
 * @description ResponseType allow to filter wich type of response is recieved from the server.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType} for further information.
 */
const ResponseType = toEnum( {
    ArrayBuffer: { value: 'arraybuffer' },
    Blob:        { value: 'blob' },
    Document:    { value: 'document' },
    Json:        { value: 'json' },
    DOMString:   { value: 'text' },
    Default:     { value: '' }
} );

/**
 * @class
 * @classdesc TStore is a simple javascript object whose purpose is to store some ket/value data to future usage. It could be enable/disable.
 *
 * @example {@lang javascript}
 * var cache = new TCache()
 * cache.add( 'foo', 'bar' )
 * TLogger.log( cache.get('foo') ) // 'bar'
 *
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 */
class TStore {

    /**
     *
     * @param value
     * @param validators
     * @private
     */
    static _validate ( value, validators ) {

        for ( let validatorIndex = 0, numberOfValidators = validators.length ; validatorIndex < numberOfValidators ; validatorIndex++ ) {

            let validator = validators[ validatorIndex ];

            if ( !validator.validator( value ) ) {

                const error = validator.error;
                if ( isString( error ) ) {
                    throw new TypeError( error )
                } else if ( isFunction( error ) ) {
                    throw new TypeError( error( value ) )
                } else {
                    throw new TypeError( `${value} is invalid.` )
                }

            }

        }

    }

    /**
     * @constructor
     * @param {Object} [parameters={}]
     * @param {Object} [parameters.collection={}]
     * @param {Boolean} [parameters.allowOverride=false]
     * @param {Array.<function>} [parameters.keyValidators=[]]
     * @param {Array.<function>} [parameters.valueValidators=[]]
     */
    constructor ( parameters = {} ) {

        const _parameters = {
            ...{
                collection:      {},
                allowOverride:   false,
                keyValidators:   [],
                valueValidators: []
            }, ...parameters
        };

        this.collection      = _parameters.collection;
        this.allowOverride   = _parameters.allowOverride;
        this.keyValidators   = _parameters.keyValidators;
        this.valueValidators = _parameters.valueValidators;

    }

    /**
     *
     * @return {{}}
     */
    get collection () {

        return this._collection

    }

    set collection ( value ) {

        const memberName = 'Collection';
        const expect     = 'Expect an object.';

        if ( isNull( value ) ) { throw new TypeError( `${memberName} cannot be null ! ${expect}` ) }
        if ( isUndefined( value ) ) { throw new TypeError( `${memberName} cannot be undefined ! ${expect}` ) }
        if ( isNotObject( value ) ) { throw new TypeError( `${memberName} cannot be an instance of ${value.constructor.name} ! ${expect}` ) }

        this._collection = value;

    }

    /**
     *
     * @return {*}
     */
    get allowOverride () {

        return this._allowOverride

    }

    set allowOverride ( value ) {

        const memberName = 'Allow override';
        const expect     = 'Expect a boolean.';

        if ( isNull( value ) ) { throw new TypeError( `${memberName} cannot be null ! ${expect}` ) }
        if ( isUndefined( value ) ) { throw new TypeError( `${memberName} cannot be undefined ! ${expect}` ) }
        if ( isNotBoolean( value ) ) { throw new TypeError( `${memberName} cannot be an instance of ${value.constructor.name} ! ${expect}` ) }

        this._allowOverride = value;

    }

    /**
     *
     * @return {*}
     */
    get keyValidators () {

        return this._keyValidators

    }

    set keyValidators ( value ) {

        const memberName = 'Keys validators';
        const expect     = 'Expect an array of TValidator or an empty array.';

        if ( isNull( value ) ) { throw new TypeError( `${memberName} cannot be null ! ${expect}` ) }
        if ( isUndefined( value ) ) { throw new TypeError( `${memberName} cannot be undefined ! ${expect}` ) }
        if ( isNotArray( value ) ) { throw new TypeError( `${memberName} cannot be an instance of ${value.constructor.name} ! ${expect}` ) }

        this._keyValidators = value;

    }

    /**
     *
     * @return {*}
     */
    get valueValidators () {
        return this._valueValidators
    }

    set valueValidators ( value ) {

        const memberName = 'Values validators';
        const expect     = 'Expect an array of TValidator or an empty array.';

        if ( isNull( value ) ) { throw new TypeError( `${memberName} cannot be null ! ${expect}` ) }
        if ( isUndefined( value ) ) { throw new TypeError( `${memberName} cannot be undefined ! ${expect}` ) }
        if ( isNotArray( value ) ) { throw new TypeError( `${memberName} cannot be an instance of ${value.constructor.name} ! ${expect}` ) }

        this._valueValidators = value;

    }

    /**
     *
     * @return {string[]}
     */
    get keys () {

        return Object.keys( this._collection )

    }

    /**
     *
     * @return {unknown[] | any[]}
     */
    get values () {

        return Object.values( this._collection )

    }

    /**
     *
     * @param value
     * @return {TStore} The current instance (this)
     */
    setCollection ( value ) {

        this.collection = value;
        return this

    }

    /**
     *
     * @param value
     * @return {TStore} The current instance (this)
     */
    setAllowOverride ( value ) {

        this.allowOverride = value;
        return this

    }

    /**
     *
     * @param value
     * @return {TStore} The current instance (this)
     */
    setKeyValidators ( value ) {

        this.keyValidators( value );
        return this

    }

    /**
     *
     * @param value
     * @return {TStore} The current instance (this)
     */
    setValueValidators ( value ) {

        this.valueValidators( value );
        return this

    }

    /**
     * Allow to add new key value pair, the key cannot be null, undefined, or an empty string.
     * In case the key already exist, the value will be overwritten if force params is true or this
     * allow overriding else it throw an TypeError.
     *
     * @param {*} key
     * @param {*} value
     * @param {Boolean} force
     * @return {TStore} The current instance (this)
     */
    add ( key, value, force = false ) {

        if ( this.contain( key ) && ( !this._allowOverride && !force ) ) {
            throw new TypeError( `Item with key (${key}) already exist in collection !` )
        }

        TStore._validate( key, this._keyValidators );
        TStore._validate( value, this._valueValidators );

        this._collection[ key ] = value;

        return this

    }

    /**
     *
     * @param key
     * @return {boolean}
     */
    contain ( key ) {

        return isNotUndefined( this._collection[ key ] )

    }

    /**
     * Return the value associated to the key.
     *
     * @param key
     * @returns {*}
     */
    get ( key ) {

        return this._collection[ key ]

    }

    /**
     * Remove to value from the cache. Does nothing if the key does not exist.
     *
     * @param key
     * @return {TStore} The current instance (this)
     */
    remove ( key ) {

        delete this._collection[ key ];

        return this

    }

    /**
     * Clear the cache and reset collection to an empty object.
     * @return {TStore} The current instance (this)
     */
    clear () {

        this._collection = {};

        return this

    }

}

/**
 * @class
 * @classdesc The abstract class to create factory
 * @abstract
 * @extends TStore
 *
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 */
class TAbstractFactory extends TStore {

    /**
     * @constructor
     * @param parameters
     */
    constructor ( parameters = {} ) {

        const _parameters = { ...{}, ...parameters };

        super( _parameters );

    }


    /**
     * The create factory method. It allow to automate Class creation by constructor key, and parameters to pass for initialized the instance.
     * @abstract
     * @param {*} key
     * @param parameters
     */
    // eslint-disable-next-line no-unused-vars
    create ( key, ...parameters ) {

        // Need to be reimplemented

    }

}

/**
 * @class
 * @classdesc The TCloningFactory is a kind a factory that performe instanciation by cloning a base instance.
 * @extends TAbstractFactory
 *
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 */
class TCloningFactory extends TAbstractFactory {

    /**
     * @param parameters
     */
    constructor ( parameters = {} ) {

        const _parameters = { ...{}, ...parameters };

        super( _parameters );

    }

    /**
     *
     * @param key
     * @param parameters
     * @returns {*}
     */
    create ( key, ...parameters ) {
        super.create( key, ...parameters );

        return this.get( key ).clone( ...parameters )

    }
}

/**
 * @class
 * @classdesc The TInstancingFactory is a kind a factory that performe instanciation based on registred constructor.
 * @extends TAbstractFactory
 *
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 */
class TInstancingFactory extends TAbstractFactory {

    /**
     * The ctor description
     * @param parameters
     */
    constructor ( parameters = {} ) {

        const _parameters = { ...{}, ...parameters };

        super( _parameters );

    }

    /**
     *
     * @param key
     * @param parameters
     * @returns {*}
     */
    create ( key, ...parameters ) {
        super.create( key, ...parameters );

        return new this.get( key )( ...parameters )

    }

}

/* eslint-env browser */

/**
 * @class
 * @classdesc TKeyboardController allow single source of thruth for keyboard state checking (based on Lee Stemkoski work).
 * See TKeyboardController.k object data below for names of keys whose state can be polled
 *
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 * @example {@lang javascript}
 * // (1) create a global variable:
 * var keyboard = new TKeyboardController();
 *
 * // (2) during main loop:
 * keyboard.update();
 *
 * // (3) check state of keys:
 * keyboard.down("A")    -- true for one update cycle after key is pressed
 * keyboard.pressed("A") -- true as long as key is being pressed
 * keyboard.up("A")      -- true for one update cycle after key is released
 */
class TKeyboardController {

    /**
     *
     * @param keyCode
     * @return {string}
     */
    static keyName ( keyCode ) {
        return ( TKeyboardController.k[ keyCode ] !== null ) ?
            TKeyboardController.k[ keyCode ] :
            String.fromCharCode( keyCode )
    }

    /**
     *
     * @param event
     */
    static onKeyUp ( event ) {
        var key = TKeyboardController.keyName( event.keyCode );
        if ( TKeyboardController.status[ key ] ) {
            TKeyboardController.status[ key ].pressed = false;
        }
    }

    /**
     *
     * @param event
     */
    static onKeyDown ( event ) {
        var key = TKeyboardController.keyName( event.keyCode );
        if ( !TKeyboardController.status[ key ] ) {
            TKeyboardController.status[ key ] = {
                down:              false,
                pressed:           false,
                up:                false,
                updatedPreviously: false
            };
        }
    }

    /**
     *
     * @param parameters
     */
    // eslint-disable-next-line no-unused-vars
    constructor ( parameters = {} ) {

//         const _parameters = {
//             ...{},
//             ...parameters
//         }

        // bind keyEvents
        document.addEventListener( 'keydown', TKeyboardController.onKeyDown, false );
        document.addEventListener( 'keyup', TKeyboardController.onKeyUp, false );

    }

    /**
     *
     */
    update () {
        for ( var key in TKeyboardController.status ) {
            // insure that every keypress has "down" status exactly once
            if ( !TKeyboardController.status[ key ].updatedPreviously ) {
                TKeyboardController.status[ key ].down              = true;
                TKeyboardController.status[ key ].pressed           = true;
                TKeyboardController.status[ key ].updatedPreviously = true;
            } else { // updated previously
                TKeyboardController.status[ key ].down = false;
            }

            // key has been flagged as "up" since last update
            if ( TKeyboardController.status[ key ].up ) {
                delete TKeyboardController.status[ key ];
                continue // move on to next key
            }

            if ( !TKeyboardController.status[ key ].pressed ) // key released
            {
                TKeyboardController.status[ key ].up = true;
            }
        }
    }

    /**
     *
     * @param keyName
     * @return {*}
     */
    down ( keyName ) {
        return ( TKeyboardController.status[ keyName ] && TKeyboardController.status[ keyName ].down )
    }

    /**
     *
     * @param keyName
     * @return {*|pressed|boolean}
     */
    pressed ( keyName ) {
        return ( TKeyboardController.status[ keyName ] && TKeyboardController.status[ keyName ].pressed )
    }

    /**
     *
     * @param keyName
     * @return {*}
     */
    up ( keyName ) {
        return ( TKeyboardController.status[ keyName ] && TKeyboardController.status[ keyName ].up )
    }

    /**
     *
     */
    debug () {
        var list = 'Keys active: ';
        for ( var arg in TKeyboardController.status ) {
            list += ' ' + arg;
        }
        DefaultLogger.log( list );
    }

}

/**
 *
 * @type {Keys}
 */
TKeyboardController.k      = Keys;

/**
 *
 * @type {{}}
 */
TKeyboardController.status = {};

/* eslint-env browser */

/**
 * @class
 * @classdesc TMouseController allow single source of thruth for mouse state checking
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 * @example
 * (1) create a global variable:
 *      var keyboard = new TKeyboardController();
 * (2) during main loop:
 *       keyboard.update();
 * (3) check state of keys:
 *       keyboard.down("A")    -- true for one update cycle after key is pressed
 *       keyboard.pressed("A") -- true as long as key is being pressed
 *       keyboard.up("A")      -- true for one update cycle after key is released
 *
 *  See TKeyboardController.k object data below for names of keys whose state can be polled
 */
class TMouseController {

    /**
     * @constructor
     */
    constructor ( /*parameters = {}*/ ) {

    }

}

/* eslint-env browser */

/**
 * @typedef {Enum} Endianness
 * @property {Boolean} Little=true - The Little endianess
 * @property {Number} Big=false - The Big endianess
 *
 * @constant
 * @type {Endianness}
 * @description Endianness enum allow semantic usage.
 */
const Endianness = toEnum( {
    Little: true,
    Big:    false
} );

/**
 * @typedef {Enum} Byte
 * @property {Number} One=1 - Octet
 * @property {Number} Two=2 - Doublet
 * @property {Number} Four=4 - Quadlet
 * @property {Number} Height=8 - Octlet
 *
 * @constant
 * @type {Byte}
 * @description Byte allow semantic meaning of quantity of bytes based on power of two.
 */
const Byte = toEnum( {
    One:    1,
    Two:    2,
    Four:   4,
    Height: 8
} );


/**
 * @class
 * @classdesc TBinaryReader is design to perform fast binary read/write
 *
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 */
class TBinaryReader {

    /**
     * @constructor
     * @param parameters
     * @param parameters.buffer
     * @param parameters.offset
     * @param parameters.length
     * @param parameters.endianness
     * @constructor
     */
    constructor ( parameters = {} ) {

        const _parameters = {
            ...{
                buffer:     new ArrayBuffer( 0 ),
                offset:     0,
                length:     0,
                endianness: Endianness.Little
            }, ...parameters
        };

        this.buffer     = _parameters.buffer;
        this.offset     = _parameters.offset;
        this.length     = _parameters.length;
        this.endianness = _parameters.endianness;

        this._updateDataView();

    }

    /**
     *
     * @returns {*}
     */
    get buffer () {
        return this._buffer
    }

    set buffer ( value ) {

        const memberName = 'Buffer';
        const expect     = 'Expect an instance of ArrayBuffer.';

        if ( isNull( value ) ) { throw new TypeError( `${memberName} cannot be null ! ${expect}` ) }
        if ( isUndefined( value ) ) { throw new TypeError( `${memberName} cannot be undefined ! ${expect}` ) }
        if ( isNotArrayBuffer( value ) ) { throw new TypeError( `${memberName} cannot be an instance of ${value.constructor.name} ! ${expect}` ) }

        this._buffer = value;
        this._offset = 0;
        this._length = value.byteLength;

        this._updateDataView();

    }

    /**
     *
     * @returns {*}
     */
    get offset () {
        return this._offset
    }

    set offset ( value ) {

        const memberName = 'Offset';
        const expect     = 'Expect a number.';

        if ( isNull( value ) ) { throw new TypeError( `${memberName} cannot be null ! ${expect}` ) }
        if ( isUndefined( value ) ) { throw new TypeError( `${memberName} cannot be undefined ! ${expect}` ) }
        if ( isNotNumber( value ) ) { throw new TypeError( `${memberName} cannot be an instance of ${value.constructor.name} ! ${expect}` ) }

        this._offset = value;

        this._updateDataView();

    }

    get length () {
        return this._length
    }

    /**
     *
     * @param value
     */
    set length ( value ) {

        const memberName = 'Length';
        const expect     = 'Expect a number.';

        if ( isNull( value ) ) { throw new TypeError( `${memberName} cannot be null ! ${expect}` ) }
        if ( isUndefined( value ) ) { throw new TypeError( `${memberName} cannot be undefined ! ${expect}` ) }
        if ( isNotNumber( value ) ) { throw new TypeError( `${memberName} cannot be an instance of ${value.constructor.name} ! ${expect}` ) }

        this._length = value;

        this._updateDataView();

    }

    /**
     *
     * @returns {*}
     */
    get endianness () {
        return this._endianness
    }

    set endianness ( value ) {

        const memberName = 'Endianness';
        const expect     = 'Expect a boolean.';

        if ( isNull( value ) ) { throw new TypeError( `${memberName} cannot be null ! ${expect}` ) }
        if ( isUndefined( value ) ) { throw new TypeError( `${memberName} cannot be undefined ! ${expect}` ) }
        if ( isNotBoolean( value ) ) { throw new TypeError( `${memberName} cannot be an instance of ${value.constructor.name} ! ${expect}` ) }

        this._endianness = value;
    }

    /**
     *
     * @param buffer
     * @param offset
     * @param length
     * @returns {TBinaryReader}
     */
    setBuffer ( buffer, offset, length ) {

        this.buffer = buffer;
        this.offset = offset || 0;
        this.length = length || buffer.byteLength;

        return this

    }

    /**
     *
     * @param value
     * @returns {TBinaryReader}
     */
    setOffset ( value ) {

        this.offset = value;
        return this

    }

    /**
     *
     * @param value
     * @returns {TBinaryReader}
     */
    setLength ( value ) {

        this.length = value;
        return this

    }

    /**
     *
     * @param endianess
     * @returns {TBinaryReader}
     */
    setEndianess ( endianess ) {

        this.endianness = endianess;
        return this

    }

    /**
     *
     * @param increment
     * @returns {*}
     * @private
     */
    _getAndUpdateOffsetBy ( increment ) {

        const currentOffset = this._offset;
        this._offset += increment;
        return currentOffset

    }

    /**
     *
     * @private
     */
    _updateDataView () {

        this._dataView = new DataView( this._buffer, this._offset, this._length );

    }

    /**
     *
     * @returns {boolean}
     */
    isEndOfFile () {

        return ( this._offset === this._length )

    }

    /**
     *
     * @param offset
     * @returns {TBinaryReader}
     */
    skipOffsetTo ( offset ) {

        this._offset = offset;

        return this

    }

    /**
     *
     * @param nBytes
     * @returns {TBinaryReader}
     */
    skipOffsetOf ( nBytes ) {

        this._offset += nBytes;

        return this

    }

    /**
     *
     * @returns {boolean}
     */
    getBoolean () {

        return ( ( this.getUint8() & 1 ) === 1 )

    }

    /**
     *
     * @param length
     * @returns {Array}
     */
    getBooleanArray ( length ) {

        const array = [];

        for ( let i = 0 ; i < length ; i++ ) {

            array.push( this.getBoolean() );

        }

        return array

    }

    /**
     *
     * @returns {number}
     */
    getInt8 () {

        return this._dataView.getInt8( this._getAndUpdateOffsetBy( Byte.One ) )

    }

    /**
     *
     * @param length
     * @returns {Array}
     */
    getInt8Array ( length ) {

        const array = [];

        for ( let i = 0 ; i < length ; i++ ) {

            array.push( this.getInt8() );

        }

        return array

    }

    /**
     *
     * @returns {number}
     */
    getUint8 () {

        return this._dataView.getUint8( this._getAndUpdateOffsetBy( Byte.One ) )

    }

    /**
     *
     * @param length
     * @returns {Array}
     */
    getUint8Array ( length ) {

        const array = [];

        for ( let i = 0 ; i < length ; i++ ) {

            array.push( this.getUint8() );

        }

        return array

    }

    /**
     *
     * @returns {number}
     */
    getInt16 () {

        return this._dataView.getInt16( this._getAndUpdateOffsetBy( Byte.Two ), this._endianness )

    }

    /**
     *
     * @param length
     * @returns {Array}
     */
    getInt16Array ( length ) {

        const array = [];

        for ( let i = 0 ; i < length ; i++ ) {

            array.push( this.getInt16() );

        }

        return array

    }

    /**
     *
     * @returns {number}
     */
    getUint16 () {

        return this._dataView.getUint16( this._getAndUpdateOffsetBy( Byte.Two ), this._endianness )

    }

    /**
     *
     * @param length
     * @returns {Array}
     */
    getUint16Array ( length ) {

        const array = [];

        for ( let i = 0 ; i < length ; i++ ) {

            array.push( this.getUint16() );

        }

        return array

    }

    /**
     *
     * @returns {number}
     */
    getInt32 () {

        return this._dataView.getInt32( this._getAndUpdateOffsetBy( Byte.Four ), this._endianness )

    }

    /**
     *
     * @param length
     * @returns {Array}
     */
    getInt32Array ( length ) {

        const array = [];

        for ( let i = 0 ; i < length ; i++ ) {

            array.push( this.getInt32() );

        }

        return array

    }

    /**
     *
     * @returns {number}
     */
    getUint32 () {

        return this._dataView.getUint32( this._getAndUpdateOffsetBy( Byte.Four ), this._endianness )

    }

    /**
     *
     * @param length
     * @returns {Array}
     */
    getUint32Array ( length ) {

        const array = [];

        for ( let i = 0 ; i < length ; i++ ) {

            array.push( this.getUint32() );

        }

        return array

    }

    /**
     *
     * @returns {number}
     */
    getInt64 () {

        // From THREE.FBXLoader
        // JavaScript doesn't support 64-bit integer so attempting to calculate by ourselves.
        // 1 << 32 will return 1 so using multiply operation instead here.
        // There'd be a possibility that this method returns wrong value if the value
        // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
        // TODO: safely handle 64-bit integer

        let low  = null;
        let high = null;

        if ( this._endianness === Endianness.Little ) {

            low  = this.getUint32();
            high = this.getUint32();

        } else {

            high = this.getUint32();
            low  = this.getUint32();

        }

        // calculate negative value
        if ( high & 0x80000000 ) {

            high = ~high & 0xFFFFFFFF;
            low  = ~low & 0xFFFFFFFF;

            if ( low === 0xFFFFFFFF ) {
                high = ( high + 1 ) & 0xFFFFFFFF;
            }

            low = ( low + 1 ) & 0xFFFFFFFF;

            return -( high * 0x100000000 + low )

        }

        return high * 0x100000000 + low

    }

    /**
     *
     * @param length
     * @returns {Array}
     */
    getInt64Array ( length ) {

        const array = [];

        for ( let i = 0 ; i < length ; i++ ) {

            array.push( this.getInt64() );

        }

        return array

    }


    /**
     *
     * @returns {number}
     */
    getUint64 () {
        // Note: see getInt64() comment

        let low  = null;
        let high = null;

        if ( this._endianness === Endianness.Little ) {

            low  = this.getUint32();
            high = this.getUint32();

        } else {

            high = this.getUint32();
            low  = this.getUint32();

        }

        return high * 0x100000000 + low

    }

    /**
     *
     * @param length
     * @returns {Array}
     */
    getUint64Array ( length ) {

        const array = [];

        for ( let i = 0 ; i < length ; i++ ) {

            array.push( this.getUint64() );

        }

        return array

    }

    /**
     *
     * @returns {number}
     */
    getFloat32 () {

        return this._dataView.getFloat32( this._getAndUpdateOffsetBy( Byte.Four ), this._endianness )

    }

    /**
     *
     * @param length
     * @returns {Array}
     */
    getFloat32Array ( length ) {

        const array = [];

        for ( let i = 0 ; i < length ; i++ ) {

            array.push( this.getFloat32() );

        }

        return array

    }

    /**
     *
     * @return {number}
     */
    getFloat64 () {

        return this._dataView.getFloat64( this._getAndUpdateOffsetBy( Byte.Height ), this._endianness )

    }

    /**
     *
     * @param length
     * @returns {Array}
     */
    getFloat64Array ( length ) {

        const array = [];

        for ( let i = 0 ; i < length ; i++ ) {

            array.push( this.getFloat64() );

        }

        return array

    }

    /**
     *
     * @returns {string}
     */
    getChar () {

        return String.fromCharCode( this.getUint8() )

    }

    /**
     *
     * @param length
     * @param trim
     * @return {string}
     */
    getString ( length, trim = true ) {

        let string   = '';
        let charCode = null;

        for ( let i = 0 ; i < length ; i++ ) {
            charCode = this.getUint8();

            if ( charCode === 0 ) {
                continue
            }

            string += String.fromCharCode( charCode );
        }

        if ( trim ) {
            string = string.trim();
        }

        return string

    }

    /**
     *
     * @param size
     * @returns {ArrayBuffer}
     */
    getArrayBuffer ( size ) {

        const offset = this._getAndUpdateOffsetBy( size );
        return this._dataView.buffer.slice( offset, offset + size )

    }

}

/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @class TDataBaseManager
 * @classdesc The base class of database managers. Give the basic interface about database call.
 *
 * @requires {@link HttpVerb}
 * @requires {@link ResponseType}
 * @requires {@link HttpStatusCode}
 * @requires {@link TOrchestrator}
 * @requires {@link TStore}
 *
 * @example Todo
 *
 */


/**
 * @deprecated
 */
class IdGenerator {

    constructor () {
        this._id = 0;
    }

    get id () {
        this._id += 1;
        return this._id
    }

}

const Generate = new IdGenerator();

/**
 *
 * @type {ReadonlyArray<unknown>}
 */
const RequestType = toEnum( {
    CreateOne:   0,
    CreateMany:  1,
    ReadOne:     2,
    ReadMany:    3,
    ReadWhere:   4,
    ReadAll:     5,
    UpdateOne:   6,
    UpdateMany:  7,
    UpdateWhere: 8,
    UpdateAll:   9,
    DeleteOne:   10,
    DeleteMany:  11,
    DeleteWhere: 12,
    DeleteAll:   13
} );

/**
 * @class
 */
class TDataBaseManager {

    /**
     *
     * @returns {number}
     */
    static get requestId () {
        TDataBaseManager._requestId++;
        return TDataBaseManager._requestId
    }

    /**
     *
     * @param parameters
     */
    constructor ( parameters = {} ) {

        const _parameters = {
            ...{
                basePath:               '/',
                responseType:           ResponseType.Json,
                bunchSize:              500,
                requestAggregationTime: 200,
                requestsConcurrency:    6,
                logger:                 DefaultLogger
            }, ...parameters
        };

        this.basePath               = _parameters.basePath;
        this.responseType           = _parameters.responseType;
        this.bunchSize              = _parameters.bunchSize;
        this.requestAggregationTime = _parameters.requestAggregationTime;
        this.requestsConcurrency    = _parameters.requestsConcurrency;
        this.logger                 = _parameters.logger;

        this._cache                = new TStore();
        this._waitingQueue         = [];
        this._aggregateQueue       = [];
        this._requestQueue         = [];
        this._processQueue         = [];
        this._aggregationTimeoutId = null;

        this._idToRequest = [];

    }

    /**
     *
     * @returns {*}
     */
    get basePath () {
        return this._basePath
    }

    set basePath ( value ) {

        if ( isNull( value ) ) { throw new TypeError( 'Base path cannot be null ! Expect a non empty string.' ) }
        if ( isUndefined( value ) ) { throw new TypeError( 'Base path cannot be undefined ! Expect a non empty string.' ) }
        if ( isNotString( value ) ) { throw new TypeError( `Base path cannot be an instance of ${value.constructor.name} ! Expect a non empty string.` ) }
        if ( isEmptyString( value ) ) { throw new TypeError( 'Base path cannot be empty ! Expect a non empty string.' ) }
        if ( isBlankString( value ) ) { throw new TypeError( 'Base path cannot contain only whitespace ! Expect a non empty string.' ) }

        this._basePath = value;

    }

    /**
     *
     * @returns {*}
     */
    get responseType () {
        return this._responseType
    }

    set responseType ( value ) {

        if ( isNull( value ) ) { throw new Error( 'TDataBaseManager: responseType cannot be null !' ) }
        if ( isNull( value ) ) { throw new TypeError( 'Response type cannot be null ! Expect a non empty string.' ) }
        if ( isUndefined( value ) ) { throw new TypeError( 'Response type cannot be undefined ! Expect a non empty string.' ) }
        //        if ( !( value instanceof ResponseType ) ) { throw new TypeError( `Response type cannot be an instance of ${value.constructor.name} ! Expect a value from ResponseType enum.` ) }

        this._responseType = value;

    }

    /**
     *
     * @returns {*}
     */
    get bunchSize () {
        return this._bunchSize
    }

    set bunchSize ( value ) {

        if ( isNull( value ) ) { throw new TypeError( 'Bunch size cannot be null ! Expect a positive number.' ) }
        if ( isUndefined( value ) ) { throw new TypeError( 'Bunch size cannot be undefined ! Expect a positive number.' ) }
        if ( isNotNumber( value ) ) { throw new TypeError( `Bunch size cannot be an instance of ${value.constructor.name} ! Expect a positive number.` ) }
        if ( !isNumberPositive( value ) ) { throw new TypeError( `Bunch size cannot be lower or equal to zero ! Expect a positive number.` ) }

        this._bunchSize = value;

    }

    /**
     *
     * @returns {*}
     */
    get requestAggregationTime () {
        return this._requestAggregationTime
    }

    set requestAggregationTime ( value ) {

        if ( isNull( value ) ) {
            throw new TypeError( 'Requests aggregation time cannot be null ! Expect a positive number.' )
        }

        if ( isUndefined( value ) ) {
            throw new TypeError( 'Requests aggregation time cannot be undefined ! Expect a positive number.' )
        }

        if ( isNotNumber( value ) ) {
            throw new TypeError( `Requests aggregation time cannot be an instance of ${value.constructor.name} ! Expect a positive number.` )
        }

        if ( isNumberNegative( value ) ) {
            throw new TypeError( 'Requests aggregation time cannot be lower or equal to zero ! Expect a positive number.' )
        }

        this._requestAggregationTime = value;

    }

    /**
     *
     * @returns {*}
     */
    get requestsConcurrency () {
        return this._requestsConcurrency
    }

    set requestsConcurrency ( value ) {

        if ( isNull( value ) ) {
            throw new TypeError( 'Minimum of simultaneous request cannot be null ! Expect a positive number.' )
        }

        if ( isUndefined( value ) ) {
            throw new TypeError( 'Minimum of simultaneous request cannot be undefined ! Expect a positive number.' )
        }

        if ( isNotNumber( value ) ) {
            throw new TypeError( `Minimum of simultaneous request cannot be an instance of ${value.constructor.name} ! Expect a positive number.` )
        }

        if ( isZero( value ) || isNumberNegative( value ) ) {
            throw new TypeError( 'Minimum of simultaneous request cannot be lower or equal to zero ! Expect a positive number.' )
        }

        this._requestsConcurrency = value;

    }

    /**
     *
     * @returns {TLogger}
     */
    get logger () {
        return this._logger
    }

    set logger ( value ) {

        if ( isNull( value ) ) { throw new TypeError( 'Progress manager cannot be null ! Expect an instance of TProgressManager.' ) }
        if ( isUndefined( value ) ) { throw new TypeError( 'Progress manager cannot be undefined ! Expect an instance of TProgressManager.' ) }
        if ( !( value instanceof TLogger ) ) { throw new TypeError( `Progress manager cannot be an instance of ${value.constructor.name} ! Expect an instance of TProgressManager.` ) }

        this._logger = value;

    }

    /**
     *
     * @param value
     * @returns {TDataBaseManager}
     */
    setBasePath ( value ) {

        this.basePath = value;
        return this

    }

    /**
     *
     * @param value
     * @returns {TDataBaseManager}
     */
    setResponseType ( value ) {

        this.responseType = value;
        return this

    }

    /**
     *
     * @param value
     * @returns {TDataBaseManager}
     */
    setBunchSize ( value ) {

        this.bunchSize = value;
        return this

    }

    /**
     *
     * @param value
     * @returns {TDataBaseManager}
     */
    setRequestAggregationTime ( value ) {

        this.requestAggregationTime = value;
        return this

    }

    /**
     *
     * @param value
     * @returns {TDataBaseManager}
     */
    setRequestsConcurrency ( value ) {

        this.requestsConcurrency = value;
        return this

    }

    /**
     *
     * @param value
     * @returns {TDataBaseManager}
     */
    setLogger ( value ) {

        this.logger = value;
        return this

    }

    /**
     *
     */
    aggregateQueue () {

        clearTimeout( this._aggregationTimeoutId );

        this._aggregationTimeoutId = setTimeout( () => {

            const datasToRequest = this._idToRequest;
            let idBunch          = [];
            for ( let idIndex = datasToRequest.length - 1 ; idIndex >= 0 ; idIndex-- ) {

                idBunch.push( datasToRequest.pop() );

                if ( idBunch.length === this._bunchSize || idIndex === 0 ) {

                    this._requestQueue.push( {
                        _id:        `readMany_${Generate.id}`,
                        _timeStart: new Date(),
                        _type:      RequestType.ReadMany,
                        method:     HttpVerb.Read.value,
                        url:        this._basePath,
                        data:       {
                            ids: idBunch
                        },
                        responseType: this._responseType
                    } );

                    idBunch = [];
                }

            }

            this.processQueue.call( this );

        }, this._requestAggregationTime );

    }

    /**
     *
     */
    processQueue () {

        while ( this._requestQueue.length > 0 && this._processQueue.length < this._requestsConcurrency ) {

            const requestSkull = this._requestQueue.pop();
            this._processQueue.push( requestSkull );

            const request              = new XMLHttpRequest();
            request.onloadstart        = _onLoadStart.bind( this );
            request.onload             = this._onLoad.bind( this,
                requestSkull,
                this._onEnd.bind( this, requestSkull, requestSkull.onLoad ),
                this._onProgress.bind( this, requestSkull.onProgress ),
                this._onError.bind( this, requestSkull, requestSkull.onError )
            );
            request.onloadend          = _onLoadEnd.bind( this );
            request.onprogress         = this._onProgress.bind( this, requestSkull.onProgress );
            request.onreadystatechange = _onReadyStateChange.bind( this );
            request.onabort            = _onAbort.bind( this );
            request.onerror            = this._onError.bind( this, requestSkull, requestSkull.onError );
            request.ontimeout          = _onTimeout.bind( this );
            request.open( requestSkull.method, requestSkull.url, true );
            request.setRequestHeader( 'Content-Type', 'application/json' );
            request.setRequestHeader( 'Accept', 'application/json' );
            request.responseType = requestSkull.responseType.value;

            const dataToSend = ( requestSkull.data && requestSkull.responseType === ResponseType.Json ) ? JSON.stringify( requestSkull.data ) : requestSkull.data;
            request.send( dataToSend );

        }

        function _onLoadStart ( loadStartEvent ) { this.logger.progress( loadStartEvent ); }

        function _onLoadEnd ( loadEndEvent ) { this.logger.progress( loadEndEvent ); }

        function _onReadyStateChange ( readyStateEvent ) { this.logger.debug( readyStateEvent ); }

        function _onAbort ( abortEvent ) { this.logger.error( abortEvent ); }

        function _onTimeout ( timeoutEvent ) { this.logger.error( timeoutEvent ); }

    }

    // Publics
    /**
     * The create method allow to create a new ressource on the server. Providing a single object that match a database schema, or an array of them.
     *
     * @param {object|array.<object>} data - The data to send for create new objects.
     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
     */
    create ( data, onLoadCallback, onProgressCallback, onErrorCallback ) {

        if ( isArray( data ) && isNotEmptyArray( data ) ) {

            if ( isArrayOfSingleElement( data ) ) {

                this._createOne( data[ 0 ], onLoadCallback, onProgressCallback, onErrorCallback );

            } else {

                this._createMany( data, onLoadCallback, onProgressCallback, onErrorCallback );

            }

        } else if ( isObject( data ) && isNotEmptyObject( data ) ) {

            this._createOne( data, onLoadCallback, onProgressCallback, onErrorCallback );

        } else {

            onErrorCallback( 'TDataBaseManager.create: Invalid data type, expect object or array of objects.' );

        }

    }

    /**
     * The read method allow to retrieve data from the server, using a single id or an array of them.
     *
     * @param {string|array.<string>} condition - The ids of objects to retrieve.
     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
     */
    read ( condition, projection, onLoadCallback, onProgressCallback, onErrorCallback ) {

        if ( isString( condition ) && isNotEmptyString( condition ) && isNotBlankString( condition ) ) {

            this._readOne( condition, projection, onLoadCallback, onProgressCallback, onErrorCallback );

        } else if ( isArray( condition ) && isNotEmptyArray( condition ) ) {

            if ( isArrayOfSingleElement( condition ) ) {

                this._readOne( condition[ 0 ], projection, onLoadCallback, onProgressCallback, onErrorCallback );

            } else {

                this._readMany( condition, projection, onLoadCallback, onProgressCallback, onErrorCallback );

            }

        } else if ( isObject( condition ) ) {

            if ( isEmptyObject( condition ) ) {

                this._readAll( projection, onLoadCallback, onProgressCallback, onErrorCallback );

            } else {

                this._readWhere( condition, projection, onLoadCallback, onProgressCallback, onErrorCallback );

            }

        } else {

            onErrorCallback( 'TDataBaseManager.read: Invalid data type, expect string, object or array of objects.' );

        }

    }

    /**
     * The update method allow to update data on the server, using a single id or an array of them, and a corresponding object about the data to update.
     *
     * @param {string|array.<string>} condition - The ids of objects to update.
     * @param {object} update - The update data ( need to match the related database schema ! ). In case of multiple ids they will be updated with the same given data.
     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
     */
    update ( condition, update, onLoadCallback, onProgressCallback, onErrorCallback ) {

        if ( isNotDefined( update ) ) {
            onErrorCallback( 'TDataBaseManager.update: Update data cannot be null or undefined !' );
            return
        }

        if ( isNotObject( update ) ) {
            onErrorCallback( 'TDataBaseManager.update: Invalid update data type. Expect an object.' );
            return
        }

        if ( isString( condition ) && isNotEmptyString( condition ) && isNotBlankString( condition ) ) {

            this._updateOne( condition, update, onLoadCallback, onProgressCallback, onErrorCallback );

        } else if ( isArray( condition ) && isNotEmptyArray( condition ) ) {

            if ( isArrayOfSingleElement( condition ) ) {

                this._updateOne( condition[ 0 ], update, onLoadCallback, onProgressCallback, onErrorCallback );

            } else {

                this._updateMany( condition, update, onLoadCallback, onProgressCallback, onErrorCallback );

            }

        } else if ( isObject( condition ) ) {

            if ( isEmptyObject( condition ) ) {

                this._updateAll( update, onLoadCallback, onProgressCallback, onErrorCallback );

            } else {

                this._updateWhere( condition, update, onLoadCallback, onProgressCallback, onErrorCallback );

            }

        } else {

            onErrorCallback( 'TDataBaseManager.update: Invalid data type, expect string, object or array of objects.' );

        }

    }

    /**
     * The delete method allow to remove data from the server, using a single id or an array of them.
     *
     * @param {string|array.<string>|object|null} condition - The ids of objects to delete.
     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
     */
    delete ( condition, onLoadCallback, onProgressCallback, onErrorCallback ) {

        if ( isString( condition ) && isNotEmptyString( condition ) && isNotBlankString( condition ) ) {

            this._deleteOne( condition, onLoadCallback, onProgressCallback, onErrorCallback );

        } else if ( isArray( condition ) && isNotEmptyArray( condition ) ) {

            if ( isArrayOfSingleElement( condition ) ) {

                this._deleteOne( condition[ 0 ], onLoadCallback, onProgressCallback, onErrorCallback );

            } else {

                this._deleteMany( condition, onLoadCallback, onProgressCallback, onErrorCallback );

            }

        } else if ( isObject( condition ) ) {

            if ( isEmptyObject( condition ) ) {

                this._deleteAll( onLoadCallback, onProgressCallback, onErrorCallback );

            } else {

                this._deleteWhere( condition, onLoadCallback, onProgressCallback, onErrorCallback );

            }

        } else {

            onErrorCallback( 'TDataBaseManager.delete: Invalid data type, expect null, string, object or array of objects.' );

        }

    }

    // Privates

    //// Events

    /**
     * The private _onLoad method allow to process the server response in an abstract way to check against error and wrong status code.
     * It will bind user callback on each type of returns, and dispatch in sub methods in function of the response type.
     *
     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
     * @param {object} loadEvent - The server response object to parse.
     * @private
     */
    _onLoad ( request, onLoadCallback, onProgressCallback, onErrorCallback, loadEvent ) {

        const target       = loadEvent.target;
        const status       = target.status;
        const response     = target.response;
        const responseType = target.responseType;

        switch ( status ) {

            // 100
            //            case HttpStatusCode.Continue.value:
            //            case HttpStatusCode.SwitchingProtocols.value:
            //            case HttpStatusCode.Processing.value:

            // 200
            case HttpStatusCode.Ok.value:
                this._dispatchResponse( response, responseType, onLoadCallback, onProgressCallback, onErrorCallback );
                break
            //            case HttpStatusCode.Created.value:
            //            case HttpStatusCode.Accepted.value:

            case HttpStatusCode.NonAuthoritativeInformation.value:
            case HttpStatusCode.NoContent.value:
            case HttpStatusCode.ResetContent.value:
            case HttpStatusCode.PartialContent.value:
            case HttpStatusCode.MultiStatus.value:
            case HttpStatusCode.AlreadyReported.value:
            case HttpStatusCode.ContentDifferent.value:
            case HttpStatusCode.IMUsed.value:
            case HttpStatusCode.MultipleChoices.value:
            case HttpStatusCode.MovedPermanently.value:
            case HttpStatusCode.Found.value:
            case HttpStatusCode.SeeOther.value:
            case HttpStatusCode.NotModified.value:
            case HttpStatusCode.UseProxy.value:
            case HttpStatusCode.Unused.value:
            case HttpStatusCode.TemporaryRedirect.value:
            case HttpStatusCode.PermanentRedirect.value:
            case HttpStatusCode.TooManyRedirects.value:
            case HttpStatusCode.BadRequest.value:
            case HttpStatusCode.Unauthorized.value:
            case HttpStatusCode.PaymentRequired.value:
            case HttpStatusCode.Forbidden.value:
            case HttpStatusCode.NotFound.value:
            case HttpStatusCode.MethodNotAllowed.value:
            case HttpStatusCode.NotAcceptable.value:
            case HttpStatusCode.ProxyAuthenticationRequired.value:
            case HttpStatusCode.RequestTimeOut.value:
            case HttpStatusCode.Conflict.value:
            case HttpStatusCode.Gone.value:
            case HttpStatusCode.LengthRequired.value:
            case HttpStatusCode.PreconditionFailed.value:
            case HttpStatusCode.RequestEntityTooLarge.value:
            case HttpStatusCode.RequestRangeUnsatisfiable.value:
            case HttpStatusCode.ExpectationFailed.value:
            case HttpStatusCode.ImATeapot.value:
            case HttpStatusCode.BadMapping.value:
            case HttpStatusCode.UnprocessableEntity.value:
            case HttpStatusCode.Locked.value:
            case HttpStatusCode.MethodFailure.value:
            case HttpStatusCode.UnorderedCollection.value:
            case HttpStatusCode.UpgradeRequired.value:
            case HttpStatusCode.PreconditionRequired.value:
            case HttpStatusCode.TooManyRequests.value:
            case HttpStatusCode.RequestHeaderFieldsTooLarge.value:
            case HttpStatusCode.NoResponse.value:
            case HttpStatusCode.RetryWith.value:
            case HttpStatusCode.BlockedByWindowsParentalControls.value:
            case HttpStatusCode.UnavailableForLegalReasons.value:
            case HttpStatusCode.UnrecoverableError.value:
            case HttpStatusCode.SSLCertificateError.value:
            case HttpStatusCode.SSLCertificateRequired.value:
            case HttpStatusCode.HTTPRequestSentToHTTPSPort.value:
            case HttpStatusCode.ClientClosedRequest.value:
            case HttpStatusCode.InternalServerError.value:
            case HttpStatusCode.NotImplemented.value:
            case HttpStatusCode.BadGateway.value:
            case HttpStatusCode.ServiceUnavailable.value:
            case HttpStatusCode.GatewayTimeOut.value:
            case HttpStatusCode.HTTPVersionNotSupported.value:
            case HttpStatusCode.VariantAlsoNegotiates.value:
            case HttpStatusCode.InsufficientStorage.value:
            case HttpStatusCode.LoopDetected.value:
            case HttpStatusCode.BandwidthLimitExceeded.value:
            case HttpStatusCode.NotExtended.value:
            case HttpStatusCode.NetworkAuthenticationRequired.value:
            case HttpStatusCode.UnknownError.value:
            case HttpStatusCode.WebServerIsDown.value:
            case HttpStatusCode.ConnectionTimedOut.value:
            case HttpStatusCode.OriginIsUnreachable.value:
            case HttpStatusCode.ATimeoutOccured.value:
            case HttpStatusCode.SSLHandshakeFailed.value:
            case HttpStatusCode.InvalidSSLCertificate.value:
            case HttpStatusCode.RailgunError.value:
                onErrorCallback( response );
                break

            default:
                throw new RangeError( `Unmanaged HttpStatusCode: ${status}` )

        }

    }

    /**
     * The private _onProgress method will handle all progress event from server and submit them to the logger if exist else to the user onProgressCallback
     *
     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
     * @param {object} progressEvent - The server progress event.
     * @private
     */
    _onProgress ( onProgressCallback, progressEvent ) {

        if ( isDefined( this.logger ) ) {

            this.logger.progress( progressEvent, onProgressCallback );

        } else if ( isDefined( onProgressCallback ) ) {

            onProgressCallback( progressEvent );

        }

    }

    /**
     * The private _onError method will handle all error event from server and submit them to the logger if exist else to the user onErrorCallback
     *
     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
     * @param {object} errorEvent - A server error event
     * @private
     */
    _onError ( request, onErrorCallback, errorEvent ) {

        this._closeRequest( request );

        if ( isDefined( this.logger ) ) {

            this.logger.error( errorEvent, onErrorCallback );

        } else if ( isDefined( onErrorCallback ) ) {

            onErrorCallback( errorEvent );

        }

    }

    /**
     * The private _onEnd method is call after all other callback and perform request type checking in view to upadte cache, waitingqueue and callback if needed,
     * to finally close the request
     *
     * @param request
     * @param onLoadCallback
     * @param response
     * @private
     */
    _onEnd ( request, onLoadCallback, response ) {

        const type = request._type;

        switch ( type ) {

            case RequestType.ReadOne:
            case RequestType.ReadMany:
                this._updateCache( response );
                this._updateWaitingQueue();
                break

            case RequestType.ReadWhere:
            case RequestType.ReadAll:
                this._updateCache( response );
                this._updateWaitingQueue();
                onLoadCallback( response );
                break

            case RequestType.CreateOne:
            case RequestType.CreateMany:
            case RequestType.UpdateOne:
            case RequestType.UpdateMany:
            case RequestType.UpdateWhere:
            case RequestType.UpdateAll:
            case RequestType.DeleteOne:
            case RequestType.DeleteMany:
            case RequestType.DeleteWhere:
            case RequestType.DeleteAll:
                onLoadCallback( response );
                break

            default:
                throw new RangeError( `Invalid request type: ${type}` )

        }

        this._closeRequest( request );

    }

    //// Data parsing
    // Expect that methods were reimplemented when TDataBaseManager is inherited

    /**
     * Dispatch response to the correct handler in function of response type
     *
     * @param response
     * @param responseType
     * @param onLoadCallback
     * @param onProgressCallback
     * @param onErrorCallback
     * @private
     */
    _dispatchResponse ( response, responseType, onLoadCallback, onProgressCallback, onErrorCallback ) {

        switch ( responseType ) {

            case ResponseType.ArrayBuffer.value:
                this._onArrayBuffer(
                    response,
                    onLoadCallback,
                    onProgressCallback,
                    onErrorCallback
                );
                break

            case ResponseType.Blob.value:
                this._onBlob(
                    response,
                    onLoadCallback,
                    onProgressCallback,
                    onErrorCallback
                );
                break

            case ResponseType.Json.value:
                this._onJson(
                    response,
                    onLoadCallback,
                    onProgressCallback,
                    onErrorCallback
                );
                break

            case ResponseType.DOMString.value:
            case ResponseType.Default.value:
                this._onText(
                    response,
                    onLoadCallback,
                    onProgressCallback,
                    onErrorCallback
                );
                break

            default:
                throw new Error( `Unknown response type: ${responseType}` )

        }

    }

    /**
     * Will remove the request from the process queue
     *
     * @param request
     * @private
     */
    _closeRequest ( request ) {

        this._processQueue.splice( this._processQueue.indexOf( request ), 1 );

        if ( Window.Itee && Window.Itee.Debug ) {

            const diff    = new Date().valueOf() - request._timeStart.valueOf();
            const message = `${this.constructor.name} close request [${request._id}] on ${diff}ms.` +
                `Waiting queue: ${this._waitingQueue.length}` +
                `Request queue: ${this._requestQueue.length}` +
                `Process queue: ${this._processQueue.length}` +
                `==========================`;
            this.logger.debug( message );

        }

        this.processQueue();

    }

    /**
     *
     * @param ids
     * @returns {Object}
     * @private
     */
    _retrieveCachedValues ( ids ) {

        let results      = {};
        let underRequest = [];
        let toRequest    = [];

        for ( let idIndex = 0, numberOfIds = ids.length ; idIndex < numberOfIds ; idIndex++ ) {

            const id          = ids[ idIndex ];
            const cachedValue = this._cache.get( id );

            if ( isDefined( cachedValue ) ) {
                results[ id ] = cachedValue;
            } else if ( isNull( cachedValue ) ) { // In request
                underRequest.push( id );
            } else {
                toRequest.push( id );
            }

        }

        return {
            results,
            underRequest,
            toRequest
        }

    }

    /**
     *
     * @param datas
     * @private
     */
    _updateCache ( datas ) {

        if ( isNull( datas ) ) { throw new TypeError( 'Data cannot be null ! Expect an array of object.' ) }
        if ( isUndefined( datas ) ) { throw new TypeError( 'Data cannot be undefined ! Expect an array of object.' ) }

        let _datas = {};
        if ( isArray( datas ) ) {

            for ( let key in datas ) {
                _datas[ datas[ key ]._id ] = datas[ key ];
            }

        } else {

            _datas = datas;

        }

        for ( let [ id, data ] of Object.entries( _datas ) ) {

            const cachedResult = this._cache.get( id );

            if ( isNull( cachedResult ) ) {
                this._cache.add( id, data, true );
            } else if ( isUndefined( cachedResult ) ) {
                this.logger.warn( 'Cache was not pre-allocated with null value.' );
                this._cache.add( id, data );
            } else {
                this.logger.error( 'Cached value already exist !' );
            }

        }

    }

    /**
     *
     * @private
     */
    _updateWaitingQueue () {

        const haveNoRequestToProcess = ( this._requestQueue.length === 0 && this._processQueue.length === 0 );

        for ( let requestIndex = this._waitingQueue.length - 1 ; requestIndex >= 0 ; requestIndex-- ) {

            const demand = this._waitingQueue[ requestIndex ];

            // Update requested datas
            for ( let dataIndex = demand.underRequest.length - 1 ; dataIndex >= 0 ; dataIndex-- ) {

                const id           = demand.underRequest[ dataIndex ];
                const cachedResult = this._cache.get( id );

                if ( isNotDefined( cachedResult ) ) { continue }

                // Assign the cached value
                demand.results[ id ] = cachedResult;

                // Remove the requested object that is now added
                demand.underRequest.splice( demand.underRequest.indexOf( id ), 1 );

            }

            // Check if request is now fullfilled
            const demandIsComplet = ( demand.underRequest.length === 0 );
            if ( demandIsComplet ) {

                this._waitingQueue.splice( requestIndex, 1 );
                demand.onLoadCallback( demand.results );

            } else if ( !demandIsComplet && haveNoRequestToProcess /* && haveTryAgainManyTimesButFail */ ) {

                this.logger.warn( 'Incomplet demand but empty request/process queue' );
                this._waitingQueue.splice( requestIndex, 1 );
                demand.onLoadCallback( demand.results );

            } else ;

        }

    }

    /**
     * The abstract private _onArrayBuffer method must be overridden in case the parser expect an array buffer as input data.
     *
     * @private
     * @abstract
     * @param {ArrayBuffer} data - The retrieved data to parse.
     * @param {function} onSuccess - The onLoad callback, which is call when parser parse with success the data.
     * @param {function} onProgress - The onProgress callback, which is call during the parsing.
     * @param {function} onError - The onError callback, which is call when parser throw an error during parsing.
     */
    // eslint-disable-next-line no-unused-vars
    _onArrayBuffer ( data, onSuccess, onProgress, onError ) {}

    /**
     * The abstract private _onBlob method must be overridden in case the parser expect a blob as input data.
     *
     * @private
     * @abstract
     * @param {Blob} data - The retrieved data to parse.
     * @param {function} onSuccess - The onLoad callback, which is call when parser parse with success the data.
     * @param {function} onProgress - The onProgress callback, which is call during the parsing.
     * @param {function} onError - The onError callback, which is call when parser throw an error during parsing.
     */
    // eslint-disable-next-line no-unused-vars
    _onBlob ( data, onSuccess, onProgress, onError ) {}

    /**
     * The abstract private _onJson method must be overridden in case the parser expect json as input data.
     *
     * @private
     * @abstract
     * @param {json} data - The retrieved data to parse.
     * @param {function} onSuccess - The onLoad callback, which is call when parser parse with success the data.
     * @param {function} onProgress - The onProgress callback, which is call during the parsing.
     * @param {function} onError - The onError callback, which is call when parser throw an error during parsing.
     */
    // eslint-disable-next-line no-unused-vars
    _onJson ( data, onSuccess, onProgress, onError ) {}

    /**
     * The abstract private _onText method must be overridden in case the parser expect a string/text as input data.
     *
     * @private
     * @abstract
     * @param {string} data - The retrieved data to parse.
     * @param {function} onSuccess - The onLoad callback, which is call when parser parse with success the data.
     * @param {function} onProgress - The onProgress callback, which is call during the parsing.
     * @param {function} onError - The onError callback, which is call when parser throw an error during parsing.
     */
    // eslint-disable-next-line no-unused-vars
    _onText ( data, onSuccess, onProgress, onError ) {}

    // REST Api calls
    /**
     * The private _create method allow to format a server request to create objects with the given data and get creation result with given callbacks.
     *
     * @private
     * @param {object} data - The data to send.
     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
     */
    _createOne ( data, onLoadCallback, onProgressCallback, onErrorCallback ) {

        this._requestQueue.push( {
            _id:          `createOne_${Generate.id}`,
            _timeStart:   new Date(),
            _type:        RequestType.CreateOne,
            method:       HttpVerb.Create.value,
            url:          this._basePath,
            data:         data,
            onLoad:       onLoadCallback,
            onProgress:   onProgressCallback,
            onError:      onErrorCallback,
            responseType: this._responseType
        } );

        this.processQueue();

    }

    /**
     *
     * @param datas
     * @param onLoadCallback
     * @param onProgressCallback
     * @param onErrorCallback
     * @private
     */
    _createMany ( datas, onLoadCallback, onProgressCallback, onErrorCallback ) {

        this._requestQueue.push( {
            _id:          `createMany_${Generate.id}`,
            _timeStart:   new Date(),
            _type:        RequestType.CreateMany,
            method:       HttpVerb.Create.value,
            url:          this._basePath,
            data:         datas,
            onLoad:       onLoadCallback,
            onProgress:   onProgressCallback,
            onError:      onErrorCallback,
            responseType: this._responseType
        } );

        this.processQueue();

    }

    /**
     * The private _updateOne method will format a server request to get a single object with the given id.
     *
     * @private
     * @param {string} id - The object's id of the object to retrieve.
     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
     */
    _readOne ( id, projection, onLoadCallback, onProgressCallback, onErrorCallback ) {

        // Filter requested values by cached values
        const datas = this._retrieveCachedValues( [ id ] );

        // retrieveLocalStorageValues...

        // getDatabaseValues()

        if ( datas.toRequest.length === 0 ) {

            if ( datas.underRequest.length === 0 ) {

                onLoadCallback( datas.results );

            } else {

                datas[ 'onLoadCallback' ]     = onLoadCallback;
                datas[ 'onProgressCallback' ] = onProgressCallback;
                datas[ 'onErrorCallback' ]    = onErrorCallback;
                this._waitingQueue.push( datas );

            }

        } else {

            datas[ 'onLoadCallback' ]     = onLoadCallback;
            datas[ 'onProgressCallback' ] = onProgressCallback;
            datas[ 'onErrorCallback' ]    = onErrorCallback;
            this._waitingQueue.push( datas );

            try {
                this._cache.add( id, null );
                datas.underRequest.push( id );
                datas.toRequest.splice( datas.toRequest.indexOf( id ), 1 );
            } catch ( error ) {
                this.logger.error( error );
            }

            this._idToRequest.push( id );
            this.aggregateQueue();

        }

    }

    /**
     * The private _readMany method will format a server request to get objects with id in the ids array.
     *
     * @private
     * @param {array.<string>} ids - The ids of objects to retrieve.
     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
     */
    _readMany ( ids, projection, onLoadCallback, onProgressCallback, onErrorCallback ) {

        // Filter requested values by cached values
        const datas = this._retrieveCachedValues( ids );

        // retrieveLocalStorageValues...

        // getDatabaseValues()

        if ( datas.toRequest.length === 0 ) {

            if ( datas.underRequest.length === 0 ) {

                onLoadCallback( datas.results );

            } else {

                datas[ 'onLoadCallback' ]     = onLoadCallback;
                datas[ 'onProgressCallback' ] = onProgressCallback;
                datas[ 'onErrorCallback' ]    = onErrorCallback;
                this._waitingQueue.push( datas );

            }

        } else {

            datas[ 'onLoadCallback' ]     = onLoadCallback;
            datas[ 'onProgressCallback' ] = onProgressCallback;
            datas[ 'onErrorCallback' ]    = onErrorCallback;
            this._waitingQueue.push( datas );

            const datasToRequest = datas.toRequest;
            let id               = undefined;
            for ( let idIndex = datasToRequest.length - 1 ; idIndex >= 0 ; idIndex-- ) {

                id = datasToRequest[ idIndex ];

                // Prepare entry for id to request
                try {
                    this._cache.add( id, null );
                    datas.underRequest.push( id );
                    datas.toRequest.splice( datas.toRequest.indexOf( id ), 1 );
                } catch ( error ) {
                    this.logger.error( error );
                }

                this._idToRequest.push( id );

            }

            this.aggregateQueue();

        }

    }

    /**
     *
     * @param query
     * @param projection
     * @param onLoadCallback
     * @param onProgressCallback
     * @param onErrorCallback
     * @private
     */
    _readWhere ( query, projection, onLoadCallback, onProgressCallback, onErrorCallback ) {

        //        // Filter requested values by cached values
        //                const datas = {
        //                    results: {},
        //                    underRequest: [],
        //                    toRequest: []
        //                }
        //
        //        datas[ 'onLoadCallback' ] = onLoadCallback
        //        this._waitingQueue.push( datas )

        this._requestQueue.push( {
            _id:        `readWhere_${Generate.id}`,
            _timeStart: new Date(),
            _type:      RequestType.ReadWhere,
            method:     HttpVerb.Read.value,
            url:        this._basePath,
            data:       {
                query,
                projection
            },
            onLoad:       onLoadCallback,
            onProgress:   onProgressCallback,
            onError:      onErrorCallback,
            responseType: this._responseType
        } );

        this.processQueue();

    }

    /**
     *
     * @param projection
     * @param onLoadCallback
     * @param onProgressCallback
     * @param onErrorCallback
     * @private
     */
    _readAll ( projection, onLoadCallback, onProgressCallback, onErrorCallback ) {

        //        const datas = {
        //            results: {},
        //            underRequest: [],
        //            toRequest: []
        //        }
        //
        //        datas[ 'onLoadCallback' ] = onLoadCallback
        //        this._waitingQueue.push( datas )

        const query = {};

        this._requestQueue.push( {
            _id:        `readAll_${Generate.id}`,
            _timeStart: new Date(),
            _type:      RequestType.ReadAll,
            method:     HttpVerb.Read.value,
            url:        this._basePath,
            data:       {
                query,
                projection
            },
            onLoad:       onLoadCallback,
            onProgress:   onProgressCallback,
            onError:      onErrorCallback,
            responseType: this._responseType
        } );

        this.processQueue();

    }

    /**
     * The private _updateOne method will format a server request to update a single object with the given id.
     *
     * @param {string} id - The object's id of the object to update.
     * @param update
     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
     * @private
     */
    _updateOne ( id, update, onLoadCallback, onProgressCallback, onErrorCallback ) {

        this._requestQueue.push( {
            _id:        `updateOne_${Generate.id}`,
            _timeStart: new Date(),
            _type:      RequestType.UpdateOne,
            method:     HttpVerb.Update.value,
            url:        `${this._basePath}/${id}`,
            data:       {
                update
            },
            onLoad:       onLoadCallback,
            onProgress:   onProgressCallback,
            onError:      onErrorCallback,
            responseType: this._responseType
        } );

        this.processQueue();

    }

    /**
     * The private _updateMany method will format a server request to update objects with id in the ids array.
     *
     * @param {array.<string>} ids - The ids of objects to update.
     * @param update
     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
     * @private
     */
    _updateMany ( ids, update, onLoadCallback, onProgressCallback, onErrorCallback ) {

        this._requestQueue.push( {
            _id:        `updateMany_${Generate.id}`,
            _timeStart: new Date(),
            _type:      RequestType.UpdateMany,
            method:     HttpVerb.Update.value,
            url:        this._basePath,
            data:       {
                ids,
                update
            },
            onLoad:       onLoadCallback,
            onProgress:   onProgressCallback,
            onError:      onErrorCallback,
            responseType: this._responseType
        } );

        this.processQueue();

    }

    /**
     *
     * @param query
     * @param update
     * @param onLoadCallback
     * @param onProgressCallback
     * @param onErrorCallback
     * @private
     */
    _updateWhere ( query, update, onLoadCallback, onProgressCallback, onErrorCallback ) {

        this._requestQueue.push( {
            _id:        `updateWhere_${Generate.id}`,
            _timeStart: new Date(),
            _type:      RequestType.UpdateWhere,
            method:     HttpVerb.Update.value,
            url:        this._basePath,
            data:       {
                query,
                update
            },
            onLoad:       onLoadCallback,
            onProgress:   onProgressCallback,
            onError:      onErrorCallback,
            responseType: this._responseType
        } );

        this.processQueue();

    }

    /**
     *
     * @param update
     * @param onLoadCallback
     * @param onProgressCallback
     * @param onErrorCallback
     * @private
     */
    _updateAll ( update, onLoadCallback, onProgressCallback, onErrorCallback ) {

        const query = {};

        this._requestQueue.push( {
            _id:        `updateAll_${Generate.id}`,
            _timeStart: new Date(),
            _type:      RequestType.UpdateAll,
            method:     HttpVerb.Update.value,
            url:        this._basePath,
            data:       {
                query,
                update
            },
            onLoad:       onLoadCallback,
            onProgress:   onProgressCallback,
            onError:      onErrorCallback,
            responseType: this._responseType
        } );

        this.processQueue();

    }

    /**
     * The private _deleteOne method will format a server request to delete a single object with the given id.
     *
     * @param {string} id - The object's id of the object to delete.
     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
     * @private
     */
    _deleteOne ( id, onLoadCallback, onProgressCallback, onErrorCallback ) {

        this._requestQueue.push( {
            _id:          `deleteOne_${Generate.id}`,
            _timeStart:   new Date(),
            _type:        RequestType.DeleteOne,
            method:       HttpVerb.Delete.value,
            url:          `${this._basePath}/${id}`,
            data:         null,
            onLoad:       onLoadCallback,
            onProgress:   onProgressCallback,
            onError:      onErrorCallback,
            responseType: this._responseType
        } );

        this.processQueue();

    }

    /**
     * The private _deleteMany method will format a server request to delete objects with id in the ids array.
     *
     * @param {array.<string>} ids - The ids of objects to delete.
     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
     * @private
     */
    _deleteMany ( ids, onLoadCallback, onProgressCallback, onErrorCallback ) {

        this._requestQueue.push( {
            _id:        `deleteMany_${Generate.id}`,
            _timeStart: new Date(),
            _type:      RequestType.DeleteMany,
            method:     HttpVerb.Delete.value,
            url:        this._basePath,
            data:       {
                ids
            },
            onLoad:       onLoadCallback,
            onProgress:   onProgressCallback,
            onError:      onErrorCallback,
            responseType: this._responseType
        } );

        this.processQueue();

    }

    /**
     *
     * @param query
     * @param onLoadCallback
     * @param onProgressCallback
     * @param onErrorCallback
     * @private
     */
    _deleteWhere ( query, onLoadCallback, onProgressCallback, onErrorCallback ) {

        this._requestQueue.push( {
            _id:        `deleteWhere_${Generate.id}`,
            _timeStart: new Date(),
            _type:      RequestType.DeleteWhere,
            method:     HttpVerb.Delete.value,
            url:        this._basePath,
            data:       {
                query
            },
            onLoad:       onLoadCallback,
            onProgress:   onProgressCallback,
            onError:      onErrorCallback,
            responseType: this._responseType
        } );

        this.processQueue();

    }

    /**
     *
     * @param onLoadCallback
     * @param onProgressCallback
     * @param onErrorCallback
     * @private
     */
    _deleteAll ( onLoadCallback, onProgressCallback, onErrorCallback ) {

        const query = {};

        this._requestQueue.push( {
            _id:        `deleteAll_${Generate.id}`,
            _timeStart: new Date(),
            _type:      RequestType.DeleteAll,
            method:     HttpVerb.Delete.value,
            url:        this._basePath,
            data:       {
                query
            },
            onLoad:       onLoadCallback,
            onProgress:   onProgressCallback,
            onError:      onErrorCallback,
            responseType: this._responseType
        } );

        this.processQueue();

    }

}

// Static stuff
/**
 *
 * @type {number}
 * @private
 */
TDataBaseManager._requestId = 0;

/**
 *
 * @type {Object}
 * @private
 */
TDataBaseManager._requests = {
    /**
     * The global waiting queue to process
     */
    waitingQueue: {},
    /**
     * The objects not requested yet
     */
    toProcess:    {
        create: {},
        read:   {},
        update: {},
        delete: {}
    },
    /**
     * The object currently under request
     */
    underProcess: {
        create: {},
        read:   {},
        update: {},
        delete: {}
    },
    /**
     * The objects already processed
     */
    processed: {
        create: {},
        read:   {},
        update: {},
        delete: {}
    }
};

/**
 * @deprecated
 * @type {ReadonlyArray<unknown>}
 */
const TIdFactoryType = toEnum( {
    Number: 0,
    String: 1,
    Uuid:   2
} );

/**
 * @deprecated
 */
class TIdFactory {

    constructor ( type = TIdFactoryType.Number, base = null ) {

        this.type = type;
        this.base = base;

        this._counter = 0;

    }

    get type () {
        return this._type
    }

    set type ( value ) {

        if ( isNull( value ) ) { throw new Error( `Type cannot be null ! Expect an value from TIdFactoryType enum: ${TIdFactoryType.types()}` ) }
        if ( isUndefined( value ) ) { throw new Error( `Type cannot be undefined ! Expect an value from TIdFactoryType enum: ${TIdFactoryType.types()}` ) }
        if ( !TIdFactoryType.includes( value ) ) { throw new Error( `Invalide type ! Expect an value from TIdFactoryType enum: ${TIdFactoryType.types()}` ) }

        this._type = value;
    }

    get base () {
        return this._base
    }

    set base ( value ) {

        if ( isUndefined( value ) ) { throw new Error( 'Base cannot be undefined ! Expect an instance of Object3D.' ) }

        if ( ( this._type === TIdFactoryType.Number ) && isNotNumber( value ) ) { throw new Error( 'Invalide Base ! It does not match the type.' ) }
        if ( ( this._type === TIdFactoryType.String ) && isNotString( value ) ) { throw new Error( 'Invalide Base ! It does not match the type.' ) }
        //        if( (this._type === TIdFactoryType.Uuid) && isNotUuid( value ) ) { throw new Error( 'Invalide Base ! It does not match the type.' ) }

        this._base = value;
    }

    setType ( value ) {

        this.type = value;
        return this

    }

    setBase ( value ) {

        this.base = value;
        return this

    }

    createId () {
        return this._base + this._counter++
    }

}

// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}

var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

function validate(uuid) {
  return typeof uuid === 'string' && REGEX.test(uuid);
}

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!validate(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return stringify(rnds);
}

/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 */

/**
 * @typedef {Object} WebAPIMessageSerialized
 * @property {string} id
 * @property {string} type
 */

/**
 * @class
 * @classdesc The base class for all web api message
 */
class WebAPIMessage {

    /**
     * @static
     * @type {boolean}
     */
    static isWebAPIMessage = true

    /**
     *
     * @param {string} type
     */
    constructor ( type ) {
        this._id  = v4();
        this.type = type;
    }

    /**
     *
     */
    get id () {
        return this._id
    }

    /**
     *
     * @returns {string}
     */
    get type () {
        return this._type
    }

    set type ( value ) {
        if ( isNotString( value ) ) { throw new ReferenceError( 'WebAPIMessage type cannot be null or undefined !' )}
        if ( isEmptyString( value ) ) { throw new TypeError( 'WebAPIMessage type cannot be an empty string !' )}

        this._type = value;
    }

    /**
     *
     * @returns {{id: string, type: string}}
     */
    toJSON () {

        return {
            id:   this.id,
            type: this.type
        }

    }

}

/**
 * @typedef {Object} WebAPIMessageDataSerialized
 * @property {object} data
 * @instance
 */

/**
 * @class
 * @classdesc The web api message for serializable data transfert
 * @extends WebAPIMessage
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 */
class WebAPIMessageData extends WebAPIMessage {

    /**
     * @static
     * @type {boolean}
     */
    static isWebAPIMessageData = true

    /**
     *
     * @param data
     */
    constructor ( data ) {
        super( '_data' );

        this.data = data;
    }

    /**
     *
     * @returns {{data: *}}
     */
    toJSON () {

        return {
            ...super.toJSON(),
            ...{
                data: JSON.stringify( this.data )
            }
        }

    }

}

/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 */

class WebAPIMessageError extends WebAPIMessage {

    static isWebAPIMessageError = true

    /**
     *
     * @param error
     */
    constructor ( error ) {
        super( '_error' );

        this.message = error.message;
        this.stack   = error.stack;
    }

    /**
     *
     * @returns {{stack: *, message: *}}
     */
    toJSON () {

        return {
            ...super.toJSON(),
            ...{
                message: this.message,
                stack:   this.stack
            }
        }

    }

}

/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 */

/**
 * @class
 */
class WebAPIMessageProgress extends WebAPIMessage {

    static isWebAPIMessageProgress = true

    /**
     *
     * @param loaded
     * @param total
     */
    constructor ( loaded = 0, total = 0 ) {
        super( '_progress' );

        this.lengthComputable = false;
        this.loaded           = loaded;
        this.total            = total;
    }

    /**
     *
     * @returns {*}
     */
    get loaded () {
        return this._loaded
    }

    set loaded ( value ) {
        this._loaded = value;
        this._checkIfLengthComputable();
    }

    /**
     *
     * @returns {*}
     */
    get total () {
        return this._total
    }

    set total ( value ) {
        this._total = value;
        this._checkIfLengthComputable();
    }

    /**
     *
     * @private
     */
    _checkIfLengthComputable () {

        this.lengthComputable = false;

        if (
            this._total > 0 &&
            this._total < Number.MAX_SAFE_INTEGER &&
            this._loaded >= 0 &&
            this._loaded < Number.MAX_SAFE_INTEGER
        ) {
            this.lengthComputable = true;
        }

    }

    /**
     *
     * @returns {{loaded: *, lengthComputable: boolean, total: *}}
     */
    toJSON () {

        return {
            ...super.toJSON(),
            ...{
                lengthComputable: this.lengthComputable,
                loaded:           this.loaded,
                total:            this.total
            }
        }

    }

}

/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 */

/**
 * @class
 * @classdesc Internal ready message to broadcast for prevent bad or dead messager
 */
class WebAPIMessageReady extends WebAPIMessage {

    /**
     * @static
     * @type {boolean}
     */
    static isWebAPIMessageReady = true

    /**
     *
     */
    constructor () {
        super( '_ready' );
    }

}

/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 */

/**
 * @class
 * @classdesc The message response to a message request
 */
class WebApiMessageResponse extends WebAPIMessage {

    /**
     *
     * @type {boolean}
     */
    static isWebApiMessageResponse = true

    /**
     *
     * @param request
     * @param result
     */
    constructor ( request, result ) {
        super( '_response' );

        this.request = request;
        this.result  = result;
    }

    /**
     *
     * @returns {*}
     */
    get request () {
        return this._request
    }

    set request ( value ) {
        if ( isNull( value ) ) { return }
        if ( isUndefined( value ) ) { return }

        this._request = value;
    }

    /**
     *
     * @returns {*}
     */
    get result () {
        return this._result
    }

    set result ( value ) {
        this._result = value;
    }

    /**
     *
     * @returns {{result: *, request: *}}
     */
    toJSON () {

        return {
            ...super.toJSON(),
            ...{
                request: this.request,
                result:  this.result
            }
        }

    }

}

/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 */

/**
 * A POJO object containg datas about a distant source to allow
 * @typedef {Object} AllowedOrigin
 * @property {string} id - The id to reference this origin as a human readable string
 * @property {string} uri - The uri of the origin to allow
 * @property {Array<String>} methods - An array of methods names that are allowed for this origins. To allow all methods use '*', in case no methods string were provide the origin won't be able to do
 *     anything.
 */

/**
 * @class
 * @classdesc The abstract class to use standardized webapi.
 * @abstract
 */
class AbstractWebAPI {

    /**
     * @constructor
     * @param {Object} parameters - An object containing all parameters to pass through the inheritance chain to initialize this instance
     * @param {Boolean} [parameters.allowAnyOrigins=false] - A boolean to allow or not any origins calls
     * @param {Array<AllowedOrigin>} [parameters.allowedOrigins=[]] - An array containing configured allowed origins
     * @param {String} [parameters.targetOrigin=''] - The current selected target origins on which will be send all requests
     * @param {Number} [parameters.requestTimeout=2000] - The request timeout before throw an error
     */
    constructor ( parameters = {} ) {

        const _parameters = {
            ...{
                logger:          DefaultLogger,
                allowAnyOrigins: false,
                allowedOrigins:  [],
                //                targetOrigin:    '',
                requestTimeout:  2000
            },
            ...parameters
        };

        // Internal stuff
        this.logger    = _parameters.logger;
        this._origin    = window.location.origin;
        this._responses = new Map();

        // Listen message from Window
        window.addEventListener( 'message', this._onMessage.bind( this ), false );

        // Public stuff
        this.allowAnyOrigins = _parameters.allowAnyOrigins;
        this.allowedOrigins  = _parameters.allowedOrigins;
        //        this.targetOrigin    = _parameters.targetOrigin // Todo: defaulting targetOrigin to the first allowedOrigins if exist
        this.requestTimeout  = _parameters.requestTimeout;

        // Emit onReady event
        this._broadCastReadyMessage();
    }

    get logger() {
        return this._logger
    }
    set logger(value) {
        if ( isNull( value ) ) { throw new ReferenceError( `[${ this._origin }]: The logger cannot be null, expect a TLogger.` )}
        if ( isUndefined( value ) ) { throw new ReferenceError( `[${ this._origin }]: The logger cannot be undefined, expect a TLogger.` )}
        if ( !value.isLogger ) { throw new ReferenceError( `[${ this._origin }]: The logger cannot be undefined, expect a TLogger.` )}

        this._logger = value;
    }

    /**
     *
     * @returns {Array<AllowedOrigin>}
     */
    get allowedOrigins () {
        return this._allowedOrigins
    }

    set allowedOrigins ( value ) {

        this._allowedOrigins = [];

        const _allowedOrigins = Array.isArray( value ) ? value : [ value ];
        for ( let originIndex = 0, numberOfOrigins = _allowedOrigins.length ; originIndex < numberOfOrigins ; originIndex++ ) {

            const origin = _allowedOrigins[ originIndex ];
            this._allowedOrigins.push( {
                id:           origin.id || `origin_${ Math.random().toString().slice( 2 ) }`,
                uri:          origin.uri,
                methods:      origin.methods,
                window:       this._getOriginWindow( origin.uri ),
                messageQueue: [],
                isReady:      false
            } );

        }

        this._broadCastReadyMessage();

    }

    /**
     *
     * @returns {*}
     */
    //    get targetOrigin () {
    //        return this._targetOrigin
    //    }
    //
    //    set targetOrigin ( value ) {
    //
    //        const expectation = 'Expect a valid string origin id !'
    //
    //        if ( isUndefined( value ) ) { throw new ReferenceError( `[${ this._origin }]: Target origin cannot be undefined. ${ expectation }` ) }
    //        if ( isNull( value ) ) { throw new ReferenceError( `[${ this._origin }]: Target origin cannot be null. ${ expectation }` ) }
    //        if ( isNotString( value ) ) { throw new ReferenceError( `[${ this._origin }]: Target origin is invalid. ${ expectation }` ) }
    //
    //        const allowedOriginsIds = this.allowedOrigins.map( origin => origin.id )
    //        if ( !allowedOriginsIds.includes( value ) ) { throw new ReferenceError( `[${ this._origin }]: Provided target origin is not contain in current allowedOrigins. ${ expectation }` ) }
    //
    //        this._targetOrigin = value
    //
    //    }

    /**
     *
     * @returns {*}
     */
    get requestTimeout () {
        return this._requestTimeout
    }

    set requestTimeout ( value ) {
        if ( isNull( value ) ) { throw new ReferenceError( `[${ this._origin }]: The request timeout cannot be null, expect to be 0 or a positive number.` )}
        if ( isUndefined( value ) ) { throw new ReferenceError( `[${ this._origin }]: The request timeout cannot be undefined, expect to be 0 or a positive number.` )}
        if ( isNotNumber( value ) ) { throw new ReferenceError( `[${ this._origin }]: The request timeout expect to be 0 or a positive number.` )}
        if ( isNumberNegative( value ) && !isZero( value ) ) { throw new ReferenceError( `[${ this._origin }]: The request timeout expect to be 0 or a positive number.` )}

        this._requestTimeout = value;
    }

    /**
     *
     * @param value
     * @returns {AbstractWebAPI}
     */
    setAllowedOrigins ( value ) {
        this.allowedOrigins = value;
        return this
    }

    /**
     *
     * @param value
     * @returns {AbstractWebAPI}
     */
    setTargetOrigin ( value ) {
        this.targetOrigin = value;
        return this
    }

    /**
     *
     * @param value
     * @returns {AbstractWebAPI}
     */
    setRequestTimeout ( value ) {
        this.requestTimeout = value;
        return this
    }

    /**
     *
     * @returns {boolean}
     * @private
     */
    _isInIframe () {

        try {
            return window.self !== window.top
        } catch ( e ) {
            return true
        }

    }

    _isNotAllowedForAllOrigins () {
        return !this.allowAnyOrigins
    }

    _isNotAllowedOrigin ( originURI ) {
        return !this._allowedOrigins.map( allowedOrigin => allowedOrigin.uri ).includes( originURI )
    }

    /**
     *
     * @param origin
     * @returns {boolean}
     * @private
     */
    _isNotAllowedForAllMethods ( origin ) {
        return ( origin.methods.indexOf( '*' ) === -1 )
    }

    /**
     *
     * @param origin
     * @param methodName
     * @returns {boolean}
     * @private
     */
    _isNotAllowedMethod ( origin, methodName ) {
        return ( origin.methods.indexOf( methodName ) === -1 )
    }

    /////////////////

    /**
     *
     * @param methodName
     * @returns {boolean}
     * @private
     */
    _methodNotExist ( methodName ) {
        return isNotDefined( this[ methodName ] )
    }

    /**
     *
     * @param id
     * @returns {T}
     * @private
     */
    _getAllowedOriginById ( id ) {

        return Object.values( this._allowedOrigins )
                     .find( ( origin ) => {
                         return origin.id === id
                     } )

    }

    /**
     *
     * @param uri
     * @returns {T}
     * @private
     */
    _getAllowedOriginByURI ( uri ) {

        return Object.values( this._allowedOrigins )
                     .find( ( origin ) => {
                         return origin.uri === uri
                     } )

    }

    /////////////////

    /**
     *
     * @param originURI
     * @returns {WindowProxy}
     * @private
     */
    _getOriginWindow ( originURI ) {

        let originWindow = null;

        if ( this._isInIframe() ) {

            originWindow = window.parent;

        } else {

            const frames = document.getElementsByTagName( 'iframe' );
            const frame  = Array.from( frames ).find( iframe => iframe.src.includes( originURI ) );
            if ( isNotDefined( frame ) ) {
                this.logger.warn( `[${ this._origin }]: Unable to find iframe for [${ originURI }] URI !` );
                originWindow = null;
            } else {
                originWindow = frame.contentWindow;
            }

        }

        return originWindow

    }

    /**
     *
     * @param event
     * @private
     */
    async _onMessage ( event ) {

        // Is allowed origin
        if ( this._isNotAllowedForAllOrigins() && this._isNotAllowedOrigin( event.origin ) ) {
            this.logger.warn( `[${ this._origin }]: An unallowed origin [${ event.origin }] try to access the web api.` );
            return
        }

        // In case we are not in embbeded iframe or the origin is not an iframe set the origin window as the source event
        let origin = this._getAllowedOriginByURI( event.origin );
        if ( isNotDefined( origin ) ) {
            origin = {
                id:           `origin_${ Math.random().toString().slice( 2 ) }`,
                uri:          event.origin,
                methods:      [ '*' ],
                window:       event.source,
                messageQueue: [],
                isReady:      false
            };
            this._allowedOrigins.push( origin );
        } else if ( origin.window === null ) {
            origin.window = event.source;
        }

        try {

            await this._dispatchMessageFrom( origin, JSON.parse( event.data ) );

        } catch ( error ) {

            this.postErrorTo( origin.id, error );

        }

    }

    /**
     *
     * @param origin
     * @param message
     * @private
     */
    async _dispatchMessageFrom ( origin, message ) {

        if ( isNotDefined( message ) ) { throw new ReferenceError( `[${ this._origin }]: Message cannot be null or undefined ! Expect a json object.` ) }

        const messageType = message.type;

        if ( messageType === '_ready' ) {

            this.logger.log( `[${ this._origin }]: Recieve '_ready' message from [${ origin.uri }].` );
            this.onReadyFrom( origin, message );

        } else if ( messageType === '_progress' ) {

            this.logger.log( `[${ this._origin }]: Recieve '_progress' message from [${ origin.uri }].` );
            this.onProgressFrom( origin, message );

        } else if ( messageType === '_error' ) {

            this.logger.log( `[${ this._origin }]: Recieve '_error' message from [${ origin.uri }].` );
            this.onErrorFrom( origin, message );

        } else if ( messageType === '_response' ) {

            this.logger.log( `[${ this._origin }]: Recieve '_response' message from [${ origin.uri }].` );
            this.onResponseFrom( origin, message );

        } else if ( messageType === '_request' ) {

            this.logger.log( `[${ this._origin }]: Recieve '_request' message from [${ origin.uri }].` );
            await this.onRequestFrom( origin, message );

        } else {

            this.logger.log( `[${ this._origin }]: Recieve 'custom' message from [${ origin.uri }].` );
            this.onMessageFrom( origin, message );

        }

    }

    /**
     *
     * @param origin
     * @param message
     */
    // eslint-disable-next-line no-unused-vars
    onReadyFrom ( origin, message ) {

        if ( !origin.isReady ) {
            origin.isReady = true;
            const ready    = new WebAPIMessageReady();
            this.postMessageTo( origin.id, ready, true );
        }

        // processMessageQueueOf
        const messageQueue = origin.messageQueue;
        for ( let messageIndex = messageQueue.length - 1 ; messageIndex >= 0 ; messageIndex-- ) {
            this.postMessageTo( origin.id, messageQueue.shift() );
        }

    }

    /**
     *
     * @param origin
     * @param request
     */
    async onRequestFrom ( origin, request ) {

        const method = request.method;
        if ( this._isNotAllowedForAllMethods( origin ) && this._isNotAllowedMethod( origin, method ) ) { throw new Error( `[${ this._origin }]: Origin [${ origin }] try to access an unallowed method named ${ method }.` ) }
        if ( this._methodNotExist( method ) ) { throw new ReferenceError( `[${ this._origin }]: Origin [${ origin.uri }] try to access an unexisting method named "${ method }".` ) }

        const parameters = request.parameters;
        let message;

        try {
            const result = await this[ method ]( ...parameters );
            message      = new WebAPIMessageData( result );
        } catch ( error ) {
            message = new WebAPIMessageError( error );
        }

        const response = new WebApiMessageResponse( request, message );
        this.postMessageTo( origin.id, response );

    }

    /**
     *
     * @param origin
     * @param response
     */
    onResponseFrom ( origin, response ) {

        this._responses.set( response.request.id, response );

    }

    /**
     *
     * @param origin
     * @param progress
     */
    // eslint-disable-next-line no-unused-vars
    onProgressFrom ( origin, progress ) {
        // todo: emit progress base on request id ?
    }

    /**
     *
     * @param origin
     * @param error
     */
    // eslint-disable-next-line no-unused-vars
    onErrorFrom ( origin, error ) {
        // todo: manage intternal error than allow user define handling
    }

    /**
     *
     * @param origin
     * @param message
     */
    // eslint-disable-next-line no-unused-vars
    onMessageFrom ( origin, message ) {
        // Need to be reimplemented if needed
    }

    // Send

    /**
     *
     * @private
     */
    _broadCastReadyMessage () {

        const ready      = new WebAPIMessageReady();
        const intervalId = setInterval( () => {

            const allowedOrigins        = this.allowedOrigins;
            const includeUnreadyOrigins = allowedOrigins.map( origin => origin.isReady ).includes( false );
            if ( includeUnreadyOrigins ) {

                Object.values( allowedOrigins )
                      .forEach( ( origin ) => {

                          if ( origin.isReady ) { return }
                          if ( origin.isUnreachable ) { return }

                          if ( isDefined( origin.silent ) ) {
                              if ( isFalse( origin.silent ) ) {
                                  this.postMessageTo( origin.id, ready, true );
                              } else {
                                  origin.isReady = true;
                              }
                          } else {
                              this.postMessageTo( origin.id, ready, true );
                          }

                      } );

            } else {

                clearInterval( intervalId );

            }

        }, 1000 );

    }

    /**
     *
     * @param originId
     * @param error
     */
    postErrorTo ( originId, error ) {

        let _error = null;
        if ( error.isWebAPIMessageError ) {
            _error = error;
        } else {
            _error = new WebAPIMessageError( error );
        }
        this.postMessageTo( originId, _error.toJSON() );

    }

    /**
     *
     * @param originId
     * @param progress
     */
    postProgressTo ( originId, progress ) {

        let _progress = null;
        if ( progress.isWebAPIMessageProgress ) {
            _progress = progress;
        } else {
            _progress = new WebAPIMessageProgress( progress.loaded, progress.total );
        }
        this.postMessageTo( originId, _progress.toJSON() );

    }

    /**
     *
     * @param originId
     * @param data
     */
    postDataTo ( originId, data ) {

        let _data = null;
        if ( data.isWebAPIMessageData ) {
            _data = data;
        } else {
            _data = new WebAPIMessageData( data );
        }
        this.postMessageTo( originId, _data.toJSON() );

    }

    /**
     *
     * @param originId
     * @param request
     * @returns {Promise}
     */
    postRequestTo ( originId, request ) {

        const refreshFrequency = 200;
        let currentWaitingTime = 0;

        return new Promise( ( resovle, reject ) => {

            try {

                this.postMessageTo( originId, request );

                const intervalId = setInterval( () => {

                    if ( this._responses.has( request.id ) ) {

                        const response = this._responses.get( request.id );
                        this._responses.delete( request.id );
                        clearInterval( intervalId );

                        const result = response.result;
                        if ( isDefined( result ) ) {

                            if ( result.type === '_error' ) {

                                reject( result.message );

                            } else if ( result.type === '_data' ) {

                                resovle( result.data );

                            } else {

                                resovle( result );

                            }

                        } else {

                            resovle();

                        }

                    } else if ( currentWaitingTime >= this.requestTimeout ) {

                        clearInterval( intervalId );
                        reject( new Error( `Request timeout for ${ JSON.stringify( request ) }` ) );

                    } else {

                        currentWaitingTime += refreshFrequency;

                    }

                }, refreshFrequency );

            } catch ( error ) {

                reject( error );

            }

        } )

    }

    /**
     *
     * @param originId
     * @param message
     * @param force
     */
    postMessageTo ( originId, message, force = false ) {

        if ( isNotDefined( originId ) ) { throw new ReferenceError( `[${ this._origin }]: Unable to post message to null or undefined origin id !` ) }
        if ( isNotDefined( message ) ) { throw new ReferenceError( `[${ this._origin }]: Unable to post null or undefined message !` ) }

        const origin = this._getAllowedOriginById( originId );
        if ( isNotDefined( origin ) ) { throw new ReferenceError( `[${ this._origin }]: Unable to retrieved origin with id: ${ originId }` ) }

        try {

            if ( !force && !origin.isReady ) {

                this.logger.warn( `[${ this._origin }]: Origin "${ origin.uri }" is not ready yet !` );
                origin.messageQueue.push( message );

            } else if ( force && !origin.window ) {

                this.logger.error( `[${ this._origin }]: Origin "${ origin.uri }" is unreachable !` );
                origin.isUnreachable = true;
                origin.messageQueue.push( message );

            } else {

                this.logger.log( `[${ this._origin }]: Send message of type [${ message.type }] to  [${ origin.uri }]` );
                origin.window.postMessage( JSON.stringify( message ), origin.uri );

            }

        } catch ( error ) {

            this.logger.error( error );

        }

    }

}

/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 */

/**
 * @class
 * @classdesc Special message to request a distant method and expect result.
 */
class WebAPIMessageRequest extends WebAPIMessage {

    /**
     * @static
     * @type {boolean}
     */
    static isWebAPIMessageRequest = true

    /**
     *
     * @param method
     * @param parameters
     */
    constructor ( method, parameters = [] ) {
        super( '_request' );

        this.method     = method;
        this.parameters = parameters;
    }

    /**
     *
     * @returns {*}
     */
    get method () {
        return this._method
    }

    set method ( value ) {
        if ( isNull( value ) ) { return }
        if ( isUndefined( value ) ) { return }
        if ( isNotString( value ) ) { return }

        this._method = value;
    }

    /**
     *
     * @returns {*}
     */
    get parameters () {
        return this._parameters
    }

    set parameters ( value ) {
        if ( isNotArray( value ) ) { return }

        this._parameters = value;
    }

    /**
     *
     * @returns {{method: *, parameters: *}}
     */
    toJSON () {

        return {
            ...super.toJSON(),
            ...{
                method:     this.method,
                parameters: this.parameters
            }
        }

    }

}

/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 */

class WorkerMessage {

    static isWorkerMessage = true

    constructor ( type ) {

        this.type = type;

    }

    get type () {
        return this._type
    }

    set type ( type ) {
        this._type = type;
    }

    toJSON () {

        return {
            type: this.type
        }

    }

}

/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 */

class WorkerMessageData extends WorkerMessage {

    static isWorkerMessageData = true

    constructor ( type, buffer ) {
        super( type );

        this.buffer = buffer;
    }

    toJSON () {

        return {
            ...super.toJSON(),
            ...{
                buffer: this.buffer
            }
        }

    }

}

/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 */

class WorkerMessageError extends WorkerMessage {

    static isWorkerMessageError = true

    constructor ( error ) {
        super( 'error' );

        this.message = error.message;
        this.stack   = error.stack;
    }

    toJSON () {

        return {
            ...super.toJSON(),
            ...{
                message: this.message,
                stack:   this.stack
            }
        }

    }

}

/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 */

class WorkerProgessMessage extends WorkerMessage {

    static isWorkerMessageProgess = true

    constructor ( loaded = 0, total = 0 ) {
        super( 'progress' );

        this.lengthComputable = false;
        this.loaded           = loaded;
        this.total            = total;
    }

    get loaded () {
        return this._loaded
    }

    set loaded ( value ) {
        this._loaded = value;
        this._checkIfLengthComputable();
    }

    get total () {
        return this._total
    }

    set total ( value ) {
        this._total = value;
        this._checkIfLengthComputable();
    }

    _checkIfLengthComputable () {

        this.lengthComputable = false;

        if (
            this._total > 0 &&
            this._total < Number.MAX_SAFE_INTEGER &&
            this._loaded >= 0 &&
            this._loaded < Number.MAX_SAFE_INTEGER
        ) {
            this.lengthComputable = true;
        }

    }

    toJSON () {

        return {
            ...super.toJSON(),
            ...{
                lengthComputable: this.lengthComputable,
                loaded:           this.loaded,
                total:            this.total
            }
        }

    }

}

/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 */

/**
 * @class
 * @classdesc Base worker interface that allow messaging between callee and caller
 */
class AbstractWorker {

    /**
     *
     * @param progress
     */
    postProgress ( progress ) {

        if ( progress.isWorkerMessageProgess ) {
            postMessage( progress.toJSON() );
        } else {
            postMessage( new WorkerProgessMessage( progress.loaded, progress.total ).toJSON() );
        }

    }

    /**
     *
     * @param error
     */
    postError ( error ) {

        if ( error.isWorkerMessageError ) {
            postMessage( error.toJSON() );
        } else {
            postMessage( new WorkerMessageError( error ).toJSON() );
        }

    }

    /**
     *
     * @param type
     * @param arrayBuffer
     */
    postData ( type, arrayBuffer ) {

        if ( isArray( arrayBuffer ) ) {
            postMessage( new WorkerMessageData( type, arrayBuffer ).toJSON(), [ ...arrayBuffer ] );
        } else if ( isArrayBuffer( arrayBuffer ) ) {
            postMessage( new WorkerMessageData( type, arrayBuffer ).toJSON(), [ arrayBuffer ] );
        } else {
            throw new TypeError(`AbstractWorker.postData: Unable to post data of type [${type}].`)
        }

    }

    /**
     *
     * @param message
     * @returns {boolean}
     */
    onMessage ( message ) {

        if ( isNotDefined( message ) ) {
            this.postError( new Error( 'Message event cannot be null or undefined !' ) );
            return true
        }

        const data = message.data;
        if ( isNotDefined( data ) ) {
            this.postError( new Error( 'Message data cannot be null or undefined !' ) );
            return true
        }

        const dataType = data.type;
        if ( isNotDefined( dataType ) ) {
            this.postError( new Error( 'Message data type cannot be null or undefined !' ) );
            return true
        }

        if ( data.type === 'methodCall' ) {

            const methodName = data.method;
            if ( isNotDefined( methodName ) ) {
                this.postError( new Error( 'Message of type "methodCall" cannot have null, undefined or empty name !' ) );
                return true
            }

            if ( isNotString( methodName ) ) {
                this.postError( new Error( 'Message of type "methodCall" expect name to be a string !' ) );
                return true
            }

            if ( isEmptyString( methodName ) ) {
                this.postError( new Error( 'Message of type "methodCall" expect name to be a non empty string !' ) );
                return true
            }

            const methodParameters = data.parameters || [];
            if ( isNotArray( methodParameters ) ) {
                this.postError( new Error( 'Message of type "methodCall" expect parameters to be an array !' ) );
                return true
            }

            this._invoke( methodName, methodParameters );
            return true

        }

    }

    /**
     *
     * @param name
     * @param parameters
     * @private
     */
    _invoke ( name, parameters = [] ) {

        try {

            const result = this[ name ]( ...parameters );
            if ( result ) {
                postMessage( {
                    type:   name,
                    result: result
                } );
            }

        } catch ( error ) {
            this.postError( error );
        }

    }

}

/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 */

class WorkerMessageMethodCall extends WorkerMessage {

    static isWorkerMessageMethodCall = true

    constructor ( method, parameters = [] ) {
        super( 'methodCall' );

        this.method     = method;
        this.parameters = parameters;
    }

    get method () {
        return this._method
    }

    set method ( value ) {
        if ( isNull( value ) ) { return }
        if ( isUndefined( value ) ) { return }
        if ( isNotString( value ) ) { return }

        this._method = value;
    }

    get parameters () {
        return this._parameters
    }

    set parameters ( value ) {
        if ( isNotArray( value ) ) { return }

        this._parameters = value;
    }

    toJSON () {

        return {
            ...super.toJSON(),
            ...{
                method:     this.method,
                parameters: this.parameters
            }
        }

    }

}

export { AbstractWebAPI, AbstractWorker, Byte, Endianness, FileFormat, HttpStatusCode, HttpVerb, Keys, MimeType, Mouse, ResponseType, TAbstractFactory, TBinaryReader, TCloningFactory, TDataBaseManager, TIdFactory, TIdFactoryType, TInstancingFactory, TKeyboardController, TMouseController, TStore, WebAPIMessage, WebAPIMessageData, WebAPIMessageError, WebAPIMessageProgress, WebAPIMessageReady, WebAPIMessageRequest, WebApiMessageResponse, WorkerMessage, WorkerMessageData, WorkerMessageError, WorkerMessageMethodCall, WorkerProgessMessage };
//# sourceMappingURL=itee-client.esm.js.map
