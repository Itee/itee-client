define(['exports'], function (exports) { 'use strict';

  /**
   * @author [Tristan Valcke]{@link https://github.com/Itee}
   * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
   */

  /**
   * A freezed javascript object used like an enum.
   * @typedef {object} Enum
   * @example
   * const Foo = Object.freeze( {
   *     Bar: 0,
   *     Baz: 1,
   *     Qux: 3
   * } )
   */

  /**
   * @typedef {Enum} HttpVerb
   * @property {string} Create="PUT" - Corresponding to the create http verb for an itee server, namely "PUT".
   * @property {string} Read="POST" - Corresponding to the read http verb for an itee server, namely "POST".
   * @property {string} Update="PATCH" - Corresponding to the update http verb for an itee server, namely "PATCH".
   * @property {string} Delete="DELETE" - Corresponding to the delete http verb for an itee server, namely "DELETE".
   *
   * @constant
   * @type {HttpVerb}
   * @description HttpVerb contains the CRUD actions with corresponding http verb to request an itee server.
   * @see {@link https://en.wikipedia.org/wiki/Create,_read,_update_and_delete} for further information.
   */
  var HttpVerb = Object.freeze( {
      Create: "PUT",
      Read:   "POST",
      Update: "PATCH",
      Delete: "DELETE"
  } );

  /**
   * @typedef {Enum} ResponseType
   * @property {string} ArrayBuffer="arraybuffer" - The "arraybuffer" server response type.
   * @property {string} Blob="blob" - The "blob" server response type.
   * @property {string} Document="document" - The "document" server response type.
   * @property {string} Json="json" - The "json" server response type.
   * @property {string} DOMString="text" - The "text" server response type.
   * @property {string} Default="text" - The "" server response type ( equivalent to DOMString ).
   *
   * @constant
   * @type {ResponseType}
   * @description ResponseType allow to filter wich type of response is recieved from the server.
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType} for further information.
   */
  var ResponseType = Object.freeze( {
      ArrayBuffer: 'arraybuffer',
      Blob:        'blob',
      Document:    'document',
      Json:        'json',
      DOMString:   'text',
      Default:     ''
  } );

  /**
   * @typedef {Enum} HttpStatusCode
   * @property {number} Continue=100 - Waiting for the continuation of the request.
   * @property {number} SwitchingProtocols=101 - The requester has asked the server to switch protocols and the server has agreed to do so.
   * @property {number} Processing=102 - WebDAV: Processing in progress (prevents the client from exceeding the limited waiting time).
   * @property {number} Ok=200 - Query successfully processed.
   * @property {number} Created=201 - Query successfully processed and a document was created.
   * @property {number} Accepted=202 - Query processed, but without guarantee of result.
   * @property {number} NonAuthoritativeInformation=203 - Information returned, but generated by an uncertified source.
   * @property {number} NoContent=204 - Query successfully processed but no information returned.
   * @property {number} ResetContent=205 - Query successfully processed, the current page can be cleared.
   * @property {number} PartialContent=206 - Only part of the resource has been transmitted.
   * @property {number} MultiStatus=207 - WebDAV: Multiple Response.
   * @property {number} AlreadyReported=208 - WebDAV: The document was previously sent to this collection.
   * @property {number} ContentDifferent=210 - WebDAV: The copy of the client-side resource differs from that of the server (content or properties).
   * @property {number} IMUsed=226 - The server has completed the request for the resource, and the response is a representation of the result of one or more instance manipulations applied to the current instance.
   * @property {number} MultipleChoices=300 - The requested URI refers to multiple resources.
   * @property {number} MovedPermanently=301 - Document moved permanently.
   * @property {number} Found=302 - Document moved temporarily.
   * @property {number} SeeOther=303 - The answer to this query is elsewhere.
   * @property {number} NotModified=304 - Document not modified since the last request.
   * @property {number} UseProxy=305 - The request must be re-addressed to the proxy.
   * @property {number} Unused=306 - Code used by an older version of RFC 2616, now reserved.
   * @property {number} TemporaryRedirect=307 - The request must be temporarily redirected to the specified URI.
   * @property {number} PermanentRedirect=308 - The request must be redirected permanently to the specified URI.
   * @property {number} TooManyRedirects=310 - The request must be redirected too many times, or is the victim of a redirection loop.
   * @property {number} BadRequest=400 - The syntax of the query is wrong.
   * @property {number} Unauthorized=401 - Authentication is required to access the resource.
   * @property {number} PaymentRequired=402 - Payment required to access the resource.
   * @property {number} Forbidden=403 - The server understood the request, but refuses to execute it. Unlike error 401, authenticating will not make any difference. On servers where authentication is required, this usually means that authentication has been accepted but access rights do not allow the client to access the resource.
   * @property {number} NotFound=404 - Resource not found.
   * @property {number} MethodNotAllowed=405 - Unauthorized request method.
   * @property {number} NotAcceptable=406 - The requested resource is not available in a format that would respect the "Accept" headers of the request.
   * @property {number} ProxyAuthenticationRequired=407 - Access to the authorized resource by identification with the proxy.
   * @property {number} RequestTimeOut=408 - Waiting time for an elapsed client request.
   * @property {number} Conflict=409 - The request can not be processed in the current state.
   * @property {number} Gone=410 - The resource is no longer available and no redirection address is known.
   * @property {number} LengthRequired=411 - The length of the request has not been specified.
   * @property {number} PreconditionFailed=412 - Preconditions sent by the query unverified.
   * @property {number} RequestEntityTooLarge=413 - Abandoned processing due to excessive request
   * @property {number} RequestURITooLong=414 - URI too long
   * @property {number} UnsupportedMediaType=415 - Unsupported query format for a given method and resource.
   * @property {number} RequestRangeUnsatisfiable=416 - Invalid "range" request header fields.
   * @property {number} ExpectationFailed=417 - Expected behavior and defined in the header of the unsatisfactory request.
   * @property {number} ImATeapot=418 - "I am a teapot". This code is defined in RFC 2324 dated April 1, 1998, Hyper Text Coffee Pot Control Protocol.
   * @property {number} BadMapping=421 - The request was sent to a server that is not able to produce a response (for example, because a connection has been reused).
   * @property {number} UnprocessableEntity=422 - WebDAV: The entity provided with the request is incomprehensible or incomplete.
   * @property {number} Locked=423 - WebDAV: The operation can not take place because the resource is locked.
   * @property {number} MethodFailure=424 - WebDAV: A method of the transaction failed.
   * @property {number} UnorderedCollection=425 - WebDAV RFC 3648. This code is defined in the WebDAV Advanced Collections Protocol draft , but is absent from the Web Distributed Authoring and Versioning (WebDAV) Ordered Collections Protocol.
   * @property {number} UpgradeRequired=426 - RFC 2817 The client should change protocol, for example to TLS / 1.0 .
   * @property {number} PreconditionRequired=428 - RFC 6585 The request must be conditional.
   * @property {number} TooManyRequests=429 - RFC 6585 The client has issued too many requests within a given time.
   * @property {number} RequestHeaderFieldsTooLarge=431 - RFC 6585 HTTP headers issued exceed the maximum size allowed by the server.
   * @property {number} NoResponse=444 - Indicates that the server did not return any information to the client and closed the connection.
   * @property {number} RetryWith=449 - Code defined by Microsoft . The request should be returned after performing an action.
   * @property {number} BlockedByWindowsParentalControls=450 - Code defined by Microsoft. This error is generated when Windows Parental Control tools are enabled and block access to the page.
   * @property {number} UnavailableForLegalReasons=451 - This error code indicates that the requested resource is inaccessible for legal reasons
   * @property {number} UnrecoverableError=456 - WebDAV: Fatal error.
   * @property {number} SSLCertificateError=495 - An extension of the 400 Bad Request error, used when the client provided an invalid certificate.
   * @property {number} SSLCertificateRequired=496 - An extension of the 400 Bad Request error, used when a required client certificate is not provided.
   * @property {number} HTTPRequestSentToHTTPSPort=497 - An extension of the 400 Bad Request error, used when the client sends an HTTP request to port 443 normally intended for HTTPS requests.
   * @property {number} ClientClosedRequest=499 - The client closed the connection before receiving the response. This error occurs when the processing is too long on the server side.
   * @property {number} InternalServerError=500 - Internal server error.
   * @property {number} NotImplemented=501 - Functionality claimed not supported by the server.
   * @property {number} BadGateway=502 - Wrong response sent to an intermediate server by another server.
   * @property {number} ServiceUnavailable=503 - Service temporarily unavailable or under maintenance.
   * @property {number} GatewayTimeOut=504 - Waiting time for a response from a server to an intermediate server that has elapsed.
   * @property {number} HTTPVersionNotSupported=505 - HTTP version not managed by the server.
   * @property {number} VariantAlsoNegotiates=506 - RFC 2295: Negotiation Error. Transparent content negociation.
   * @property {number} InsufficientStorage=507 - WebDAV: Insufficient space to modify properties or build the collection.
   * @property {number} LoopDetected=508 - WebDAV: Loop in a Resource Match
   * @property {number} BandwidthLimitExceeded=509 - Used by many servers to indicate a quota overrun.
   * @property {number} NotExtended=510 - RFC 2774: The request does not respect the policy for accessing extended HTTP resources.
   * @property {number} NetworkAuthenticationRequired=511 - RFC 6585: The client must authenticate to access the network. Used by captive portals to redirect clients to the authentication page.
   * @property {number} UnknownError=520 - Error 520 is used as a wildcard response when the origin server returns an unexpected result.
   * @property {number} WebServerIsDown=521 - The server has refused the connection from Cloudflare.
   * @property {number} ConnectionTimedOut=522 - Cloudflare could not negotiate a TCP handshake with the origin server.
   * @property {number} OriginIsUnreachable=523 - Cloudflare failed to reach the origin server. This can occur if DNS server name resolution fails.
   * @property {number} ATimeoutOccured=524 - Cloudflare established a TCP connection with the origin server but did not receive an HTTP response before the login timeout.
   * @property {number} SSLHandshakeFailed=525 - Cloudflare could not negotiate SSL / TLS handshake with the origin server.
   * @property {number} InvalidSSLCertificate=526 - Cloudflare could not validate the SSL certificate presented by the origin server.
   * @property {number} RailgunError=527 - Error 527 indicates that the request has timed out or failed after the WAN connection was established.
   *
   * @constant
   * @type {HttpStatusCode}
   * @description HttpStatusCode contains all http status code available to check and process correctly server response.
   * @see {@link https://en.wikipedia.org/wiki/List_of_HTTP_status_codes} for further information.
   */
  var HttpStatusCode = Object.freeze( {

      // 100
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,

      // 200
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ContentDifferent: 210,
      IMUsed: 226,

      // 300
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      TooManyRedirects: 310,

      // 400
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeOut: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      RequestEntityTooLarge: 413,
      RequestRangeUnsatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      BadMapping: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      MethodFailure: 424,
      UnorderedCollection: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      NoResponse: 444,
      RetryWith: 449,
      BlockedByWindowsParentalControls: 450,
      UnavailableForLegalReasons: 451,
      UnrecoverableError: 456,
      SSLCertificateError: 495,
      SSLCertificateRequired: 496,
      HTTPRequestSentToHTTPSPort: 497,
      ClientClosedRequest: 499,

      // 500
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeOut: 504,
      HTTPVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      BandwidthLimitExceeded: 509,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511,
      UnknownError: 520,
      WebServerIsDown: 521,
      ConnectionTimedOut: 522,
      OriginIsUnreachable: 523,
      ATimeoutOccured: 524,
      SSLHandshakeFailed: 525,
      InvalidSSLCertificate: 526,
      RailgunError: 527

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   */

  var _Math = {

  	DEG2RAD: Math.PI / 180,
  	RAD2DEG: 180 / Math.PI,

  	generateUUID: function () {

  		// http://www.broofa.com/Tools/Math.uuid.htm

  		var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
  		var uuid = new Array( 36 );
  		var rnd = 0, r;

  		return function generateUUID() {

  			for ( var i = 0; i < 36; i ++ ) {

  				if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

  					uuid[ i ] = '-';

  				} else if ( i === 14 ) {

  					uuid[ i ] = '4';

  				} else {

  					if ( rnd <= 0x02 ) { rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0; }
  					r = rnd & 0xf;
  					rnd = rnd >> 4;
  					uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

  				}

  			}

  			return uuid.join( '' );

  		};

  	}(),

  	clamp: function ( value, min, max ) {

  		return Math.max( min, Math.min( max, value ) );

  	},

  	// compute euclidian modulo of m % n
  	// https://en.wikipedia.org/wiki/Modulo_operation

  	euclideanModulo: function ( n, m ) {

  		return ( ( n % m ) + m ) % m;

  	},

  	// Linear mapping from range <a1, a2> to range <b1, b2>

  	mapLinear: function ( x, a1, a2, b1, b2 ) {

  		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

  	},

  	// https://en.wikipedia.org/wiki/Linear_interpolation

  	lerp: function ( x, y, t ) {

  		return ( 1 - t ) * x + t * y;

  	},

  	// http://en.wikipedia.org/wiki/Smoothstep

  	smoothstep: function ( x, min, max ) {

  		if ( x <= min ) { return 0; }
  		if ( x >= max ) { return 1; }

  		x = ( x - min ) / ( max - min );

  		return x * x * ( 3 - 2 * x );

  	},

  	smootherstep: function ( x, min, max ) {

  		if ( x <= min ) { return 0; }
  		if ( x >= max ) { return 1; }

  		x = ( x - min ) / ( max - min );

  		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

  	},

  	// Random integer from <low, high> interval

  	randInt: function ( low, high ) {

  		return low + Math.floor( Math.random() * ( high - low + 1 ) );

  	},

  	// Random float from <low, high> interval

  	randFloat: function ( low, high ) {

  		return low + Math.random() * ( high - low );

  	},

  	// Random float from <-range/2, range/2> interval

  	randFloatSpread: function ( range ) {

  		return range * ( 0.5 - Math.random() );

  	},

  	degToRad: function ( degrees ) {

  		return degrees * _Math.DEG2RAD;

  	},

  	radToDeg: function ( radians ) {

  		return radians * _Math.RAD2DEG;

  	},

  	isPowerOfTwo: function ( value ) {

  		return ( value & ( value - 1 ) ) === 0 && value !== 0;

  	},

  	ceilPowerOfTwo: function ( value ) {

  		return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

  	},

  	floorPowerOfTwo: function ( value ) {

  		return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

  	}

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author supereggbert / http://www.paulbrunt.co.uk/
   * @author philogb / http://blog.thejit.org/
   * @author jordi_ros / http://plattsoft.com
   * @author D1plo1d / http://github.com/D1plo1d
   * @author alteredq / http://alteredqualia.com/
   * @author mikael emtinger / http://gomo.se/
   * @author timknip / http://www.floorplanner.com/
   * @author bhouston / http://clara.io
   * @author WestLangley / http://github.com/WestLangley
   */

  function Matrix4() {

  	this.elements = [

  		1, 0, 0, 0,
  		0, 1, 0, 0,
  		0, 0, 1, 0,
  		0, 0, 0, 1

  	];

  	if ( arguments.length > 0 ) {

  		console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

  	}

  }

  Object.assign( Matrix4.prototype, {

  	isMatrix4: true,

  	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

  		var te = this.elements;

  		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
  		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
  		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
  		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

  		return this;

  	},

  	identity: function () {

  		this.set(

  			1, 0, 0, 0,
  			0, 1, 0, 0,
  			0, 0, 1, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	},

  	clone: function () {

  		return new Matrix4().fromArray( this.elements );

  	},

  	copy: function ( m ) {

  		var te = this.elements;
  		var me = m.elements;

  		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
  		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
  		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
  		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

  		return this;

  	},

  	copyPosition: function ( m ) {

  		var te = this.elements, me = m.elements;

  		te[ 12 ] = me[ 12 ];
  		te[ 13 ] = me[ 13 ];
  		te[ 14 ] = me[ 14 ];

  		return this;

  	},

  	extractBasis: function ( xAxis, yAxis, zAxis ) {

  		xAxis.setFromMatrixColumn( this, 0 );
  		yAxis.setFromMatrixColumn( this, 1 );
  		zAxis.setFromMatrixColumn( this, 2 );

  		return this;

  	},

  	makeBasis: function ( xAxis, yAxis, zAxis ) {

  		this.set(
  			xAxis.x, yAxis.x, zAxis.x, 0,
  			xAxis.y, yAxis.y, zAxis.y, 0,
  			xAxis.z, yAxis.z, zAxis.z, 0,
  			0, 0, 0, 1
  		);

  		return this;

  	},

  	extractRotation: function () {

  		var v1 = new Vector3$1();

  		return function extractRotation( m ) {

  			var te = this.elements;
  			var me = m.elements;

  			var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
  			var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
  			var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();

  			te[ 0 ] = me[ 0 ] * scaleX;
  			te[ 1 ] = me[ 1 ] * scaleX;
  			te[ 2 ] = me[ 2 ] * scaleX;

  			te[ 4 ] = me[ 4 ] * scaleY;
  			te[ 5 ] = me[ 5 ] * scaleY;
  			te[ 6 ] = me[ 6 ] * scaleY;

  			te[ 8 ] = me[ 8 ] * scaleZ;
  			te[ 9 ] = me[ 9 ] * scaleZ;
  			te[ 10 ] = me[ 10 ] * scaleZ;

  			return this;

  		};

  	}(),

  	makeRotationFromEuler: function ( euler ) {

  		if ( ! ( euler && euler.isEuler ) ) {

  			console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

  		}

  		var te = this.elements;

  		var x = euler.x, y = euler.y, z = euler.z;
  		var a = Math.cos( x ), b = Math.sin( x );
  		var c = Math.cos( y ), d = Math.sin( y );
  		var e = Math.cos( z ), f = Math.sin( z );

  		if ( euler.order === 'XYZ' ) {

  			var ae = a * e, af = a * f, be = b * e, bf = b * f;

  			te[ 0 ] = c * e;
  			te[ 4 ] = - c * f;
  			te[ 8 ] = d;

  			te[ 1 ] = af + be * d;
  			te[ 5 ] = ae - bf * d;
  			te[ 9 ] = - b * c;

  			te[ 2 ] = bf - ae * d;
  			te[ 6 ] = be + af * d;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'YXZ' ) {

  			var ce = c * e, cf = c * f, de = d * e, df = d * f;

  			te[ 0 ] = ce + df * b;
  			te[ 4 ] = de * b - cf;
  			te[ 8 ] = a * d;

  			te[ 1 ] = a * f;
  			te[ 5 ] = a * e;
  			te[ 9 ] = - b;

  			te[ 2 ] = cf * b - de;
  			te[ 6 ] = df + ce * b;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'ZXY' ) {

  			var ce = c * e, cf = c * f, de = d * e, df = d * f;

  			te[ 0 ] = ce - df * b;
  			te[ 4 ] = - a * f;
  			te[ 8 ] = de + cf * b;

  			te[ 1 ] = cf + de * b;
  			te[ 5 ] = a * e;
  			te[ 9 ] = df - ce * b;

  			te[ 2 ] = - a * d;
  			te[ 6 ] = b;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'ZYX' ) {

  			var ae = a * e, af = a * f, be = b * e, bf = b * f;

  			te[ 0 ] = c * e;
  			te[ 4 ] = be * d - af;
  			te[ 8 ] = ae * d + bf;

  			te[ 1 ] = c * f;
  			te[ 5 ] = bf * d + ae;
  			te[ 9 ] = af * d - be;

  			te[ 2 ] = - d;
  			te[ 6 ] = b * c;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'YZX' ) {

  			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

  			te[ 0 ] = c * e;
  			te[ 4 ] = bd - ac * f;
  			te[ 8 ] = bc * f + ad;

  			te[ 1 ] = f;
  			te[ 5 ] = a * e;
  			te[ 9 ] = - b * e;

  			te[ 2 ] = - d * e;
  			te[ 6 ] = ad * f + bc;
  			te[ 10 ] = ac - bd * f;

  		} else if ( euler.order === 'XZY' ) {

  			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

  			te[ 0 ] = c * e;
  			te[ 4 ] = - f;
  			te[ 8 ] = d * e;

  			te[ 1 ] = ac * f + bd;
  			te[ 5 ] = a * e;
  			te[ 9 ] = ad * f - bc;

  			te[ 2 ] = bc * f - ad;
  			te[ 6 ] = b * e;
  			te[ 10 ] = bd * f + ac;

  		}

  		// last column
  		te[ 3 ] = 0;
  		te[ 7 ] = 0;
  		te[ 11 ] = 0;

  		// bottom row
  		te[ 12 ] = 0;
  		te[ 13 ] = 0;
  		te[ 14 ] = 0;
  		te[ 15 ] = 1;

  		return this;

  	},

  	makeRotationFromQuaternion: function ( q ) {

  		var te = this.elements;

  		var x = q._x, y = q._y, z = q._z, w = q._w;
  		var x2 = x + x, y2 = y + y, z2 = z + z;
  		var xx = x * x2, xy = x * y2, xz = x * z2;
  		var yy = y * y2, yz = y * z2, zz = z * z2;
  		var wx = w * x2, wy = w * y2, wz = w * z2;

  		te[ 0 ] = 1 - ( yy + zz );
  		te[ 4 ] = xy - wz;
  		te[ 8 ] = xz + wy;

  		te[ 1 ] = xy + wz;
  		te[ 5 ] = 1 - ( xx + zz );
  		te[ 9 ] = yz - wx;

  		te[ 2 ] = xz - wy;
  		te[ 6 ] = yz + wx;
  		te[ 10 ] = 1 - ( xx + yy );

  		// last column
  		te[ 3 ] = 0;
  		te[ 7 ] = 0;
  		te[ 11 ] = 0;

  		// bottom row
  		te[ 12 ] = 0;
  		te[ 13 ] = 0;
  		te[ 14 ] = 0;
  		te[ 15 ] = 1;

  		return this;

  	},

  	lookAt: function () {

  		var x = new Vector3$1();
  		var y = new Vector3$1();
  		var z = new Vector3$1();

  		return function lookAt( eye, target, up ) {

  			var te = this.elements;

  			z.subVectors( eye, target );

  			if ( z.lengthSq() === 0 ) {

  				// eye and target are in the same position

  				z.z = 1;

  			}

  			z.normalize();
  			x.crossVectors( up, z );

  			if ( x.lengthSq() === 0 ) {

  				// up and z are parallel

  				if ( Math.abs( up.z ) === 1 ) {

  					z.x += 0.0001;

  				} else {

  					z.z += 0.0001;

  				}

  				z.normalize();
  				x.crossVectors( up, z );

  			}

  			x.normalize();
  			y.crossVectors( z, x );

  			te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
  			te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
  			te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

  			return this;

  		};

  	}(),

  	multiply: function ( m, n ) {

  		if ( n !== undefined ) {

  			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
  			return this.multiplyMatrices( m, n );

  		}

  		return this.multiplyMatrices( this, m );

  	},

  	premultiply: function ( m ) {

  		return this.multiplyMatrices( m, this );

  	},

  	multiplyMatrices: function ( a, b ) {

  		var ae = a.elements;
  		var be = b.elements;
  		var te = this.elements;

  		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
  		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
  		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
  		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

  		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
  		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
  		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
  		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

  		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
  		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
  		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
  		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

  		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
  		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
  		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
  		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

  		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
  		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
  		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
  		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

  		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
  		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
  		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
  		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

  		return this;

  	},

  	multiplyScalar: function ( s ) {

  		var te = this.elements;

  		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
  		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
  		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
  		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

  		return this;

  	},

  	applyToBufferAttribute: function () {

  		var v1 = new Vector3$1();

  		return function applyToBufferAttribute( attribute ) {
  			var this$1 = this;


  			for ( var i = 0, l = attribute.count; i < l; i ++ ) {

  				v1.x = attribute.getX( i );
  				v1.y = attribute.getY( i );
  				v1.z = attribute.getZ( i );

  				v1.applyMatrix4( this$1 );

  				attribute.setXYZ( i, v1.x, v1.y, v1.z );

  			}

  			return attribute;

  		};

  	}(),

  	determinant: function () {

  		var te = this.elements;

  		var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
  		var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
  		var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
  		var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

  		//TODO: make this more efficient
  		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

  		return (
  			n41 * (
  				+ n14 * n23 * n32
  				 - n13 * n24 * n32
  				 - n14 * n22 * n33
  				 + n12 * n24 * n33
  				 + n13 * n22 * n34
  				 - n12 * n23 * n34
  			) +
  			n42 * (
  				+ n11 * n23 * n34
  				 - n11 * n24 * n33
  				 + n14 * n21 * n33
  				 - n13 * n21 * n34
  				 + n13 * n24 * n31
  				 - n14 * n23 * n31
  			) +
  			n43 * (
  				+ n11 * n24 * n32
  				 - n11 * n22 * n34
  				 - n14 * n21 * n32
  				 + n12 * n21 * n34
  				 + n14 * n22 * n31
  				 - n12 * n24 * n31
  			) +
  			n44 * (
  				- n13 * n22 * n31
  				 - n11 * n23 * n32
  				 + n11 * n22 * n33
  				 + n13 * n21 * n32
  				 - n12 * n21 * n33
  				 + n12 * n23 * n31
  			)

  		);

  	},

  	transpose: function () {

  		var te = this.elements;
  		var tmp;

  		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
  		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
  		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

  		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
  		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
  		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

  		return this;

  	},

  	setPosition: function ( v ) {

  		var te = this.elements;

  		te[ 12 ] = v.x;
  		te[ 13 ] = v.y;
  		te[ 14 ] = v.z;

  		return this;

  	},

  	getInverse: function ( m, throwOnDegenerate ) {

  		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
  		var te = this.elements,
  			me = m.elements,

  			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
  			n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
  			n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
  			n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

  			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
  			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
  			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
  			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

  		var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

  		if ( det === 0 ) {

  			var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";

  			if ( throwOnDegenerate === true ) {

  				throw new Error( msg );

  			} else {

  				console.warn( msg );

  			}

  			return this.identity();

  		}

  		var detInv = 1 / det;

  		te[ 0 ] = t11 * detInv;
  		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
  		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
  		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

  		te[ 4 ] = t12 * detInv;
  		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
  		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
  		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

  		te[ 8 ] = t13 * detInv;
  		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
  		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
  		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

  		te[ 12 ] = t14 * detInv;
  		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
  		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
  		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

  		return this;

  	},

  	scale: function ( v ) {

  		var te = this.elements;
  		var x = v.x, y = v.y, z = v.z;

  		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
  		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
  		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
  		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

  		return this;

  	},

  	getMaxScaleOnAxis: function () {

  		var te = this.elements;

  		var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
  		var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
  		var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

  		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

  	},

  	makeTranslation: function ( x, y, z ) {

  		this.set(

  			1, 0, 0, x,
  			0, 1, 0, y,
  			0, 0, 1, z,
  			0, 0, 0, 1

  		);

  		return this;

  	},

  	makeRotationX: function ( theta ) {

  		var c = Math.cos( theta ), s = Math.sin( theta );

  		this.set(

  			1, 0, 0, 0,
  			0, c, - s, 0,
  			0, s, c, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	},

  	makeRotationY: function ( theta ) {

  		var c = Math.cos( theta ), s = Math.sin( theta );

  		this.set(

  			 c, 0, s, 0,
  			 0, 1, 0, 0,
  			- s, 0, c, 0,
  			 0, 0, 0, 1

  		);

  		return this;

  	},

  	makeRotationZ: function ( theta ) {

  		var c = Math.cos( theta ), s = Math.sin( theta );

  		this.set(

  			c, - s, 0, 0,
  			s, c, 0, 0,
  			0, 0, 1, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	},

  	makeRotationAxis: function ( axis, angle ) {

  		// Based on http://www.gamedev.net/reference/articles/article1199.asp

  		var c = Math.cos( angle );
  		var s = Math.sin( angle );
  		var t = 1 - c;
  		var x = axis.x, y = axis.y, z = axis.z;
  		var tx = t * x, ty = t * y;

  		this.set(

  			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
  			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
  			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
  			0, 0, 0, 1

  		);

  		 return this;

  	},

  	makeScale: function ( x, y, z ) {

  		this.set(

  			x, 0, 0, 0,
  			0, y, 0, 0,
  			0, 0, z, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	},

  	makeShear: function ( x, y, z ) {

  		this.set(

  			1, y, z, 0,
  			x, 1, z, 0,
  			x, y, 1, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	},

  	compose: function ( position, quaternion, scale ) {

  		this.makeRotationFromQuaternion( quaternion );
  		this.scale( scale );
  		this.setPosition( position );

  		return this;

  	},

  	decompose: function () {

  		var vector = new Vector3$1();
  		var matrix = new Matrix4();

  		return function decompose( position, quaternion, scale ) {

  			var te = this.elements;

  			var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
  			var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
  			var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

  			// if determine is negative, we need to invert one scale
  			var det = this.determinant();
  			if ( det < 0 ) { sx = - sx; }

  			position.x = te[ 12 ];
  			position.y = te[ 13 ];
  			position.z = te[ 14 ];

  			// scale the rotation part
  			matrix.copy( this );

  			var invSX = 1 / sx;
  			var invSY = 1 / sy;
  			var invSZ = 1 / sz;

  			matrix.elements[ 0 ] *= invSX;
  			matrix.elements[ 1 ] *= invSX;
  			matrix.elements[ 2 ] *= invSX;

  			matrix.elements[ 4 ] *= invSY;
  			matrix.elements[ 5 ] *= invSY;
  			matrix.elements[ 6 ] *= invSY;

  			matrix.elements[ 8 ] *= invSZ;
  			matrix.elements[ 9 ] *= invSZ;
  			matrix.elements[ 10 ] *= invSZ;

  			quaternion.setFromRotationMatrix( matrix );

  			scale.x = sx;
  			scale.y = sy;
  			scale.z = sz;

  			return this;

  		};

  	}(),

  	makePerspective: function ( left, right, top, bottom, near, far ) {

  		if ( far === undefined ) {

  			console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

  		}

  		var te = this.elements;
  		var x = 2 * near / ( right - left );
  		var y = 2 * near / ( top - bottom );

  		var a = ( right + left ) / ( right - left );
  		var b = ( top + bottom ) / ( top - bottom );
  		var c = - ( far + near ) / ( far - near );
  		var d = - 2 * far * near / ( far - near );

  		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
  		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
  		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
  		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

  		return this;

  	},

  	makeOrthographic: function ( left, right, top, bottom, near, far ) {

  		var te = this.elements;
  		var w = 1.0 / ( right - left );
  		var h = 1.0 / ( top - bottom );
  		var p = 1.0 / ( far - near );

  		var x = ( right + left ) * w;
  		var y = ( top + bottom ) * h;
  		var z = ( far + near ) * p;

  		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
  		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
  		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
  		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

  		return this;

  	},

  	equals: function ( matrix ) {

  		var te = this.elements;
  		var me = matrix.elements;

  		for ( var i = 0; i < 16; i ++ ) {

  			if ( te[ i ] !== me[ i ] ) { return false; }

  		}

  		return true;

  	},

  	fromArray: function ( array, offset ) {
  		var this$1 = this;


  		if ( offset === undefined ) { offset = 0; }

  		for ( var i = 0; i < 16; i ++ ) {

  			this$1.elements[ i ] = array[ i + offset ];

  		}

  		return this;

  	},

  	toArray: function ( array, offset ) {

  		if ( array === undefined ) { array = []; }
  		if ( offset === undefined ) { offset = 0; }

  		var te = this.elements;

  		array[ offset ] = te[ 0 ];
  		array[ offset + 1 ] = te[ 1 ];
  		array[ offset + 2 ] = te[ 2 ];
  		array[ offset + 3 ] = te[ 3 ];

  		array[ offset + 4 ] = te[ 4 ];
  		array[ offset + 5 ] = te[ 5 ];
  		array[ offset + 6 ] = te[ 6 ];
  		array[ offset + 7 ] = te[ 7 ];

  		array[ offset + 8 ] = te[ 8 ];
  		array[ offset + 9 ] = te[ 9 ];
  		array[ offset + 10 ] = te[ 10 ];
  		array[ offset + 11 ] = te[ 11 ];

  		array[ offset + 12 ] = te[ 12 ];
  		array[ offset + 13 ] = te[ 13 ];
  		array[ offset + 14 ] = te[ 14 ];
  		array[ offset + 15 ] = te[ 15 ];

  		return array;

  	}

  } );

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author WestLangley / http://github.com/WestLangley
   * @author bhouston / http://clara.io
   */

  function Quaternion( x, y, z, w ) {

  	this._x = x || 0;
  	this._y = y || 0;
  	this._z = z || 0;
  	this._w = ( w !== undefined ) ? w : 1;

  }

  Object.assign( Quaternion, {

  	slerp: function ( qa, qb, qm, t ) {

  		return qm.copy( qa ).slerp( qb, t );

  	},

  	slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

  		// fuzz-free, array-based Quaternion SLERP operation

  		var x0 = src0[ srcOffset0 + 0 ],
  			y0 = src0[ srcOffset0 + 1 ],
  			z0 = src0[ srcOffset0 + 2 ],
  			w0 = src0[ srcOffset0 + 3 ],

  			x1 = src1[ srcOffset1 + 0 ],
  			y1 = src1[ srcOffset1 + 1 ],
  			z1 = src1[ srcOffset1 + 2 ],
  			w1 = src1[ srcOffset1 + 3 ];

  		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

  			var s = 1 - t,

  				cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

  				dir = ( cos >= 0 ? 1 : - 1 ),
  				sqrSin = 1 - cos * cos;

  			// Skip the Slerp for tiny steps to avoid numeric problems:
  			if ( sqrSin > Number.EPSILON ) {

  				var sin = Math.sqrt( sqrSin ),
  					len = Math.atan2( sin, cos * dir );

  				s = Math.sin( s * len ) / sin;
  				t = Math.sin( t * len ) / sin;

  			}

  			var tDir = t * dir;

  			x0 = x0 * s + x1 * tDir;
  			y0 = y0 * s + y1 * tDir;
  			z0 = z0 * s + z1 * tDir;
  			w0 = w0 * s + w1 * tDir;

  			// Normalize in case we just did a lerp:
  			if ( s === 1 - t ) {

  				var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

  				x0 *= f;
  				y0 *= f;
  				z0 *= f;
  				w0 *= f;

  			}

  		}

  		dst[ dstOffset ] = x0;
  		dst[ dstOffset + 1 ] = y0;
  		dst[ dstOffset + 2 ] = z0;
  		dst[ dstOffset + 3 ] = w0;

  	}

  } );

  Object.defineProperties( Quaternion.prototype, {

  	x: {

  		get: function () {

  			return this._x;

  		},

  		set: function ( value ) {

  			this._x = value;
  			this.onChangeCallback();

  		}

  	},

  	y: {

  		get: function () {

  			return this._y;

  		},

  		set: function ( value ) {

  			this._y = value;
  			this.onChangeCallback();

  		}

  	},

  	z: {

  		get: function () {

  			return this._z;

  		},

  		set: function ( value ) {

  			this._z = value;
  			this.onChangeCallback();

  		}

  	},

  	w: {

  		get: function () {

  			return this._w;

  		},

  		set: function ( value ) {

  			this._w = value;
  			this.onChangeCallback();

  		}

  	}

  } );

  Object.assign( Quaternion.prototype, {

  	set: function ( x, y, z, w ) {

  		this._x = x;
  		this._y = y;
  		this._z = z;
  		this._w = w;

  		this.onChangeCallback();

  		return this;

  	},

  	clone: function () {

  		return new this.constructor( this._x, this._y, this._z, this._w );

  	},

  	copy: function ( quaternion ) {

  		this._x = quaternion.x;
  		this._y = quaternion.y;
  		this._z = quaternion.z;
  		this._w = quaternion.w;

  		this.onChangeCallback();

  		return this;

  	},

  	setFromEuler: function ( euler, update ) {

  		if ( ! ( euler && euler.isEuler ) ) {

  			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

  		}

  		var x = euler._x, y = euler._y, z = euler._z, order = euler.order;

  		// http://www.mathworks.com/matlabcentral/fileexchange/
  		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
  		//	content/SpinCalc.m

  		var cos = Math.cos;
  		var sin = Math.sin;

  		var c1 = cos( x / 2 );
  		var c2 = cos( y / 2 );
  		var c3 = cos( z / 2 );

  		var s1 = sin( x / 2 );
  		var s2 = sin( y / 2 );
  		var s3 = sin( z / 2 );

  		if ( order === 'XYZ' ) {

  			this._x = s1 * c2 * c3 + c1 * s2 * s3;
  			this._y = c1 * s2 * c3 - s1 * c2 * s3;
  			this._z = c1 * c2 * s3 + s1 * s2 * c3;
  			this._w = c1 * c2 * c3 - s1 * s2 * s3;

  		} else if ( order === 'YXZ' ) {

  			this._x = s1 * c2 * c3 + c1 * s2 * s3;
  			this._y = c1 * s2 * c3 - s1 * c2 * s3;
  			this._z = c1 * c2 * s3 - s1 * s2 * c3;
  			this._w = c1 * c2 * c3 + s1 * s2 * s3;

  		} else if ( order === 'ZXY' ) {

  			this._x = s1 * c2 * c3 - c1 * s2 * s3;
  			this._y = c1 * s2 * c3 + s1 * c2 * s3;
  			this._z = c1 * c2 * s3 + s1 * s2 * c3;
  			this._w = c1 * c2 * c3 - s1 * s2 * s3;

  		} else if ( order === 'ZYX' ) {

  			this._x = s1 * c2 * c3 - c1 * s2 * s3;
  			this._y = c1 * s2 * c3 + s1 * c2 * s3;
  			this._z = c1 * c2 * s3 - s1 * s2 * c3;
  			this._w = c1 * c2 * c3 + s1 * s2 * s3;

  		} else if ( order === 'YZX' ) {

  			this._x = s1 * c2 * c3 + c1 * s2 * s3;
  			this._y = c1 * s2 * c3 + s1 * c2 * s3;
  			this._z = c1 * c2 * s3 - s1 * s2 * c3;
  			this._w = c1 * c2 * c3 - s1 * s2 * s3;

  		} else if ( order === 'XZY' ) {

  			this._x = s1 * c2 * c3 - c1 * s2 * s3;
  			this._y = c1 * s2 * c3 - s1 * c2 * s3;
  			this._z = c1 * c2 * s3 + s1 * s2 * c3;
  			this._w = c1 * c2 * c3 + s1 * s2 * s3;

  		}

  		if ( update !== false ) { this.onChangeCallback(); }

  		return this;

  	},

  	setFromAxisAngle: function ( axis, angle ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

  		// assumes axis is normalized

  		var halfAngle = angle / 2, s = Math.sin( halfAngle );

  		this._x = axis.x * s;
  		this._y = axis.y * s;
  		this._z = axis.z * s;
  		this._w = Math.cos( halfAngle );

  		this.onChangeCallback();

  		return this;

  	},

  	setFromRotationMatrix: function ( m ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		var te = m.elements,

  			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
  			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
  			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

  			trace = m11 + m22 + m33,
  			s;

  		if ( trace > 0 ) {

  			s = 0.5 / Math.sqrt( trace + 1.0 );

  			this._w = 0.25 / s;
  			this._x = ( m32 - m23 ) * s;
  			this._y = ( m13 - m31 ) * s;
  			this._z = ( m21 - m12 ) * s;

  		} else if ( m11 > m22 && m11 > m33 ) {

  			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

  			this._w = ( m32 - m23 ) / s;
  			this._x = 0.25 * s;
  			this._y = ( m12 + m21 ) / s;
  			this._z = ( m13 + m31 ) / s;

  		} else if ( m22 > m33 ) {

  			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

  			this._w = ( m13 - m31 ) / s;
  			this._x = ( m12 + m21 ) / s;
  			this._y = 0.25 * s;
  			this._z = ( m23 + m32 ) / s;

  		} else {

  			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

  			this._w = ( m21 - m12 ) / s;
  			this._x = ( m13 + m31 ) / s;
  			this._y = ( m23 + m32 ) / s;
  			this._z = 0.25 * s;

  		}

  		this.onChangeCallback();

  		return this;

  	},

  	setFromUnitVectors: function () {

  		// assumes direction vectors vFrom and vTo are normalized

  		var v1 = new Vector3$1();
  		var r;

  		var EPS = 0.000001;

  		return function setFromUnitVectors( vFrom, vTo ) {

  			if ( v1 === undefined ) { v1 = new Vector3$1(); }

  			r = vFrom.dot( vTo ) + 1;

  			if ( r < EPS ) {

  				r = 0;

  				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

  					v1.set( - vFrom.y, vFrom.x, 0 );

  				} else {

  					v1.set( 0, - vFrom.z, vFrom.y );

  				}

  			} else {

  				v1.crossVectors( vFrom, vTo );

  			}

  			this._x = v1.x;
  			this._y = v1.y;
  			this._z = v1.z;
  			this._w = r;

  			return this.normalize();

  		};

  	}(),

  	inverse: function () {

  		return this.conjugate().normalize();

  	},

  	conjugate: function () {

  		this._x *= - 1;
  		this._y *= - 1;
  		this._z *= - 1;

  		this.onChangeCallback();

  		return this;

  	},

  	dot: function ( v ) {

  		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

  	},

  	lengthSq: function () {

  		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

  	},

  	length: function () {

  		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

  	},

  	normalize: function () {

  		var l = this.length();

  		if ( l === 0 ) {

  			this._x = 0;
  			this._y = 0;
  			this._z = 0;
  			this._w = 1;

  		} else {

  			l = 1 / l;

  			this._x = this._x * l;
  			this._y = this._y * l;
  			this._z = this._z * l;
  			this._w = this._w * l;

  		}

  		this.onChangeCallback();

  		return this;

  	},

  	multiply: function ( q, p ) {

  		if ( p !== undefined ) {

  			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
  			return this.multiplyQuaternions( q, p );

  		}

  		return this.multiplyQuaternions( this, q );

  	},

  	premultiply: function ( q ) {

  		return this.multiplyQuaternions( q, this );

  	},

  	multiplyQuaternions: function ( a, b ) {

  		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

  		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
  		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

  		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
  		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
  		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
  		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

  		this.onChangeCallback();

  		return this;

  	},

  	slerp: function ( qb, t ) {

  		if ( t === 0 ) { return this; }
  		if ( t === 1 ) { return this.copy( qb ); }

  		var x = this._x, y = this._y, z = this._z, w = this._w;

  		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

  		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

  		if ( cosHalfTheta < 0 ) {

  			this._w = - qb._w;
  			this._x = - qb._x;
  			this._y = - qb._y;
  			this._z = - qb._z;

  			cosHalfTheta = - cosHalfTheta;

  		} else {

  			this.copy( qb );

  		}

  		if ( cosHalfTheta >= 1.0 ) {

  			this._w = w;
  			this._x = x;
  			this._y = y;
  			this._z = z;

  			return this;

  		}

  		var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

  		if ( Math.abs( sinHalfTheta ) < 0.001 ) {

  			this._w = 0.5 * ( w + this._w );
  			this._x = 0.5 * ( x + this._x );
  			this._y = 0.5 * ( y + this._y );
  			this._z = 0.5 * ( z + this._z );

  			return this;

  		}

  		var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
  		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
  			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

  		this._w = ( w * ratioA + this._w * ratioB );
  		this._x = ( x * ratioA + this._x * ratioB );
  		this._y = ( y * ratioA + this._y * ratioB );
  		this._z = ( z * ratioA + this._z * ratioB );

  		this.onChangeCallback();

  		return this;

  	},

  	equals: function ( quaternion ) {

  		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

  	},

  	fromArray: function ( array, offset ) {

  		if ( offset === undefined ) { offset = 0; }

  		this._x = array[ offset ];
  		this._y = array[ offset + 1 ];
  		this._z = array[ offset + 2 ];
  		this._w = array[ offset + 3 ];

  		this.onChangeCallback();

  		return this;

  	},

  	toArray: function ( array, offset ) {

  		if ( array === undefined ) { array = []; }
  		if ( offset === undefined ) { offset = 0; }

  		array[ offset ] = this._x;
  		array[ offset + 1 ] = this._y;
  		array[ offset + 2 ] = this._z;
  		array[ offset + 3 ] = this._w;

  		return array;

  	},

  	onChange: function ( callback ) {

  		this.onChangeCallback = callback;

  		return this;

  	},

  	onChangeCallback: function () {}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author kile / http://kile.stravaganza.org/
   * @author philogb / http://blog.thejit.org/
   * @author mikael emtinger / http://gomo.se/
   * @author egraether / http://egraether.com/
   * @author WestLangley / http://github.com/WestLangley
   */

  function Vector3$1( x, y, z ) {

  	this.x = x || 0;
  	this.y = y || 0;
  	this.z = z || 0;

  }

  Object.assign( Vector3$1.prototype, {

  	isVector3: true,

  	set: function ( x, y, z ) {

  		this.x = x;
  		this.y = y;
  		this.z = z;

  		return this;

  	},

  	setScalar: function ( scalar ) {

  		this.x = scalar;
  		this.y = scalar;
  		this.z = scalar;

  		return this;

  	},

  	setX: function ( x ) {

  		this.x = x;

  		return this;

  	},

  	setY: function ( y ) {

  		this.y = y;

  		return this;

  	},

  	setZ: function ( z ) {

  		this.z = z;

  		return this;

  	},

  	setComponent: function ( index, value ) {

  		switch ( index ) {

  			case 0: this.x = value; break;
  			case 1: this.y = value; break;
  			case 2: this.z = value; break;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  		return this;

  	},

  	getComponent: function ( index ) {

  		switch ( index ) {

  			case 0: return this.x;
  			case 1: return this.y;
  			case 2: return this.z;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  	},

  	clone: function () {

  		return new this.constructor( this.x, this.y, this.z );

  	},

  	copy: function ( v ) {

  		this.x = v.x;
  		this.y = v.y;
  		this.z = v.z;

  		return this;

  	},

  	add: function ( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
  			return this.addVectors( v, w );

  		}

  		this.x += v.x;
  		this.y += v.y;
  		this.z += v.z;

  		return this;

  	},

  	addScalar: function ( s ) {

  		this.x += s;
  		this.y += s;
  		this.z += s;

  		return this;

  	},

  	addVectors: function ( a, b ) {

  		this.x = a.x + b.x;
  		this.y = a.y + b.y;
  		this.z = a.z + b.z;

  		return this;

  	},

  	addScaledVector: function ( v, s ) {

  		this.x += v.x * s;
  		this.y += v.y * s;
  		this.z += v.z * s;

  		return this;

  	},

  	sub: function ( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
  			return this.subVectors( v, w );

  		}

  		this.x -= v.x;
  		this.y -= v.y;
  		this.z -= v.z;

  		return this;

  	},

  	subScalar: function ( s ) {

  		this.x -= s;
  		this.y -= s;
  		this.z -= s;

  		return this;

  	},

  	subVectors: function ( a, b ) {

  		this.x = a.x - b.x;
  		this.y = a.y - b.y;
  		this.z = a.z - b.z;

  		return this;

  	},

  	multiply: function ( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
  			return this.multiplyVectors( v, w );

  		}

  		this.x *= v.x;
  		this.y *= v.y;
  		this.z *= v.z;

  		return this;

  	},

  	multiplyScalar: function ( scalar ) {

  		this.x *= scalar;
  		this.y *= scalar;
  		this.z *= scalar;

  		return this;

  	},

  	multiplyVectors: function ( a, b ) {

  		this.x = a.x * b.x;
  		this.y = a.y * b.y;
  		this.z = a.z * b.z;

  		return this;

  	},

  	applyEuler: function () {

  		var quaternion = new Quaternion();

  		return function applyEuler( euler ) {

  			if ( ! ( euler && euler.isEuler ) ) {

  				console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

  			}

  			return this.applyQuaternion( quaternion.setFromEuler( euler ) );

  		};

  	}(),

  	applyAxisAngle: function () {

  		var quaternion = new Quaternion();

  		return function applyAxisAngle( axis, angle ) {

  			return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

  		};

  	}(),

  	applyMatrix3: function ( m ) {

  		var x = this.x, y = this.y, z = this.z;
  		var e = m.elements;

  		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
  		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
  		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

  		return this;

  	},

  	applyMatrix4: function ( m ) {

  		var x = this.x, y = this.y, z = this.z;
  		var e = m.elements;

  		var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

  		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
  		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
  		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

  		return this;

  	},

  	applyQuaternion: function ( q ) {

  		var x = this.x, y = this.y, z = this.z;
  		var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

  		// calculate quat * vector

  		var ix = qw * x + qy * z - qz * y;
  		var iy = qw * y + qz * x - qx * z;
  		var iz = qw * z + qx * y - qy * x;
  		var iw = - qx * x - qy * y - qz * z;

  		// calculate result * inverse quat

  		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
  		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
  		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

  		return this;

  	},

  	project: function () {

  		var matrix = new Matrix4();

  		return function project( camera ) {

  			matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
  			return this.applyMatrix4( matrix );

  		};

  	}(),

  	unproject: function () {

  		var matrix = new Matrix4();

  		return function unproject( camera ) {

  			matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
  			return this.applyMatrix4( matrix );

  		};

  	}(),

  	transformDirection: function ( m ) {

  		// input: THREE.Matrix4 affine matrix
  		// vector interpreted as a direction

  		var x = this.x, y = this.y, z = this.z;
  		var e = m.elements;

  		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
  		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
  		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

  		return this.normalize();

  	},

  	divide: function ( v ) {

  		this.x /= v.x;
  		this.y /= v.y;
  		this.z /= v.z;

  		return this;

  	},

  	divideScalar: function ( scalar ) {

  		return this.multiplyScalar( 1 / scalar );

  	},

  	min: function ( v ) {

  		this.x = Math.min( this.x, v.x );
  		this.y = Math.min( this.y, v.y );
  		this.z = Math.min( this.z, v.z );

  		return this;

  	},

  	max: function ( v ) {

  		this.x = Math.max( this.x, v.x );
  		this.y = Math.max( this.y, v.y );
  		this.z = Math.max( this.z, v.z );

  		return this;

  	},

  	clamp: function ( min, max ) {

  		// assumes min < max, componentwise

  		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
  		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
  		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

  		return this;

  	},

  	clampScalar: function () {

  		var min = new Vector3$1();
  		var max = new Vector3$1();

  		return function clampScalar( minVal, maxVal ) {

  			min.set( minVal, minVal, minVal );
  			max.set( maxVal, maxVal, maxVal );

  			return this.clamp( min, max );

  		};

  	}(),

  	clampLength: function ( min, max ) {

  		var length = this.length();

  		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

  	},

  	floor: function () {

  		this.x = Math.floor( this.x );
  		this.y = Math.floor( this.y );
  		this.z = Math.floor( this.z );

  		return this;

  	},

  	ceil: function () {

  		this.x = Math.ceil( this.x );
  		this.y = Math.ceil( this.y );
  		this.z = Math.ceil( this.z );

  		return this;

  	},

  	round: function () {

  		this.x = Math.round( this.x );
  		this.y = Math.round( this.y );
  		this.z = Math.round( this.z );

  		return this;

  	},

  	roundToZero: function () {

  		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
  		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
  		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

  		return this;

  	},

  	negate: function () {

  		this.x = - this.x;
  		this.y = - this.y;
  		this.z = - this.z;

  		return this;

  	},

  	dot: function ( v ) {

  		return this.x * v.x + this.y * v.y + this.z * v.z;

  	},

  	// TODO lengthSquared?

  	lengthSq: function () {

  		return this.x * this.x + this.y * this.y + this.z * this.z;

  	},

  	length: function () {

  		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

  	},

  	lengthManhattan: function () {

  		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

  	},

  	normalize: function () {

  		return this.divideScalar( this.length() || 1 );

  	},

  	setLength: function ( length ) {

  		return this.normalize().multiplyScalar( length );

  	},

  	lerp: function ( v, alpha ) {

  		this.x += ( v.x - this.x ) * alpha;
  		this.y += ( v.y - this.y ) * alpha;
  		this.z += ( v.z - this.z ) * alpha;

  		return this;

  	},

  	lerpVectors: function ( v1, v2, alpha ) {

  		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

  	},

  	cross: function ( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
  			return this.crossVectors( v, w );

  		}

  		var x = this.x, y = this.y, z = this.z;

  		this.x = y * v.z - z * v.y;
  		this.y = z * v.x - x * v.z;
  		this.z = x * v.y - y * v.x;

  		return this;

  	},

  	crossVectors: function ( a, b ) {

  		var ax = a.x, ay = a.y, az = a.z;
  		var bx = b.x, by = b.y, bz = b.z;

  		this.x = ay * bz - az * by;
  		this.y = az * bx - ax * bz;
  		this.z = ax * by - ay * bx;

  		return this;

  	},

  	projectOnVector: function ( vector ) {

  		var scalar = vector.dot( this ) / vector.lengthSq();

  		return this.copy( vector ).multiplyScalar( scalar );

  	},

  	projectOnPlane: function () {

  		var v1 = new Vector3$1();

  		return function projectOnPlane( planeNormal ) {

  			v1.copy( this ).projectOnVector( planeNormal );

  			return this.sub( v1 );

  		};

  	}(),

  	reflect: function () {

  		// reflect incident vector off plane orthogonal to normal
  		// normal is assumed to have unit length

  		var v1 = new Vector3$1();

  		return function reflect( normal ) {

  			return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

  		};

  	}(),

  	angleTo: function ( v ) {

  		var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );

  		// clamp, to handle numerical problems

  		return Math.acos( _Math.clamp( theta, - 1, 1 ) );

  	},

  	distanceTo: function ( v ) {

  		return Math.sqrt( this.distanceToSquared( v ) );

  	},

  	distanceToSquared: function ( v ) {

  		var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

  		return dx * dx + dy * dy + dz * dz;

  	},

  	distanceToManhattan: function ( v ) {

  		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

  	},

  	setFromSpherical: function ( s ) {

  		var sinPhiRadius = Math.sin( s.phi ) * s.radius;

  		this.x = sinPhiRadius * Math.sin( s.theta );
  		this.y = Math.cos( s.phi ) * s.radius;
  		this.z = sinPhiRadius * Math.cos( s.theta );

  		return this;

  	},

  	setFromCylindrical: function ( c ) {

  		this.x = c.radius * Math.sin( c.theta );
  		this.y = c.y;
  		this.z = c.radius * Math.cos( c.theta );

  		return this;

  	},

  	setFromMatrixPosition: function ( m ) {

  		var e = m.elements;

  		this.x = e[ 12 ];
  		this.y = e[ 13 ];
  		this.z = e[ 14 ];

  		return this;

  	},

  	setFromMatrixScale: function ( m ) {

  		var sx = this.setFromMatrixColumn( m, 0 ).length();
  		var sy = this.setFromMatrixColumn( m, 1 ).length();
  		var sz = this.setFromMatrixColumn( m, 2 ).length();

  		this.x = sx;
  		this.y = sy;
  		this.z = sz;

  		return this;

  	},

  	setFromMatrixColumn: function ( m, index ) {

  		return this.fromArray( m.elements, index * 4 );

  	},

  	equals: function ( v ) {

  		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

  	},

  	fromArray: function ( array, offset ) {

  		if ( offset === undefined ) { offset = 0; }

  		this.x = array[ offset ];
  		this.y = array[ offset + 1 ];
  		this.z = array[ offset + 2 ];

  		return this;

  	},

  	toArray: function ( array, offset ) {

  		if ( array === undefined ) { array = []; }
  		if ( offset === undefined ) { offset = 0; }

  		array[ offset ] = this.x;
  		array[ offset + 1 ] = this.y;
  		array[ offset + 2 ] = this.z;

  		return array;

  	},

  	fromBufferAttribute: function ( attribute, index, offset ) {

  		if ( offset !== undefined ) {

  			console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

  		}

  		this.x = attribute.getX( index );
  		this.y = attribute.getY( index );
  		this.z = attribute.getZ( index );

  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author philogb / http://blog.thejit.org/
   * @author egraether / http://egraether.com/
   * @author zz85 / http://www.lab4games.net/zz85/blog
   */

  function Vector2( x, y ) {

  	this.x = x || 0;
  	this.y = y || 0;

  }

  Object.defineProperties( Vector2.prototype, {

  	"width": {

  		get: function () {

  			return this.x;

  		},

  		set: function ( value ) {

  			this.x = value;

  		}

  	},

  	"height": {

  		get: function () {

  			return this.y;

  		},

  		set: function ( value ) {

  			this.y = value;

  		}

  	}

  } );

  Object.assign( Vector2.prototype, {

  	isVector2: true,

  	set: function ( x, y ) {

  		this.x = x;
  		this.y = y;

  		return this;

  	},

  	setScalar: function ( scalar ) {

  		this.x = scalar;
  		this.y = scalar;

  		return this;

  	},

  	setX: function ( x ) {

  		this.x = x;

  		return this;

  	},

  	setY: function ( y ) {

  		this.y = y;

  		return this;

  	},

  	setComponent: function ( index, value ) {

  		switch ( index ) {

  			case 0: this.x = value; break;
  			case 1: this.y = value; break;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  		return this;

  	},

  	getComponent: function ( index ) {

  		switch ( index ) {

  			case 0: return this.x;
  			case 1: return this.y;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  	},

  	clone: function () {

  		return new this.constructor( this.x, this.y );

  	},

  	copy: function ( v ) {

  		this.x = v.x;
  		this.y = v.y;

  		return this;

  	},

  	add: function ( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
  			return this.addVectors( v, w );

  		}

  		this.x += v.x;
  		this.y += v.y;

  		return this;

  	},

  	addScalar: function ( s ) {

  		this.x += s;
  		this.y += s;

  		return this;

  	},

  	addVectors: function ( a, b ) {

  		this.x = a.x + b.x;
  		this.y = a.y + b.y;

  		return this;

  	},

  	addScaledVector: function ( v, s ) {

  		this.x += v.x * s;
  		this.y += v.y * s;

  		return this;

  	},

  	sub: function ( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
  			return this.subVectors( v, w );

  		}

  		this.x -= v.x;
  		this.y -= v.y;

  		return this;

  	},

  	subScalar: function ( s ) {

  		this.x -= s;
  		this.y -= s;

  		return this;

  	},

  	subVectors: function ( a, b ) {

  		this.x = a.x - b.x;
  		this.y = a.y - b.y;

  		return this;

  	},

  	multiply: function ( v ) {

  		this.x *= v.x;
  		this.y *= v.y;

  		return this;

  	},

  	multiplyScalar: function ( scalar ) {

  		this.x *= scalar;
  		this.y *= scalar;

  		return this;

  	},

  	divide: function ( v ) {

  		this.x /= v.x;
  		this.y /= v.y;

  		return this;

  	},

  	divideScalar: function ( scalar ) {

  		return this.multiplyScalar( 1 / scalar );

  	},

  	applyMatrix3: function ( m ) {

  		var x = this.x, y = this.y;
  		var e = m.elements;

  		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
  		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

  		return this;

  	},

  	min: function ( v ) {

  		this.x = Math.min( this.x, v.x );
  		this.y = Math.min( this.y, v.y );

  		return this;

  	},

  	max: function ( v ) {

  		this.x = Math.max( this.x, v.x );
  		this.y = Math.max( this.y, v.y );

  		return this;

  	},

  	clamp: function ( min, max ) {

  		// assumes min < max, componentwise

  		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
  		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

  		return this;

  	},

  	clampScalar: function () {

  		var min = new Vector2();
  		var max = new Vector2();

  		return function clampScalar( minVal, maxVal ) {

  			min.set( minVal, minVal );
  			max.set( maxVal, maxVal );

  			return this.clamp( min, max );

  		};

  	}(),

  	clampLength: function ( min, max ) {

  		var length = this.length();

  		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

  	},

  	floor: function () {

  		this.x = Math.floor( this.x );
  		this.y = Math.floor( this.y );

  		return this;

  	},

  	ceil: function () {

  		this.x = Math.ceil( this.x );
  		this.y = Math.ceil( this.y );

  		return this;

  	},

  	round: function () {

  		this.x = Math.round( this.x );
  		this.y = Math.round( this.y );

  		return this;

  	},

  	roundToZero: function () {

  		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
  		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

  		return this;

  	},

  	negate: function () {

  		this.x = - this.x;
  		this.y = - this.y;

  		return this;

  	},

  	dot: function ( v ) {

  		return this.x * v.x + this.y * v.y;

  	},

  	lengthSq: function () {

  		return this.x * this.x + this.y * this.y;

  	},

  	length: function () {

  		return Math.sqrt( this.x * this.x + this.y * this.y );

  	},

  	lengthManhattan: function () {

  		return Math.abs( this.x ) + Math.abs( this.y );

  	},

  	normalize: function () {

  		return this.divideScalar( this.length() || 1 );

  	},

  	angle: function () {

  		// computes the angle in radians with respect to the positive x-axis

  		var angle = Math.atan2( this.y, this.x );

  		if ( angle < 0 ) { angle += 2 * Math.PI; }

  		return angle;

  	},

  	distanceTo: function ( v ) {

  		return Math.sqrt( this.distanceToSquared( v ) );

  	},

  	distanceToSquared: function ( v ) {

  		var dx = this.x - v.x, dy = this.y - v.y;
  		return dx * dx + dy * dy;

  	},

  	distanceToManhattan: function ( v ) {

  		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

  	},

  	setLength: function ( length ) {

  		return this.normalize().multiplyScalar( length );

  	},

  	lerp: function ( v, alpha ) {

  		this.x += ( v.x - this.x ) * alpha;
  		this.y += ( v.y - this.y ) * alpha;

  		return this;

  	},

  	lerpVectors: function ( v1, v2, alpha ) {

  		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

  	},

  	equals: function ( v ) {

  		return ( ( v.x === this.x ) && ( v.y === this.y ) );

  	},

  	fromArray: function ( array, offset ) {

  		if ( offset === undefined ) { offset = 0; }

  		this.x = array[ offset ];
  		this.y = array[ offset + 1 ];

  		return this;

  	},

  	toArray: function ( array, offset ) {

  		if ( array === undefined ) { array = []; }
  		if ( offset === undefined ) { offset = 0; }

  		array[ offset ] = this.x;
  		array[ offset + 1 ] = this.y;

  		return array;

  	},

  	fromBufferAttribute: function ( attribute, index, offset ) {

  		if ( offset !== undefined ) {

  			console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

  		}

  		this.x = attribute.getX( index );
  		this.y = attribute.getY( index );

  		return this;

  	},

  	rotateAround: function ( center, angle ) {

  		var c = Math.cos( angle ), s = Math.sin( angle );

  		var x = this.x - center.x;
  		var y = this.y - center.y;

  		this.x = x * c - y * s + center.x;
  		this.y = x * s + y * c + center.y;

  		return this;

  	}

  } );

  /**
   * @author bhouston / http://clara.io
   * @author WestLangley / http://github.com/WestLangley
   */

  function Box3( min, max ) {

  	this.min = ( min !== undefined ) ? min : new Vector3$1( + Infinity, + Infinity, + Infinity );
  	this.max = ( max !== undefined ) ? max : new Vector3$1( - Infinity, - Infinity, - Infinity );

  }

  Object.assign( Box3.prototype, {

  	isBox3: true,

  	set: function ( min, max ) {

  		this.min.copy( min );
  		this.max.copy( max );

  		return this;

  	},

  	setFromArray: function ( array ) {

  		var minX = + Infinity;
  		var minY = + Infinity;
  		var minZ = + Infinity;

  		var maxX = - Infinity;
  		var maxY = - Infinity;
  		var maxZ = - Infinity;

  		for ( var i = 0, l = array.length; i < l; i += 3 ) {

  			var x = array[ i ];
  			var y = array[ i + 1 ];
  			var z = array[ i + 2 ];

  			if ( x < minX ) { minX = x; }
  			if ( y < minY ) { minY = y; }
  			if ( z < minZ ) { minZ = z; }

  			if ( x > maxX ) { maxX = x; }
  			if ( y > maxY ) { maxY = y; }
  			if ( z > maxZ ) { maxZ = z; }

  		}

  		this.min.set( minX, minY, minZ );
  		this.max.set( maxX, maxY, maxZ );

  		return this;

  	},

  	setFromBufferAttribute: function ( attribute ) {

  		var minX = + Infinity;
  		var minY = + Infinity;
  		var minZ = + Infinity;

  		var maxX = - Infinity;
  		var maxY = - Infinity;
  		var maxZ = - Infinity;

  		for ( var i = 0, l = attribute.count; i < l; i ++ ) {

  			var x = attribute.getX( i );
  			var y = attribute.getY( i );
  			var z = attribute.getZ( i );

  			if ( x < minX ) { minX = x; }
  			if ( y < minY ) { minY = y; }
  			if ( z < minZ ) { minZ = z; }

  			if ( x > maxX ) { maxX = x; }
  			if ( y > maxY ) { maxY = y; }
  			if ( z > maxZ ) { maxZ = z; }

  		}

  		this.min.set( minX, minY, minZ );
  		this.max.set( maxX, maxY, maxZ );

  		return this;

  	},

  	setFromPoints: function ( points ) {
  		var this$1 = this;


  		this.makeEmpty();

  		for ( var i = 0, il = points.length; i < il; i ++ ) {

  			this$1.expandByPoint( points[ i ] );

  		}

  		return this;

  	},

  	setFromCenterAndSize: function () {

  		var v1 = new Vector3$1();

  		return function setFromCenterAndSize( center, size ) {

  			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

  			this.min.copy( center ).sub( halfSize );
  			this.max.copy( center ).add( halfSize );

  			return this;

  		};

  	}(),

  	setFromObject: function ( object ) {

  		this.makeEmpty();

  		return this.expandByObject( object );

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( box ) {

  		this.min.copy( box.min );
  		this.max.copy( box.max );

  		return this;

  	},

  	makeEmpty: function () {

  		this.min.x = this.min.y = this.min.z = + Infinity;
  		this.max.x = this.max.y = this.max.z = - Infinity;

  		return this;

  	},

  	isEmpty: function () {

  		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

  		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

  	},

  	getCenter: function ( optionalTarget ) {

  		var result = optionalTarget || new Vector3$1();
  		return this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

  	},

  	getSize: function ( optionalTarget ) {

  		var result = optionalTarget || new Vector3$1();
  		return this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );

  	},

  	expandByPoint: function ( point ) {

  		this.min.min( point );
  		this.max.max( point );

  		return this;

  	},

  	expandByVector: function ( vector ) {

  		this.min.sub( vector );
  		this.max.add( vector );

  		return this;

  	},

  	expandByScalar: function ( scalar ) {

  		this.min.addScalar( - scalar );
  		this.max.addScalar( scalar );

  		return this;

  	},

  	expandByObject: function () {

  		// Computes the world-axis-aligned bounding box of an object (including its children),
  		// accounting for both the object's, and children's, world transforms

  		var v1 = new Vector3$1();

  		return function expandByObject( object ) {

  			var scope = this;

  			object.updateMatrixWorld( true );

  			object.traverse( function ( node ) {

  				var i, l;

  				var geometry = node.geometry;

  				if ( geometry !== undefined ) {

  					if ( geometry.isGeometry ) {

  						var vertices = geometry.vertices;

  						for ( i = 0, l = vertices.length; i < l; i ++ ) {

  							v1.copy( vertices[ i ] );
  							v1.applyMatrix4( node.matrixWorld );

  							scope.expandByPoint( v1 );

  						}

  					} else if ( geometry.isBufferGeometry ) {

  						var attribute = geometry.attributes.position;

  						if ( attribute !== undefined ) {

  							for ( i = 0, l = attribute.count; i < l; i ++ ) {

  								v1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );

  								scope.expandByPoint( v1 );

  							}

  						}

  					}

  				}

  			} );

  			return this;

  		};

  	}(),

  	containsPoint: function ( point ) {

  		return point.x < this.min.x || point.x > this.max.x ||
  			point.y < this.min.y || point.y > this.max.y ||
  			point.z < this.min.z || point.z > this.max.z ? false : true;

  	},

  	containsBox: function ( box ) {

  		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
  			this.min.y <= box.min.y && box.max.y <= this.max.y &&
  			this.min.z <= box.min.z && box.max.z <= this.max.z;

  	},

  	getParameter: function ( point, optionalTarget ) {

  		// This can potentially have a divide by zero if the box
  		// has a size dimension of 0.

  		var result = optionalTarget || new Vector3$1();

  		return result.set(
  			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
  			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
  			( point.z - this.min.z ) / ( this.max.z - this.min.z )
  		);

  	},

  	intersectsBox: function ( box ) {

  		// using 6 splitting planes to rule out intersections.
  		return box.max.x < this.min.x || box.min.x > this.max.x ||
  			box.max.y < this.min.y || box.min.y > this.max.y ||
  			box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

  	},

  	intersectsSphere: ( function () {

  		var closestPoint = new Vector3$1();

  		return function intersectsSphere( sphere ) {

  			// Find the point on the AABB closest to the sphere center.
  			this.clampPoint( sphere.center, closestPoint );

  			// If that point is inside the sphere, the AABB and sphere intersect.
  			return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

  		};

  	} )(),

  	intersectsPlane: function ( plane ) {

  		// We compute the minimum and maximum dot product values. If those values
  		// are on the same side (back or front) of the plane, then there is no intersection.

  		var min, max;

  		if ( plane.normal.x > 0 ) {

  			min = plane.normal.x * this.min.x;
  			max = plane.normal.x * this.max.x;

  		} else {

  			min = plane.normal.x * this.max.x;
  			max = plane.normal.x * this.min.x;

  		}

  		if ( plane.normal.y > 0 ) {

  			min += plane.normal.y * this.min.y;
  			max += plane.normal.y * this.max.y;

  		} else {

  			min += plane.normal.y * this.max.y;
  			max += plane.normal.y * this.min.y;

  		}

  		if ( plane.normal.z > 0 ) {

  			min += plane.normal.z * this.min.z;
  			max += plane.normal.z * this.max.z;

  		} else {

  			min += plane.normal.z * this.max.z;
  			max += plane.normal.z * this.min.z;

  		}

  		return ( min <= plane.constant && max >= plane.constant );

  	},

  	clampPoint: function ( point, optionalTarget ) {

  		var result = optionalTarget || new Vector3$1();
  		return result.copy( point ).clamp( this.min, this.max );

  	},

  	distanceToPoint: function () {

  		var v1 = new Vector3$1();

  		return function distanceToPoint( point ) {

  			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
  			return clampedPoint.sub( point ).length();

  		};

  	}(),

  	getBoundingSphere: function () {

  		var v1 = new Vector3$1();

  		return function getBoundingSphere( optionalTarget ) {

  			var result = optionalTarget || new Sphere();

  			this.getCenter( result.center );

  			result.radius = this.getSize( v1 ).length() * 0.5;

  			return result;

  		};

  	}(),

  	intersect: function ( box ) {

  		this.min.max( box.min );
  		this.max.min( box.max );

  		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
  		if ( this.isEmpty() ) { this.makeEmpty(); }

  		return this;

  	},

  	union: function ( box ) {

  		this.min.min( box.min );
  		this.max.max( box.max );

  		return this;

  	},

  	applyMatrix4: function () {

  		var points = [
  			new Vector3$1(),
  			new Vector3$1(),
  			new Vector3$1(),
  			new Vector3$1(),
  			new Vector3$1(),
  			new Vector3$1(),
  			new Vector3$1(),
  			new Vector3$1()
  		];

  		return function applyMatrix4( matrix ) {

  			// transform of empty box is an empty box.
  			if ( this.isEmpty() ) { return this; }

  			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
  			points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
  			points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
  			points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
  			points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
  			points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
  			points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
  			points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
  			points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );	// 111

  			this.setFromPoints( points );

  			return this;

  		};

  	}(),

  	translate: function ( offset ) {

  		this.min.add( offset );
  		this.max.add( offset );

  		return this;

  	},

  	equals: function ( box ) {

  		return box.min.equals( this.min ) && box.max.equals( this.max );

  	}

  } );

  /**
   * @author bhouston / http://clara.io
   * @author mrdoob / http://mrdoob.com/
   */

  function Sphere( center, radius ) {

  	this.center = ( center !== undefined ) ? center : new Vector3$1();
  	this.radius = ( radius !== undefined ) ? radius : 0;

  }

  Object.assign( Sphere.prototype, {

  	set: function ( center, radius ) {

  		this.center.copy( center );
  		this.radius = radius;

  		return this;

  	},

  	setFromPoints: function () {

  		var box = new Box3();

  		return function setFromPoints( points, optionalCenter ) {

  			var center = this.center;

  			if ( optionalCenter !== undefined ) {

  				center.copy( optionalCenter );

  			} else {

  				box.setFromPoints( points ).getCenter( center );

  			}

  			var maxRadiusSq = 0;

  			for ( var i = 0, il = points.length; i < il; i ++ ) {

  				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

  			}

  			this.radius = Math.sqrt( maxRadiusSq );

  			return this;

  		};

  	}(),

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( sphere ) {

  		this.center.copy( sphere.center );
  		this.radius = sphere.radius;

  		return this;

  	},

  	empty: function () {

  		return ( this.radius <= 0 );

  	},

  	containsPoint: function ( point ) {

  		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

  	},

  	distanceToPoint: function ( point ) {

  		return ( point.distanceTo( this.center ) - this.radius );

  	},

  	intersectsSphere: function ( sphere ) {

  		var radiusSum = this.radius + sphere.radius;

  		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

  	},

  	intersectsBox: function ( box ) {

  		return box.intersectsSphere( this );

  	},

  	intersectsPlane: function ( plane ) {

  		return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

  	},

  	clampPoint: function ( point, optionalTarget ) {

  		var deltaLengthSq = this.center.distanceToSquared( point );

  		var result = optionalTarget || new Vector3$1();

  		result.copy( point );

  		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

  			result.sub( this.center ).normalize();
  			result.multiplyScalar( this.radius ).add( this.center );

  		}

  		return result;

  	},

  	getBoundingBox: function ( optionalTarget ) {

  		var box = optionalTarget || new Box3();

  		box.set( this.center, this.center );
  		box.expandByScalar( this.radius );

  		return box;

  	},

  	applyMatrix4: function ( matrix ) {

  		this.center.applyMatrix4( matrix );
  		this.radius = this.radius * matrix.getMaxScaleOnAxis();

  		return this;

  	},

  	translate: function ( offset ) {

  		this.center.add( offset );

  		return this;

  	},

  	equals: function ( sphere ) {

  		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

  	}

  } );

  /**
   * @author bhouston / http://clara.io
   */

  function Ray( origin, direction ) {

  	this.origin = ( origin !== undefined ) ? origin : new Vector3$1();
  	this.direction = ( direction !== undefined ) ? direction : new Vector3$1();

  }

  Object.assign( Ray.prototype, {

  	set: function ( origin, direction ) {

  		this.origin.copy( origin );
  		this.direction.copy( direction );

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( ray ) {

  		this.origin.copy( ray.origin );
  		this.direction.copy( ray.direction );

  		return this;

  	},

  	at: function ( t, optionalTarget ) {

  		var result = optionalTarget || new Vector3$1();

  		return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

  	},

  	lookAt: function ( v ) {

  		this.direction.copy( v ).sub( this.origin ).normalize();

  		return this;

  	},

  	recast: function () {

  		var v1 = new Vector3$1();

  		return function recast( t ) {

  			this.origin.copy( this.at( t, v1 ) );

  			return this;

  		};

  	}(),

  	closestPointToPoint: function ( point, optionalTarget ) {

  		var result = optionalTarget || new Vector3$1();
  		result.subVectors( point, this.origin );
  		var directionDistance = result.dot( this.direction );

  		if ( directionDistance < 0 ) {

  			return result.copy( this.origin );

  		}

  		return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

  	},

  	distanceToPoint: function ( point ) {

  		return Math.sqrt( this.distanceSqToPoint( point ) );

  	},

  	distanceSqToPoint: function () {

  		var v1 = new Vector3$1();

  		return function distanceSqToPoint( point ) {

  			var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

  			// point behind the ray

  			if ( directionDistance < 0 ) {

  				return this.origin.distanceToSquared( point );

  			}

  			v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

  			return v1.distanceToSquared( point );

  		};

  	}(),

  	distanceSqToSegment: function () {

  		var segCenter = new Vector3$1();
  		var segDir = new Vector3$1();
  		var diff = new Vector3$1();

  		return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

  			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
  			// It returns the min distance between the ray and the segment
  			// defined by v0 and v1
  			// It can also set two optional targets :
  			// - The closest point on the ray
  			// - The closest point on the segment

  			segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
  			segDir.copy( v1 ).sub( v0 ).normalize();
  			diff.copy( this.origin ).sub( segCenter );

  			var segExtent = v0.distanceTo( v1 ) * 0.5;
  			var a01 = - this.direction.dot( segDir );
  			var b0 = diff.dot( this.direction );
  			var b1 = - diff.dot( segDir );
  			var c = diff.lengthSq();
  			var det = Math.abs( 1 - a01 * a01 );
  			var s0, s1, sqrDist, extDet;

  			if ( det > 0 ) {

  				// The ray and segment are not parallel.

  				s0 = a01 * b1 - b0;
  				s1 = a01 * b0 - b1;
  				extDet = segExtent * det;

  				if ( s0 >= 0 ) {

  					if ( s1 >= - extDet ) {

  						if ( s1 <= extDet ) {

  							// region 0
  							// Minimum at interior points of ray and segment.

  							var invDet = 1 / det;
  							s0 *= invDet;
  							s1 *= invDet;
  							sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

  						} else {

  							// region 1

  							s1 = segExtent;
  							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
  							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  						}

  					} else {

  						// region 5

  						s1 = - segExtent;
  						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
  						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  					}

  				} else {

  					if ( s1 <= - extDet ) {

  						// region 4

  						s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
  						s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
  						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  					} else if ( s1 <= extDet ) {

  						// region 3

  						s0 = 0;
  						s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
  						sqrDist = s1 * ( s1 + 2 * b1 ) + c;

  					} else {

  						// region 2

  						s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
  						s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
  						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  					}

  				}

  			} else {

  				// Ray and segment are parallel.

  				s1 = ( a01 > 0 ) ? - segExtent : segExtent;
  				s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
  				sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  			}

  			if ( optionalPointOnRay ) {

  				optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

  			}

  			if ( optionalPointOnSegment ) {

  				optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

  			}

  			return sqrDist;

  		};

  	}(),

  	intersectSphere: function () {

  		var v1 = new Vector3$1();

  		return function intersectSphere( sphere, optionalTarget ) {

  			v1.subVectors( sphere.center, this.origin );
  			var tca = v1.dot( this.direction );
  			var d2 = v1.dot( v1 ) - tca * tca;
  			var radius2 = sphere.radius * sphere.radius;

  			if ( d2 > radius2 ) { return null; }

  			var thc = Math.sqrt( radius2 - d2 );

  			// t0 = first intersect point - entrance on front of sphere
  			var t0 = tca - thc;

  			// t1 = second intersect point - exit point on back of sphere
  			var t1 = tca + thc;

  			// test to see if both t0 and t1 are behind the ray - if so, return null
  			if ( t0 < 0 && t1 < 0 ) { return null; }

  			// test to see if t0 is behind the ray:
  			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
  			// in order to always return an intersect point that is in front of the ray.
  			if ( t0 < 0 ) { return this.at( t1, optionalTarget ); }

  			// else t0 is in front of the ray, so return the first collision point scaled by t0
  			return this.at( t0, optionalTarget );

  		};

  	}(),

  	intersectsSphere: function ( sphere ) {

  		return this.distanceToPoint( sphere.center ) <= sphere.radius;

  	},

  	distanceToPlane: function ( plane ) {

  		var denominator = plane.normal.dot( this.direction );

  		if ( denominator === 0 ) {

  			// line is coplanar, return origin
  			if ( plane.distanceToPoint( this.origin ) === 0 ) {

  				return 0;

  			}

  			// Null is preferable to undefined since undefined means.... it is undefined

  			return null;

  		}

  		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

  		// Return if the ray never intersects the plane

  		return t >= 0 ? t : null;

  	},

  	intersectPlane: function ( plane, optionalTarget ) {

  		var t = this.distanceToPlane( plane );

  		if ( t === null ) {

  			return null;

  		}

  		return this.at( t, optionalTarget );

  	},

  	intersectsPlane: function ( plane ) {

  		// check if the ray lies on the plane first

  		var distToPoint = plane.distanceToPoint( this.origin );

  		if ( distToPoint === 0 ) {

  			return true;

  		}

  		var denominator = plane.normal.dot( this.direction );

  		if ( denominator * distToPoint < 0 ) {

  			return true;

  		}

  		// ray origin is behind the plane (and is pointing behind it)

  		return false;

  	},

  	intersectBox: function ( box, optionalTarget ) {

  		var tmin, tmax, tymin, tymax, tzmin, tzmax;

  		var invdirx = 1 / this.direction.x,
  			invdiry = 1 / this.direction.y,
  			invdirz = 1 / this.direction.z;

  		var origin = this.origin;

  		if ( invdirx >= 0 ) {

  			tmin = ( box.min.x - origin.x ) * invdirx;
  			tmax = ( box.max.x - origin.x ) * invdirx;

  		} else {

  			tmin = ( box.max.x - origin.x ) * invdirx;
  			tmax = ( box.min.x - origin.x ) * invdirx;

  		}

  		if ( invdiry >= 0 ) {

  			tymin = ( box.min.y - origin.y ) * invdiry;
  			tymax = ( box.max.y - origin.y ) * invdiry;

  		} else {

  			tymin = ( box.max.y - origin.y ) * invdiry;
  			tymax = ( box.min.y - origin.y ) * invdiry;

  		}

  		if ( ( tmin > tymax ) || ( tymin > tmax ) ) { return null; }

  		// These lines also handle the case where tmin or tmax is NaN
  		// (result of 0 * Infinity). x !== x returns true if x is NaN

  		if ( tymin > tmin || tmin !== tmin ) { tmin = tymin; }

  		if ( tymax < tmax || tmax !== tmax ) { tmax = tymax; }

  		if ( invdirz >= 0 ) {

  			tzmin = ( box.min.z - origin.z ) * invdirz;
  			tzmax = ( box.max.z - origin.z ) * invdirz;

  		} else {

  			tzmin = ( box.max.z - origin.z ) * invdirz;
  			tzmax = ( box.min.z - origin.z ) * invdirz;

  		}

  		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) { return null; }

  		if ( tzmin > tmin || tmin !== tmin ) { tmin = tzmin; }

  		if ( tzmax < tmax || tmax !== tmax ) { tmax = tzmax; }

  		//return point closest to the ray (positive side)

  		if ( tmax < 0 ) { return null; }

  		return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

  	},

  	intersectsBox: ( function () {

  		var v = new Vector3$1();

  		return function intersectsBox( box ) {

  			return this.intersectBox( box, v ) !== null;

  		};

  	} )(),

  	intersectTriangle: function () {

  		// Compute the offset origin, edges, and normal.
  		var diff = new Vector3$1();
  		var edge1 = new Vector3$1();
  		var edge2 = new Vector3$1();
  		var normal = new Vector3$1();

  		return function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {

  			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

  			edge1.subVectors( b, a );
  			edge2.subVectors( c, a );
  			normal.crossVectors( edge1, edge2 );

  			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
  			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
  			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
  			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
  			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
  			var DdN = this.direction.dot( normal );
  			var sign;

  			if ( DdN > 0 ) {

  				if ( backfaceCulling ) { return null; }
  				sign = 1;

  			} else if ( DdN < 0 ) {

  				sign = - 1;
  				DdN = - DdN;

  			} else {

  				return null;

  			}

  			diff.subVectors( this.origin, a );
  			var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

  			// b1 < 0, no intersection
  			if ( DdQxE2 < 0 ) {

  				return null;

  			}

  			var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

  			// b2 < 0, no intersection
  			if ( DdE1xQ < 0 ) {

  				return null;

  			}

  			// b1+b2 > 1, no intersection
  			if ( DdQxE2 + DdE1xQ > DdN ) {

  				return null;

  			}

  			// Line intersects triangle, check if ray does.
  			var QdN = - sign * diff.dot( normal );

  			// t < 0, no intersection
  			if ( QdN < 0 ) {

  				return null;

  			}

  			// Ray intersects triangle.
  			return this.at( QdN / DdN, optionalTarget );

  		};

  	}(),

  	applyMatrix4: function ( matrix4 ) {

  		this.origin.applyMatrix4( matrix4 );
  		this.direction.transformDirection( matrix4 );

  		return this;

  	},

  	equals: function ( ray ) {

  		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

  	}

  } );

  /**
   * https://github.com/mrdoob/eventdispatcher.js/
   */

  function EventDispatcher() {}

  Object.assign( EventDispatcher.prototype, {

  	addEventListener: function ( type, listener ) {

  		if ( this._listeners === undefined ) { this._listeners = {}; }

  		var listeners = this._listeners;

  		if ( listeners[ type ] === undefined ) {

  			listeners[ type ] = [];

  		}

  		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

  			listeners[ type ].push( listener );

  		}

  	},

  	hasEventListener: function ( type, listener ) {

  		if ( this._listeners === undefined ) { return false; }

  		var listeners = this._listeners;

  		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

  	},

  	removeEventListener: function ( type, listener ) {

  		if ( this._listeners === undefined ) { return; }

  		var listeners = this._listeners;
  		var listenerArray = listeners[ type ];

  		if ( listenerArray !== undefined ) {

  			var index = listenerArray.indexOf( listener );

  			if ( index !== - 1 ) {

  				listenerArray.splice( index, 1 );

  			}

  		}

  	},

  	dispatchEvent: function ( event ) {
  		var this$1 = this;


  		if ( this._listeners === undefined ) { return; }

  		var listeners = this._listeners;
  		var listenerArray = listeners[ event.type ];

  		if ( listenerArray !== undefined ) {

  			event.target = this;

  			var array = listenerArray.slice( 0 );

  			for ( var i = 0, l = array.length; i < l; i ++ ) {

  				array[ i ].call( this$1, event );

  			}

  		}

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author WestLangley / http://github.com/WestLangley
   * @author bhouston / http://clara.io
   */

  function Euler( x, y, z, order ) {

  	this._x = x || 0;
  	this._y = y || 0;
  	this._z = z || 0;
  	this._order = order || Euler.DefaultOrder;

  }

  Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

  Euler.DefaultOrder = 'XYZ';

  Object.defineProperties( Euler.prototype, {

  	x: {

  		get: function () {

  			return this._x;

  		},

  		set: function ( value ) {

  			this._x = value;
  			this.onChangeCallback();

  		}

  	},

  	y: {

  		get: function () {

  			return this._y;

  		},

  		set: function ( value ) {

  			this._y = value;
  			this.onChangeCallback();

  		}

  	},

  	z: {

  		get: function () {

  			return this._z;

  		},

  		set: function ( value ) {

  			this._z = value;
  			this.onChangeCallback();

  		}

  	},

  	order: {

  		get: function () {

  			return this._order;

  		},

  		set: function ( value ) {

  			this._order = value;
  			this.onChangeCallback();

  		}

  	}

  } );

  Object.assign( Euler.prototype, {

  	isEuler: true,

  	set: function ( x, y, z, order ) {

  		this._x = x;
  		this._y = y;
  		this._z = z;
  		this._order = order || this._order;

  		this.onChangeCallback();

  		return this;

  	},

  	clone: function () {

  		return new this.constructor( this._x, this._y, this._z, this._order );

  	},

  	copy: function ( euler ) {

  		this._x = euler._x;
  		this._y = euler._y;
  		this._z = euler._z;
  		this._order = euler._order;

  		this.onChangeCallback();

  		return this;

  	},

  	setFromRotationMatrix: function ( m, order, update ) {

  		var clamp = _Math.clamp;

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		var te = m.elements;
  		var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
  		var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
  		var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

  		order = order || this._order;

  		if ( order === 'XYZ' ) {

  			this._y = Math.asin( clamp( m13, - 1, 1 ) );

  			if ( Math.abs( m13 ) < 0.99999 ) {

  				this._x = Math.atan2( - m23, m33 );
  				this._z = Math.atan2( - m12, m11 );

  			} else {

  				this._x = Math.atan2( m32, m22 );
  				this._z = 0;

  			}

  		} else if ( order === 'YXZ' ) {

  			this._x = Math.asin( - clamp( m23, - 1, 1 ) );

  			if ( Math.abs( m23 ) < 0.99999 ) {

  				this._y = Math.atan2( m13, m33 );
  				this._z = Math.atan2( m21, m22 );

  			} else {

  				this._y = Math.atan2( - m31, m11 );
  				this._z = 0;

  			}

  		} else if ( order === 'ZXY' ) {

  			this._x = Math.asin( clamp( m32, - 1, 1 ) );

  			if ( Math.abs( m32 ) < 0.99999 ) {

  				this._y = Math.atan2( - m31, m33 );
  				this._z = Math.atan2( - m12, m22 );

  			} else {

  				this._y = 0;
  				this._z = Math.atan2( m21, m11 );

  			}

  		} else if ( order === 'ZYX' ) {

  			this._y = Math.asin( - clamp( m31, - 1, 1 ) );

  			if ( Math.abs( m31 ) < 0.99999 ) {

  				this._x = Math.atan2( m32, m33 );
  				this._z = Math.atan2( m21, m11 );

  			} else {

  				this._x = 0;
  				this._z = Math.atan2( - m12, m22 );

  			}

  		} else if ( order === 'YZX' ) {

  			this._z = Math.asin( clamp( m21, - 1, 1 ) );

  			if ( Math.abs( m21 ) < 0.99999 ) {

  				this._x = Math.atan2( - m23, m22 );
  				this._y = Math.atan2( - m31, m11 );

  			} else {

  				this._x = 0;
  				this._y = Math.atan2( m13, m33 );

  			}

  		} else if ( order === 'XZY' ) {

  			this._z = Math.asin( - clamp( m12, - 1, 1 ) );

  			if ( Math.abs( m12 ) < 0.99999 ) {

  				this._x = Math.atan2( m32, m22 );
  				this._y = Math.atan2( m13, m11 );

  			} else {

  				this._x = Math.atan2( - m23, m33 );
  				this._y = 0;

  			}

  		} else {

  			console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );

  		}

  		this._order = order;

  		if ( update !== false ) { this.onChangeCallback(); }

  		return this;

  	},

  	setFromQuaternion: function () {

  		var matrix = new Matrix4();

  		return function setFromQuaternion( q, order, update ) {

  			matrix.makeRotationFromQuaternion( q );

  			return this.setFromRotationMatrix( matrix, order, update );

  		};

  	}(),

  	setFromVector3: function ( v, order ) {

  		return this.set( v.x, v.y, v.z, order || this._order );

  	},

  	reorder: function () {

  		// WARNING: this discards revolution information -bhouston

  		var q = new Quaternion();

  		return function reorder( newOrder ) {

  			q.setFromEuler( this );

  			return this.setFromQuaternion( q, newOrder );

  		};

  	}(),

  	equals: function ( euler ) {

  		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

  	},

  	fromArray: function ( array ) {

  		this._x = array[ 0 ];
  		this._y = array[ 1 ];
  		this._z = array[ 2 ];
  		if ( array[ 3 ] !== undefined ) { this._order = array[ 3 ]; }

  		this.onChangeCallback();

  		return this;

  	},

  	toArray: function ( array, offset ) {

  		if ( array === undefined ) { array = []; }
  		if ( offset === undefined ) { offset = 0; }

  		array[ offset ] = this._x;
  		array[ offset + 1 ] = this._y;
  		array[ offset + 2 ] = this._z;
  		array[ offset + 3 ] = this._order;

  		return array;

  	},

  	toVector3: function ( optionalResult ) {

  		if ( optionalResult ) {

  			return optionalResult.set( this._x, this._y, this._z );

  		} else {

  			return new Vector3$1( this._x, this._y, this._z );

  		}

  	},

  	onChange: function ( callback ) {

  		this.onChangeCallback = callback;

  		return this;

  	},

  	onChangeCallback: function () {}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function Layers() {

  	this.mask = 1 | 0;

  }

  Object.assign( Layers.prototype, {

  	set: function ( channel ) {

  		this.mask = 1 << channel | 0;

  	},

  	enable: function ( channel ) {

  		this.mask |= 1 << channel | 0;

  	},

  	toggle: function ( channel ) {

  		this.mask ^= 1 << channel | 0;

  	},

  	disable: function ( channel ) {

  		this.mask &= ~ ( 1 << channel | 0 );

  	},

  	test: function ( layers ) {

  		return ( this.mask & layers.mask ) !== 0;

  	}

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author WestLangley / http://github.com/WestLangley
   * @author bhouston / http://clara.io
   * @author tschw
   */

  function Matrix3() {

  	this.elements = [

  		1, 0, 0,
  		0, 1, 0,
  		0, 0, 1

  	];

  	if ( arguments.length > 0 ) {

  		console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

  	}

  }

  Object.assign( Matrix3.prototype, {

  	isMatrix3: true,

  	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

  		var te = this.elements;

  		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
  		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
  		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

  		return this;

  	},

  	identity: function () {

  		this.set(

  			1, 0, 0,
  			0, 1, 0,
  			0, 0, 1

  		);

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().fromArray( this.elements );

  	},

  	copy: function ( m ) {

  		var te = this.elements;
  		var me = m.elements;

  		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
  		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
  		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

  		return this;

  	},

  	setFromMatrix4: function ( m ) {

  		var me = m.elements;

  		this.set(

  			me[ 0 ], me[ 4 ], me[ 8 ],
  			me[ 1 ], me[ 5 ], me[ 9 ],
  			me[ 2 ], me[ 6 ], me[ 10 ]

  		);

  		return this;

  	},

  	applyToBufferAttribute: function () {

  		var v1 = new Vector3$1();

  		return function applyToBufferAttribute( attribute ) {
  			var this$1 = this;


  			for ( var i = 0, l = attribute.count; i < l; i ++ ) {

  				v1.x = attribute.getX( i );
  				v1.y = attribute.getY( i );
  				v1.z = attribute.getZ( i );

  				v1.applyMatrix3( this$1 );

  				attribute.setXYZ( i, v1.x, v1.y, v1.z );

  			}

  			return attribute;

  		};

  	}(),

  	multiply: function ( m ) {

  		return this.multiplyMatrices( this, m );

  	},

  	premultiply: function ( m ) {

  		return this.multiplyMatrices( m, this );

  	},

  	multiplyMatrices: function ( a, b ) {

  		var ae = a.elements;
  		var be = b.elements;
  		var te = this.elements;

  		var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
  		var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
  		var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

  		var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
  		var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
  		var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

  		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
  		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
  		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

  		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
  		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
  		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

  		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
  		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
  		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

  		return this;

  	},

  	multiplyScalar: function ( s ) {

  		var te = this.elements;

  		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
  		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
  		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

  		return this;

  	},

  	determinant: function () {

  		var te = this.elements;

  		var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
  			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
  			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

  		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

  	},

  	getInverse: function ( matrix, throwOnDegenerate ) {

  		if ( matrix && matrix.isMatrix4 ) {

  			console.error( "THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument." );

  		}

  		var me = matrix.elements,
  			te = this.elements,

  			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
  			n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
  			n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

  			t11 = n33 * n22 - n32 * n23,
  			t12 = n32 * n13 - n33 * n12,
  			t13 = n23 * n12 - n22 * n13,

  			det = n11 * t11 + n21 * t12 + n31 * t13;

  		if ( det === 0 ) {

  			var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";

  			if ( throwOnDegenerate === true ) {

  				throw new Error( msg );

  			} else {

  				console.warn( msg );

  			}

  			return this.identity();

  		}

  		var detInv = 1 / det;

  		te[ 0 ] = t11 * detInv;
  		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
  		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

  		te[ 3 ] = t12 * detInv;
  		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
  		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

  		te[ 6 ] = t13 * detInv;
  		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
  		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

  		return this;

  	},

  	transpose: function () {

  		var tmp, m = this.elements;

  		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
  		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
  		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

  		return this;

  	},

  	getNormalMatrix: function ( matrix4 ) {

  		return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

  	},

  	transposeIntoArray: function ( r ) {

  		var m = this.elements;

  		r[ 0 ] = m[ 0 ];
  		r[ 1 ] = m[ 3 ];
  		r[ 2 ] = m[ 6 ];
  		r[ 3 ] = m[ 1 ];
  		r[ 4 ] = m[ 4 ];
  		r[ 5 ] = m[ 7 ];
  		r[ 6 ] = m[ 2 ];
  		r[ 7 ] = m[ 5 ];
  		r[ 8 ] = m[ 8 ];

  		return this;

  	},

  	setUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {

  		var c = Math.cos( rotation );
  		var s = Math.sin( rotation );

  		this.set(
  			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
  			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
  			0, 0, 1
  		);

  	},

  	scale: function ( sx, sy ) {

  		var te = this.elements;

  		te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
  		te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

  		return this;

  	},

  	rotate: function ( theta ) {

  		var c = Math.cos( theta );
  		var s = Math.sin( theta );

  		var te = this.elements;

  		var a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
  		var a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

  		te[ 0 ] = c * a11 + s * a21;
  		te[ 3 ] = c * a12 + s * a22;
  		te[ 6 ] = c * a13 + s * a23;

  		te[ 1 ] = - s * a11 + c * a21;
  		te[ 4 ] = - s * a12 + c * a22;
  		te[ 7 ] = - s * a13 + c * a23;

  		return this;

  	},

  	translate: function ( tx, ty ) {

  		var te = this.elements;

  		te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
  		te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

  		return this;

  	},

  	equals: function ( matrix ) {

  		var te = this.elements;
  		var me = matrix.elements;

  		for ( var i = 0; i < 9; i ++ ) {

  			if ( te[ i ] !== me[ i ] ) { return false; }

  		}

  		return true;

  	},

  	fromArray: function ( array, offset ) {
  		var this$1 = this;


  		if ( offset === undefined ) { offset = 0; }

  		for ( var i = 0; i < 9; i ++ ) {

  			this$1.elements[ i ] = array[ i + offset ];

  		}

  		return this;

  	},

  	toArray: function ( array, offset ) {

  		if ( array === undefined ) { array = []; }
  		if ( offset === undefined ) { offset = 0; }

  		var te = this.elements;

  		array[ offset ] = te[ 0 ];
  		array[ offset + 1 ] = te[ 1 ];
  		array[ offset + 2 ] = te[ 2 ];

  		array[ offset + 3 ] = te[ 3 ];
  		array[ offset + 4 ] = te[ 4 ];
  		array[ offset + 5 ] = te[ 5 ];

  		array[ offset + 6 ] = te[ 6 ];
  		array[ offset + 7 ] = te[ 7 ];
  		array[ offset + 8 ] = te[ 8 ];

  		return array;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author WestLangley / http://github.com/WestLangley
   * @author elephantatwork / www.elephantatwork.ch
   */

  var object3DId = 0;

  function Object3D() {

  	Object.defineProperty( this, 'id', { value: object3DId ++ } );

  	this.uuid = _Math.generateUUID();

  	this.name = '';
  	this.type = 'Object3D';

  	this.parent = null;
  	this.children = [];

  	this.up = Object3D.DefaultUp.clone();

  	var position = new Vector3$1();
  	var rotation = new Euler();
  	var quaternion = new Quaternion();
  	var scale = new Vector3$1( 1, 1, 1 );

  	function onRotationChange() {

  		quaternion.setFromEuler( rotation, false );

  	}

  	function onQuaternionChange() {

  		rotation.setFromQuaternion( quaternion, undefined, false );

  	}

  	rotation.onChange( onRotationChange );
  	quaternion.onChange( onQuaternionChange );

  	Object.defineProperties( this, {
  		position: {
  			enumerable: true,
  			value: position
  		},
  		rotation: {
  			enumerable: true,
  			value: rotation
  		},
  		quaternion: {
  			enumerable: true,
  			value: quaternion
  		},
  		scale: {
  			enumerable: true,
  			value: scale
  		},
  		modelViewMatrix: {
  			value: new Matrix4()
  		},
  		normalMatrix: {
  			value: new Matrix3()
  		}
  	} );

  	this.matrix = new Matrix4();
  	this.matrixWorld = new Matrix4();

  	this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
  	this.matrixWorldNeedsUpdate = false;

  	this.layers = new Layers();
  	this.visible = true;

  	this.castShadow = false;
  	this.receiveShadow = false;

  	this.frustumCulled = true;
  	this.renderOrder = 0;

  	this.userData = {};

  }

  Object3D.DefaultUp = new Vector3$1( 0, 1, 0 );
  Object3D.DefaultMatrixAutoUpdate = true;

  Object.assign( Object3D.prototype, EventDispatcher.prototype, {

  	isObject3D: true,

  	onBeforeRender: function () {},
  	onAfterRender: function () {},

  	applyMatrix: function ( matrix ) {

  		this.matrix.multiplyMatrices( matrix, this.matrix );

  		this.matrix.decompose( this.position, this.quaternion, this.scale );

  	},

  	applyQuaternion: function ( q ) {

  		this.quaternion.premultiply( q );

  		return this;

  	},

  	setRotationFromAxisAngle: function ( axis, angle ) {

  		// assumes axis is normalized

  		this.quaternion.setFromAxisAngle( axis, angle );

  	},

  	setRotationFromEuler: function ( euler ) {

  		this.quaternion.setFromEuler( euler, true );

  	},

  	setRotationFromMatrix: function ( m ) {

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		this.quaternion.setFromRotationMatrix( m );

  	},

  	setRotationFromQuaternion: function ( q ) {

  		// assumes q is normalized

  		this.quaternion.copy( q );

  	},

  	rotateOnAxis: function () {

  		// rotate object on axis in object space
  		// axis is assumed to be normalized

  		var q1 = new Quaternion();

  		return function rotateOnAxis( axis, angle ) {

  			q1.setFromAxisAngle( axis, angle );

  			this.quaternion.multiply( q1 );

  			return this;

  		};

  	}(),

  	rotateX: function () {

  		var v1 = new Vector3$1( 1, 0, 0 );

  		return function rotateX( angle ) {

  			return this.rotateOnAxis( v1, angle );

  		};

  	}(),

  	rotateY: function () {

  		var v1 = new Vector3$1( 0, 1, 0 );

  		return function rotateY( angle ) {

  			return this.rotateOnAxis( v1, angle );

  		};

  	}(),

  	rotateZ: function () {

  		var v1 = new Vector3$1( 0, 0, 1 );

  		return function rotateZ( angle ) {

  			return this.rotateOnAxis( v1, angle );

  		};

  	}(),

  	translateOnAxis: function () {

  		// translate object by distance along axis in object space
  		// axis is assumed to be normalized

  		var v1 = new Vector3$1();

  		return function translateOnAxis( axis, distance ) {

  			v1.copy( axis ).applyQuaternion( this.quaternion );

  			this.position.add( v1.multiplyScalar( distance ) );

  			return this;

  		};

  	}(),

  	translateX: function () {

  		var v1 = new Vector3$1( 1, 0, 0 );

  		return function translateX( distance ) {

  			return this.translateOnAxis( v1, distance );

  		};

  	}(),

  	translateY: function () {

  		var v1 = new Vector3$1( 0, 1, 0 );

  		return function translateY( distance ) {

  			return this.translateOnAxis( v1, distance );

  		};

  	}(),

  	translateZ: function () {

  		var v1 = new Vector3$1( 0, 0, 1 );

  		return function translateZ( distance ) {

  			return this.translateOnAxis( v1, distance );

  		};

  	}(),

  	localToWorld: function ( vector ) {

  		return vector.applyMatrix4( this.matrixWorld );

  	},

  	worldToLocal: function () {

  		var m1 = new Matrix4();

  		return function worldToLocal( vector ) {

  			return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

  		};

  	}(),

  	lookAt: function () {

  		// This method does not support objects with rotated and/or translated parent(s)

  		var m1 = new Matrix4();
  		var vector = new Vector3$1();

  		return function lookAt( x, y, z ) {

  			if ( x.isVector3 ) {

  				vector.copy( x );

  			} else {

  				vector.set( x, y, z );

  			}

  			if ( this.isCamera ) {

  				m1.lookAt( this.position, vector, this.up );

  			} else {

  				m1.lookAt( vector, this.position, this.up );

  			}

  			this.quaternion.setFromRotationMatrix( m1 );

  		};

  	}(),

  	add: function ( object ) {
  		var arguments$1 = arguments;
  		var this$1 = this;


  		if ( arguments.length > 1 ) {

  			for ( var i = 0; i < arguments.length; i ++ ) {

  				this$1.add( arguments$1[ i ] );

  			}

  			return this;

  		}

  		if ( object === this ) {

  			console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
  			return this;

  		}

  		if ( ( object && object.isObject3D ) ) {

  			if ( object.parent !== null ) {

  				object.parent.remove( object );

  			}

  			object.parent = this;
  			object.dispatchEvent( { type: 'added' } );

  			this.children.push( object );

  		} else {

  			console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

  		}

  		return this;

  	},

  	remove: function ( object ) {
  		var arguments$1 = arguments;
  		var this$1 = this;


  		if ( arguments.length > 1 ) {

  			for ( var i = 0; i < arguments.length; i ++ ) {

  				this$1.remove( arguments$1[ i ] );

  			}

  			return this;

  		}

  		var index = this.children.indexOf( object );

  		if ( index !== - 1 ) {

  			object.parent = null;

  			object.dispatchEvent( { type: 'removed' } );

  			this.children.splice( index, 1 );

  		}

  		return this;

  	},

  	getObjectById: function ( id ) {

  		return this.getObjectByProperty( 'id', id );

  	},

  	getObjectByName: function ( name ) {

  		return this.getObjectByProperty( 'name', name );

  	},

  	getObjectByProperty: function ( name, value ) {
  		var this$1 = this;


  		if ( this[ name ] === value ) { return this; }

  		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

  			var child = this$1.children[ i ];
  			var object = child.getObjectByProperty( name, value );

  			if ( object !== undefined ) {

  				return object;

  			}

  		}

  		return undefined;

  	},

  	getWorldPosition: function ( optionalTarget ) {

  		var result = optionalTarget || new Vector3$1();

  		this.updateMatrixWorld( true );

  		return result.setFromMatrixPosition( this.matrixWorld );

  	},

  	getWorldQuaternion: function () {

  		var position = new Vector3$1();
  		var scale = new Vector3$1();

  		return function getWorldQuaternion( optionalTarget ) {

  			var result = optionalTarget || new Quaternion();

  			this.updateMatrixWorld( true );

  			this.matrixWorld.decompose( position, result, scale );

  			return result;

  		};

  	}(),

  	getWorldRotation: function () {

  		var quaternion = new Quaternion();

  		return function getWorldRotation( optionalTarget ) {

  			var result = optionalTarget || new Euler();

  			this.getWorldQuaternion( quaternion );

  			return result.setFromQuaternion( quaternion, this.rotation.order, false );

  		};

  	}(),

  	getWorldScale: function () {

  		var position = new Vector3$1();
  		var quaternion = new Quaternion();

  		return function getWorldScale( optionalTarget ) {

  			var result = optionalTarget || new Vector3$1();

  			this.updateMatrixWorld( true );

  			this.matrixWorld.decompose( position, quaternion, result );

  			return result;

  		};

  	}(),

  	getWorldDirection: function () {

  		var quaternion = new Quaternion();

  		return function getWorldDirection( optionalTarget ) {

  			var result = optionalTarget || new Vector3$1();

  			this.getWorldQuaternion( quaternion );

  			return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

  		};

  	}(),

  	raycast: function () {},

  	traverse: function ( callback ) {

  		callback( this );

  		var children = this.children;

  		for ( var i = 0, l = children.length; i < l; i ++ ) {

  			children[ i ].traverse( callback );

  		}

  	},

  	traverseVisible: function ( callback ) {

  		if ( this.visible === false ) { return; }

  		callback( this );

  		var children = this.children;

  		for ( var i = 0, l = children.length; i < l; i ++ ) {

  			children[ i ].traverseVisible( callback );

  		}

  	},

  	traverseAncestors: function ( callback ) {

  		var parent = this.parent;

  		if ( parent !== null ) {

  			callback( parent );

  			parent.traverseAncestors( callback );

  		}

  	},

  	updateMatrix: function () {

  		this.matrix.compose( this.position, this.quaternion, this.scale );

  		this.matrixWorldNeedsUpdate = true;

  	},

  	updateMatrixWorld: function ( force ) {

  		if ( this.matrixAutoUpdate ) { this.updateMatrix(); }

  		if ( this.matrixWorldNeedsUpdate || force ) {

  			if ( this.parent === null ) {

  				this.matrixWorld.copy( this.matrix );

  			} else {

  				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

  			}

  			this.matrixWorldNeedsUpdate = false;

  			force = true;

  		}

  		// update children

  		var children = this.children;

  		for ( var i = 0, l = children.length; i < l; i ++ ) {

  			children[ i ].updateMatrixWorld( force );

  		}

  	},

  	toJSON: function ( meta ) {
  		var this$1 = this;


  		// meta is '' when called from JSON.stringify
  		var isRootObject = ( meta === undefined || meta === '' );

  		var output = {};

  		// meta is a hash used to collect geometries, materials.
  		// not providing it implies that this is the root object
  		// being serialized.
  		if ( isRootObject ) {

  			// initialize meta obj
  			meta = {
  				geometries: {},
  				materials: {},
  				textures: {},
  				images: {}
  			};

  			output.metadata = {
  				version: 4.5,
  				type: 'Object',
  				generator: 'Object3D.toJSON'
  			};

  		}

  		// standard Object3D serialization

  		var object = {};

  		object.uuid = this.uuid;
  		object.type = this.type;

  		if ( this.name !== '' ) { object.name = this.name; }
  		if ( this.castShadow === true ) { object.castShadow = true; }
  		if ( this.receiveShadow === true ) { object.receiveShadow = true; }
  		if ( this.visible === false ) { object.visible = false; }
  		if ( JSON.stringify( this.userData ) !== '{}' ) { object.userData = this.userData; }

  		object.matrix = this.matrix.toArray();

  		//

  		function serialize( library, element ) {

  			if ( library[ element.uuid ] === undefined ) {

  				library[ element.uuid ] = element.toJSON( meta );

  			}

  			return element.uuid;

  		}

  		if ( this.geometry !== undefined ) {

  			object.geometry = serialize( meta.geometries, this.geometry );

  		}

  		if ( this.material !== undefined ) {

  			if ( Array.isArray( this.material ) ) {

  				var uuids = [];

  				for ( var i = 0, l = this.material.length; i < l; i ++ ) {

  					uuids.push( serialize( meta.materials, this$1.material[ i ] ) );

  				}

  				object.material = uuids;

  			} else {

  				object.material = serialize( meta.materials, this.material );

  			}

  		}

  		//

  		if ( this.children.length > 0 ) {

  			object.children = [];

  			for ( var i = 0; i < this.children.length; i ++ ) {

  				object.children.push( this$1.children[ i ].toJSON( meta ).object );

  			}

  		}

  		if ( isRootObject ) {

  			var geometries = extractFromCache( meta.geometries );
  			var materials = extractFromCache( meta.materials );
  			var textures = extractFromCache( meta.textures );
  			var images = extractFromCache( meta.images );

  			if ( geometries.length > 0 ) { output.geometries = geometries; }
  			if ( materials.length > 0 ) { output.materials = materials; }
  			if ( textures.length > 0 ) { output.textures = textures; }
  			if ( images.length > 0 ) { output.images = images; }

  		}

  		output.object = object;

  		return output;

  		// extract data from the cache hash
  		// remove metadata on each item
  		// and return as array
  		function extractFromCache( cache ) {

  			var values = [];
  			for ( var key in cache ) {

  				var data = cache[ key ];
  				delete data.metadata;
  				values.push( data );

  			}
  			return values;

  		}

  	},

  	clone: function ( recursive ) {

  		return new this.constructor().copy( this, recursive );

  	},

  	copy: function ( source, recursive ) {
  		var this$1 = this;


  		if ( recursive === undefined ) { recursive = true; }

  		this.name = source.name;

  		this.up.copy( source.up );

  		this.position.copy( source.position );
  		this.quaternion.copy( source.quaternion );
  		this.scale.copy( source.scale );

  		this.matrix.copy( source.matrix );
  		this.matrixWorld.copy( source.matrixWorld );

  		this.matrixAutoUpdate = source.matrixAutoUpdate;
  		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

  		this.layers.mask = source.layers.mask;
  		this.visible = source.visible;

  		this.castShadow = source.castShadow;
  		this.receiveShadow = source.receiveShadow;

  		this.frustumCulled = source.frustumCulled;
  		this.renderOrder = source.renderOrder;

  		this.userData = JSON.parse( JSON.stringify( source.userData ) );

  		if ( recursive === true ) {

  			for ( var i = 0; i < source.children.length; i ++ ) {

  				var child = source.children[ i ];
  				this$1.add( child.clone() );

  			}

  		}

  		return this;

  	}

  } );

  /**
   * @author bhouston / http://clara.io
   */

  function Line3( start, end ) {

  	this.start = ( start !== undefined ) ? start : new Vector3$1();
  	this.end = ( end !== undefined ) ? end : new Vector3$1();

  }

  Object.assign( Line3.prototype, {

  	set: function ( start, end ) {

  		this.start.copy( start );
  		this.end.copy( end );

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( line ) {

  		this.start.copy( line.start );
  		this.end.copy( line.end );

  		return this;

  	},

  	getCenter: function ( optionalTarget ) {

  		var result = optionalTarget || new Vector3$1();
  		return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

  	},

  	delta: function ( optionalTarget ) {

  		var result = optionalTarget || new Vector3$1();
  		return result.subVectors( this.end, this.start );

  	},

  	distanceSq: function () {

  		return this.start.distanceToSquared( this.end );

  	},

  	distance: function () {

  		return this.start.distanceTo( this.end );

  	},

  	at: function ( t, optionalTarget ) {

  		var result = optionalTarget || new Vector3$1();

  		return this.delta( result ).multiplyScalar( t ).add( this.start );

  	},

  	closestPointToPointParameter: function () {

  		var startP = new Vector3$1();
  		var startEnd = new Vector3$1();

  		return function closestPointToPointParameter( point, clampToLine ) {

  			startP.subVectors( point, this.start );
  			startEnd.subVectors( this.end, this.start );

  			var startEnd2 = startEnd.dot( startEnd );
  			var startEnd_startP = startEnd.dot( startP );

  			var t = startEnd_startP / startEnd2;

  			if ( clampToLine ) {

  				t = _Math.clamp( t, 0, 1 );

  			}

  			return t;

  		};

  	}(),

  	closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

  		var t = this.closestPointToPointParameter( point, clampToLine );

  		var result = optionalTarget || new Vector3$1();

  		return this.delta( result ).multiplyScalar( t ).add( this.start );

  	},

  	applyMatrix4: function ( matrix ) {

  		this.start.applyMatrix4( matrix );
  		this.end.applyMatrix4( matrix );

  		return this;

  	},

  	equals: function ( line ) {

  		return line.start.equals( this.start ) && line.end.equals( this.end );

  	}

  } );

  /**
   * @author bhouston / http://clara.io
   */

  function Plane( normal, constant ) {

  	// normal is assumed to be normalized

  	this.normal = ( normal !== undefined ) ? normal : new Vector3$1( 1, 0, 0 );
  	this.constant = ( constant !== undefined ) ? constant : 0;

  }

  Object.assign( Plane.prototype, {

  	set: function ( normal, constant ) {

  		this.normal.copy( normal );
  		this.constant = constant;

  		return this;

  	},

  	setComponents: function ( x, y, z, w ) {

  		this.normal.set( x, y, z );
  		this.constant = w;

  		return this;

  	},

  	setFromNormalAndCoplanarPoint: function ( normal, point ) {

  		this.normal.copy( normal );
  		this.constant = - point.dot( this.normal );

  		return this;

  	},

  	setFromCoplanarPoints: function () {

  		var v1 = new Vector3$1();
  		var v2 = new Vector3$1();

  		return function setFromCoplanarPoints( a, b, c ) {

  			var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

  			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

  			this.setFromNormalAndCoplanarPoint( normal, a );

  			return this;

  		};

  	}(),

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( plane ) {

  		this.normal.copy( plane.normal );
  		this.constant = plane.constant;

  		return this;

  	},

  	normalize: function () {

  		// Note: will lead to a divide by zero if the plane is invalid.

  		var inverseNormalLength = 1.0 / this.normal.length();
  		this.normal.multiplyScalar( inverseNormalLength );
  		this.constant *= inverseNormalLength;

  		return this;

  	},

  	negate: function () {

  		this.constant *= - 1;
  		this.normal.negate();

  		return this;

  	},

  	distanceToPoint: function ( point ) {

  		return this.normal.dot( point ) + this.constant;

  	},

  	distanceToSphere: function ( sphere ) {

  		return this.distanceToPoint( sphere.center ) - sphere.radius;

  	},

  	projectPoint: function ( point, optionalTarget ) {

  		var result = optionalTarget || new Vector3$1();

  		return result.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

  	},

  	intersectLine: function () {

  		var v1 = new Vector3$1();

  		return function intersectLine( line, optionalTarget ) {

  			var result = optionalTarget || new Vector3$1();

  			var direction = line.delta( v1 );

  			var denominator = this.normal.dot( direction );

  			if ( denominator === 0 ) {

  				// line is coplanar, return origin
  				if ( this.distanceToPoint( line.start ) === 0 ) {

  					return result.copy( line.start );

  				}

  				// Unsure if this is the correct method to handle this case.
  				return undefined;

  			}

  			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

  			if ( t < 0 || t > 1 ) {

  				return undefined;

  			}

  			return result.copy( direction ).multiplyScalar( t ).add( line.start );

  		};

  	}(),

  	intersectsLine: function ( line ) {

  		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

  		var startSign = this.distanceToPoint( line.start );
  		var endSign = this.distanceToPoint( line.end );

  		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

  	},

  	intersectsBox: function ( box ) {

  		return box.intersectsPlane( this );

  	},

  	intersectsSphere: function ( sphere ) {

  		return sphere.intersectsPlane( this );

  	},

  	coplanarPoint: function ( optionalTarget ) {

  		var result = optionalTarget || new Vector3$1();

  		return result.copy( this.normal ).multiplyScalar( - this.constant );

  	},

  	applyMatrix4: function () {

  		var v1 = new Vector3$1();
  		var m1 = new Matrix3();

  		return function applyMatrix4( matrix, optionalNormalMatrix ) {

  			var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );

  			var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );

  			var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

  			this.constant = - referencePoint.dot( normal );

  			return this;

  		};

  	}(),

  	translate: function ( offset ) {

  		this.constant -= offset.dot( this.normal );

  		return this;

  	},

  	equals: function ( plane ) {

  		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

  	}

  } );

  /**
   * @author bhouston / http://clara.io
   * @author mrdoob / http://mrdoob.com/
   */

  function Triangle( a, b, c ) {

  	this.a = ( a !== undefined ) ? a : new Vector3$1();
  	this.b = ( b !== undefined ) ? b : new Vector3$1();
  	this.c = ( c !== undefined ) ? c : new Vector3$1();

  }

  Object.assign( Triangle, {

  	normal: function () {

  		var v0 = new Vector3$1();

  		return function normal( a, b, c, optionalTarget ) {

  			var result = optionalTarget || new Vector3$1();

  			result.subVectors( c, b );
  			v0.subVectors( a, b );
  			result.cross( v0 );

  			var resultLengthSq = result.lengthSq();
  			if ( resultLengthSq > 0 ) {

  				return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

  			}

  			return result.set( 0, 0, 0 );

  		};

  	}(),

  	// static/instance method to calculate barycentric coordinates
  	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  	barycoordFromPoint: function () {

  		var v0 = new Vector3$1();
  		var v1 = new Vector3$1();
  		var v2 = new Vector3$1();

  		return function barycoordFromPoint( point, a, b, c, optionalTarget ) {

  			v0.subVectors( c, a );
  			v1.subVectors( b, a );
  			v2.subVectors( point, a );

  			var dot00 = v0.dot( v0 );
  			var dot01 = v0.dot( v1 );
  			var dot02 = v0.dot( v2 );
  			var dot11 = v1.dot( v1 );
  			var dot12 = v1.dot( v2 );

  			var denom = ( dot00 * dot11 - dot01 * dot01 );

  			var result = optionalTarget || new Vector3$1();

  			// collinear or singular triangle
  			if ( denom === 0 ) {

  				// arbitrary location outside of triangle?
  				// not sure if this is the best idea, maybe should be returning undefined
  				return result.set( - 2, - 1, - 1 );

  			}

  			var invDenom = 1 / denom;
  			var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
  			var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

  			// barycentric coordinates must always sum to 1
  			return result.set( 1 - u - v, v, u );

  		};

  	}(),

  	containsPoint: function () {

  		var v1 = new Vector3$1();

  		return function containsPoint( point, a, b, c ) {

  			var result = Triangle.barycoordFromPoint( point, a, b, c, v1 );

  			return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

  		};

  	}()

  } );

  Object.assign( Triangle.prototype, {

  	set: function ( a, b, c ) {

  		this.a.copy( a );
  		this.b.copy( b );
  		this.c.copy( c );

  		return this;

  	},

  	setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

  		this.a.copy( points[ i0 ] );
  		this.b.copy( points[ i1 ] );
  		this.c.copy( points[ i2 ] );

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( triangle ) {

  		this.a.copy( triangle.a );
  		this.b.copy( triangle.b );
  		this.c.copy( triangle.c );

  		return this;

  	},

  	area: function () {

  		var v0 = new Vector3$1();
  		var v1 = new Vector3$1();

  		return function area() {

  			v0.subVectors( this.c, this.b );
  			v1.subVectors( this.a, this.b );

  			return v0.cross( v1 ).length() * 0.5;

  		};

  	}(),

  	midpoint: function ( optionalTarget ) {

  		var result = optionalTarget || new Vector3$1();
  		return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

  	},

  	normal: function ( optionalTarget ) {

  		return Triangle.normal( this.a, this.b, this.c, optionalTarget );

  	},

  	plane: function ( optionalTarget ) {

  		var result = optionalTarget || new Plane();

  		return result.setFromCoplanarPoints( this.a, this.b, this.c );

  	},

  	barycoordFromPoint: function ( point, optionalTarget ) {

  		return Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

  	},

  	containsPoint: function ( point ) {

  		return Triangle.containsPoint( point, this.a, this.b, this.c );

  	},

  	closestPointToPoint: function () {

  		var plane = new Plane();
  		var edgeList = [ new Line3(), new Line3(), new Line3() ];
  		var projectedPoint = new Vector3$1();
  		var closestPoint = new Vector3$1();

  		return function closestPointToPoint( point, optionalTarget ) {

  			var result = optionalTarget || new Vector3$1();
  			var minDistance = Infinity;

  			// project the point onto the plane of the triangle

  			plane.setFromCoplanarPoints( this.a, this.b, this.c );
  			plane.projectPoint( point, projectedPoint );

  			// check if the projection lies within the triangle

  			if ( this.containsPoint( projectedPoint ) === true ) {

  				// if so, this is the closest point

  				result.copy( projectedPoint );

  			} else {

  				// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices

  				edgeList[ 0 ].set( this.a, this.b );
  				edgeList[ 1 ].set( this.b, this.c );
  				edgeList[ 2 ].set( this.c, this.a );

  				for ( var i = 0; i < edgeList.length; i ++ ) {

  					edgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );

  					var distance = projectedPoint.distanceToSquared( closestPoint );

  					if ( distance < minDistance ) {

  						minDistance = distance;

  						result.copy( closestPoint );

  					}

  				}

  			}

  			return result;

  		};

  	}(),

  	equals: function ( triangle ) {

  		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
  	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
  	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
  	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
  	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
  	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
  	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
  	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
  	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
  	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
  	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
  	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
  	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
  	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
  	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
  	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
  	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
  	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
  	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
  	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
  	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
  	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
  	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
  	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

  function Color( r, g, b ) {

  	if ( g === undefined && b === undefined ) {

  		// r is THREE.Color, hex or string
  		return this.set( r );

  	}

  	return this.setRGB( r, g, b );

  }

  Object.assign( Color.prototype, {

  	isColor: true,

  	r: 1, g: 1, b: 1,

  	set: function ( value ) {

  		if ( value && value.isColor ) {

  			this.copy( value );

  		} else if ( typeof value === 'number' ) {

  			this.setHex( value );

  		} else if ( typeof value === 'string' ) {

  			this.setStyle( value );

  		}

  		return this;

  	},

  	setScalar: function ( scalar ) {

  		this.r = scalar;
  		this.g = scalar;
  		this.b = scalar;

  		return this;

  	},

  	setHex: function ( hex ) {

  		hex = Math.floor( hex );

  		this.r = ( hex >> 16 & 255 ) / 255;
  		this.g = ( hex >> 8 & 255 ) / 255;
  		this.b = ( hex & 255 ) / 255;

  		return this;

  	},

  	setRGB: function ( r, g, b ) {

  		this.r = r;
  		this.g = g;
  		this.b = b;

  		return this;

  	},

  	setHSL: function () {

  		function hue2rgb( p, q, t ) {

  			if ( t < 0 ) { t += 1; }
  			if ( t > 1 ) { t -= 1; }
  			if ( t < 1 / 6 ) { return p + ( q - p ) * 6 * t; }
  			if ( t < 1 / 2 ) { return q; }
  			if ( t < 2 / 3 ) { return p + ( q - p ) * 6 * ( 2 / 3 - t ); }
  			return p;

  		}

  		return function setHSL( h, s, l ) {

  			// h,s,l ranges are in 0.0 - 1.0
  			h = _Math.euclideanModulo( h, 1 );
  			s = _Math.clamp( s, 0, 1 );
  			l = _Math.clamp( l, 0, 1 );

  			if ( s === 0 ) {

  				this.r = this.g = this.b = l;

  			} else {

  				var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
  				var q = ( 2 * l ) - p;

  				this.r = hue2rgb( q, p, h + 1 / 3 );
  				this.g = hue2rgb( q, p, h );
  				this.b = hue2rgb( q, p, h - 1 / 3 );

  			}

  			return this;

  		};

  	}(),

  	setStyle: function ( style ) {

  		function handleAlpha( string ) {

  			if ( string === undefined ) { return; }

  			if ( parseFloat( string ) < 1 ) {

  				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

  			}

  		}


  		var m;

  		if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

  			// rgb / hsl

  			var color;
  			var name = m[ 1 ];
  			var components = m[ 2 ];

  			switch ( name ) {

  				case 'rgb':
  				case 'rgba':

  					if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

  						// rgb(255,0,0) rgba(255,0,0,0.5)
  						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
  						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
  						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

  						handleAlpha( color[ 5 ] );

  						return this;

  					}

  					if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

  						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
  						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
  						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
  						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

  						handleAlpha( color[ 5 ] );

  						return this;

  					}

  					break;

  				case 'hsl':
  				case 'hsla':

  					if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

  						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
  						var h = parseFloat( color[ 1 ] ) / 360;
  						var s = parseInt( color[ 2 ], 10 ) / 100;
  						var l = parseInt( color[ 3 ], 10 ) / 100;

  						handleAlpha( color[ 5 ] );

  						return this.setHSL( h, s, l );

  					}

  					break;

  			}

  		} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

  			// hex color

  			var hex = m[ 1 ];
  			var size = hex.length;

  			if ( size === 3 ) {

  				// #ff0
  				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
  				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
  				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

  				return this;

  			} else if ( size === 6 ) {

  				// #ff0000
  				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
  				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
  				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

  				return this;

  			}

  		}

  		if ( style && style.length > 0 ) {

  			// color keywords
  			var hex = ColorKeywords[ style ];

  			if ( hex !== undefined ) {

  				// red
  				this.setHex( hex );

  			} else {

  				// unknown color
  				console.warn( 'THREE.Color: Unknown color ' + style );

  			}

  		}

  		return this;

  	},

  	clone: function () {

  		return new this.constructor( this.r, this.g, this.b );

  	},

  	copy: function ( color ) {

  		this.r = color.r;
  		this.g = color.g;
  		this.b = color.b;

  		return this;

  	},

  	copyGammaToLinear: function ( color, gammaFactor ) {

  		if ( gammaFactor === undefined ) { gammaFactor = 2.0; }

  		this.r = Math.pow( color.r, gammaFactor );
  		this.g = Math.pow( color.g, gammaFactor );
  		this.b = Math.pow( color.b, gammaFactor );

  		return this;

  	},

  	copyLinearToGamma: function ( color, gammaFactor ) {

  		if ( gammaFactor === undefined ) { gammaFactor = 2.0; }

  		var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

  		this.r = Math.pow( color.r, safeInverse );
  		this.g = Math.pow( color.g, safeInverse );
  		this.b = Math.pow( color.b, safeInverse );

  		return this;

  	},

  	convertGammaToLinear: function () {

  		var r = this.r, g = this.g, b = this.b;

  		this.r = r * r;
  		this.g = g * g;
  		this.b = b * b;

  		return this;

  	},

  	convertLinearToGamma: function () {

  		this.r = Math.sqrt( this.r );
  		this.g = Math.sqrt( this.g );
  		this.b = Math.sqrt( this.b );

  		return this;

  	},

  	getHex: function () {

  		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

  	},

  	getHexString: function () {

  		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

  	},

  	getHSL: function ( optionalTarget ) {

  		// h,s,l ranges are in 0.0 - 1.0

  		var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

  		var r = this.r, g = this.g, b = this.b;

  		var max = Math.max( r, g, b );
  		var min = Math.min( r, g, b );

  		var hue, saturation;
  		var lightness = ( min + max ) / 2.0;

  		if ( min === max ) {

  			hue = 0;
  			saturation = 0;

  		} else {

  			var delta = max - min;

  			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

  			switch ( max ) {

  				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
  				case g: hue = ( b - r ) / delta + 2; break;
  				case b: hue = ( r - g ) / delta + 4; break;

  			}

  			hue /= 6;

  		}

  		hsl.h = hue;
  		hsl.s = saturation;
  		hsl.l = lightness;

  		return hsl;

  	},

  	getStyle: function () {

  		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

  	},

  	offsetHSL: function ( h, s, l ) {

  		var hsl = this.getHSL();

  		hsl.h += h; hsl.s += s; hsl.l += l;

  		this.setHSL( hsl.h, hsl.s, hsl.l );

  		return this;

  	},

  	add: function ( color ) {

  		this.r += color.r;
  		this.g += color.g;
  		this.b += color.b;

  		return this;

  	},

  	addColors: function ( color1, color2 ) {

  		this.r = color1.r + color2.r;
  		this.g = color1.g + color2.g;
  		this.b = color1.b + color2.b;

  		return this;

  	},

  	addScalar: function ( s ) {

  		this.r += s;
  		this.g += s;
  		this.b += s;

  		return this;

  	},

  	sub: function ( color ) {

  		this.r = Math.max( 0, this.r - color.r );
  		this.g = Math.max( 0, this.g - color.g );
  		this.b = Math.max( 0, this.b - color.b );

  		return this;

  	},

  	multiply: function ( color ) {

  		this.r *= color.r;
  		this.g *= color.g;
  		this.b *= color.b;

  		return this;

  	},

  	multiplyScalar: function ( s ) {

  		this.r *= s;
  		this.g *= s;
  		this.b *= s;

  		return this;

  	},

  	lerp: function ( color, alpha ) {

  		this.r += ( color.r - this.r ) * alpha;
  		this.g += ( color.g - this.g ) * alpha;
  		this.b += ( color.b - this.b ) * alpha;

  		return this;

  	},

  	equals: function ( c ) {

  		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

  	},

  	fromArray: function ( array, offset ) {

  		if ( offset === undefined ) { offset = 0; }

  		this.r = array[ offset ];
  		this.g = array[ offset + 1 ];
  		this.b = array[ offset + 2 ];

  		return this;

  	},

  	toArray: function ( array, offset ) {

  		if ( array === undefined ) { array = []; }
  		if ( offset === undefined ) { offset = 0; }

  		array[ offset ] = this.r;
  		array[ offset + 1 ] = this.g;
  		array[ offset + 2 ] = this.b;

  		return array;

  	},

  	toJSON: function () {

  		return this.getHex();

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  function Face3$1( a, b, c, normal, color, materialIndex ) {

  	this.a = a;
  	this.b = b;
  	this.c = c;

  	this.normal = ( normal && normal.isVector3 ) ? normal : new Vector3$1();
  	this.vertexNormals = Array.isArray( normal ) ? normal : [];

  	this.color = ( color && color.isColor ) ? color : new Color();
  	this.vertexColors = Array.isArray( color ) ? color : [];

  	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

  }

  Object.assign( Face3$1.prototype, {

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( source ) {
  		var this$1 = this;


  		this.a = source.a;
  		this.b = source.b;
  		this.c = source.c;

  		this.normal.copy( source.normal );
  		this.color.copy( source.color );

  		this.materialIndex = source.materialIndex;

  		for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

  			this$1.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

  		}

  		for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

  			this$1.vertexColors[ i ] = source.vertexColors[ i ].clone();

  		}

  		return this;

  	}

  } );

  var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };









  var FrontSide = 0;
  var BackSide = 1;
  var DoubleSide = 2;
  var FlatShading = 1;

  var NoColors = 0;
  var FaceColors = 1;
  var VertexColors = 2;
  var NoBlending = 0;
  var NormalBlending = 1;
  var AdditiveBlending = 2;
  var SubtractiveBlending = 3;
  var MultiplyBlending = 4;
  var CustomBlending = 5;
  var AddEquation = 100;








  var SrcAlphaFactor = 204;
  var OneMinusSrcAlphaFactor = 205;








  var LessEqualDepth = 3;




  var MultiplyOperation = 0;







  var UVMapping = 300;
  var CubeReflectionMapping = 301;
  var CubeRefractionMapping = 302;
  var EquirectangularReflectionMapping = 303;
  var EquirectangularRefractionMapping = 304;
  var SphericalReflectionMapping = 305;
  var CubeUVReflectionMapping = 306;
  var CubeUVRefractionMapping = 307;
  var RepeatWrapping = 1000;
  var ClampToEdgeWrapping = 1001;
  var MirroredRepeatWrapping = 1002;
  var NearestFilter = 1003;
  var NearestMipMapNearestFilter = 1004;
  var NearestMipMapLinearFilter = 1005;
  var LinearFilter = 1006;
  var LinearMipMapNearestFilter = 1007;
  var LinearMipMapLinearFilter = 1008;
  var UnsignedByteType = 1009;












  var RGBFormat = 1022;
  var RGBAFormat = 1023;














  var LoopOnce = 2200;
  var LoopRepeat = 2201;
  var LoopPingPong = 2202;
  var InterpolateDiscrete = 2300;
  var InterpolateLinear = 2301;
  var InterpolateSmooth = 2302;
  var ZeroCurvatureEnding = 2400;
  var ZeroSlopeEnding = 2401;
  var WrapAroundEnding = 2402;
  var TrianglesDrawMode = 0;


  var LinearEncoding = 3000;







  var BasicDepthPacking = 3200;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  var materialId = 0;

  function Material() {

  	Object.defineProperty( this, 'id', { value: materialId ++ } );

  	this.uuid = _Math.generateUUID();

  	this.name = '';
  	this.type = 'Material';

  	this.fog = true;
  	this.lights = true;

  	this.blending = NormalBlending;
  	this.side = FrontSide;
  	this.flatShading = false;
  	this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors

  	this.opacity = 1;
  	this.transparent = false;

  	this.blendSrc = SrcAlphaFactor;
  	this.blendDst = OneMinusSrcAlphaFactor;
  	this.blendEquation = AddEquation;
  	this.blendSrcAlpha = null;
  	this.blendDstAlpha = null;
  	this.blendEquationAlpha = null;

  	this.depthFunc = LessEqualDepth;
  	this.depthTest = true;
  	this.depthWrite = true;

  	this.clippingPlanes = null;
  	this.clipIntersection = false;
  	this.clipShadows = false;

  	this.colorWrite = true;

  	this.precision = null; // override the renderer's default precision for this material

  	this.polygonOffset = false;
  	this.polygonOffsetFactor = 0;
  	this.polygonOffsetUnits = 0;

  	this.dithering = false;

  	this.alphaTest = 0;
  	this.premultipliedAlpha = false;

  	this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

  	this.visible = true;

  	this.userData = {};

  	this.needsUpdate = true;

  }

  Object.assign( Material.prototype, EventDispatcher.prototype, {

  	isMaterial: true,

  	onBeforeCompile: function () {},

  	setValues: function ( values ) {
  		var this$1 = this;


  		if ( values === undefined ) { return; }

  		for ( var key in values ) {

  			var newValue = values[ key ];

  			if ( newValue === undefined ) {

  				console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
  				continue;

  			}

  			// for backward compatability if shading is set in the constructor
  			if ( key === 'shading' ) {

  				console.warn( 'THREE.' + this$1.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
  				this$1.flatShading = ( newValue === FlatShading ) ? true : false;
  				continue;

  			}

  			var currentValue = this$1[ key ];

  			if ( currentValue === undefined ) {

  				console.warn( "THREE." + this$1.type + ": '" + key + "' is not a property of this material." );
  				continue;

  			}

  			if ( currentValue && currentValue.isColor ) {

  				currentValue.set( newValue );

  			} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

  				currentValue.copy( newValue );

  			} else if ( key === 'overdraw' ) {

  				// ensure overdraw is backwards-compatible with legacy boolean type
  				this$1[ key ] = Number( newValue );

  			} else {

  				this$1[ key ] = newValue;

  			}

  		}

  	},

  	toJSON: function ( meta ) {

  		var isRoot = meta === undefined;

  		if ( isRoot ) {

  			meta = {
  				textures: {},
  				images: {}
  			};

  		}

  		var data = {
  			metadata: {
  				version: 4.5,
  				type: 'Material',
  				generator: 'Material.toJSON'
  			}
  		};

  		// standard Material serialization
  		data.uuid = this.uuid;
  		data.type = this.type;

  		if ( this.name !== '' ) { data.name = this.name; }

  		if ( this.color && this.color.isColor ) { data.color = this.color.getHex(); }

  		if ( this.roughness !== undefined ) { data.roughness = this.roughness; }
  		if ( this.metalness !== undefined ) { data.metalness = this.metalness; }

  		if ( this.emissive && this.emissive.isColor ) { data.emissive = this.emissive.getHex(); }
  		if ( this.specular && this.specular.isColor ) { data.specular = this.specular.getHex(); }
  		if ( this.shininess !== undefined ) { data.shininess = this.shininess; }
  		if ( this.clearCoat !== undefined ) { data.clearCoat = this.clearCoat; }
  		if ( this.clearCoatRoughness !== undefined ) { data.clearCoatRoughness = this.clearCoatRoughness; }

  		if ( this.map && this.map.isTexture ) { data.map = this.map.toJSON( meta ).uuid; }
  		if ( this.alphaMap && this.alphaMap.isTexture ) { data.alphaMap = this.alphaMap.toJSON( meta ).uuid; }
  		if ( this.lightMap && this.lightMap.isTexture ) { data.lightMap = this.lightMap.toJSON( meta ).uuid; }
  		if ( this.bumpMap && this.bumpMap.isTexture ) {

  			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
  			data.bumpScale = this.bumpScale;

  		}
  		if ( this.normalMap && this.normalMap.isTexture ) {

  			data.normalMap = this.normalMap.toJSON( meta ).uuid;
  			data.normalScale = this.normalScale.toArray();

  		}
  		if ( this.displacementMap && this.displacementMap.isTexture ) {

  			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
  			data.displacementScale = this.displacementScale;
  			data.displacementBias = this.displacementBias;

  		}
  		if ( this.roughnessMap && this.roughnessMap.isTexture ) { data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid; }
  		if ( this.metalnessMap && this.metalnessMap.isTexture ) { data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid; }

  		if ( this.emissiveMap && this.emissiveMap.isTexture ) { data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid; }
  		if ( this.specularMap && this.specularMap.isTexture ) { data.specularMap = this.specularMap.toJSON( meta ).uuid; }

  		if ( this.envMap && this.envMap.isTexture ) {

  			data.envMap = this.envMap.toJSON( meta ).uuid;
  			data.reflectivity = this.reflectivity; // Scale behind envMap

  		}

  		if ( this.gradientMap && this.gradientMap.isTexture ) {

  			data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

  		}

  		if ( this.size !== undefined ) { data.size = this.size; }
  		if ( this.sizeAttenuation !== undefined ) { data.sizeAttenuation = this.sizeAttenuation; }

  		if ( this.blending !== NormalBlending ) { data.blending = this.blending; }
  		if ( this.flatShading === true ) { data.flatShading = this.flatShading; }
  		if ( this.side !== FrontSide ) { data.side = this.side; }
  		if ( this.vertexColors !== NoColors ) { data.vertexColors = this.vertexColors; }

  		if ( this.opacity < 1 ) { data.opacity = this.opacity; }
  		if ( this.transparent === true ) { data.transparent = this.transparent; }

  		data.depthFunc = this.depthFunc;
  		data.depthTest = this.depthTest;
  		data.depthWrite = this.depthWrite;

  		if ( this.dithering === true ) { data.dithering = true; }

  		if ( this.alphaTest > 0 ) { data.alphaTest = this.alphaTest; }
  		if ( this.premultipliedAlpha === true ) { data.premultipliedAlpha = this.premultipliedAlpha; }

  		if ( this.wireframe === true ) { data.wireframe = this.wireframe; }
  		if ( this.wireframeLinewidth > 1 ) { data.wireframeLinewidth = this.wireframeLinewidth; }
  		if ( this.wireframeLinecap !== 'round' ) { data.wireframeLinecap = this.wireframeLinecap; }
  		if ( this.wireframeLinejoin !== 'round' ) { data.wireframeLinejoin = this.wireframeLinejoin; }

  		if ( this.morphTargets === true ) { data.morphTargets = true; }
  		if ( this.skinning === true ) { data.skinning = true; }

  		if ( this.visible === false ) { data.visible = false; }
  		if ( JSON.stringify( this.userData ) !== '{}' ) { data.userData = this.userData; }

  		// TODO: Copied from Object3D.toJSON

  		function extractFromCache( cache ) {

  			var values = [];

  			for ( var key in cache ) {

  				var data = cache[ key ];
  				delete data.metadata;
  				values.push( data );

  			}

  			return values;

  		}

  		if ( isRoot ) {

  			var textures = extractFromCache( meta.textures );
  			var images = extractFromCache( meta.images );

  			if ( textures.length > 0 ) { data.textures = textures; }
  			if ( images.length > 0 ) { data.images = images; }

  		}

  		return data;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( source ) {

  		this.name = source.name;

  		this.fog = source.fog;
  		this.lights = source.lights;

  		this.blending = source.blending;
  		this.side = source.side;
  		this.flatShading = source.flatShading;
  		this.vertexColors = source.vertexColors;

  		this.opacity = source.opacity;
  		this.transparent = source.transparent;

  		this.blendSrc = source.blendSrc;
  		this.blendDst = source.blendDst;
  		this.blendEquation = source.blendEquation;
  		this.blendSrcAlpha = source.blendSrcAlpha;
  		this.blendDstAlpha = source.blendDstAlpha;
  		this.blendEquationAlpha = source.blendEquationAlpha;

  		this.depthFunc = source.depthFunc;
  		this.depthTest = source.depthTest;
  		this.depthWrite = source.depthWrite;

  		this.colorWrite = source.colorWrite;

  		this.precision = source.precision;

  		this.polygonOffset = source.polygonOffset;
  		this.polygonOffsetFactor = source.polygonOffsetFactor;
  		this.polygonOffsetUnits = source.polygonOffsetUnits;

  		this.dithering = source.dithering;

  		this.alphaTest = source.alphaTest;
  		this.premultipliedAlpha = source.premultipliedAlpha;

  		this.overdraw = source.overdraw;

  		this.visible = source.visible;
  		this.userData = JSON.parse( JSON.stringify( source.userData ) );

  		this.clipShadows = source.clipShadows;
  		this.clipIntersection = source.clipIntersection;

  		var srcPlanes = source.clippingPlanes,
  			dstPlanes = null;

  		if ( srcPlanes !== null ) {

  			var n = srcPlanes.length;
  			dstPlanes = new Array( n );

  			for ( var i = 0; i !== n; ++ i )
  				{ dstPlanes[ i ] = srcPlanes[ i ].clone(); }

  		}

  		this.clippingPlanes = dstPlanes;

  		return this;

  	},

  	dispose: function () {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  specularMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
   *  combine: THREE.Multiply,
   *  reflectivity: <float>,
   *  refractionRatio: <float>,
   *
   *  depthTest: <bool>,
   *  depthWrite: <bool>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>
   * }
   */

  function MeshBasicMaterial( parameters ) {

  	Material.call( this );

  	this.type = 'MeshBasicMaterial';

  	this.color = new Color( 0xffffff ); // emissive

  	this.map = null;

  	this.lightMap = null;
  	this.lightMapIntensity = 1.0;

  	this.aoMap = null;
  	this.aoMapIntensity = 1.0;

  	this.specularMap = null;

  	this.alphaMap = null;

  	this.envMap = null;
  	this.combine = MultiplyOperation;
  	this.reflectivity = 1;
  	this.refractionRatio = 0.98;

  	this.wireframe = false;
  	this.wireframeLinewidth = 1;
  	this.wireframeLinecap = 'round';
  	this.wireframeLinejoin = 'round';

  	this.skinning = false;
  	this.morphTargets = false;

  	this.lights = false;

  	this.setValues( parameters );

  }

  MeshBasicMaterial.prototype = Object.create( Material.prototype );
  MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

  MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

  MeshBasicMaterial.prototype.copy = function ( source ) {

  	Material.prototype.copy.call( this, source );

  	this.color.copy( source.color );

  	this.map = source.map;

  	this.lightMap = source.lightMap;
  	this.lightMapIntensity = source.lightMapIntensity;

  	this.aoMap = source.aoMap;
  	this.aoMapIntensity = source.aoMapIntensity;

  	this.specularMap = source.specularMap;

  	this.alphaMap = source.alphaMap;

  	this.envMap = source.envMap;
  	this.combine = source.combine;
  	this.reflectivity = source.reflectivity;
  	this.refractionRatio = source.refractionRatio;

  	this.wireframe = source.wireframe;
  	this.wireframeLinewidth = source.wireframeLinewidth;
  	this.wireframeLinecap = source.wireframeLinecap;
  	this.wireframeLinejoin = source.wireframeLinejoin;

  	this.skinning = source.skinning;
  	this.morphTargets = source.morphTargets;

  	return this;

  };

  /**
   * @author supereggbert / http://www.paulbrunt.co.uk/
   * @author philogb / http://blog.thejit.org/
   * @author mikael emtinger / http://gomo.se/
   * @author egraether / http://egraether.com/
   * @author WestLangley / http://github.com/WestLangley
   */

  function Vector4( x, y, z, w ) {

  	this.x = x || 0;
  	this.y = y || 0;
  	this.z = z || 0;
  	this.w = ( w !== undefined ) ? w : 1;

  }

  Object.assign( Vector4.prototype, {

  	isVector4: true,

  	set: function ( x, y, z, w ) {

  		this.x = x;
  		this.y = y;
  		this.z = z;
  		this.w = w;

  		return this;

  	},

  	setScalar: function ( scalar ) {

  		this.x = scalar;
  		this.y = scalar;
  		this.z = scalar;
  		this.w = scalar;

  		return this;

  	},

  	setX: function ( x ) {

  		this.x = x;

  		return this;

  	},

  	setY: function ( y ) {

  		this.y = y;

  		return this;

  	},

  	setZ: function ( z ) {

  		this.z = z;

  		return this;

  	},

  	setW: function ( w ) {

  		this.w = w;

  		return this;

  	},

  	setComponent: function ( index, value ) {

  		switch ( index ) {

  			case 0: this.x = value; break;
  			case 1: this.y = value; break;
  			case 2: this.z = value; break;
  			case 3: this.w = value; break;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  		return this;

  	},

  	getComponent: function ( index ) {

  		switch ( index ) {

  			case 0: return this.x;
  			case 1: return this.y;
  			case 2: return this.z;
  			case 3: return this.w;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  	},

  	clone: function () {

  		return new this.constructor( this.x, this.y, this.z, this.w );

  	},

  	copy: function ( v ) {

  		this.x = v.x;
  		this.y = v.y;
  		this.z = v.z;
  		this.w = ( v.w !== undefined ) ? v.w : 1;

  		return this;

  	},

  	add: function ( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
  			return this.addVectors( v, w );

  		}

  		this.x += v.x;
  		this.y += v.y;
  		this.z += v.z;
  		this.w += v.w;

  		return this;

  	},

  	addScalar: function ( s ) {

  		this.x += s;
  		this.y += s;
  		this.z += s;
  		this.w += s;

  		return this;

  	},

  	addVectors: function ( a, b ) {

  		this.x = a.x + b.x;
  		this.y = a.y + b.y;
  		this.z = a.z + b.z;
  		this.w = a.w + b.w;

  		return this;

  	},

  	addScaledVector: function ( v, s ) {

  		this.x += v.x * s;
  		this.y += v.y * s;
  		this.z += v.z * s;
  		this.w += v.w * s;

  		return this;

  	},

  	sub: function ( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
  			return this.subVectors( v, w );

  		}

  		this.x -= v.x;
  		this.y -= v.y;
  		this.z -= v.z;
  		this.w -= v.w;

  		return this;

  	},

  	subScalar: function ( s ) {

  		this.x -= s;
  		this.y -= s;
  		this.z -= s;
  		this.w -= s;

  		return this;

  	},

  	subVectors: function ( a, b ) {

  		this.x = a.x - b.x;
  		this.y = a.y - b.y;
  		this.z = a.z - b.z;
  		this.w = a.w - b.w;

  		return this;

  	},

  	multiplyScalar: function ( scalar ) {

  		this.x *= scalar;
  		this.y *= scalar;
  		this.z *= scalar;
  		this.w *= scalar;

  		return this;

  	},

  	applyMatrix4: function ( m ) {

  		var x = this.x, y = this.y, z = this.z, w = this.w;
  		var e = m.elements;

  		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
  		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
  		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
  		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

  		return this;

  	},

  	divideScalar: function ( scalar ) {

  		return this.multiplyScalar( 1 / scalar );

  	},

  	setAxisAngleFromQuaternion: function ( q ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

  		// q is assumed to be normalized

  		this.w = 2 * Math.acos( q.w );

  		var s = Math.sqrt( 1 - q.w * q.w );

  		if ( s < 0.0001 ) {

  			this.x = 1;
  			this.y = 0;
  			this.z = 0;

  		} else {

  			this.x = q.x / s;
  			this.y = q.y / s;
  			this.z = q.z / s;

  		}

  		return this;

  	},

  	setAxisAngleFromRotationMatrix: function ( m ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		var angle, x, y, z,		// variables for result
  			epsilon = 0.01,		// margin to allow for rounding errors
  			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

  			te = m.elements,

  			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
  			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
  			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

  		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
  		     ( Math.abs( m13 - m31 ) < epsilon ) &&
  		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

  			// singularity found
  			// first check for identity matrix which must have +1 for all terms
  			// in leading diagonal and zero in other terms

  			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
  			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
  			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
  			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

  				// this singularity is identity matrix so angle = 0

  				this.set( 1, 0, 0, 0 );

  				return this; // zero angle, arbitrary axis

  			}

  			// otherwise this singularity is angle = 180

  			angle = Math.PI;

  			var xx = ( m11 + 1 ) / 2;
  			var yy = ( m22 + 1 ) / 2;
  			var zz = ( m33 + 1 ) / 2;
  			var xy = ( m12 + m21 ) / 4;
  			var xz = ( m13 + m31 ) / 4;
  			var yz = ( m23 + m32 ) / 4;

  			if ( ( xx > yy ) && ( xx > zz ) ) {

  				// m11 is the largest diagonal term

  				if ( xx < epsilon ) {

  					x = 0;
  					y = 0.707106781;
  					z = 0.707106781;

  				} else {

  					x = Math.sqrt( xx );
  					y = xy / x;
  					z = xz / x;

  				}

  			} else if ( yy > zz ) {

  				// m22 is the largest diagonal term

  				if ( yy < epsilon ) {

  					x = 0.707106781;
  					y = 0;
  					z = 0.707106781;

  				} else {

  					y = Math.sqrt( yy );
  					x = xy / y;
  					z = yz / y;

  				}

  			} else {

  				// m33 is the largest diagonal term so base result on this

  				if ( zz < epsilon ) {

  					x = 0.707106781;
  					y = 0.707106781;
  					z = 0;

  				} else {

  					z = Math.sqrt( zz );
  					x = xz / z;
  					y = yz / z;

  				}

  			}

  			this.set( x, y, z, angle );

  			return this; // return 180 deg rotation

  		}

  		// as we have reached here there are no singularities so we can handle normally

  		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
  		                   ( m13 - m31 ) * ( m13 - m31 ) +
  		                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

  		if ( Math.abs( s ) < 0.001 ) { s = 1; }

  		// prevent divide by zero, should not happen if matrix is orthogonal and should be
  		// caught by singularity test above, but I've left it in just in case

  		this.x = ( m32 - m23 ) / s;
  		this.y = ( m13 - m31 ) / s;
  		this.z = ( m21 - m12 ) / s;
  		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

  		return this;

  	},

  	min: function ( v ) {

  		this.x = Math.min( this.x, v.x );
  		this.y = Math.min( this.y, v.y );
  		this.z = Math.min( this.z, v.z );
  		this.w = Math.min( this.w, v.w );

  		return this;

  	},

  	max: function ( v ) {

  		this.x = Math.max( this.x, v.x );
  		this.y = Math.max( this.y, v.y );
  		this.z = Math.max( this.z, v.z );
  		this.w = Math.max( this.w, v.w );

  		return this;

  	},

  	clamp: function ( min, max ) {

  		// assumes min < max, componentwise

  		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
  		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
  		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
  		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

  		return this;

  	},

  	clampScalar: function () {

  		var min, max;

  		return function clampScalar( minVal, maxVal ) {

  			if ( min === undefined ) {

  				min = new Vector4();
  				max = new Vector4();

  			}

  			min.set( minVal, minVal, minVal, minVal );
  			max.set( maxVal, maxVal, maxVal, maxVal );

  			return this.clamp( min, max );

  		};

  	}(),

  	clampLength: function ( min, max ) {

  		var length = this.length();

  		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

  	},

  	floor: function () {

  		this.x = Math.floor( this.x );
  		this.y = Math.floor( this.y );
  		this.z = Math.floor( this.z );
  		this.w = Math.floor( this.w );

  		return this;

  	},

  	ceil: function () {

  		this.x = Math.ceil( this.x );
  		this.y = Math.ceil( this.y );
  		this.z = Math.ceil( this.z );
  		this.w = Math.ceil( this.w );

  		return this;

  	},

  	round: function () {

  		this.x = Math.round( this.x );
  		this.y = Math.round( this.y );
  		this.z = Math.round( this.z );
  		this.w = Math.round( this.w );

  		return this;

  	},

  	roundToZero: function () {

  		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
  		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
  		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
  		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

  		return this;

  	},

  	negate: function () {

  		this.x = - this.x;
  		this.y = - this.y;
  		this.z = - this.z;
  		this.w = - this.w;

  		return this;

  	},

  	dot: function ( v ) {

  		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

  	},

  	lengthSq: function () {

  		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

  	},

  	length: function () {

  		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

  	},

  	lengthManhattan: function () {

  		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

  	},

  	normalize: function () {

  		return this.divideScalar( this.length() || 1 );

  	},

  	setLength: function ( length ) {

  		return this.normalize().multiplyScalar( length );

  	},

  	lerp: function ( v, alpha ) {

  		this.x += ( v.x - this.x ) * alpha;
  		this.y += ( v.y - this.y ) * alpha;
  		this.z += ( v.z - this.z ) * alpha;
  		this.w += ( v.w - this.w ) * alpha;

  		return this;

  	},

  	lerpVectors: function ( v1, v2, alpha ) {

  		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

  	},

  	equals: function ( v ) {

  		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

  	},

  	fromArray: function ( array, offset ) {

  		if ( offset === undefined ) { offset = 0; }

  		this.x = array[ offset ];
  		this.y = array[ offset + 1 ];
  		this.z = array[ offset + 2 ];
  		this.w = array[ offset + 3 ];

  		return this;

  	},

  	toArray: function ( array, offset ) {

  		if ( array === undefined ) { array = []; }
  		if ( offset === undefined ) { offset = 0; }

  		array[ offset ] = this.x;
  		array[ offset + 1 ] = this.y;
  		array[ offset + 2 ] = this.z;
  		array[ offset + 3 ] = this.w;

  		return array;

  	},

  	fromBufferAttribute: function ( attribute, index, offset ) {

  		if ( offset !== undefined ) {

  			console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

  		}

  		this.x = attribute.getX( index );
  		this.y = attribute.getY( index );
  		this.z = attribute.getZ( index );
  		this.w = attribute.getW( index );

  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function BufferAttribute( array, itemSize, normalized ) {

  	if ( Array.isArray( array ) ) {

  		throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

  	}

  	this.uuid = _Math.generateUUID();
  	this.name = '';

  	this.array = array;
  	this.itemSize = itemSize;
  	this.count = array !== undefined ? array.length / itemSize : 0;
  	this.normalized = normalized === true;

  	this.dynamic = false;
  	this.updateRange = { offset: 0, count: - 1 };

  	this.onUploadCallback = function () {};

  	this.version = 0;

  }

  Object.defineProperty( BufferAttribute.prototype, 'needsUpdate', {

  	set: function ( value ) {

  		if ( value === true ) { this.version ++; }

  	}

  } );

  Object.assign( BufferAttribute.prototype, {

  	isBufferAttribute: true,

  	setArray: function ( array ) {

  		if ( Array.isArray( array ) ) {

  			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

  		}

  		this.count = array !== undefined ? array.length / this.itemSize : 0;
  		this.array = array;

  	},

  	setDynamic: function ( value ) {

  		this.dynamic = value;

  		return this;

  	},

  	copy: function ( source ) {

  		this.array = new source.array.constructor( source.array );
  		this.itemSize = source.itemSize;
  		this.count = source.count;
  		this.normalized = source.normalized;

  		this.dynamic = source.dynamic;

  		return this;

  	},

  	copyAt: function ( index1, attribute, index2 ) {
  		var this$1 = this;


  		index1 *= this.itemSize;
  		index2 *= attribute.itemSize;

  		for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

  			this$1.array[ index1 + i ] = attribute.array[ index2 + i ];

  		}

  		return this;

  	},

  	copyArray: function ( array ) {

  		this.array.set( array );

  		return this;

  	},

  	copyColorsArray: function ( colors ) {

  		var array = this.array, offset = 0;

  		for ( var i = 0, l = colors.length; i < l; i ++ ) {

  			var color = colors[ i ];

  			if ( color === undefined ) {

  				console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
  				color = new Color();

  			}

  			array[ offset ++ ] = color.r;
  			array[ offset ++ ] = color.g;
  			array[ offset ++ ] = color.b;

  		}

  		return this;

  	},

  	copyIndicesArray: function ( indices ) {

  		var array = this.array, offset = 0;

  		for ( var i = 0, l = indices.length; i < l; i ++ ) {

  			var index = indices[ i ];

  			array[ offset ++ ] = index.a;
  			array[ offset ++ ] = index.b;
  			array[ offset ++ ] = index.c;

  		}

  		return this;

  	},

  	copyVector2sArray: function ( vectors ) {

  		var array = this.array, offset = 0;

  		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

  			var vector = vectors[ i ];

  			if ( vector === undefined ) {

  				console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
  				vector = new Vector2();

  			}

  			array[ offset ++ ] = vector.x;
  			array[ offset ++ ] = vector.y;

  		}

  		return this;

  	},

  	copyVector3sArray: function ( vectors ) {

  		var array = this.array, offset = 0;

  		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

  			var vector = vectors[ i ];

  			if ( vector === undefined ) {

  				console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
  				vector = new Vector3$1();

  			}

  			array[ offset ++ ] = vector.x;
  			array[ offset ++ ] = vector.y;
  			array[ offset ++ ] = vector.z;

  		}

  		return this;

  	},

  	copyVector4sArray: function ( vectors ) {

  		var array = this.array, offset = 0;

  		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

  			var vector = vectors[ i ];

  			if ( vector === undefined ) {

  				console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
  				vector = new Vector4();

  			}

  			array[ offset ++ ] = vector.x;
  			array[ offset ++ ] = vector.y;
  			array[ offset ++ ] = vector.z;
  			array[ offset ++ ] = vector.w;

  		}

  		return this;

  	},

  	set: function ( value, offset ) {

  		if ( offset === undefined ) { offset = 0; }

  		this.array.set( value, offset );

  		return this;

  	},

  	getX: function ( index ) {

  		return this.array[ index * this.itemSize ];

  	},

  	setX: function ( index, x ) {

  		this.array[ index * this.itemSize ] = x;

  		return this;

  	},

  	getY: function ( index ) {

  		return this.array[ index * this.itemSize + 1 ];

  	},

  	setY: function ( index, y ) {

  		this.array[ index * this.itemSize + 1 ] = y;

  		return this;

  	},

  	getZ: function ( index ) {

  		return this.array[ index * this.itemSize + 2 ];

  	},

  	setZ: function ( index, z ) {

  		this.array[ index * this.itemSize + 2 ] = z;

  		return this;

  	},

  	getW: function ( index ) {

  		return this.array[ index * this.itemSize + 3 ];

  	},

  	setW: function ( index, w ) {

  		this.array[ index * this.itemSize + 3 ] = w;

  		return this;

  	},

  	setXY: function ( index, x, y ) {

  		index *= this.itemSize;

  		this.array[ index + 0 ] = x;
  		this.array[ index + 1 ] = y;

  		return this;

  	},

  	setXYZ: function ( index, x, y, z ) {

  		index *= this.itemSize;

  		this.array[ index + 0 ] = x;
  		this.array[ index + 1 ] = y;
  		this.array[ index + 2 ] = z;

  		return this;

  	},

  	setXYZW: function ( index, x, y, z, w ) {

  		index *= this.itemSize;

  		this.array[ index + 0 ] = x;
  		this.array[ index + 1 ] = y;
  		this.array[ index + 2 ] = z;
  		this.array[ index + 3 ] = w;

  		return this;

  	},

  	onUpload: function ( callback ) {

  		this.onUploadCallback = callback;

  		return this;

  	},

  	clone: function () {

  		return new this.constructor( this.array, this.itemSize ).copy( this );

  	}

  } );

  //

  function Int8BufferAttribute( array, itemSize ) {

  	BufferAttribute.call( this, new Int8Array( array ), itemSize );

  }

  Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;


  function Uint8BufferAttribute( array, itemSize ) {

  	BufferAttribute.call( this, new Uint8Array( array ), itemSize );

  }

  Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;


  function Uint8ClampedBufferAttribute( array, itemSize ) {

  	BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize );

  }

  Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;


  function Int16BufferAttribute( array, itemSize ) {

  	BufferAttribute.call( this, new Int16Array( array ), itemSize );

  }

  Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;


  function Uint16BufferAttribute( array, itemSize ) {

  	BufferAttribute.call( this, new Uint16Array( array ), itemSize );

  }

  Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;


  function Int32BufferAttribute( array, itemSize ) {

  	BufferAttribute.call( this, new Int32Array( array ), itemSize );

  }

  Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;


  function Uint32BufferAttribute( array, itemSize ) {

  	BufferAttribute.call( this, new Uint32Array( array ), itemSize );

  }

  Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;


  function Float32BufferAttribute( array, itemSize ) {

  	BufferAttribute.call( this, new Float32Array( array ), itemSize );

  }

  Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;


  function Float64BufferAttribute( array, itemSize ) {

  	BufferAttribute.call( this, new Float64Array( array ), itemSize );

  }

  Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function DirectGeometry() {

  	this.indices = [];
  	this.vertices = [];
  	this.normals = [];
  	this.colors = [];
  	this.uvs = [];
  	this.uvs2 = [];

  	this.groups = [];

  	this.morphTargets = {};

  	this.skinWeights = [];
  	this.skinIndices = [];

  	// this.lineDistances = [];

  	this.boundingBox = null;
  	this.boundingSphere = null;

  	// update flags

  	this.verticesNeedUpdate = false;
  	this.normalsNeedUpdate = false;
  	this.colorsNeedUpdate = false;
  	this.uvsNeedUpdate = false;
  	this.groupsNeedUpdate = false;

  }

  Object.assign( DirectGeometry.prototype, {

  	computeGroups: function ( geometry ) {

  		var group;
  		var groups = [];
  		var materialIndex = undefined;

  		var faces = geometry.faces;

  		for ( var i = 0; i < faces.length; i ++ ) {

  			var face = faces[ i ];

  			// materials

  			if ( face.materialIndex !== materialIndex ) {

  				materialIndex = face.materialIndex;

  				if ( group !== undefined ) {

  					group.count = ( i * 3 ) - group.start;
  					groups.push( group );

  				}

  				group = {
  					start: i * 3,
  					materialIndex: materialIndex
  				};

  			}

  		}

  		if ( group !== undefined ) {

  			group.count = ( i * 3 ) - group.start;
  			groups.push( group );

  		}

  		this.groups = groups;

  	},

  	fromGeometry: function ( geometry ) {
  		var this$1 = this;


  		var faces = geometry.faces;
  		var vertices = geometry.vertices;
  		var faceVertexUvs = geometry.faceVertexUvs;

  		var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
  		var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

  		// morphs

  		var morphTargets = geometry.morphTargets;
  		var morphTargetsLength = morphTargets.length;

  		var morphTargetsPosition;

  		if ( morphTargetsLength > 0 ) {

  			morphTargetsPosition = [];

  			for ( var i = 0; i < morphTargetsLength; i ++ ) {

  				morphTargetsPosition[ i ] = [];

  			}

  			this.morphTargets.position = morphTargetsPosition;

  		}

  		var morphNormals = geometry.morphNormals;
  		var morphNormalsLength = morphNormals.length;

  		var morphTargetsNormal;

  		if ( morphNormalsLength > 0 ) {

  			morphTargetsNormal = [];

  			for ( var i = 0; i < morphNormalsLength; i ++ ) {

  				morphTargetsNormal[ i ] = [];

  			}

  			this.morphTargets.normal = morphTargetsNormal;

  		}

  		// skins

  		var skinIndices = geometry.skinIndices;
  		var skinWeights = geometry.skinWeights;

  		var hasSkinIndices = skinIndices.length === vertices.length;
  		var hasSkinWeights = skinWeights.length === vertices.length;

  		//

  		for ( var i = 0; i < faces.length; i ++ ) {

  			var face = faces[ i ];

  			this$1.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

  			var vertexNormals = face.vertexNormals;

  			if ( vertexNormals.length === 3 ) {

  				this$1.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

  			} else {

  				var normal = face.normal;

  				this$1.normals.push( normal, normal, normal );

  			}

  			var vertexColors = face.vertexColors;

  			if ( vertexColors.length === 3 ) {

  				this$1.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

  			} else {

  				var color = face.color;

  				this$1.colors.push( color, color, color );

  			}

  			if ( hasFaceVertexUv === true ) {

  				var vertexUvs = faceVertexUvs[ 0 ][ i ];

  				if ( vertexUvs !== undefined ) {

  					this$1.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

  				} else {

  					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

  					this$1.uvs.push( new Vector2(), new Vector2(), new Vector2() );

  				}

  			}

  			if ( hasFaceVertexUv2 === true ) {

  				var vertexUvs = faceVertexUvs[ 1 ][ i ];

  				if ( vertexUvs !== undefined ) {

  					this$1.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

  				} else {

  					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

  					this$1.uvs2.push( new Vector2(), new Vector2(), new Vector2() );

  				}

  			}

  			// morphs

  			for ( var j = 0; j < morphTargetsLength; j ++ ) {

  				var morphTarget = morphTargets[ j ].vertices;

  				morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

  			}

  			for ( var j = 0; j < morphNormalsLength; j ++ ) {

  				var morphNormal = morphNormals[ j ].vertexNormals[ i ];

  				morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

  			}

  			// skins

  			if ( hasSkinIndices ) {

  				this$1.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

  			}

  			if ( hasSkinWeights ) {

  				this$1.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

  			}

  		}

  		this.computeGroups( geometry );

  		this.verticesNeedUpdate = geometry.verticesNeedUpdate;
  		this.normalsNeedUpdate = geometry.normalsNeedUpdate;
  		this.colorsNeedUpdate = geometry.colorsNeedUpdate;
  		this.uvsNeedUpdate = geometry.uvsNeedUpdate;
  		this.groupsNeedUpdate = geometry.groupsNeedUpdate;

  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function arrayMax( array ) {

  	if ( array.length === 0 ) { return - Infinity; }

  	var max = array[ 0 ];

  	for ( var i = 1, l = array.length; i < l; ++ i ) {

  		if ( array[ i ] > max ) { max = array[ i ]; }

  	}

  	return max;

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author kile / http://kile.stravaganza.org/
   * @author alteredq / http://alteredqualia.com/
   * @author mikael emtinger / http://gomo.se/
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * @author bhouston / http://clara.io
   */

  var count = 0;

  function GeometryIdCount() {

  	return count ++;

  }

  function Geometry() {

  	Object.defineProperty( this, 'id', { value: GeometryIdCount() } );

  	this.uuid = _Math.generateUUID();

  	this.name = '';
  	this.type = 'Geometry';

  	this.vertices = [];
  	this.colors = [];
  	this.faces = [];
  	this.faceVertexUvs = [[]];

  	this.morphTargets = [];
  	this.morphNormals = [];

  	this.skinWeights = [];
  	this.skinIndices = [];

  	this.lineDistances = [];

  	this.boundingBox = null;
  	this.boundingSphere = null;

  	// update flags

  	this.elementsNeedUpdate = false;
  	this.verticesNeedUpdate = false;
  	this.uvsNeedUpdate = false;
  	this.normalsNeedUpdate = false;
  	this.colorsNeedUpdate = false;
  	this.lineDistancesNeedUpdate = false;
  	this.groupsNeedUpdate = false;

  }

  Object.assign( Geometry.prototype, EventDispatcher.prototype, {

  	isGeometry: true,

  	applyMatrix: function ( matrix ) {
  		var this$1 = this;


  		var normalMatrix = new Matrix3().getNormalMatrix( matrix );

  		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

  			var vertex = this$1.vertices[ i ];
  			vertex.applyMatrix4( matrix );

  		}

  		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

  			var face = this$1.faces[ i ];
  			face.normal.applyMatrix3( normalMatrix ).normalize();

  			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

  				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

  			}

  		}

  		if ( this.boundingBox !== null ) {

  			this.computeBoundingBox();

  		}

  		if ( this.boundingSphere !== null ) {

  			this.computeBoundingSphere();

  		}

  		this.verticesNeedUpdate = true;
  		this.normalsNeedUpdate = true;

  		return this;

  	},

  	rotateX: function () {

  		// rotate geometry around world x-axis

  		var m1 = new Matrix4();

  		return function rotateX( angle ) {

  			m1.makeRotationX( angle );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	rotateY: function () {

  		// rotate geometry around world y-axis

  		var m1 = new Matrix4();

  		return function rotateY( angle ) {

  			m1.makeRotationY( angle );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	rotateZ: function () {

  		// rotate geometry around world z-axis

  		var m1 = new Matrix4();

  		return function rotateZ( angle ) {

  			m1.makeRotationZ( angle );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	translate: function () {

  		// translate geometry

  		var m1 = new Matrix4();

  		return function translate( x, y, z ) {

  			m1.makeTranslation( x, y, z );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	scale: function () {

  		// scale geometry

  		var m1 = new Matrix4();

  		return function scale( x, y, z ) {

  			m1.makeScale( x, y, z );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	lookAt: function () {

  		var obj = new Object3D();

  		return function lookAt( vector ) {

  			obj.lookAt( vector );

  			obj.updateMatrix();

  			this.applyMatrix( obj.matrix );

  		};

  	}(),

  	fromBufferGeometry: function ( geometry ) {

  		var scope = this;

  		var indices = geometry.index !== null ? geometry.index.array : undefined;
  		var attributes = geometry.attributes;

  		var positions = attributes.position.array;
  		var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
  		var colors = attributes.color !== undefined ? attributes.color.array : undefined;
  		var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
  		var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

  		if ( uvs2 !== undefined ) { this.faceVertexUvs[ 1 ] = []; }

  		var tempNormals = [];
  		var tempUVs = [];
  		var tempUVs2 = [];

  		for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {

  			scope.vertices.push( new Vector3$1( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );

  			if ( normals !== undefined ) {

  				tempNormals.push( new Vector3$1( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

  			}

  			if ( colors !== undefined ) {

  				scope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

  			}

  			if ( uvs !== undefined ) {

  				tempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );

  			}

  			if ( uvs2 !== undefined ) {

  				tempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );

  			}

  		}

  		function addFace( a, b, c, materialIndex ) {

  			var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
  			var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

  			var face = new Face3$1( a, b, c, vertexNormals, vertexColors, materialIndex );

  			scope.faces.push( face );

  			if ( uvs !== undefined ) {

  				scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

  			}

  			if ( uvs2 !== undefined ) {

  				scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

  			}

  		}

  		var groups = geometry.groups;

  		if ( groups.length > 0 ) {

  			for ( var i = 0; i < groups.length; i ++ ) {

  				var group = groups[ i ];

  				var start = group.start;
  				var count = group.count;

  				for ( var j = start, jl = start + count; j < jl; j += 3 ) {

  					if ( indices !== undefined ) {

  						addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );

  					} else {

  						addFace( j, j + 1, j + 2, group.materialIndex );

  					}

  				}

  			}

  		} else {

  			if ( indices !== undefined ) {

  				for ( var i = 0; i < indices.length; i += 3 ) {

  					addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

  				}

  			} else {

  				for ( var i = 0; i < positions.length / 3; i += 3 ) {

  					addFace( i, i + 1, i + 2 );

  				}

  			}

  		}

  		this.computeFaceNormals();

  		if ( geometry.boundingBox !== null ) {

  			this.boundingBox = geometry.boundingBox.clone();

  		}

  		if ( geometry.boundingSphere !== null ) {

  			this.boundingSphere = geometry.boundingSphere.clone();

  		}

  		return this;

  	},

  	center: function () {

  		this.computeBoundingBox();

  		var offset = this.boundingBox.getCenter().negate();

  		this.translate( offset.x, offset.y, offset.z );

  		return offset;

  	},

  	normalize: function () {

  		this.computeBoundingSphere();

  		var center = this.boundingSphere.center;
  		var radius = this.boundingSphere.radius;

  		var s = radius === 0 ? 1 : 1.0 / radius;

  		var matrix = new Matrix4();
  		matrix.set(
  			s, 0, 0, - s * center.x,
  			0, s, 0, - s * center.y,
  			0, 0, s, - s * center.z,
  			0, 0, 0, 1
  		);

  		this.applyMatrix( matrix );

  		return this;

  	},

  	computeFaceNormals: function () {
  		var this$1 = this;


  		var cb = new Vector3$1(), ab = new Vector3$1();

  		for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

  			var face = this$1.faces[ f ];

  			var vA = this$1.vertices[ face.a ];
  			var vB = this$1.vertices[ face.b ];
  			var vC = this$1.vertices[ face.c ];

  			cb.subVectors( vC, vB );
  			ab.subVectors( vA, vB );
  			cb.cross( ab );

  			cb.normalize();

  			face.normal.copy( cb );

  		}

  	},

  	computeVertexNormals: function ( areaWeighted ) {
  		var this$1 = this;


  		if ( areaWeighted === undefined ) { areaWeighted = true; }

  		var v, vl, f, fl, face, vertices;

  		vertices = new Array( this.vertices.length );

  		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

  			vertices[ v ] = new Vector3$1();

  		}

  		if ( areaWeighted ) {

  			// vertex normals weighted by triangle areas
  			// http://www.iquilezles.org/www/articles/normals/normals.htm

  			var vA, vB, vC;
  			var cb = new Vector3$1(), ab = new Vector3$1();

  			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  				face = this$1.faces[ f ];

  				vA = this$1.vertices[ face.a ];
  				vB = this$1.vertices[ face.b ];
  				vC = this$1.vertices[ face.c ];

  				cb.subVectors( vC, vB );
  				ab.subVectors( vA, vB );
  				cb.cross( ab );

  				vertices[ face.a ].add( cb );
  				vertices[ face.b ].add( cb );
  				vertices[ face.c ].add( cb );

  			}

  		} else {

  			this.computeFaceNormals();

  			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  				face = this$1.faces[ f ];

  				vertices[ face.a ].add( face.normal );
  				vertices[ face.b ].add( face.normal );
  				vertices[ face.c ].add( face.normal );

  			}

  		}

  		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

  			vertices[ v ].normalize();

  		}

  		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  			face = this$1.faces[ f ];

  			var vertexNormals = face.vertexNormals;

  			if ( vertexNormals.length === 3 ) {

  				vertexNormals[ 0 ].copy( vertices[ face.a ] );
  				vertexNormals[ 1 ].copy( vertices[ face.b ] );
  				vertexNormals[ 2 ].copy( vertices[ face.c ] );

  			} else {

  				vertexNormals[ 0 ] = vertices[ face.a ].clone();
  				vertexNormals[ 1 ] = vertices[ face.b ].clone();
  				vertexNormals[ 2 ] = vertices[ face.c ].clone();

  			}

  		}

  		if ( this.faces.length > 0 ) {

  			this.normalsNeedUpdate = true;

  		}

  	},

  	computeFlatVertexNormals: function () {
  		var this$1 = this;


  		var f, fl, face;

  		this.computeFaceNormals();

  		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  			face = this$1.faces[ f ];

  			var vertexNormals = face.vertexNormals;

  			if ( vertexNormals.length === 3 ) {

  				vertexNormals[ 0 ].copy( face.normal );
  				vertexNormals[ 1 ].copy( face.normal );
  				vertexNormals[ 2 ].copy( face.normal );

  			} else {

  				vertexNormals[ 0 ] = face.normal.clone();
  				vertexNormals[ 1 ] = face.normal.clone();
  				vertexNormals[ 2 ] = face.normal.clone();

  			}

  		}

  		if ( this.faces.length > 0 ) {

  			this.normalsNeedUpdate = true;

  		}

  	},

  	computeMorphNormals: function () {
  		var this$1 = this;


  		var i, il, f, fl, face;

  		// save original normals
  		// - create temp variables on first access
  		//   otherwise just copy (for faster repeated calls)

  		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  			face = this$1.faces[ f ];

  			if ( ! face.__originalFaceNormal ) {

  				face.__originalFaceNormal = face.normal.clone();

  			} else {

  				face.__originalFaceNormal.copy( face.normal );

  			}

  			if ( ! face.__originalVertexNormals ) { face.__originalVertexNormals = []; }

  			for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

  				if ( ! face.__originalVertexNormals[ i ] ) {

  					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

  				} else {

  					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

  				}

  			}

  		}

  		// use temp geometry to compute face and vertex normals for each morph

  		var tmpGeo = new Geometry();
  		tmpGeo.faces = this.faces;

  		for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

  			// create on first access

  			if ( ! this$1.morphNormals[ i ] ) {

  				this$1.morphNormals[ i ] = {};
  				this$1.morphNormals[ i ].faceNormals = [];
  				this$1.morphNormals[ i ].vertexNormals = [];

  				var dstNormalsFace = this$1.morphNormals[ i ].faceNormals;
  				var dstNormalsVertex = this$1.morphNormals[ i ].vertexNormals;

  				var faceNormal, vertexNormals;

  				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  					faceNormal = new Vector3$1();
  					vertexNormals = { a: new Vector3$1(), b: new Vector3$1(), c: new Vector3$1() };

  					dstNormalsFace.push( faceNormal );
  					dstNormalsVertex.push( vertexNormals );

  				}

  			}

  			var morphNormals = this$1.morphNormals[ i ];

  			// set vertices to morph target

  			tmpGeo.vertices = this$1.morphTargets[ i ].vertices;

  			// compute morph normals

  			tmpGeo.computeFaceNormals();
  			tmpGeo.computeVertexNormals();

  			// store morph normals

  			var faceNormal, vertexNormals;

  			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  				face = this$1.faces[ f ];

  				faceNormal = morphNormals.faceNormals[ f ];
  				vertexNormals = morphNormals.vertexNormals[ f ];

  				faceNormal.copy( face.normal );

  				vertexNormals.a.copy( face.vertexNormals[ 0 ] );
  				vertexNormals.b.copy( face.vertexNormals[ 1 ] );
  				vertexNormals.c.copy( face.vertexNormals[ 2 ] );

  			}

  		}

  		// restore original normals

  		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  			face = this$1.faces[ f ];

  			face.normal = face.__originalFaceNormal;
  			face.vertexNormals = face.__originalVertexNormals;

  		}

  	},

  	computeLineDistances: function () {
  		var this$1 = this;


  		var d = 0;
  		var vertices = this.vertices;

  		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

  			if ( i > 0 ) {

  				d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

  			}

  			this$1.lineDistances[ i ] = d;

  		}

  	},

  	computeBoundingBox: function () {

  		if ( this.boundingBox === null ) {

  			this.boundingBox = new Box3();

  		}

  		this.boundingBox.setFromPoints( this.vertices );

  	},

  	computeBoundingSphere: function () {

  		if ( this.boundingSphere === null ) {

  			this.boundingSphere = new Sphere();

  		}

  		this.boundingSphere.setFromPoints( this.vertices );

  	},

  	merge: function ( geometry, matrix, materialIndexOffset ) {

  		if ( ! ( geometry && geometry.isGeometry ) ) {

  			console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
  			return;

  		}

  		var normalMatrix,
  			vertexOffset = this.vertices.length,
  			vertices1 = this.vertices,
  			vertices2 = geometry.vertices,
  			faces1 = this.faces,
  			faces2 = geometry.faces,
  			uvs1 = this.faceVertexUvs[ 0 ],
  			uvs2 = geometry.faceVertexUvs[ 0 ],
  			colors1 = this.colors,
  			colors2 = geometry.colors;

  		if ( materialIndexOffset === undefined ) { materialIndexOffset = 0; }

  		if ( matrix !== undefined ) {

  			normalMatrix = new Matrix3().getNormalMatrix( matrix );

  		}

  		// vertices

  		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

  			var vertex = vertices2[ i ];

  			var vertexCopy = vertex.clone();

  			if ( matrix !== undefined ) { vertexCopy.applyMatrix4( matrix ); }

  			vertices1.push( vertexCopy );

  		}

  		// colors

  		for ( var i = 0, il = colors2.length; i < il; i ++ ) {

  			colors1.push( colors2[ i ].clone() );

  		}

  		// faces

  		for ( i = 0, il = faces2.length; i < il; i ++ ) {

  			var face = faces2[ i ], faceCopy, normal, color,
  				faceVertexNormals = face.vertexNormals,
  				faceVertexColors = face.vertexColors;

  			faceCopy = new Face3$1( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
  			faceCopy.normal.copy( face.normal );

  			if ( normalMatrix !== undefined ) {

  				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

  			}

  			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

  				normal = faceVertexNormals[ j ].clone();

  				if ( normalMatrix !== undefined ) {

  					normal.applyMatrix3( normalMatrix ).normalize();

  				}

  				faceCopy.vertexNormals.push( normal );

  			}

  			faceCopy.color.copy( face.color );

  			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

  				color = faceVertexColors[ j ];
  				faceCopy.vertexColors.push( color.clone() );

  			}

  			faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

  			faces1.push( faceCopy );

  		}

  		// uvs

  		for ( i = 0, il = uvs2.length; i < il; i ++ ) {

  			var uv = uvs2[ i ], uvCopy = [];

  			if ( uv === undefined ) {

  				continue;

  			}

  			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

  				uvCopy.push( uv[ j ].clone() );

  			}

  			uvs1.push( uvCopy );

  		}

  	},

  	mergeMesh: function ( mesh ) {

  		if ( ! ( mesh && mesh.isMesh ) ) {

  			console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
  			return;

  		}

  		mesh.matrixAutoUpdate && mesh.updateMatrix();

  		this.merge( mesh.geometry, mesh.matrix );

  	},

  	/*
  	 * Checks for duplicate vertices with hashmap.
  	 * Duplicated vertices are removed
  	 * and faces' vertices are updated.
  	 */

  	mergeVertices: function () {
  		var this$1 = this;


  		var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
  		var unique = [], changes = [];

  		var v, key;
  		var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
  		var precision = Math.pow( 10, precisionPoints );
  		var i, il, face;
  		var indices, j, jl;

  		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

  			v = this$1.vertices[ i ];
  			key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

  			if ( verticesMap[ key ] === undefined ) {

  				verticesMap[ key ] = i;
  				unique.push( this$1.vertices[ i ] );
  				changes[ i ] = unique.length - 1;

  			} else {

  				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
  				changes[ i ] = changes[ verticesMap[ key ] ];

  			}

  		}


  		// if faces are completely degenerate after merging vertices, we
  		// have to remove them from the geometry.
  		var faceIndicesToRemove = [];

  		for ( i = 0, il = this.faces.length; i < il; i ++ ) {

  			face = this$1.faces[ i ];

  			face.a = changes[ face.a ];
  			face.b = changes[ face.b ];
  			face.c = changes[ face.c ];

  			indices = [ face.a, face.b, face.c ];

  			// if any duplicate vertices are found in a Face3
  			// we have to remove the face as nothing can be saved
  			for ( var n = 0; n < 3; n ++ ) {

  				if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

  					faceIndicesToRemove.push( i );
  					break;

  				}

  			}

  		}

  		for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

  			var idx = faceIndicesToRemove[ i ];

  			this$1.faces.splice( idx, 1 );

  			for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

  				this$1.faceVertexUvs[ j ].splice( idx, 1 );

  			}

  		}

  		// Use unique set of vertices

  		var diff = this.vertices.length - unique.length;
  		this.vertices = unique;
  		return diff;

  	},

  	sortFacesByMaterialIndex: function () {

  		var faces = this.faces;
  		var length = faces.length;

  		// tag faces

  		for ( var i = 0; i < length; i ++ ) {

  			faces[ i ]._id = i;

  		}

  		// sort faces

  		function materialIndexSort( a, b ) {

  			return a.materialIndex - b.materialIndex;

  		}

  		faces.sort( materialIndexSort );

  		// sort uvs

  		var uvs1 = this.faceVertexUvs[ 0 ];
  		var uvs2 = this.faceVertexUvs[ 1 ];

  		var newUvs1, newUvs2;

  		if ( uvs1 && uvs1.length === length ) { newUvs1 = []; }
  		if ( uvs2 && uvs2.length === length ) { newUvs2 = []; }

  		for ( var i = 0; i < length; i ++ ) {

  			var id = faces[ i ]._id;

  			if ( newUvs1 ) { newUvs1.push( uvs1[ id ] ); }
  			if ( newUvs2 ) { newUvs2.push( uvs2[ id ] ); }

  		}

  		if ( newUvs1 ) { this.faceVertexUvs[ 0 ] = newUvs1; }
  		if ( newUvs2 ) { this.faceVertexUvs[ 1 ] = newUvs2; }

  	},

  	toJSON: function () {
  		var this$1 = this;


  		var data = {
  			metadata: {
  				version: 4.5,
  				type: 'Geometry',
  				generator: 'Geometry.toJSON'
  			}
  		};

  		// standard Geometry serialization

  		data.uuid = this.uuid;
  		data.type = this.type;
  		if ( this.name !== '' ) { data.name = this.name; }

  		if ( this.parameters !== undefined ) {

  			var parameters = this.parameters;

  			for ( var key in parameters ) {

  				if ( parameters[ key ] !== undefined ) { data[ key ] = parameters[ key ]; }

  			}

  			return data;

  		}

  		var vertices = [];

  		for ( var i = 0; i < this.vertices.length; i ++ ) {

  			var vertex = this$1.vertices[ i ];
  			vertices.push( vertex.x, vertex.y, vertex.z );

  		}

  		var faces = [];
  		var normals = [];
  		var normalsHash = {};
  		var colors = [];
  		var colorsHash = {};
  		var uvs = [];
  		var uvsHash = {};

  		for ( var i = 0; i < this.faces.length; i ++ ) {

  			var face = this$1.faces[ i ];

  			var hasMaterial = true;
  			var hasFaceUv = false; // deprecated
  			var hasFaceVertexUv = this$1.faceVertexUvs[ 0 ][ i ] !== undefined;
  			var hasFaceNormal = face.normal.length() > 0;
  			var hasFaceVertexNormal = face.vertexNormals.length > 0;
  			var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
  			var hasFaceVertexColor = face.vertexColors.length > 0;

  			var faceType = 0;

  			faceType = setBit( faceType, 0, 0 ); // isQuad
  			faceType = setBit( faceType, 1, hasMaterial );
  			faceType = setBit( faceType, 2, hasFaceUv );
  			faceType = setBit( faceType, 3, hasFaceVertexUv );
  			faceType = setBit( faceType, 4, hasFaceNormal );
  			faceType = setBit( faceType, 5, hasFaceVertexNormal );
  			faceType = setBit( faceType, 6, hasFaceColor );
  			faceType = setBit( faceType, 7, hasFaceVertexColor );

  			faces.push( faceType );
  			faces.push( face.a, face.b, face.c );
  			faces.push( face.materialIndex );

  			if ( hasFaceVertexUv ) {

  				var faceVertexUvs = this$1.faceVertexUvs[ 0 ][ i ];

  				faces.push(
  					getUvIndex( faceVertexUvs[ 0 ] ),
  					getUvIndex( faceVertexUvs[ 1 ] ),
  					getUvIndex( faceVertexUvs[ 2 ] )
  				);

  			}

  			if ( hasFaceNormal ) {

  				faces.push( getNormalIndex( face.normal ) );

  			}

  			if ( hasFaceVertexNormal ) {

  				var vertexNormals = face.vertexNormals;

  				faces.push(
  					getNormalIndex( vertexNormals[ 0 ] ),
  					getNormalIndex( vertexNormals[ 1 ] ),
  					getNormalIndex( vertexNormals[ 2 ] )
  				);

  			}

  			if ( hasFaceColor ) {

  				faces.push( getColorIndex( face.color ) );

  			}

  			if ( hasFaceVertexColor ) {

  				var vertexColors = face.vertexColors;

  				faces.push(
  					getColorIndex( vertexColors[ 0 ] ),
  					getColorIndex( vertexColors[ 1 ] ),
  					getColorIndex( vertexColors[ 2 ] )
  				);

  			}

  		}

  		function setBit( value, position, enabled ) {

  			return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

  		}

  		function getNormalIndex( normal ) {

  			var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

  			if ( normalsHash[ hash ] !== undefined ) {

  				return normalsHash[ hash ];

  			}

  			normalsHash[ hash ] = normals.length / 3;
  			normals.push( normal.x, normal.y, normal.z );

  			return normalsHash[ hash ];

  		}

  		function getColorIndex( color ) {

  			var hash = color.r.toString() + color.g.toString() + color.b.toString();

  			if ( colorsHash[ hash ] !== undefined ) {

  				return colorsHash[ hash ];

  			}

  			colorsHash[ hash ] = colors.length;
  			colors.push( color.getHex() );

  			return colorsHash[ hash ];

  		}

  		function getUvIndex( uv ) {

  			var hash = uv.x.toString() + uv.y.toString();

  			if ( uvsHash[ hash ] !== undefined ) {

  				return uvsHash[ hash ];

  			}

  			uvsHash[ hash ] = uvs.length / 2;
  			uvs.push( uv.x, uv.y );

  			return uvsHash[ hash ];

  		}

  		data.data = {};

  		data.data.vertices = vertices;
  		data.data.normals = normals;
  		if ( colors.length > 0 ) { data.data.colors = colors; }
  		if ( uvs.length > 0 ) { data.data.uvs = [ uvs ]; } // temporal backward compatibility
  		data.data.faces = faces;

  		return data;

  	},

  	clone: function () {

  		/*
  		 // Handle primitives

  		 var parameters = this.parameters;

  		 if ( parameters !== undefined ) {

  		 var values = [];

  		 for ( var key in parameters ) {

  		 values.push( parameters[ key ] );

  		 }

  		 var geometry = Object.create( this.constructor.prototype );
  		 this.constructor.apply( geometry, values );
  		 return geometry;

  		 }

  		 return new this.constructor().copy( this );
  		 */

  		return new Geometry().copy( this );

  	},

  	copy: function ( source ) {
  		var this$1 = this;


  		var i, il, j, jl, k, kl;

  		// reset

  		this.vertices = [];
  		this.colors = [];
  		this.faces = [];
  		this.faceVertexUvs = [[]];
  		this.morphTargets = [];
  		this.morphNormals = [];
  		this.skinWeights = [];
  		this.skinIndices = [];
  		this.lineDistances = [];
  		this.boundingBox = null;
  		this.boundingSphere = null;

  		// name

  		this.name = source.name;

  		// vertices

  		var vertices = source.vertices;

  		for ( i = 0, il = vertices.length; i < il; i ++ ) {

  			this$1.vertices.push( vertices[ i ].clone() );

  		}

  		// colors

  		var colors = source.colors;

  		for ( i = 0, il = colors.length; i < il; i ++ ) {

  			this$1.colors.push( colors[ i ].clone() );

  		}

  		// faces

  		var faces = source.faces;

  		for ( i = 0, il = faces.length; i < il; i ++ ) {

  			this$1.faces.push( faces[ i ].clone() );

  		}

  		// face vertex uvs

  		for ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

  			var faceVertexUvs = source.faceVertexUvs[ i ];

  			if ( this$1.faceVertexUvs[ i ] === undefined ) {

  				this$1.faceVertexUvs[ i ] = [];

  			}

  			for ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

  				var uvs = faceVertexUvs[ j ], uvsCopy = [];

  				for ( k = 0, kl = uvs.length; k < kl; k ++ ) {

  					var uv = uvs[ k ];

  					uvsCopy.push( uv.clone() );

  				}

  				this$1.faceVertexUvs[ i ].push( uvsCopy );

  			}

  		}

  		// morph targets

  		var morphTargets = source.morphTargets;

  		for ( i = 0, il = morphTargets.length; i < il; i ++ ) {

  			var morphTarget = {};
  			morphTarget.name = morphTargets[ i ].name;

  			// vertices

  			if ( morphTargets[ i ].vertices !== undefined ) {

  				morphTarget.vertices = [];

  				for ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {

  					morphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );

  				}

  			}

  			// normals

  			if ( morphTargets[ i ].normals !== undefined ) {

  				morphTarget.normals = [];

  				for ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {

  					morphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );

  				}

  			}

  			this$1.morphTargets.push( morphTarget );

  		}

  		// morph normals

  		var morphNormals = source.morphNormals;

  		for ( i = 0, il = morphNormals.length; i < il; i ++ ) {

  			var morphNormal = {};

  			// vertex normals

  			if ( morphNormals[ i ].vertexNormals !== undefined ) {

  				morphNormal.vertexNormals = [];

  				for ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {

  					var srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];
  					var destVertexNormal = {};

  					destVertexNormal.a = srcVertexNormal.a.clone();
  					destVertexNormal.b = srcVertexNormal.b.clone();
  					destVertexNormal.c = srcVertexNormal.c.clone();

  					morphNormal.vertexNormals.push( destVertexNormal );

  				}

  			}

  			// face normals

  			if ( morphNormals[ i ].faceNormals !== undefined ) {

  				morphNormal.faceNormals = [];

  				for ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {

  					morphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );

  				}

  			}

  			this$1.morphNormals.push( morphNormal );

  		}

  		// skin weights

  		var skinWeights = source.skinWeights;

  		for ( i = 0, il = skinWeights.length; i < il; i ++ ) {

  			this$1.skinWeights.push( skinWeights[ i ].clone() );

  		}

  		// skin indices

  		var skinIndices = source.skinIndices;

  		for ( i = 0, il = skinIndices.length; i < il; i ++ ) {

  			this$1.skinIndices.push( skinIndices[ i ].clone() );

  		}

  		// line distances

  		var lineDistances = source.lineDistances;

  		for ( i = 0, il = lineDistances.length; i < il; i ++ ) {

  			this$1.lineDistances.push( lineDistances[ i ] );

  		}

  		// bounding box

  		var boundingBox = source.boundingBox;

  		if ( boundingBox !== null ) {

  			this.boundingBox = boundingBox.clone();

  		}

  		// bounding sphere

  		var boundingSphere = source.boundingSphere;

  		if ( boundingSphere !== null ) {

  			this.boundingSphere = boundingSphere.clone();

  		}

  		// update flags

  		this.elementsNeedUpdate = source.elementsNeedUpdate;
  		this.verticesNeedUpdate = source.verticesNeedUpdate;
  		this.uvsNeedUpdate = source.uvsNeedUpdate;
  		this.normalsNeedUpdate = source.normalsNeedUpdate;
  		this.colorsNeedUpdate = source.colorsNeedUpdate;
  		this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
  		this.groupsNeedUpdate = source.groupsNeedUpdate;

  		return this;

  	},

  	dispose: function () {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   */

  function BufferGeometry() {

  	Object.defineProperty( this, 'id', { value: GeometryIdCount() } );

  	this.uuid = _Math.generateUUID();

  	this.name = '';
  	this.type = 'BufferGeometry';

  	this.index = null;
  	this.attributes = {};

  	this.morphAttributes = {};

  	this.groups = [];

  	this.boundingBox = null;
  	this.boundingSphere = null;

  	this.drawRange = { start: 0, count: Infinity };

  }

  BufferGeometry.MaxIndex = 65535;

  Object.assign( BufferGeometry.prototype, EventDispatcher.prototype, {

  	isBufferGeometry: true,

  	getIndex: function () {

  		return this.index;

  	},

  	setIndex: function ( index ) {

  		if ( Array.isArray( index ) ) {

  			this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

  		} else {

  			this.index = index;

  		}

  	},

  	addAttribute: function ( name, attribute ) {

  		if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {

  			console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

  			this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

  			return;

  		}

  		if ( name === 'index' ) {

  			console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
  			this.setIndex( attribute );

  			return;

  		}

  		this.attributes[ name ] = attribute;

  		return this;

  	},

  	getAttribute: function ( name ) {

  		return this.attributes[ name ];

  	},

  	removeAttribute: function ( name ) {

  		delete this.attributes[ name ];

  		return this;

  	},

  	addGroup: function ( start, count, materialIndex ) {

  		this.groups.push( {

  			start: start,
  			count: count,
  			materialIndex: materialIndex !== undefined ? materialIndex : 0

  		} );

  	},

  	clearGroups: function () {

  		this.groups = [];

  	},

  	setDrawRange: function ( start, count ) {

  		this.drawRange.start = start;
  		this.drawRange.count = count;

  	},

  	applyMatrix: function ( matrix ) {

  		var position = this.attributes.position;

  		if ( position !== undefined ) {

  			matrix.applyToBufferAttribute( position );
  			position.needsUpdate = true;

  		}

  		var normal = this.attributes.normal;

  		if ( normal !== undefined ) {

  			var normalMatrix = new Matrix3().getNormalMatrix( matrix );

  			normalMatrix.applyToBufferAttribute( normal );
  			normal.needsUpdate = true;

  		}

  		if ( this.boundingBox !== null ) {

  			this.computeBoundingBox();

  		}

  		if ( this.boundingSphere !== null ) {

  			this.computeBoundingSphere();

  		}

  		return this;

  	},

  	rotateX: function () {

  		// rotate geometry around world x-axis

  		var m1 = new Matrix4();

  		return function rotateX( angle ) {

  			m1.makeRotationX( angle );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	rotateY: function () {

  		// rotate geometry around world y-axis

  		var m1 = new Matrix4();

  		return function rotateY( angle ) {

  			m1.makeRotationY( angle );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	rotateZ: function () {

  		// rotate geometry around world z-axis

  		var m1 = new Matrix4();

  		return function rotateZ( angle ) {

  			m1.makeRotationZ( angle );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	translate: function () {

  		// translate geometry

  		var m1 = new Matrix4();

  		return function translate( x, y, z ) {

  			m1.makeTranslation( x, y, z );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	scale: function () {

  		// scale geometry

  		var m1 = new Matrix4();

  		return function scale( x, y, z ) {

  			m1.makeScale( x, y, z );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	lookAt: function () {

  		var obj = new Object3D();

  		return function lookAt( vector ) {

  			obj.lookAt( vector );

  			obj.updateMatrix();

  			this.applyMatrix( obj.matrix );

  		};

  	}(),

  	center: function () {

  		this.computeBoundingBox();

  		var offset = this.boundingBox.getCenter().negate();

  		this.translate( offset.x, offset.y, offset.z );

  		return offset;

  	},

  	setFromObject: function ( object ) {

  		// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

  		var geometry = object.geometry;

  		if ( object.isPoints || object.isLine ) {

  			var positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );
  			var colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );

  			this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
  			this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

  			if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

  				var lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );

  				this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

  			}

  			if ( geometry.boundingSphere !== null ) {

  				this.boundingSphere = geometry.boundingSphere.clone();

  			}

  			if ( geometry.boundingBox !== null ) {

  				this.boundingBox = geometry.boundingBox.clone();

  			}

  		} else if ( object.isMesh ) {

  			if ( geometry && geometry.isGeometry ) {

  				this.fromGeometry( geometry );

  			}

  		}

  		return this;

  	},

  	updateFromObject: function ( object ) {

  		var geometry = object.geometry;

  		if ( object.isMesh ) {

  			var direct = geometry.__directGeometry;

  			if ( geometry.elementsNeedUpdate === true ) {

  				direct = undefined;
  				geometry.elementsNeedUpdate = false;

  			}

  			if ( direct === undefined ) {

  				return this.fromGeometry( geometry );

  			}

  			direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
  			direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
  			direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
  			direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
  			direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

  			geometry.verticesNeedUpdate = false;
  			geometry.normalsNeedUpdate = false;
  			geometry.colorsNeedUpdate = false;
  			geometry.uvsNeedUpdate = false;
  			geometry.groupsNeedUpdate = false;

  			geometry = direct;

  		}

  		var attribute;

  		if ( geometry.verticesNeedUpdate === true ) {

  			attribute = this.attributes.position;

  			if ( attribute !== undefined ) {

  				attribute.copyVector3sArray( geometry.vertices );
  				attribute.needsUpdate = true;

  			}

  			geometry.verticesNeedUpdate = false;

  		}

  		if ( geometry.normalsNeedUpdate === true ) {

  			attribute = this.attributes.normal;

  			if ( attribute !== undefined ) {

  				attribute.copyVector3sArray( geometry.normals );
  				attribute.needsUpdate = true;

  			}

  			geometry.normalsNeedUpdate = false;

  		}

  		if ( geometry.colorsNeedUpdate === true ) {

  			attribute = this.attributes.color;

  			if ( attribute !== undefined ) {

  				attribute.copyColorsArray( geometry.colors );
  				attribute.needsUpdate = true;

  			}

  			geometry.colorsNeedUpdate = false;

  		}

  		if ( geometry.uvsNeedUpdate ) {

  			attribute = this.attributes.uv;

  			if ( attribute !== undefined ) {

  				attribute.copyVector2sArray( geometry.uvs );
  				attribute.needsUpdate = true;

  			}

  			geometry.uvsNeedUpdate = false;

  		}

  		if ( geometry.lineDistancesNeedUpdate ) {

  			attribute = this.attributes.lineDistance;

  			if ( attribute !== undefined ) {

  				attribute.copyArray( geometry.lineDistances );
  				attribute.needsUpdate = true;

  			}

  			geometry.lineDistancesNeedUpdate = false;

  		}

  		if ( geometry.groupsNeedUpdate ) {

  			geometry.computeGroups( object.geometry );
  			this.groups = geometry.groups;

  			geometry.groupsNeedUpdate = false;

  		}

  		return this;

  	},

  	fromGeometry: function ( geometry ) {

  		geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );

  		return this.fromDirectGeometry( geometry.__directGeometry );

  	},

  	fromDirectGeometry: function ( geometry ) {
  		var this$1 = this;


  		var positions = new Float32Array( geometry.vertices.length * 3 );
  		this.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

  		if ( geometry.normals.length > 0 ) {

  			var normals = new Float32Array( geometry.normals.length * 3 );
  			this.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

  		}

  		if ( geometry.colors.length > 0 ) {

  			var colors = new Float32Array( geometry.colors.length * 3 );
  			this.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

  		}

  		if ( geometry.uvs.length > 0 ) {

  			var uvs = new Float32Array( geometry.uvs.length * 2 );
  			this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

  		}

  		if ( geometry.uvs2.length > 0 ) {

  			var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
  			this.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

  		}

  		if ( geometry.indices.length > 0 ) {

  			var TypeArray = arrayMax( geometry.indices ) > 65535 ? Uint32Array : Uint16Array;
  			var indices = new TypeArray( geometry.indices.length * 3 );
  			this.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );

  		}

  		// groups

  		this.groups = geometry.groups;

  		// morphs

  		for ( var name in geometry.morphTargets ) {

  			var array = [];
  			var morphTargets = geometry.morphTargets[ name ];

  			for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

  				var morphTarget = morphTargets[ i ];

  				var attribute = new Float32BufferAttribute( morphTarget.length * 3, 3 );

  				array.push( attribute.copyVector3sArray( morphTarget ) );

  			}

  			this$1.morphAttributes[ name ] = array;

  		}

  		// skinning

  		if ( geometry.skinIndices.length > 0 ) {

  			var skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );
  			this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

  		}

  		if ( geometry.skinWeights.length > 0 ) {

  			var skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );
  			this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

  		}

  		//

  		if ( geometry.boundingSphere !== null ) {

  			this.boundingSphere = geometry.boundingSphere.clone();

  		}

  		if ( geometry.boundingBox !== null ) {

  			this.boundingBox = geometry.boundingBox.clone();

  		}

  		return this;

  	},

  	computeBoundingBox: function () {

  		if ( this.boundingBox === null ) {

  			this.boundingBox = new Box3();

  		}

  		var position = this.attributes.position;

  		if ( position !== undefined ) {

  			this.boundingBox.setFromBufferAttribute( position );

  		} else {

  			this.boundingBox.makeEmpty();

  		}

  		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

  			console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

  		}

  	},

  	computeBoundingSphere: function () {

  		var box = new Box3();
  		var vector = new Vector3$1();

  		return function computeBoundingSphere() {

  			if ( this.boundingSphere === null ) {

  				this.boundingSphere = new Sphere();

  			}

  			var position = this.attributes.position;

  			if ( position ) {

  				var center = this.boundingSphere.center;

  				box.setFromBufferAttribute( position );
  				box.getCenter( center );

  				// hoping to find a boundingSphere with a radius smaller than the
  				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

  				var maxRadiusSq = 0;

  				for ( var i = 0, il = position.count; i < il; i ++ ) {

  					vector.x = position.getX( i );
  					vector.y = position.getY( i );
  					vector.z = position.getZ( i );
  					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

  				}

  				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

  				if ( isNaN( this.boundingSphere.radius ) ) {

  					console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

  				}

  			}

  		};

  	}(),

  	computeFaceNormals: function () {

  		// backwards compatibility

  	},

  	computeVertexNormals: function () {

  		var index = this.index;
  		var attributes = this.attributes;
  		var groups = this.groups;

  		if ( attributes.position ) {

  			var positions = attributes.position.array;

  			if ( attributes.normal === undefined ) {

  				this.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );

  			} else {

  				// reset existing normals to zero

  				var array = attributes.normal.array;

  				for ( var i = 0, il = array.length; i < il; i ++ ) {

  					array[ i ] = 0;

  				}

  			}

  			var normals = attributes.normal.array;

  			var vA, vB, vC;
  			var pA = new Vector3$1(), pB = new Vector3$1(), pC = new Vector3$1();
  			var cb = new Vector3$1(), ab = new Vector3$1();

  			// indexed elements

  			if ( index ) {

  				var indices = index.array;

  				if ( groups.length === 0 ) {

  					this.addGroup( 0, indices.length );

  				}

  				for ( var j = 0, jl = groups.length; j < jl; ++ j ) {

  					var group = groups[ j ];

  					var start = group.start;
  					var count = group.count;

  					for ( var i = start, il = start + count; i < il; i += 3 ) {

  						vA = indices[ i + 0 ] * 3;
  						vB = indices[ i + 1 ] * 3;
  						vC = indices[ i + 2 ] * 3;

  						pA.fromArray( positions, vA );
  						pB.fromArray( positions, vB );
  						pC.fromArray( positions, vC );

  						cb.subVectors( pC, pB );
  						ab.subVectors( pA, pB );
  						cb.cross( ab );

  						normals[ vA ] += cb.x;
  						normals[ vA + 1 ] += cb.y;
  						normals[ vA + 2 ] += cb.z;

  						normals[ vB ] += cb.x;
  						normals[ vB + 1 ] += cb.y;
  						normals[ vB + 2 ] += cb.z;

  						normals[ vC ] += cb.x;
  						normals[ vC + 1 ] += cb.y;
  						normals[ vC + 2 ] += cb.z;

  					}

  				}

  			} else {

  				// non-indexed elements (unconnected triangle soup)

  				for ( var i = 0, il = positions.length; i < il; i += 9 ) {

  					pA.fromArray( positions, i );
  					pB.fromArray( positions, i + 3 );
  					pC.fromArray( positions, i + 6 );

  					cb.subVectors( pC, pB );
  					ab.subVectors( pA, pB );
  					cb.cross( ab );

  					normals[ i ] = cb.x;
  					normals[ i + 1 ] = cb.y;
  					normals[ i + 2 ] = cb.z;

  					normals[ i + 3 ] = cb.x;
  					normals[ i + 4 ] = cb.y;
  					normals[ i + 5 ] = cb.z;

  					normals[ i + 6 ] = cb.x;
  					normals[ i + 7 ] = cb.y;
  					normals[ i + 8 ] = cb.z;

  				}

  			}

  			this.normalizeNormals();

  			attributes.normal.needsUpdate = true;

  		}

  	},

  	merge: function ( geometry, offset ) {

  		if ( ! ( geometry && geometry.isBufferGeometry ) ) {

  			console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
  			return;

  		}

  		if ( offset === undefined ) { offset = 0; }

  		var attributes = this.attributes;

  		for ( var key in attributes ) {

  			if ( geometry.attributes[ key ] === undefined ) { continue; }

  			var attribute1 = attributes[ key ];
  			var attributeArray1 = attribute1.array;

  			var attribute2 = geometry.attributes[ key ];
  			var attributeArray2 = attribute2.array;

  			var attributeSize = attribute2.itemSize;

  			for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

  				attributeArray1[ j ] = attributeArray2[ i ];

  			}

  		}

  		return this;

  	},

  	normalizeNormals: function () {

  		var vector = new Vector3$1();

  		return function normalizeNormals() {

  			var normals = this.attributes.normal;

  			for ( var i = 0, il = normals.count; i < il; i ++ ) {

  				vector.x = normals.getX( i );
  				vector.y = normals.getY( i );
  				vector.z = normals.getZ( i );

  				vector.normalize();

  				normals.setXYZ( i, vector.x, vector.y, vector.z );

  			}

  		};

  	}(),

  	toNonIndexed: function () {

  		if ( this.index === null ) {

  			console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
  			return this;

  		}

  		var geometry2 = new BufferGeometry();

  		var indices = this.index.array;
  		var attributes = this.attributes;

  		for ( var name in attributes ) {

  			var attribute = attributes[ name ];

  			var array = attribute.array;
  			var itemSize = attribute.itemSize;

  			var array2 = new array.constructor( indices.length * itemSize );

  			var index = 0, index2 = 0;

  			for ( var i = 0, l = indices.length; i < l; i ++ ) {

  				index = indices[ i ] * itemSize;

  				for ( var j = 0; j < itemSize; j ++ ) {

  					array2[ index2 ++ ] = array[ index ++ ];

  				}

  			}

  			geometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );

  		}

  		return geometry2;

  	},

  	toJSON: function () {

  		var data = {
  			metadata: {
  				version: 4.5,
  				type: 'BufferGeometry',
  				generator: 'BufferGeometry.toJSON'
  			}
  		};

  		// standard BufferGeometry serialization

  		data.uuid = this.uuid;
  		data.type = this.type;
  		if ( this.name !== '' ) { data.name = this.name; }

  		if ( this.parameters !== undefined ) {

  			var parameters = this.parameters;

  			for ( var key in parameters ) {

  				if ( parameters[ key ] !== undefined ) { data[ key ] = parameters[ key ]; }

  			}

  			return data;

  		}

  		data.data = { attributes: {} };

  		var index = this.index;

  		if ( index !== null ) {

  			var array = Array.prototype.slice.call( index.array );

  			data.data.index = {
  				type: index.array.constructor.name,
  				array: array
  			};

  		}

  		var attributes = this.attributes;

  		for ( var key in attributes ) {

  			var attribute = attributes[ key ];

  			var array = Array.prototype.slice.call( attribute.array );

  			data.data.attributes[ key ] = {
  				itemSize: attribute.itemSize,
  				type: attribute.array.constructor.name,
  				array: array,
  				normalized: attribute.normalized
  			};

  		}

  		var groups = this.groups;

  		if ( groups.length > 0 ) {

  			data.data.groups = JSON.parse( JSON.stringify( groups ) );

  		}

  		var boundingSphere = this.boundingSphere;

  		if ( boundingSphere !== null ) {

  			data.data.boundingSphere = {
  				center: boundingSphere.center.toArray(),
  				radius: boundingSphere.radius
  			};

  		}

  		return data;

  	},

  	clone: function () {

  		/*
  		 // Handle primitives

  		 var parameters = this.parameters;

  		 if ( parameters !== undefined ) {

  		 var values = [];

  		 for ( var key in parameters ) {

  		 values.push( parameters[ key ] );

  		 }

  		 var geometry = Object.create( this.constructor.prototype );
  		 this.constructor.apply( geometry, values );
  		 return geometry;

  		 }

  		 return new this.constructor().copy( this );
  		 */

  		return new BufferGeometry().copy( this );

  	},

  	copy: function ( source ) {
  		var this$1 = this;


  		var name, i, l;

  		// reset

  		this.index = null;
  		this.attributes = {};
  		this.morphAttributes = {};
  		this.groups = [];
  		this.boundingBox = null;
  		this.boundingSphere = null;

  		// name

  		this.name = source.name;

  		// index

  		var index = source.index;

  		if ( index !== null ) {

  			this.setIndex( index.clone() );

  		}

  		// attributes

  		var attributes = source.attributes;

  		for ( name in attributes ) {

  			var attribute = attributes[ name ];
  			this$1.addAttribute( name, attribute.clone() );

  		}

  		// morph attributes

  		var morphAttributes = source.morphAttributes;

  		for ( name in morphAttributes ) {

  			var array = [];
  			var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

  			for ( i = 0, l = morphAttribute.length; i < l; i ++ ) {

  				array.push( morphAttribute[ i ].clone() );

  			}

  			this$1.morphAttributes[ name ] = array;

  		}

  		// groups

  		var groups = source.groups;

  		for ( i = 0, l = groups.length; i < l; i ++ ) {

  			var group = groups[ i ];
  			this$1.addGroup( group.start, group.count, group.materialIndex );

  		}

  		// bounding box

  		var boundingBox = source.boundingBox;

  		if ( boundingBox !== null ) {

  			this.boundingBox = boundingBox.clone();

  		}

  		// bounding sphere

  		var boundingSphere = source.boundingSphere;

  		if ( boundingSphere !== null ) {

  			this.boundingSphere = boundingSphere.clone();

  		}

  		// draw range

  		this.drawRange.start = source.drawRange.start;
  		this.drawRange.count = source.drawRange.count;

  		return this;

  	},

  	dispose: function () {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   * @author mikael emtinger / http://gomo.se/
   * @author jonobr1 / http://jonobr1.com/
   */

  function Mesh( geometry, material ) {

  	Object3D.call( this );

  	this.type = 'Mesh';

  	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
  	this.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );

  	this.drawMode = TrianglesDrawMode;

  	this.updateMorphTargets();

  }

  Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {

  	constructor: Mesh,

  	isMesh: true,

  	setDrawMode: function ( value ) {

  		this.drawMode = value;

  	},

  	copy: function ( source ) {

  		Object3D.prototype.copy.call( this, source );

  		this.drawMode = source.drawMode;

  		return this;

  	},

  	updateMorphTargets: function () {
  		var this$1 = this;


  		var geometry = this.geometry;
  		var m, ml, name;

  		if ( geometry.isBufferGeometry ) {

  			var morphAttributes = geometry.morphAttributes;
  			var keys = Object.keys( morphAttributes );

  			if ( keys.length > 0 ) {

  				var morphAttribute = morphAttributes[ keys[ 0 ] ];

  				if ( morphAttribute !== undefined ) {

  					this.morphTargetInfluences = [];
  					this.morphTargetDictionary = {};

  					for ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

  						name = morphAttribute[ m ].name || String( m );

  						this$1.morphTargetInfluences.push( 0 );
  						this$1.morphTargetDictionary[ name ] = m;

  					}

  				}

  			}

  		} else {

  			var morphTargets = geometry.morphTargets;

  			if ( morphTargets !== undefined && morphTargets.length > 0 ) {

  				this.morphTargetInfluences = [];
  				this.morphTargetDictionary = {};

  				for ( m = 0, ml = morphTargets.length; m < ml; m ++ ) {

  					name = morphTargets[ m ].name || String( m );

  					this$1.morphTargetInfluences.push( 0 );
  					this$1.morphTargetDictionary[ name ] = m;

  				}

  			}

  		}

  	},

  	raycast: ( function () {

  		var inverseMatrix = new Matrix4();
  		var ray = new Ray();
  		var sphere = new Sphere();

  		var vA = new Vector3$1();
  		var vB = new Vector3$1();
  		var vC = new Vector3$1();

  		var tempA = new Vector3$1();
  		var tempB = new Vector3$1();
  		var tempC = new Vector3$1();

  		var uvA = new Vector2();
  		var uvB = new Vector2();
  		var uvC = new Vector2();

  		var barycoord = new Vector3$1();

  		var intersectionPoint = new Vector3$1();
  		var intersectionPointWorld = new Vector3$1();

  		function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

  			Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );

  			uv1.multiplyScalar( barycoord.x );
  			uv2.multiplyScalar( barycoord.y );
  			uv3.multiplyScalar( barycoord.z );

  			uv1.add( uv2 ).add( uv3 );

  			return uv1.clone();

  		}

  		function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

  			var intersect;

  			if ( material.side === BackSide ) {

  				intersect = ray.intersectTriangle( pC, pB, pA, true, point );

  			} else {

  				intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

  			}

  			if ( intersect === null ) { return null; }

  			intersectionPointWorld.copy( point );
  			intersectionPointWorld.applyMatrix4( object.matrixWorld );

  			var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

  			if ( distance < raycaster.near || distance > raycaster.far ) { return null; }

  			return {
  				distance: distance,
  				point: intersectionPointWorld.clone(),
  				object: object
  			};

  		}

  		function checkBufferGeometryIntersection( object, raycaster, ray, position, uv, a, b, c ) {

  			vA.fromBufferAttribute( position, a );
  			vB.fromBufferAttribute( position, b );
  			vC.fromBufferAttribute( position, c );

  			var intersection = checkIntersection( object, object.material, raycaster, ray, vA, vB, vC, intersectionPoint );

  			if ( intersection ) {

  				if ( uv ) {

  					uvA.fromBufferAttribute( uv, a );
  					uvB.fromBufferAttribute( uv, b );
  					uvC.fromBufferAttribute( uv, c );

  					intersection.uv = uvIntersection( intersectionPoint, vA, vB, vC, uvA, uvB, uvC );

  				}

  				intersection.face = new Face3$1( a, b, c, Triangle.normal( vA, vB, vC ) );
  				intersection.faceIndex = a;

  			}

  			return intersection;

  		}

  		return function raycast( raycaster, intersects ) {
  			var this$1 = this;


  			var geometry = this.geometry;
  			var material = this.material;
  			var matrixWorld = this.matrixWorld;

  			if ( material === undefined ) { return; }

  			// Checking boundingSphere distance to ray

  			if ( geometry.boundingSphere === null ) { geometry.computeBoundingSphere(); }

  			sphere.copy( geometry.boundingSphere );
  			sphere.applyMatrix4( matrixWorld );

  			if ( raycaster.ray.intersectsSphere( sphere ) === false ) { return; }

  			//

  			inverseMatrix.getInverse( matrixWorld );
  			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

  			// Check boundingBox before continuing

  			if ( geometry.boundingBox !== null ) {

  				if ( ray.intersectsBox( geometry.boundingBox ) === false ) { return; }

  			}

  			var intersection;

  			if ( geometry.isBufferGeometry ) {

  				var a, b, c;
  				var index = geometry.index;
  				var position = geometry.attributes.position;
  				var uv = geometry.attributes.uv;
  				var i, l;

  				if ( index !== null ) {

  					// indexed buffer geometry

  					for ( i = 0, l = index.count; i < l; i += 3 ) {

  						a = index.getX( i );
  						b = index.getX( i + 1 );
  						c = index.getX( i + 2 );

  						intersection = checkBufferGeometryIntersection( this$1, raycaster, ray, position, uv, a, b, c );

  						if ( intersection ) {

  							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
  							intersects.push( intersection );

  						}

  					}

  				} else if ( position !== undefined ) {

  					// non-indexed buffer geometry

  					for ( i = 0, l = position.count; i < l; i += 3 ) {

  						a = i;
  						b = i + 1;
  						c = i + 2;

  						intersection = checkBufferGeometryIntersection( this$1, raycaster, ray, position, uv, a, b, c );

  						if ( intersection ) {

  							intersection.index = a; // triangle number in positions buffer semantics
  							intersects.push( intersection );

  						}

  					}

  				}

  			} else if ( geometry.isGeometry ) {

  				var fvA, fvB, fvC;
  				var isMultiMaterial = Array.isArray( material );

  				var vertices = geometry.vertices;
  				var faces = geometry.faces;
  				var uvs;

  				var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
  				if ( faceVertexUvs.length > 0 ) { uvs = faceVertexUvs; }

  				for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

  					var face = faces[ f ];
  					var faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;

  					if ( faceMaterial === undefined ) { continue; }

  					fvA = vertices[ face.a ];
  					fvB = vertices[ face.b ];
  					fvC = vertices[ face.c ];

  					if ( faceMaterial.morphTargets === true ) {

  						var morphTargets = geometry.morphTargets;
  						var morphInfluences = this$1.morphTargetInfluences;

  						vA.set( 0, 0, 0 );
  						vB.set( 0, 0, 0 );
  						vC.set( 0, 0, 0 );

  						for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

  							var influence = morphInfluences[ t ];

  							if ( influence === 0 ) { continue; }

  							var targets = morphTargets[ t ].vertices;

  							vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
  							vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
  							vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );

  						}

  						vA.add( fvA );
  						vB.add( fvB );
  						vC.add( fvC );

  						fvA = vA;
  						fvB = vB;
  						fvC = vC;

  					}

  					intersection = checkIntersection( this$1, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint );

  					if ( intersection ) {

  						if ( uvs && uvs[ f ] ) {

  							var uvs_f = uvs[ f ];
  							uvA.copy( uvs_f[ 0 ] );
  							uvB.copy( uvs_f[ 1 ] );
  							uvC.copy( uvs_f[ 2 ] );

  							intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );

  						}

  						intersection.face = face;
  						intersection.faceIndex = f;
  						intersects.push( intersection );

  					}

  				}

  			}

  		};

  	}() ),

  	clone: function () {

  		return new this.constructor( this.geometry, this.material ).copy( this );

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  specular: <hex>,
   *  shininess: <float>,
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  emissive: <hex>,
   *  emissiveIntensity: <float>
   *  emissiveMap: new THREE.Texture( <Image> ),
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  specularMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
   *  combine: THREE.Multiply,
   *  reflectivity: <float>,
   *  refractionRatio: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */

  function MeshPhongMaterial( parameters ) {

  	Material.call( this );

  	this.type = 'MeshPhongMaterial';

  	this.color = new Color( 0xffffff ); // diffuse
  	this.specular = new Color( 0x111111 );
  	this.shininess = 30;

  	this.map = null;

  	this.lightMap = null;
  	this.lightMapIntensity = 1.0;

  	this.aoMap = null;
  	this.aoMapIntensity = 1.0;

  	this.emissive = new Color( 0x000000 );
  	this.emissiveIntensity = 1.0;
  	this.emissiveMap = null;

  	this.bumpMap = null;
  	this.bumpScale = 1;

  	this.normalMap = null;
  	this.normalScale = new Vector2( 1, 1 );

  	this.displacementMap = null;
  	this.displacementScale = 1;
  	this.displacementBias = 0;

  	this.specularMap = null;

  	this.alphaMap = null;

  	this.envMap = null;
  	this.combine = MultiplyOperation;
  	this.reflectivity = 1;
  	this.refractionRatio = 0.98;

  	this.wireframe = false;
  	this.wireframeLinewidth = 1;
  	this.wireframeLinecap = 'round';
  	this.wireframeLinejoin = 'round';

  	this.skinning = false;
  	this.morphTargets = false;
  	this.morphNormals = false;

  	this.setValues( parameters );

  }

  MeshPhongMaterial.prototype = Object.create( Material.prototype );
  MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;

  MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

  MeshPhongMaterial.prototype.copy = function ( source ) {

  	Material.prototype.copy.call( this, source );

  	this.color.copy( source.color );
  	this.specular.copy( source.specular );
  	this.shininess = source.shininess;

  	this.map = source.map;

  	this.lightMap = source.lightMap;
  	this.lightMapIntensity = source.lightMapIntensity;

  	this.aoMap = source.aoMap;
  	this.aoMapIntensity = source.aoMapIntensity;

  	this.emissive.copy( source.emissive );
  	this.emissiveMap = source.emissiveMap;
  	this.emissiveIntensity = source.emissiveIntensity;

  	this.bumpMap = source.bumpMap;
  	this.bumpScale = source.bumpScale;

  	this.normalMap = source.normalMap;
  	this.normalScale.copy( source.normalScale );

  	this.displacementMap = source.displacementMap;
  	this.displacementScale = source.displacementScale;
  	this.displacementBias = source.displacementBias;

  	this.specularMap = source.specularMap;

  	this.alphaMap = source.alphaMap;

  	this.envMap = source.envMap;
  	this.combine = source.combine;
  	this.reflectivity = source.reflectivity;
  	this.refractionRatio = source.refractionRatio;

  	this.wireframe = source.wireframe;
  	this.wireframeLinewidth = source.wireframeLinewidth;
  	this.wireframeLinecap = source.wireframeLinecap;
  	this.wireframeLinejoin = source.wireframeLinejoin;

  	this.skinning = source.skinning;
  	this.morphTargets = source.morphTargets;
  	this.morphNormals = source.morphNormals;

  	return this;

  };

  /**
   * @author [Tristan Valcke]{@link https://github.com/Itee}
   * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
   *
   * @class TUniversalLoader
   * @classdesc The TUniversalLoader allow to automatically select correct THREE loader for given files. (based on https://github.com/jeromeetienne/threex.universalloader)
   * @example Todo...
   *
   */

  /* eslint-env browser */

  //import { STLLoader } from '../../builds/tmp/STLLoader'
  //import { OBJLoader } from '../../builds/tmp/OBJLoader'
  //import { FBXLoader2 } from '../../builds/tmp/FBXLoader2'
  //import { MTLLoader } from '../../builds/tmp/MTLLoader'
  //
  //import { ASCLoader } from '../../javascript/webgl/ASCLoader'

  function onError ( error ) {
      console.error( error );
  }

  function onProgress ( progressEvent ) {

      if ( progressEvent.lengthComputable ) {

          var percentComplete = progressEvent.loaded / progressEvent.total * 100;
          console.log( Math.round( percentComplete ) + '% downloaded' );

      }
  }

  function TUniversalLoader () {

  //    this.stlLoader = new STLLoader()
  //    this.ascLoader = new ASCLoader()
  //    this.fbxLoader = new FBXLoader2()
  //    this.objLoader = new OBJLoader()
  //    this.mtlLoader = new MTLLoader()

      this.stlLoader = {};
      this.ascLoader = {};
      this.fbxLoader = {};
      this.objLoader = {};
      this.mtlLoader = {};

  }

  Object.assign( TUniversalLoader.prototype, {

      load: function ( urls, onLoad, fromBlob, params ) {
          var this$1 = this;


          console.log( "TUniversalLoader.load" );
          if ( !urls ) {
              console.error( "Unable to load null or undefined urls !" );
              return
          }

          var _fromBlob       = (typeof (fromBlob) === 'boolean') ? fromBlob : false;
          var urlsConstructor = urls.constructor;

          if ( urlsConstructor === String ) {

              this.loadSingleFile( urls, onLoad, _fromBlob, params );

          } else if ( urlsConstructor === Array ) {

              if ( (urls.length === 2) && (urls[ 0 ].constructor === String) ) {
                  this.loadAssociatedFiles( urls, onLoad, _fromBlob, params );
              } else {

                  var url              = undefined;
                  var childConstructor = undefined;
                  for ( var i = 0, numberOfUrls = urls.length ; i < numberOfUrls ; i++ ) {

                      url              = urls[ i ];
                      childConstructor = url.constructor;

                      if ( childConstructor === Array ) {

                          this$1.loadAssociatedFiles( url, onLoad, _fromBlob, params );

                      } else if ( childConstructor === String ) {

                          this$1.loadSingleFile( url, onLoad, _fromBlob, params );

                      } else {

                          console.error( 'Invalid child url' );

                      }

                  }

              }

          } else if ( urlsConstructor === Function ) {

              var _urls = urls();
              this.load( _urls, onLoad, fromBlob, params );

          } else {

              console.error( 'Invalid url' );

          }

      },

      loadSingleFile: function ( url, onLoad, fromBlob, params ) {

          var filePath = url.substring( 0, url.lastIndexOf( '/' ) );
          var fileName = url.substring( url.lastIndexOf( '/' ) + 1 );
          var loadUrl  = (fromBlob) ? filePath : url;

          if ( fileName.match( /\.stl$/i ) ) {

              this.stlLoader.load(
                  loadUrl,
                  function ( geometry ) {

                      var material = new MeshPhongMaterial();
                      var object3d = new Mesh( geometry, material );
                      onLoad( object3d );

                  },
                  onProgress,
                  onError
              );

          } else if ( fileName.match( /\.rzml/i ) ) {

              this.rzmlLoader.load(
                  loadUrl,
                  onLoad,
                  onProgress,
                  onError
              );

          } else if ( fileName.match( /\.asc$/i ) ) {

              this.ascLoader.load(
                  loadUrl,
                  onLoad,
                  onProgress,
                  onError,
                  params
              );

          } else if ( fileName.match( /\.fbx$/i ) ) {

              this.fbxLoader.load(
                  loadUrl,
                  onLoad,
                  onProgress,
                  onError
              );

          } else if ( fileName.match( /\.obj$/i ) ) {

              this.objLoader.load(
                  loadUrl,
                  onLoad,
                  onProgress,
                  onError
              );

          } else {

              console.error( 'Unknown file type:' + fileName );

          }

      },

      // Todo: need to break texture resolution dependency and conert as params
      loadAssociatedFiles: function ( urls, onLoad, fromBlob, textureResolution ) {

          var TEXTURE_RESOLUTION = (textureResolution) ? textureResolution : "256";

          var firstUrl      = urls[ 0 ];
          var firstFilePath = firstUrl.substring( 0, firstUrl.lastIndexOf( '/' ) );
          var firstFileName = firstUrl.substring( firstUrl.lastIndexOf( '/' ) + 1 );
          var firstLoadUrl  = (fromBlob) ? firstFilePath : firstUrl;

          var secondUrl      = urls[ 1 ];
          var secondFilePath = secondUrl.substring( 0, secondUrl.lastIndexOf( '/' ) );
          var secondFileName = secondUrl.substring( secondUrl.lastIndexOf( '/' ) + 1 );
          var secondLoadUrl  = (fromBlob) ? secondFilePath : secondUrl;

          if ( firstFileName.match( /\.mtl$/i ) && secondFileName.match( /\.obj$/i ) ) {

              var mtlLoader = new MTLLoader();
              var objLoader = new OBJLoader();
              mtlLoader.setTexturePath( firstFilePath + '/textures/' + TEXTURE_RESOLUTION + '/' );
              mtlLoader.load( firstLoadUrl, function ( materials ) {
                  materials.preload();

                  objLoader.setMaterials( materials );
                  objLoader.load( secondLoadUrl, function ( object3d ) {
                      onLoad( object3d );
                  } );
              }.bind( this ) );

          } else if ( firstFileName.match( /\.obj$/i ) && secondFileName.match( /\.mtl$/i ) ) {

              var mtlLoader = new MTLLoader();
              var objLoader = new OBJLoader();
              mtlLoader.setTexturePath( secondFilePath + '/textures/' + TEXTURE_RESOLUTION + '/' );
              mtlLoader.load( secondLoadUrl, function ( materials ) {

                  materials.preload();

                  objLoader.setMaterials( materials );
                  objLoader.load( firstLoadUrl, function ( object3d ) {

                      onLoad( object3d );

                  } );

              }.bind( this ) );

          } else {

              this.loadSingleFile( urls[ 0 ], onLoad, fromBlob, params );
              this.loadSingleFile( urls[ 1 ], onLoad, fromBlob, params );
              console.error( 'Unknown file type' );

          }

      }

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *  map: new THREE.Texture( <Image> ),
   *
   *  size: <float>,
   *  sizeAttenuation: <bool>
   * }
   */

  function PointsMaterial( parameters ) {

  	Material.call( this );

  	this.type = 'PointsMaterial';

  	this.color = new Color( 0xffffff );

  	this.map = null;

  	this.size = 1;
  	this.sizeAttenuation = true;

  	this.lights = false;

  	this.setValues( parameters );

  }

  PointsMaterial.prototype = Object.create( Material.prototype );
  PointsMaterial.prototype.constructor = PointsMaterial;

  PointsMaterial.prototype.isPointsMaterial = true;

  PointsMaterial.prototype.copy = function ( source ) {

  	Material.prototype.copy.call( this, source );

  	this.color.copy( source.color );

  	this.map = source.map;

  	this.size = source.size;
  	this.sizeAttenuation = source.sizeAttenuation;

  	return this;

  };

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function Points( geometry, material ) {

  	Object3D.call( this );

  	this.type = 'Points';

  	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
  	this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );

  }

  Points.prototype = Object.assign( Object.create( Object3D.prototype ), {

  	constructor: Points,

  	isPoints: true,

  	raycast: ( function () {

  		var inverseMatrix = new Matrix4();
  		var ray = new Ray();
  		var sphere = new Sphere();

  		return function raycast( raycaster, intersects ) {

  			var object = this;
  			var geometry = this.geometry;
  			var matrixWorld = this.matrixWorld;
  			var threshold = raycaster.params.Points.threshold;

  			// Checking boundingSphere distance to ray

  			if ( geometry.boundingSphere === null ) { geometry.computeBoundingSphere(); }

  			sphere.copy( geometry.boundingSphere );
  			sphere.applyMatrix4( matrixWorld );
  			sphere.radius += threshold;

  			if ( raycaster.ray.intersectsSphere( sphere ) === false ) { return; }

  			//

  			inverseMatrix.getInverse( matrixWorld );
  			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

  			var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
  			var localThresholdSq = localThreshold * localThreshold;
  			var position = new Vector3$1();

  			function testPoint( point, index ) {

  				var rayPointDistanceSq = ray.distanceSqToPoint( point );

  				if ( rayPointDistanceSq < localThresholdSq ) {

  					var intersectPoint = ray.closestPointToPoint( point );
  					intersectPoint.applyMatrix4( matrixWorld );

  					var distance = raycaster.ray.origin.distanceTo( intersectPoint );

  					if ( distance < raycaster.near || distance > raycaster.far ) { return; }

  					intersects.push( {

  						distance: distance,
  						distanceToRay: Math.sqrt( rayPointDistanceSq ),
  						point: intersectPoint.clone(),
  						index: index,
  						face: null,
  						object: object

  					} );

  				}

  			}

  			if ( geometry.isBufferGeometry ) {

  				var index = geometry.index;
  				var attributes = geometry.attributes;
  				var positions = attributes.position.array;

  				if ( index !== null ) {

  					var indices = index.array;

  					for ( var i = 0, il = indices.length; i < il; i ++ ) {

  						var a = indices[ i ];

  						position.fromArray( positions, a * 3 );

  						testPoint( position, a );

  					}

  				} else {

  					for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

  						position.fromArray( positions, i * 3 );

  						testPoint( position, i );

  					}

  				}

  			} else {

  				var vertices = geometry.vertices;

  				for ( var i = 0, l = vertices.length; i < l; i ++ ) {

  					testPoint( vertices[ i ], i );

  				}

  			}

  		};

  	}() ),

  	clone: function () {

  		return new this.constructor( this.geometry, this.material ).copy( this );

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function Group() {

  	Object3D.call( this );

  	this.type = 'Group';

  }

  Group.prototype = Object.assign( Object.create( Object3D.prototype ), {

  	constructor: Group

  } );

  /**
   * @author [Tristan Valcke]{@link https://github.com/Itee}
   * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
   *
   * @class TPointsManager
   * @classdesc The TPointsManager allow to get and dump, in a webglviewport, cloud data retrieve from Itee server
   * @example Todo
   *
   */

  /* eslint-env browser */
  /* eslint no-unused-vars: warn */
  /* global $ */

  /**
   *
   * @param viewport
   * @constructor
   */

  function TPointsManager ( viewport ) {

      if( ! viewport ) { throw new Error( 'Unable to create point cloud manager for null or undefined viewport !' ) }

      this._pointCloudsDataMap = new Map();
      this._cameraDistanceMax  = 10.0;
      this._cameraDistanceMin  = 1.0;
      this._samplingMax        = 100;
      this._samplingMin        = 0.0;
      this._viewport           = viewport;
      this._globalOffset       = {
          x: 0,
          y: 0,
          z: 0
      };
      this._pointCloudGroup = new Group();
      this._pointCloudGroup.name = 'PointClouds';

      this._viewport.scene.add( this._pointCloudGroup );

  }

  Object.assign( TPointsManager, {} );

  Object.assign( TPointsManager.prototype, {

      setGlobalOffset: function ( globalOffset ) {

          this._globalOffset = globalOffset;

      },

      setMinimumSamplingLimit: function ( sampling ) {

          this._samplingMin = sampling;

      },

      setMaximumSamplingLimit: function ( sampling ) {

          this._samplingMax = sampling;

      },

      /**
       *
       */
      getPointClouds: function ( onSuccess ) {

          var self = this;

          $.ajax( {
              type:     'GET',
              url:      '/worldcells/',
              dataType: 'json',
              cache:    false,
              success:  function ( worldCells ) {

                  if ( !worldCells || worldCells.length === 0 ) {
                      console.warn( 'Unable to find world cells !' );
                      return
                  }

                  // Create the main point cloud data tree
                  self.createPointCloudDataMap( worldCells );

                  onSuccess();
                  
              },
              error:    function ( jqXHR, textStatus, errorThrown ) {
                  console.log( 'ERRORS: ' + textStatus );
              }
          } );

      },

      createPointCloudDataMap: function ( worldCells ) {
          var this$1 = this;


          var cell = undefined;
          for ( var cellIndex = 0, numberOfCells = worldCells.length ; cellIndex < numberOfCells ; cellIndex++ ) {

              cell = worldCells[ cellIndex ];

              var pointClouds  = cell.cubeDataPoint;
              var pointCloud   = undefined;
              var pointCloudId = undefined;
              for ( var pointCloudIndex = 0, numberOfPointClouds = pointClouds.length ; pointCloudIndex < numberOfPointClouds ; pointCloudIndex++ ) {

                  pointCloud   = pointClouds[ pointCloudIndex ];
                  pointCloudId = pointCloud.id;

                  this$1._pointCloudsDataMap.set( pointCloudId, {
                      id:               pointCloudId,
                      parentCellId:     cell.id,
                      coordinates:      {
                          x: pointCloud.coordinates.x + cell.lambertCoordinates.x,
                          y: pointCloud.coordinates.y + cell.lambertCoordinates.y,
                          z: pointCloud.coordinates.z + cell.lambertCoordinates.z
                      },
                      sampling:         0.0,
                      previousSampling: 0.0,
                      needIncrease:     false, // Only if sampling grows
                      needDecrease:     false // Only if sampling decrease
                  } );

              }

          }

      },

      updatePointClouds: function ( cameraWorldPosition ) {

          var cloudIdsToIncreaseData = [];
          var cloudIdsToDecreaseData  = [];

          this._pointCloudsDataMap.forEach(function( pointCloud ) {

              this.updatePointCloudSampling( pointCloud, cameraWorldPosition );

              if( pointCloud.needIncrease ) {

                  cloudIdsToIncreaseData.push( pointCloud.id );

              } else if ( pointCloud.needDecrease ) {

                  cloudIdsToDecreaseData.push( pointCloud.id );

              } else {

                  // nothings

              }

          }.bind(this));

          this.increasePointCloudData( cloudIdsToIncreaseData );
          this.decreasePointCloudData( cloudIdsToDecreaseData );

      },

      updatePointCloudSampling: function ( pointCloud, cameraWorldPosition ) {

          var pointCloudWorldCoordinates = {
              x: pointCloud.coordinates.x - this._globalOffset.x,
              y: pointCloud.coordinates.z - this._globalOffset.z,
              z: -(pointCloud.coordinates.y - this._globalOffset.y)
          };

          // TODO: Could be only power of two instead of a Sqrt !!!
          var distanceToCamera = Math.sqrt(
              Math.pow( (pointCloudWorldCoordinates.x - cameraWorldPosition.x), 2 ) +
              Math.pow( (pointCloudWorldCoordinates.y - cameraWorldPosition.y), 2 ) +
              Math.pow( (pointCloudWorldCoordinates.z - cameraWorldPosition.z), 2 )
          );

          var sampling = this.getSamplingForDistanceToCamera( distanceToCamera );

          if( sampling > pointCloud.sampling ) {

              pointCloud.needIncrease = true;
              pointCloud.needDecrease = false;

          } else if( sampling < pointCloud.sampling ) {

              pointCloud.needIncrease = false;
              pointCloud.needDecrease = true;

          } else {

              pointCloud.needIncrease = false;
              pointCloud.needDecrease = false;

          }

          pointCloud.previousSampling = pointCloud.sampling;
          pointCloud.sampling         = sampling;

      },

      /**
       *
       * @param distanceToCamera
       * @returns {number}
       */
      getSamplingForDistanceToCamera: function ( distanceToCamera ) {

          // If camera is out limits set default value
          if ( distanceToCamera < this._cameraDistanceMin ) { return this._samplingMax }
          if ( distanceToCamera > this._cameraDistanceMax ) { return this._samplingMin }

  //        var result = (-10 * distanceToCamera) + 100
          var result = (100 / Math.pow( distanceToCamera, 2 ));

          // Round at 2 digit
          var sampling = Math.round( result * 100 ) / 100;

          // Limits sampling in case where function return value outer limits
          if ( sampling < this._samplingMin ) { sampling = this._samplingMin; }
          if ( sampling > this._samplingMax ) { sampling = this._samplingMax; }

          return sampling

      },

      increasePointCloudData: function ( cloudIds ) {

          if( cloudIds.length === 0 ) { return }
          console.log( 'numberOfBuffers to increase: ' + cloudIds.length );


          var self = this;

          var url           = '/pointclouds/';
          var samplingTable = this.createSamplingTable( cloudIds );
          var jsonData      = strMapToJson( samplingTable );

          //        this.requestDataBuffer( url, samplingTable, callback )

          var request          = new XMLHttpRequest();
          request.responseType = 'arraybuffer';
          request.onload       = onLoad;

          request.open( 'POST', url, true );
          request.setRequestHeader( 'Content-Type', 'application/json' );
          request.send( jsonData );

          function onLoad ( data ) {

              var arrayBuffer = data.target.response;
              if ( arrayBuffer.byteLength <= 4 ) { return }

              var buffer          = new DataView( arrayBuffer );
              var numberOfBuffers = buffer.getUint32( 0 );
              if ( numberOfBuffers === 0 ) { return }

  //            console.log( 'numberOfBuffers to extract: ' + numberOfBuffers )

              var NUMBER_OF_BUFFER_VALUE_BYTES_LENGTH = 4; // UInt32
              var SIZES_OF_BUFFER_ARRAY_BYTES_LENGTH    = numberOfBuffers * 4; // UInt32
              var dataOffset                            = NUMBER_OF_BUFFER_VALUE_BYTES_LENGTH + SIZES_OF_BUFFER_ARRAY_BYTES_LENGTH;

              var bufferLength = 0;
              var byteArray    = undefined;
              for ( var bufferIndex = 4 ; bufferIndex <= SIZES_OF_BUFFER_ARRAY_BYTES_LENGTH ; bufferIndex += 4 ) {

                  bufferLength = buffer.getUint32( bufferIndex );
                  byteArray    = new Uint8Array( arrayBuffer, dataOffset, bufferLength );

                  self.addPointsFromBuffer( byteArray );

                  dataOffset += bufferLength;

              }

          }

          function strMapToJson ( strMap ) {

              return JSON.stringify( strMapToObj( strMap ) )

          }

          function strMapToObj ( strMap ) {

              var obj = Object.create( null );

              strMap.forEach( function ( value, key ) {

                  obj[ key ] = value;

              } );

              return obj

          }

      },

      decreasePointCloudData: function ( cloudIds ) {

          if( cloudIds.length === 0 ) { return }
          console.log( 'numberOfBuffers to decrease: ' + cloudIds.length );

          var self = this;

          console.log("Number of children (base): " + self._pointCloudGroup.children.length);
          cloudIds.forEach( function ( cloudId ) {

              var pointCloud3D = self._pointCloudGroup.getObjectByName( cloudId );
              if( ! pointCloud3D ) { return }

              // Get sampling delta to apply
              var pointCloud = self._pointCloudsDataMap.get( cloudId );
              var sampling = pointCloud.sampling;
              var previousSampling = pointCloud.previousSampling;

              var positionBufferAttribute = pointCloud3D.geometry.getAttribute( 'position' );
              var colorBufferAttribute = pointCloud3D.geometry.getAttribute( 'color' );

              // Apply delta sampling to 3d object geometry
              var numberOfPoints = positionBufferAttribute.count;
              if( numberOfPoints === 0 ) { return } // If already empty return

              var numberOfRestPoints = Math.round( ( numberOfPoints * sampling ) / previousSampling );

              var positionSlicedArray = positionBufferAttribute.array.slice( 0, numberOfRestPoints * 3 );
              positionBufferAttribute.setArray( positionSlicedArray );
              positionBufferAttribute.needsUpdate = true;

              var colorSlicedArray = colorBufferAttribute.array.slice( 0, numberOfRestPoints * 3 );
              colorBufferAttribute.setArray( colorSlicedArray );
              colorBufferAttribute.needsUpdate = true;

          } );

      },

      createSamplingTable: function ( cloudIds ) {

          var samplingTable = new Map();
          var sampling      = undefined;

          cloudIds.forEach( function ( cloudId ) {

              sampling = this._pointCloudsDataMap.get( cloudId ).sampling;
              samplingTable.set( cloudId, sampling );

          }.bind( this ) );

          return samplingTable
      },

      requestDataBuffer: function ( url, dataToSend, cloud ) {

          var self = this;

          var oReq = new XMLHttpRequest();
          oReq.open( 'POST', url, true );
          oReq.setRequestHeader( 'Content-Type', 'application/json' );
          oReq.responseType = 'arraybuffer';
          oReq.onload       = function ( oEvent ) {

              var arrayBuffer = oEvent.target.response;
              if ( arrayBuffer.byteLength <= 4 ) { return }

              var buffer          = new DataView( arrayBuffer );
              var numberOfBuffers = buffer.getUint32( 0 );
              if ( numberOfBuffers === 0 ) { return }

              console.log( 'numberOfBuffers to extract: ' + numberOfBuffers );

              var NUMBER_OF_BUFFER_VALUE_BYTES_LENGTH = 4; // UInt32
              var SIZES_OF_BUFFER_ARRAY_BYTES_LENGTH    = numberOfBuffers * 4; // UInt32
              var dataOffset                            = NUMBER_OF_BUFFER_VALUE_BYTES_LENGTH + SIZES_OF_BUFFER_ARRAY_BYTES_LENGTH;

              var bufferLength = 0;
              var byteArray    = undefined;
              for ( var bufferIndex = 4 ; bufferIndex <= SIZES_OF_BUFFER_ARRAY_BYTES_LENGTH ; bufferIndex += 4 ) {

                  bufferLength = buffer.getUint32( bufferIndex );
                  byteArray    = new Uint8Array( arrayBuffer, dataOffset, bufferLength );

                  self.addPointsFromBuffer( byteArray, cloud );

                  dataOffset += bufferLength;

              }
          };

          oReq.send( JSON.stringify( dataToSend ) );

      },

      /**
       *
       * @param boundingBox
       * @param dataBuffer
       */
      addPointsFromBuffer: function ( dataBuffer ) {
          var this$1 = this;


          if ( !dataBuffer ) {
              console.error( 'No cube data to add on gpu !' );
              return
          }

          var CUBE_ID_BYTES_LENGTH = 24;
          var cloudPointId                 = '';
          for ( var charIndex = 0 ; charIndex < CUBE_ID_BYTES_LENGTH ; ++charIndex ) {
              cloudPointId += String.fromCharCode( dataBuffer[ charIndex ] );
          }

          var CUBE_POSITION_BYTES_LENGTH  = 3;
          var HEADER_SIZE                 = CUBE_ID_BYTES_LENGTH + CUBE_POSITION_BYTES_LENGTH;
          var POINT_POSITION_BYTES_LENGTH = 3;
          var POINT_COLOR_BYTES_LENGTH    = 3;
          var POINT_DATA_BYTES_LENGTH     = POINT_POSITION_BYTES_LENGTH + POINT_COLOR_BYTES_LENGTH;
          var bufferSize                    = dataBuffer.length;
          var numberOfPoint                 = (bufferSize - HEADER_SIZE) / POINT_DATA_BYTES_LENGTH;

          var positions = new Float32Array( numberOfPoint * POINT_POSITION_BYTES_LENGTH );
          var colors    = new Float32Array( numberOfPoint * POINT_COLOR_BYTES_LENGTH );

          var pointCloudData         = this._pointCloudsDataMap.get( cloudPointId );
          var pointCloudCoordinates = pointCloudData.coordinates;

          var bufferIndex     = 0;
          var bufferDataIndex = HEADER_SIZE;
          for ( var i = 0 ; i < numberOfPoint ; i++ ) {

              // positions
              positions[ bufferIndex ]     = (dataBuffer[ bufferDataIndex ] / 1000) + pointCloudCoordinates.x - this$1._globalOffset.x;
              positions[ bufferIndex + 1 ] = (dataBuffer[ bufferDataIndex + 1 ] / 1000) + pointCloudCoordinates.y - this$1._globalOffset.y;
              positions[ bufferIndex + 2 ] = (dataBuffer[ bufferDataIndex + 2 ] / 1000) + pointCloudCoordinates.z - this$1._globalOffset.z;

              // colors
              colors[ bufferIndex ]     = dataBuffer[ bufferDataIndex + 3 ] / 255;
              colors[ bufferIndex + 1 ] = dataBuffer[ bufferDataIndex + 4 ] / 255;
              colors[ bufferIndex + 2 ] = dataBuffer[ bufferDataIndex + 5 ] / 255;

              bufferIndex += 3;
              bufferDataIndex += 6;

          }

          // If object already exist update it else create
          var pointCloud    = this._pointCloudGroup.getObjectByName( cloudPointId );
          if ( pointCloud ) {

              var positionBufferAttribute = pointCloud.geometry.getAttribute( 'position' );
              positionBufferAttribute.setArray( positions );
              positionBufferAttribute.needsUpdate = true;

              var colorBufferAttribute = pointCloud.geometry.getAttribute( 'color' );
              colorBufferAttribute.setArray( colors );
              colorBufferAttribute.needsUpdate = true;

          } else {

              var positionBufferAttribute = new BufferAttribute( positions, 3 );
              var colorBufferAttribute = new BufferAttribute( colors, 3 );

              var geometry = new BufferGeometry();
              geometry.addAttribute( 'position', positionBufferAttribute );
              geometry.addAttribute( 'color', colorBufferAttribute );

              var material        = new PointsMaterial( {
                  size:         0.005,
                  vertexColors: true
              } );

              var particleSystem  = new Points( geometry, material );
              particleSystem.name = cloudPointId;
              particleSystem.rotation.x -= Math.PI / 2; //convert obj [y forward / z up] as [-z forward / y up]

              this._pointCloudGroup.add( particleSystem );

          }

      }

  } );

  /**
   * @author [Tristan Valcke]{@link https://github.com/Itee}
   * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
   *
   * @class TOrchestrator
   * @classdesc Todo...
   * @example Todo...
   *
   */

  /**
   *
   * @constructor
   */
  function TOrchestrator () {

      this.requestQueue           = [];
      this.minSimultaneousRequest = 3;
      this.maxSimultaneousRequest = 6;

      this._numberOfRunningRequest = 0;
      this._processQueue           = [];
      this._inProcessing           = false;

  }

  Object.assign( TOrchestrator.prototype, {

      /**
       * @public
       * @memberOf TOrchestrator.prototype
       */
      processQueue: function processQueue () {

          var self = this;

          var request;
          var requestSkull;
          this._inProcessing = true;

          while ( self.requestQueue.length > 0 ) {

              if ( self._numberOfRunningRequest >= self.maxSimultaneousRequest ) { break }

              requestSkull = self.requestQueue.pop();

              self._processQueue.push( requestSkull );

              request = new XMLHttpRequest();
              request.responseType = requestSkull.responseType;

              request.onload = (function closureEndRequest () {

                  var _reqSkull = requestSkull;

                  return function _checkEndRequest ( loadEvent ) {

                      var processedRequestIndex = self._processQueue.indexOf( _reqSkull );
                      if ( processedRequestIndex > -1 ) {
                          self._processQueue.splice( processedRequestIndex, 1 );
                      }

                      self._numberOfRunningRequest--;
                      _reqSkull.onLoad( loadEvent );

                      if ( self._numberOfRunningRequest <= self.minSimultaneousRequest ) {
                          self.processQueue();
                      }

                  }

              })();

              request.onprogress = requestSkull.onProgress;
              request.onerror    = requestSkull.onError;

              request.open( requestSkull.method, requestSkull.url );
              request.setRequestHeader( "Content-Type", "application/json" );

              var dataToSend = (requestSkull.data && requestSkull.responseType === 'json') ? JSON.stringify( requestSkull.data ) : requestSkull.data;
              request.send( dataToSend );

              self._numberOfRunningRequest++;

          }

          self._inProcessing = false;

      },

      /**
       * @public
       * @memberOf TOrchestrator.prototype
       *
       * @param newRequest
       */
      queue: function queue ( newRequest ) {
          var this$1 = this;


          // Check if request for same url already exist
          var skipNewRequest = false;
          var loop = function ( requestIndex, numberOfRequest ) {

              var request = this$1.requestQueue[ requestIndex ];

              if ( request.method !== newRequest.method ) { return }
              if ( request.url !== newRequest.url ) { return }
              if ( request.data !== newRequest.data ) { return }

              // Wrap callback of existing request with new request
              var requestOnLoad = request.onLoad;
              request.onLoad      = function ( onLoadEvent ) {
                  requestOnLoad( onLoadEvent );
                  newRequest.onLoad( onLoadEvent );
              };

              var requestOnProgress = request.onProgress;
              request.onProgress      = function ( onProgressEvent ) {
                  requestOnProgress( onProgressEvent );
                  newRequest.onProgress( onProgressEvent );
              };

              var requestOnError = request.onError;
              request.onError      = function ( onErrorEvent ) {
                  requestOnError( onErrorEvent );
                  newRequest.onError( onErrorEvent );
              };

              skipNewRequest = true;

          };

          for ( var requestIndex = 0, numberOfRequest = this.requestQueue.length ; requestIndex < numberOfRequest ; requestIndex++ ) loop( requestIndex, numberOfRequest );

          var loop$1 = function ( requestIndex, numberOfRequest ) {

              var request$1 = this$1._processQueue[ requestIndex ];

              if ( request$1.method !== newRequest.method ) { return }
              if ( request$1.url !== newRequest.url ) { return }
              if ( request$1.data !== newRequest.data ) { return }

              // Wrap callback of existing request with new request
              var requestOnLoad$1 = request$1.onLoad;
              request$1.onLoad      = function ( onLoadEvent ) {
                  requestOnLoad$1( onLoadEvent );
                  newRequest.onLoad( onLoadEvent );
              };

              var requestOnProgress$1 = request$1.onProgress;
              request$1.onProgress      = function ( onProgressEvent ) {
                  requestOnProgress$1( onProgressEvent );
                  newRequest.onProgress( onProgressEvent );
              };

              var requestOnError$1 = request$1.onError;
              request$1.onError      = function ( onErrorEvent ) {
                  requestOnError$1( onErrorEvent );
                  newRequest.onError( onErrorEvent );
              };

              skipNewRequest = true;

          };

          for ( var requestIndex$1 = 0, numberOfRequest$1 = this._processQueue.length ; requestIndex$1 < numberOfRequest$1 ; requestIndex$1++ ) loop$1( requestIndex$1, numberOfRequest$1 );

          if ( skipNewRequest ) { return }

          this.requestQueue.push( newRequest );

          if ( !this._inProcessing ) { this.processQueue(); }

      }

  } );

  var singletonInstance = new TOrchestrator();

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *
   *  linewidth: <float>,
   *  linecap: "round",
   *  linejoin: "round"
   * }
   */

  function LineBasicMaterial( parameters ) {

  	Material.call( this );

  	this.type = 'LineBasicMaterial';

  	this.color = new Color( 0xffffff );

  	this.linewidth = 1;
  	this.linecap = 'round';
  	this.linejoin = 'round';

  	this.lights = false;

  	this.setValues( parameters );

  }

  LineBasicMaterial.prototype = Object.create( Material.prototype );
  LineBasicMaterial.prototype.constructor = LineBasicMaterial;

  LineBasicMaterial.prototype.isLineBasicMaterial = true;

  LineBasicMaterial.prototype.copy = function ( source ) {

  	Material.prototype.copy.call( this, source );

  	this.color.copy( source.color );

  	this.linewidth = source.linewidth;
  	this.linecap = source.linecap;
  	this.linejoin = source.linejoin;

  	return this;

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function Line( geometry, material, mode ) {

  	if ( mode === 1 ) {

  		console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
  		return new LineSegments( geometry, material );

  	}

  	Object3D.call( this );

  	this.type = 'Line';

  	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
  	this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );

  }

  Line.prototype = Object.assign( Object.create( Object3D.prototype ), {

  	constructor: Line,

  	isLine: true,

  	raycast: ( function () {

  		var inverseMatrix = new Matrix4();
  		var ray = new Ray();
  		var sphere = new Sphere();

  		return function raycast( raycaster, intersects ) {
  			var this$1 = this;


  			var precision = raycaster.linePrecision;
  			var precisionSq = precision * precision;

  			var geometry = this.geometry;
  			var matrixWorld = this.matrixWorld;

  			// Checking boundingSphere distance to ray

  			if ( geometry.boundingSphere === null ) { geometry.computeBoundingSphere(); }

  			sphere.copy( geometry.boundingSphere );
  			sphere.applyMatrix4( matrixWorld );

  			if ( raycaster.ray.intersectsSphere( sphere ) === false ) { return; }

  			//

  			inverseMatrix.getInverse( matrixWorld );
  			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

  			var vStart = new Vector3$1();
  			var vEnd = new Vector3$1();
  			var interSegment = new Vector3$1();
  			var interRay = new Vector3$1();
  			var step = ( this && this.isLineSegments ) ? 2 : 1;

  			if ( geometry.isBufferGeometry ) {

  				var index = geometry.index;
  				var attributes = geometry.attributes;
  				var positions = attributes.position.array;

  				if ( index !== null ) {

  					var indices = index.array;

  					for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

  						var a = indices[ i ];
  						var b = indices[ i + 1 ];

  						vStart.fromArray( positions, a * 3 );
  						vEnd.fromArray( positions, b * 3 );

  						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

  						if ( distSq > precisionSq ) { continue; }

  						interRay.applyMatrix4( this$1.matrixWorld ); //Move back to world space for distance calculation

  						var distance = raycaster.ray.origin.distanceTo( interRay );

  						if ( distance < raycaster.near || distance > raycaster.far ) { continue; }

  						intersects.push( {

  							distance: distance,
  							// What do we want? intersection point on the ray or on the segment??
  							// point: raycaster.ray.at( distance ),
  							point: interSegment.clone().applyMatrix4( this$1.matrixWorld ),
  							index: i,
  							face: null,
  							faceIndex: null,
  							object: this$1

  						} );

  					}

  				} else {

  					for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

  						vStart.fromArray( positions, 3 * i );
  						vEnd.fromArray( positions, 3 * i + 3 );

  						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

  						if ( distSq > precisionSq ) { continue; }

  						interRay.applyMatrix4( this$1.matrixWorld ); //Move back to world space for distance calculation

  						var distance = raycaster.ray.origin.distanceTo( interRay );

  						if ( distance < raycaster.near || distance > raycaster.far ) { continue; }

  						intersects.push( {

  							distance: distance,
  							// What do we want? intersection point on the ray or on the segment??
  							// point: raycaster.ray.at( distance ),
  							point: interSegment.clone().applyMatrix4( this$1.matrixWorld ),
  							index: i,
  							face: null,
  							faceIndex: null,
  							object: this$1

  						} );

  					}

  				}

  			} else if ( geometry.isGeometry ) {

  				var vertices = geometry.vertices;
  				var nbVertices = vertices.length;

  				for ( var i = 0; i < nbVertices - 1; i += step ) {

  					var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

  					if ( distSq > precisionSq ) { continue; }

  					interRay.applyMatrix4( this$1.matrixWorld ); //Move back to world space for distance calculation

  					var distance = raycaster.ray.origin.distanceTo( interRay );

  					if ( distance < raycaster.near || distance > raycaster.far ) { continue; }

  					intersects.push( {

  						distance: distance,
  						// What do we want? intersection point on the ray or on the segment??
  						// point: raycaster.ray.at( distance ),
  						point: interSegment.clone().applyMatrix4( this$1.matrixWorld ),
  						index: i,
  						face: null,
  						faceIndex: null,
  						object: this$1

  					} );

  				}

  			}

  		};

  	}() ),

  	clone: function () {

  		return new this.constructor( this.geometry, this.material ).copy( this );

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function LineSegments( geometry, material ) {

  	Line.call( this, geometry, material );

  	this.type = 'LineSegments';

  }

  LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {

  	constructor: LineSegments,

  	isLineSegments: true

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */

  function WireframeGeometry( geometry ) {

  	BufferGeometry.call( this );

  	this.type = 'WireframeGeometry';

  	// buffer

  	var vertices = [];

  	// helper variables

  	var i, j, l, o, ol;
  	var edge = [ 0, 0 ], edges = {}, e, edge1, edge2;
  	var key, keys = [ 'a', 'b', 'c' ];
  	var vertex;

  	// different logic for Geometry and BufferGeometry

  	if ( geometry && geometry.isGeometry ) {

  		// create a data structure that contains all edges without duplicates

  		var faces = geometry.faces;

  		for ( i = 0, l = faces.length; i < l; i ++ ) {

  			var face = faces[ i ];

  			for ( j = 0; j < 3; j ++ ) {

  				edge1 = face[ keys[ j ] ];
  				edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
  				edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
  				edge[ 1 ] = Math.max( edge1, edge2 );

  				key = edge[ 0 ] + ',' + edge[ 1 ];

  				if ( edges[ key ] === undefined ) {

  					edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

  				}

  			}

  		}

  		// generate vertices

  		for ( key in edges ) {

  			e = edges[ key ];

  			vertex = geometry.vertices[ e.index1 ];
  			vertices.push( vertex.x, vertex.y, vertex.z );

  			vertex = geometry.vertices[ e.index2 ];
  			vertices.push( vertex.x, vertex.y, vertex.z );

  		}

  	} else if ( geometry && geometry.isBufferGeometry ) {

  		var position, indices, groups;
  		var group, start, count;
  		var index1, index2;

  		vertex = new Vector3$1();

  		if ( geometry.index !== null ) {

  			// indexed BufferGeometry

  			position = geometry.attributes.position;
  			indices = geometry.index;
  			groups = geometry.groups;

  			if ( groups.length === 0 ) {

  				groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];

  			}

  			// create a data structure that contains all eges without duplicates

  			for ( o = 0, ol = groups.length; o < ol; ++ o ) {

  				group = groups[ o ];

  				start = group.start;
  				count = group.count;

  				for ( i = start, l = ( start + count ); i < l; i += 3 ) {

  					for ( j = 0; j < 3; j ++ ) {

  						edge1 = indices.getX( i + j );
  						edge2 = indices.getX( i + ( j + 1 ) % 3 );
  						edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
  						edge[ 1 ] = Math.max( edge1, edge2 );

  						key = edge[ 0 ] + ',' + edge[ 1 ];

  						if ( edges[ key ] === undefined ) {

  							edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

  						}

  					}

  				}

  			}

  			// generate vertices

  			for ( key in edges ) {

  				e = edges[ key ];

  				vertex.fromBufferAttribute( position, e.index1 );
  				vertices.push( vertex.x, vertex.y, vertex.z );

  				vertex.fromBufferAttribute( position, e.index2 );
  				vertices.push( vertex.x, vertex.y, vertex.z );

  			}

  		} else {

  			// non-indexed BufferGeometry

  			position = geometry.attributes.position;

  			for ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {

  				for ( j = 0; j < 3; j ++ ) {

  					// three edges per triangle, an edge is represented as (index1, index2)
  					// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

  					index1 = 3 * i + j;
  					vertex.fromBufferAttribute( position, index1 );
  					vertices.push( vertex.x, vertex.y, vertex.z );

  					index2 = 3 * i + ( ( j + 1 ) % 3 );
  					vertex.fromBufferAttribute( position, index2 );
  					vertices.push( vertex.x, vertex.y, vertex.z );

  				}

  			}

  		}

  	}

  	// build geometry

  	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

  }

  WireframeGeometry.prototype = Object.create( BufferGeometry.prototype );
  WireframeGeometry.prototype.constructor = WireframeGeometry;

  /**
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *  map: new THREE.Texture( <Image> ),
   *
   *	uvOffset: new THREE.Vector2(),
   *	uvScale: new THREE.Vector2()
   * }
   */

  function SpriteMaterial( parameters ) {

  	Material.call( this );

  	this.type = 'SpriteMaterial';

  	this.color = new Color( 0xffffff );
  	this.map = null;

  	this.rotation = 0;

  	this.fog = false;
  	this.lights = false;

  	this.setValues( parameters );

  }

  SpriteMaterial.prototype = Object.create( Material.prototype );
  SpriteMaterial.prototype.constructor = SpriteMaterial;
  SpriteMaterial.prototype.isSpriteMaterial = true;

  SpriteMaterial.prototype.copy = function ( source ) {

  	Material.prototype.copy.call( this, source );

  	this.color.copy( source.color );
  	this.map = source.map;

  	this.rotation = source.rotation;

  	return this;

  };

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   */

  function Sprite( material ) {

  	Object3D.call( this );

  	this.type = 'Sprite';

  	this.material = ( material !== undefined ) ? material : new SpriteMaterial();

  }

  Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {

  	constructor: Sprite,

  	isSprite: true,

  	raycast: ( function () {

  		var intersectPoint = new Vector3$1();
  		var worldPosition = new Vector3$1();
  		var worldScale = new Vector3$1();

  		return function raycast( raycaster, intersects ) {

  			worldPosition.setFromMatrixPosition( this.matrixWorld );
  			raycaster.ray.closestPointToPoint( worldPosition, intersectPoint );

  			worldScale.setFromMatrixScale( this.matrixWorld );
  			var guessSizeSq = worldScale.x * worldScale.y / 4;

  			if ( worldPosition.distanceToSquared( intersectPoint ) > guessSizeSq ) { return; }

  			var distance = raycaster.ray.origin.distanceTo( intersectPoint );

  			if ( distance < raycaster.near || distance > raycaster.far ) { return; }

  			intersects.push( {

  				distance: distance,
  				point: intersectPoint.clone(),
  				face: null,
  				object: this

  			} );

  		};

  	}() ),

  	clone: function () {

  		return new this.constructor( this.material ).copy( this );

  	}

  } );

  /**
   * @author mgreter / http://github.com/mgreter
   */

  function LineLoop( geometry, material ) {

  	Line.call( this, geometry, material );

  	this.type = 'LineLoop';

  }

  LineLoop.prototype = Object.assign( Object.create( Line.prototype ), {

  	constructor: LineLoop,

  	isLineLoop: true,

  } );

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   */

  function LOD() {

  	Object3D.call( this );

  	this.type = 'LOD';

  	Object.defineProperties( this, {
  		levels: {
  			enumerable: true,
  			value: []
  		}
  	} );

  }

  LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {

  	constructor: LOD,

  	copy: function ( source ) {
  		var this$1 = this;


  		Object3D.prototype.copy.call( this, source, false );

  		var levels = source.levels;

  		for ( var i = 0, l = levels.length; i < l; i ++ ) {

  			var level = levels[ i ];

  			this$1.addLevel( level.object.clone(), level.distance );

  		}

  		return this;

  	},

  	addLevel: function ( object, distance ) {

  		if ( distance === undefined ) { distance = 0; }

  		distance = Math.abs( distance );

  		var levels = this.levels;

  		for ( var l = 0; l < levels.length; l ++ ) {

  			if ( distance < levels[ l ].distance ) {

  				break;

  			}

  		}

  		levels.splice( l, 0, { distance: distance, object: object } );

  		this.add( object );

  	},

  	getObjectForDistance: function ( distance ) {

  		var levels = this.levels;

  		for ( var i = 1, l = levels.length; i < l; i ++ ) {

  			if ( distance < levels[ i ].distance ) {

  				break;

  			}

  		}

  		return levels[ i - 1 ].object;

  	},

  	raycast: ( function () {

  		var matrixPosition = new Vector3$1();

  		return function raycast( raycaster, intersects ) {

  			matrixPosition.setFromMatrixPosition( this.matrixWorld );

  			var distance = raycaster.ray.origin.distanceTo( matrixPosition );

  			this.getObjectForDistance( distance ).raycast( raycaster, intersects );

  		};

  	}() ),

  	update: function () {

  		var v1 = new Vector3$1();
  		var v2 = new Vector3$1();

  		return function update( camera ) {

  			var levels = this.levels;

  			if ( levels.length > 1 ) {

  				v1.setFromMatrixPosition( camera.matrixWorld );
  				v2.setFromMatrixPosition( this.matrixWorld );

  				var distance = v1.distanceTo( v2 );

  				levels[ 0 ].object.visible = true;

  				for ( var i = 1, l = levels.length; i < l; i ++ ) {

  					if ( distance >= levels[ i ].distance ) {

  						levels[ i - 1 ].object.visible = false;
  						levels[ i ].object.visible = true;

  					} else {

  						break;

  					}

  				}

  				for ( ; i < l; i ++ ) {

  					levels[ i ].object.visible = false;

  				}

  			}

  		};

  	}(),

  	toJSON: function ( meta ) {

  		var data = Object3D.prototype.toJSON.call( this, meta );

  		data.object.levels = [];

  		var levels = this.levels;

  		for ( var i = 0, l = levels.length; i < l; i ++ ) {

  			var level = levels[ i ];

  			data.object.levels.push( {
  				object: level.object.uuid,
  				distance: level.distance
  			} );

  		}

  		return data;

  	}

  } );

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author michael guerrero / http://realitymeltdown.com
   * @author ikerr / http://verold.com
   */

  function Skeleton( bones, boneInverses ) {
  	var this$1 = this;


  	// copy the bone array

  	bones = bones || [];

  	this.bones = bones.slice( 0 );
  	this.boneMatrices = new Float32Array( this.bones.length * 16 );

  	// use the supplied bone inverses or calculate the inverses

  	if ( boneInverses === undefined ) {

  		this.calculateInverses();

  	} else {

  		if ( this.bones.length === boneInverses.length ) {

  			this.boneInverses = boneInverses.slice( 0 );

  		} else {

  			console.warn( 'THREE.Skeleton boneInverses is the wrong length.' );

  			this.boneInverses = [];

  			for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

  				this$1.boneInverses.push( new Matrix4() );

  			}

  		}

  	}

  }

  Object.assign( Skeleton.prototype, {

  	calculateInverses: function () {
  		var this$1 = this;


  		this.boneInverses = [];

  		for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

  			var inverse = new Matrix4();

  			if ( this$1.bones[ i ] ) {

  				inverse.getInverse( this$1.bones[ i ].matrixWorld );

  			}

  			this$1.boneInverses.push( inverse );

  		}

  	},

  	pose: function () {
  		var this$1 = this;


  		var bone, i, il;

  		// recover the bind-time world matrices

  		for ( i = 0, il = this.bones.length; i < il; i ++ ) {

  			bone = this$1.bones[ i ];

  			if ( bone ) {

  				bone.matrixWorld.getInverse( this$1.boneInverses[ i ] );

  			}

  		}

  		// compute the local matrices, positions, rotations and scales

  		for ( i = 0, il = this.bones.length; i < il; i ++ ) {

  			bone = this$1.bones[ i ];

  			if ( bone ) {

  				if ( bone.parent && bone.parent.isBone ) {

  					bone.matrix.getInverse( bone.parent.matrixWorld );
  					bone.matrix.multiply( bone.matrixWorld );

  				} else {

  					bone.matrix.copy( bone.matrixWorld );

  				}

  				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

  			}

  		}

  	},

  	update: ( function () {

  		var offsetMatrix = new Matrix4();
  		var identityMatrix = new Matrix4();

  		return function update() {

  			var bones = this.bones;
  			var boneInverses = this.boneInverses;
  			var boneMatrices = this.boneMatrices;
  			var boneTexture = this.boneTexture;

  			// flatten bone matrices to array

  			for ( var i = 0, il = bones.length; i < il; i ++ ) {

  				// compute the offset between the current and the original transform

  				var matrix = bones[ i ] ? bones[ i ].matrixWorld : identityMatrix;

  				offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
  				offsetMatrix.toArray( boneMatrices, i * 16 );

  			}

  			if ( boneTexture !== undefined ) {

  				boneTexture.needsUpdate = true;

  			}

  		};

  	} )(),

  	clone: function () {

  		return new Skeleton( this.bones, this.boneInverses );

  	}

  } );

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author ikerr / http://verold.com
   */

  function Bone() {

  	Object3D.call( this );

  	this.type = 'Bone';

  }

  Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {

  	constructor: Bone,

  	isBone: true

  } );

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author ikerr / http://verold.com
   */

  function SkinnedMesh( geometry, material ) {

  	Mesh.call( this, geometry, material );

  	this.type = 'SkinnedMesh';

  	this.bindMode = 'attached';
  	this.bindMatrix = new Matrix4();
  	this.bindMatrixInverse = new Matrix4();

  	var bones = this.initBones();
  	var skeleton = new Skeleton( bones );

  	this.bind( skeleton, this.matrixWorld );

  	this.normalizeSkinWeights();

  }

  SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

  	constructor: SkinnedMesh,

  	isSkinnedMesh: true,

  	initBones: function () {
  		var this$1 = this;


  		var bones = [], bone, gbone;
  		var i, il;

  		if ( this.geometry && this.geometry.bones !== undefined ) {

  			// first, create array of 'Bone' objects from geometry data

  			for ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {

  				gbone = this$1.geometry.bones[ i ];

  				// create new 'Bone' object

  				bone = new Bone();
  				bones.push( bone );

  				// apply values

  				bone.name = gbone.name;
  				bone.position.fromArray( gbone.pos );
  				bone.quaternion.fromArray( gbone.rotq );
  				if ( gbone.scl !== undefined ) { bone.scale.fromArray( gbone.scl ); }

  			}

  			// second, create bone hierarchy

  			for ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {

  				gbone = this$1.geometry.bones[ i ];

  				if ( ( gbone.parent !== - 1 ) && ( gbone.parent !== null ) && ( bones[ gbone.parent ] !== undefined ) ) {

  					// subsequent bones in the hierarchy

  					bones[ gbone.parent ].add( bones[ i ] );

  				} else {

  					// topmost bone, immediate child of the skinned mesh

  					this$1.add( bones[ i ] );

  				}

  			}

  		}

  		// now the bones are part of the scene graph and children of the skinned mesh.
  		// let's update the corresponding matrices

  		this.updateMatrixWorld( true );

  		return bones;

  	},

  	bind: function ( skeleton, bindMatrix ) {

  		this.skeleton = skeleton;

  		if ( bindMatrix === undefined ) {

  			this.updateMatrixWorld( true );

  			this.skeleton.calculateInverses();

  			bindMatrix = this.matrixWorld;

  		}

  		this.bindMatrix.copy( bindMatrix );
  		this.bindMatrixInverse.getInverse( bindMatrix );

  	},

  	pose: function () {

  		this.skeleton.pose();

  	},

  	normalizeSkinWeights: function () {
  		var this$1 = this;


  		var scale, i;

  		if ( this.geometry && this.geometry.isGeometry ) {

  			for ( i = 0; i < this.geometry.skinWeights.length; i ++ ) {

  				var sw = this$1.geometry.skinWeights[ i ];

  				scale = 1.0 / sw.lengthManhattan();

  				if ( scale !== Infinity ) {

  					sw.multiplyScalar( scale );

  				} else {

  					sw.set( 1, 0, 0, 0 ); // do something reasonable

  				}

  			}

  		} else if ( this.geometry && this.geometry.isBufferGeometry ) {

  			var vec = new Vector4();

  			var skinWeight = this.geometry.attributes.skinWeight;

  			for ( i = 0; i < skinWeight.count; i ++ ) {

  				vec.x = skinWeight.getX( i );
  				vec.y = skinWeight.getY( i );
  				vec.z = skinWeight.getZ( i );
  				vec.w = skinWeight.getW( i );

  				scale = 1.0 / vec.lengthManhattan();

  				if ( scale !== Infinity ) {

  					vec.multiplyScalar( scale );

  				} else {

  					vec.set( 1, 0, 0, 0 ); // do something reasonable

  				}

  				skinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );

  			}

  		}

  	},

  	updateMatrixWorld: function ( force ) {

  		Mesh.prototype.updateMatrixWorld.call( this, force );

  		if ( this.bindMode === 'attached' ) {

  			this.bindMatrixInverse.getInverse( this.matrixWorld );

  		} else if ( this.bindMode === 'detached' ) {

  			this.bindMatrixInverse.getInverse( this.bindMatrix );

  		} else {

  			console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

  		}

  	},

  	clone: function () {

  		return new this.constructor( this.geometry, this.material ).copy( this );

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  function Fog( color, near, far ) {

  	this.name = '';

  	this.color = new Color( color );

  	this.near = ( near !== undefined ) ? near : 1;
  	this.far = ( far !== undefined ) ? far : 1000;

  }

  Fog.prototype.isFog = true;

  Fog.prototype.clone = function () {

  	return new Fog( this.color.getHex(), this.near, this.far );

  };

  Fog.prototype.toJSON = function ( /* meta */ ) {

  	return {
  		type: 'Fog',
  		color: this.color.getHex(),
  		near: this.near,
  		far: this.far
  	};

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  function FogExp2( color, density ) {

  	this.name = '';

  	this.color = new Color( color );
  	this.density = ( density !== undefined ) ? density : 0.00025;

  }

  FogExp2.prototype.isFogExp2 = true;

  FogExp2.prototype.clone = function () {

  	return new FogExp2( this.color.getHex(), this.density );

  };

  FogExp2.prototype.toJSON = function ( /* meta */ ) {

  	return {
  		type: 'FogExp2',
  		color: this.color.getHex(),
  		density: this.density
  	};

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  function Light( color, intensity ) {

  	Object3D.call( this );

  	this.type = 'Light';

  	this.color = new Color( color );
  	this.intensity = intensity !== undefined ? intensity : 1;

  	this.receiveShadow = undefined;

  }

  Light.prototype = Object.assign( Object.create( Object3D.prototype ), {

  	constructor: Light,

  	isLight: true,

  	copy: function ( source ) {

  		Object3D.prototype.copy.call( this, source );

  		this.color.copy( source.color );
  		this.intensity = source.intensity;

  		return this;

  	},

  	toJSON: function ( meta ) {

  		var data = Object3D.prototype.toJSON.call( this, meta );

  		data.object.color = this.color.getHex();
  		data.object.intensity = this.intensity;

  		if ( this.groundColor !== undefined ) { data.object.groundColor = this.groundColor.getHex(); }

  		if ( this.distance !== undefined ) { data.object.distance = this.distance; }
  		if ( this.angle !== undefined ) { data.object.angle = this.angle; }
  		if ( this.decay !== undefined ) { data.object.decay = this.decay; }
  		if ( this.penumbra !== undefined ) { data.object.penumbra = this.penumbra; }

  		if ( this.shadow !== undefined ) { data.object.shadow = this.shadow.toJSON(); }

  		return data;

  	}

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function HemisphereLight( skyColor, groundColor, intensity ) {

  	Light.call( this, skyColor, intensity );

  	this.type = 'HemisphereLight';

  	this.castShadow = undefined;

  	this.position.copy( Object3D.DefaultUp );
  	this.updateMatrix();

  	this.groundColor = new Color( groundColor );

  }

  HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {

  	constructor: HemisphereLight,

  	isHemisphereLight: true,

  	copy: function ( source ) {

  		Light.prototype.copy.call( this, source );

  		this.groundColor.copy( source.groundColor );

  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function LightShadow( camera ) {

  	this.camera = camera;

  	this.bias = 0;
  	this.radius = 1;

  	this.mapSize = new Vector2( 512, 512 );

  	this.map = null;
  	this.matrix = new Matrix4();

  }

  Object.assign( LightShadow.prototype, {

  	copy: function ( source ) {

  		this.camera = source.camera.clone();

  		this.bias = source.bias;
  		this.radius = source.radius;

  		this.mapSize.copy( source.mapSize );

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	toJSON: function () {

  		var object = {};

  		if ( this.bias !== 0 ) { object.bias = this.bias; }
  		if ( this.radius !== 1 ) { object.radius = this.radius; }
  		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) { object.mapSize = this.mapSize.toArray(); }

  		object.camera = this.camera.toJSON( false ).object;
  		delete object.camera.matrix;

  		return object;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author mikael emtinger / http://gomo.se/
   * @author WestLangley / http://github.com/WestLangley
  */

  function Camera() {

  	Object3D.call( this );

  	this.type = 'Camera';

  	this.matrixWorldInverse = new Matrix4();
  	this.projectionMatrix = new Matrix4();

  }

  Camera.prototype = Object.assign( Object.create( Object3D.prototype ), {

  	constructor: Camera,

  	isCamera: true,

  	copy: function ( source, recursive ) {

  		Object3D.prototype.copy.call( this, source, recursive );

  		this.matrixWorldInverse.copy( source.matrixWorldInverse );
  		this.projectionMatrix.copy( source.projectionMatrix );

  		return this;

  	},

  	getWorldDirection: function () {

  		var quaternion = new Quaternion();

  		return function getWorldDirection( optionalTarget ) {

  			var result = optionalTarget || new Vector3$1();

  			this.getWorldQuaternion( quaternion );

  			return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

  		};

  	}(),

  	updateMatrixWorld: function ( force ) {

  		Object3D.prototype.updateMatrixWorld.call( this, force );

  		this.matrixWorldInverse.getInverse( this.matrixWorld );

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author greggman / http://games.greggman.com/
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * @author tschw
   */

  function PerspectiveCamera( fov, aspect, near, far ) {

  	Camera.call( this );

  	this.type = 'PerspectiveCamera';

  	this.fov = fov !== undefined ? fov : 50;
  	this.zoom = 1;

  	this.near = near !== undefined ? near : 0.1;
  	this.far = far !== undefined ? far : 2000;
  	this.focus = 10;

  	this.aspect = aspect !== undefined ? aspect : 1;
  	this.view = null;

  	this.filmGauge = 35;	// width of the film (default in millimeters)
  	this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

  	this.updateProjectionMatrix();

  }

  PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

  	constructor: PerspectiveCamera,

  	isPerspectiveCamera: true,

  	copy: function ( source, recursive ) {

  		Camera.prototype.copy.call( this, source, recursive );

  		this.fov = source.fov;
  		this.zoom = source.zoom;

  		this.near = source.near;
  		this.far = source.far;
  		this.focus = source.focus;

  		this.aspect = source.aspect;
  		this.view = source.view === null ? null : Object.assign( {}, source.view );

  		this.filmGauge = source.filmGauge;
  		this.filmOffset = source.filmOffset;

  		return this;

  	},

  	/**
  	 * Sets the FOV by focal length in respect to the current .filmGauge.
  	 *
  	 * The default film gauge is 35, so that the focal length can be specified for
  	 * a 35mm (full frame) camera.
  	 *
  	 * Values for focal length and film gauge must have the same unit.
  	 */
  	setFocalLength: function ( focalLength ) {

  		// see http://www.bobatkins.com/photography/technical/field_of_view.html
  		var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

  		this.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );
  		this.updateProjectionMatrix();

  	},

  	/**
  	 * Calculates the focal length from the current .fov and .filmGauge.
  	 */
  	getFocalLength: function () {

  		var vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );

  		return 0.5 * this.getFilmHeight() / vExtentSlope;

  	},

  	getEffectiveFOV: function () {

  		return _Math.RAD2DEG * 2 * Math.atan(
  			Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );

  	},

  	getFilmWidth: function () {

  		// film not completely covered in portrait format (aspect < 1)
  		return this.filmGauge * Math.min( this.aspect, 1 );

  	},

  	getFilmHeight: function () {

  		// film not completely covered in landscape format (aspect > 1)
  		return this.filmGauge / Math.max( this.aspect, 1 );

  	},

  	/**
  	 * Sets an offset in a larger frustum. This is useful for multi-window or
  	 * multi-monitor/multi-machine setups.
  	 *
  	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
  	 * the monitors are in grid like this
  	 *
  	 *   +---+---+---+
  	 *   | A | B | C |
  	 *   +---+---+---+
  	 *   | D | E | F |
  	 *   +---+---+---+
  	 *
  	 * then for each monitor you would call it like this
  	 *
  	 *   var w = 1920;
  	 *   var h = 1080;
  	 *   var fullWidth = w * 3;
  	 *   var fullHeight = h * 2;
  	 *
  	 *   --A--
  	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
  	 *   --B--
  	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
  	 *   --C--
  	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
  	 *   --D--
  	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
  	 *   --E--
  	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
  	 *   --F--
  	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
  	 *
  	 *   Note there is no reason monitors have to be the same size or in a grid.
  	 */
  	setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

  		this.aspect = fullWidth / fullHeight;

  		if ( this.view === null ) {

  			this.view = {
  				enabled: true,
  				fullWidth: 1,
  				fullHeight: 1,
  				offsetX: 0,
  				offsetY: 0,
  				width: 1,
  				height: 1
  			};

  		}

  		this.view.enabled = true;
  		this.view.fullWidth = fullWidth;
  		this.view.fullHeight = fullHeight;
  		this.view.offsetX = x;
  		this.view.offsetY = y;
  		this.view.width = width;
  		this.view.height = height;

  		this.updateProjectionMatrix();

  	},

  	clearViewOffset: function () {

  		if ( this.view !== null ) {

  			this.view.enabled = false;

  		}

  		this.updateProjectionMatrix();

  	},

  	updateProjectionMatrix: function () {

  		var near = this.near,
  			top = near * Math.tan(
  				_Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,
  			height = 2 * top,
  			width = this.aspect * height,
  			left = - 0.5 * width,
  			view = this.view;

  		if ( this.view !== null && this.view.enabled ) {

  			var fullWidth = view.fullWidth,
  				fullHeight = view.fullHeight;

  			left += view.offsetX * width / fullWidth;
  			top -= view.offsetY * height / fullHeight;
  			width *= view.width / fullWidth;
  			height *= view.height / fullHeight;

  		}

  		var skew = this.filmOffset;
  		if ( skew !== 0 ) { left += near * skew / this.getFilmWidth(); }

  		this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

  	},

  	toJSON: function ( meta ) {

  		var data = Object3D.prototype.toJSON.call( this, meta );

  		data.object.fov = this.fov;
  		data.object.zoom = this.zoom;

  		data.object.near = this.near;
  		data.object.far = this.far;
  		data.object.focus = this.focus;

  		data.object.aspect = this.aspect;

  		if ( this.view !== null ) { data.object.view = Object.assign( {}, this.view ); }

  		data.object.filmGauge = this.filmGauge;
  		data.object.filmOffset = this.filmOffset;

  		return data;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function SpotLightShadow() {

  	LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );

  }

  SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

  	constructor: SpotLightShadow,

  	isSpotLightShadow: true,

  	update: function ( light ) {

  		var camera = this.camera;

  		var fov = _Math.RAD2DEG * 2 * light.angle;
  		var aspect = this.mapSize.width / this.mapSize.height;
  		var far = light.distance || camera.far;

  		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

  			camera.fov = fov;
  			camera.aspect = aspect;
  			camera.far = far;
  			camera.updateProjectionMatrix();

  		}

  	}

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function SpotLight( color, intensity, distance, angle, penumbra, decay ) {

  	Light.call( this, color, intensity );

  	this.type = 'SpotLight';

  	this.position.copy( Object3D.DefaultUp );
  	this.updateMatrix();

  	this.target = new Object3D();

  	Object.defineProperty( this, 'power', {
  		get: function () {

  			// intensity = power per solid angle.
  			// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
  			return this.intensity * Math.PI;

  		},
  		set: function ( power ) {

  			// intensity = power per solid angle.
  			// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
  			this.intensity = power / Math.PI;

  		}
  	} );

  	this.distance = ( distance !== undefined ) ? distance : 0;
  	this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
  	this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
  	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

  	this.shadow = new SpotLightShadow();

  }

  SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {

  	constructor: SpotLight,

  	isSpotLight: true,

  	copy: function ( source ) {

  		Light.prototype.copy.call( this, source );

  		this.distance = source.distance;
  		this.angle = source.angle;
  		this.penumbra = source.penumbra;
  		this.decay = source.decay;

  		this.target = source.target.clone();

  		this.shadow = source.shadow.clone();

  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */


  function PointLight( color, intensity, distance, decay ) {

  	Light.call( this, color, intensity );

  	this.type = 'PointLight';

  	Object.defineProperty( this, 'power', {
  		get: function () {

  			// intensity = power per solid angle.
  			// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
  			return this.intensity * 4 * Math.PI;

  		},
  		set: function ( power ) {

  			// intensity = power per solid angle.
  			// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
  			this.intensity = power / ( 4 * Math.PI );

  		}
  	} );

  	this.distance = ( distance !== undefined ) ? distance : 0;
  	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

  	this.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

  }

  PointLight.prototype = Object.assign( Object.create( Light.prototype ), {

  	constructor: PointLight,

  	isPointLight: true,

  	copy: function ( source ) {

  		Light.prototype.copy.call( this, source );

  		this.distance = source.distance;
  		this.decay = source.decay;

  		this.shadow = source.shadow.clone();

  		return this;

  	}

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author arose / http://github.com/arose
   */

  function OrthographicCamera( left, right, top, bottom, near, far ) {

  	Camera.call( this );

  	this.type = 'OrthographicCamera';

  	this.zoom = 1;
  	this.view = null;

  	this.left = left;
  	this.right = right;
  	this.top = top;
  	this.bottom = bottom;

  	this.near = ( near !== undefined ) ? near : 0.1;
  	this.far = ( far !== undefined ) ? far : 2000;

  	this.updateProjectionMatrix();

  }

  OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

  	constructor: OrthographicCamera,

  	isOrthographicCamera: true,

  	copy: function ( source, recursive ) {

  		Camera.prototype.copy.call( this, source, recursive );

  		this.left = source.left;
  		this.right = source.right;
  		this.top = source.top;
  		this.bottom = source.bottom;
  		this.near = source.near;
  		this.far = source.far;

  		this.zoom = source.zoom;
  		this.view = source.view === null ? null : Object.assign( {}, source.view );

  		return this;

  	},

  	setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

  		if ( this.view === null ) {

  			this.view = {
  				enabled: true,
  				fullWidth: 1,
  				fullHeight: 1,
  				offsetX: 0,
  				offsetY: 0,
  				width: 1,
  				height: 1
  			};

  		}

  		this.view.enabled = true;
  		this.view.fullWidth = fullWidth;
  		this.view.fullHeight = fullHeight;
  		this.view.offsetX = x;
  		this.view.offsetY = y;
  		this.view.width = width;
  		this.view.height = height;

  		this.updateProjectionMatrix();

  	},

  	clearViewOffset: function () {

  		if ( this.view !== null ) {

  			this.view.enabled = false;

  		}

  		this.updateProjectionMatrix();

  	},

  	updateProjectionMatrix: function () {

  		var dx = ( this.right - this.left ) / ( 2 * this.zoom );
  		var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
  		var cx = ( this.right + this.left ) / 2;
  		var cy = ( this.top + this.bottom ) / 2;

  		var left = cx - dx;
  		var right = cx + dx;
  		var top = cy + dy;
  		var bottom = cy - dy;

  		if ( this.view !== null && this.view.enabled ) {

  			var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );
  			var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );
  			var scaleW = ( this.right - this.left ) / this.view.width;
  			var scaleH = ( this.top - this.bottom ) / this.view.height;

  			left += scaleW * ( this.view.offsetX / zoomW );
  			right = left + scaleW * ( this.view.width / zoomW );
  			top -= scaleH * ( this.view.offsetY / zoomH );
  			bottom = top - scaleH * ( this.view.height / zoomH );

  		}

  		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

  	},

  	toJSON: function ( meta ) {

  		var data = Object3D.prototype.toJSON.call( this, meta );

  		data.object.zoom = this.zoom;
  		data.object.left = this.left;
  		data.object.right = this.right;
  		data.object.top = this.top;
  		data.object.bottom = this.bottom;
  		data.object.near = this.near;
  		data.object.far = this.far;

  		if ( this.view !== null ) { data.object.view = Object.assign( {}, this.view ); }

  		return data;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function DirectionalLightShadow( ) {

  	LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

  }

  DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

  	constructor: DirectionalLightShadow

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  function DirectionalLight( color, intensity ) {

  	Light.call( this, color, intensity );

  	this.type = 'DirectionalLight';

  	this.position.copy( Object3D.DefaultUp );
  	this.updateMatrix();

  	this.target = new Object3D();

  	this.shadow = new DirectionalLightShadow();

  }

  DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {

  	constructor: DirectionalLight,

  	isDirectionalLight: true,

  	copy: function ( source ) {

  		Light.prototype.copy.call( this, source );

  		this.target = source.target.clone();

  		this.shadow = source.shadow.clone();

  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function AmbientLight( color, intensity ) {

  	Light.call( this, color, intensity );

  	this.type = 'AmbientLight';

  	this.castShadow = undefined;

  }

  AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {

  	constructor: AmbientLight,

  	isAmbientLight: true

  } );

  /**
   * @author abelnation / http://github.com/abelnation
   */

  function RectAreaLight( color, intensity, width, height ) {

  	Light.call( this, color, intensity );

  	this.type = 'RectAreaLight';

  	this.position.set( 0, 1, 0 );
  	this.updateMatrix();

  	this.width = ( width !== undefined ) ? width : 10;
  	this.height = ( height !== undefined ) ? height : 10;

  	// TODO (abelnation): distance/decay

  	// TODO (abelnation): update method for RectAreaLight to update transform to lookat target

  	// TODO (abelnation): shadows

  }

  // TODO (abelnation): RectAreaLight update when light shape is changed
  RectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {

  	constructor: RectAreaLight,

  	isRectAreaLight: true,

  	copy: function ( source ) {

  		Light.prototype.copy.call( this, source );

  		this.width = source.width;
  		this.height = source.height;

  		return this;

  	},

  	toJSON: function ( meta ) {

  		var data = Light.prototype.toJSON.call( this, meta );

  		data.object.width = this.width;
  		data.object.height = this.height;

  		return data;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function Scene() {

  	Object3D.call( this );

  	this.type = 'Scene';

  	this.background = null;
  	this.fog = null;
  	this.overrideMaterial = null;

  	this.autoUpdate = true; // checked by the renderer

  }

  Scene.prototype = Object.assign( Object.create( Object3D.prototype ), {

  	constructor: Scene,

  	copy: function ( source, recursive ) {

  		Object3D.prototype.copy.call( this, source, recursive );

  		if ( source.background !== null ) { this.background = source.background.clone(); }
  		if ( source.fog !== null ) { this.fog = source.fog.clone(); }
  		if ( source.overrideMaterial !== null ) { this.overrideMaterial = source.overrideMaterial.clone(); }

  		this.autoUpdate = source.autoUpdate;
  		this.matrixAutoUpdate = source.matrixAutoUpdate;

  		return this;

  	},

  	toJSON: function ( meta ) {

  		var data = Object3D.prototype.toJSON.call( this, meta );

  		if ( this.background !== null ) { data.object.background = this.background.toJSON( meta ); }
  		if ( this.fog !== null ) { data.object.fog = this.fog.toJSON(); }

  		return data;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   * @author szimek / https://github.com/szimek/
   */

  var textureId = 0;

  function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

  	Object.defineProperty( this, 'id', { value: textureId ++ } );

  	this.uuid = _Math.generateUUID();

  	this.name = '';

  	this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
  	this.mipmaps = [];

  	this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;

  	this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
  	this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;

  	this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
  	this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;

  	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

  	this.format = format !== undefined ? format : RGBAFormat;
  	this.type = type !== undefined ? type : UnsignedByteType;

  	this.offset = new Vector2( 0, 0 );
  	this.repeat = new Vector2( 1, 1 );
  	this.center = new Vector2( 0, 0 );
  	this.rotation = 0;

  	this.matrixAutoUpdate = true;
  	this.matrix = new Matrix3();

  	this.generateMipmaps = true;
  	this.premultiplyAlpha = false;
  	this.flipY = true;
  	this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

  	// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
  	//
  	// Also changing the encoding after already used by a Material will not automatically make the Material
  	// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
  	this.encoding = encoding !== undefined ? encoding : LinearEncoding;

  	this.version = 0;
  	this.onUpdate = null;

  }

  Texture.DEFAULT_IMAGE = undefined;
  Texture.DEFAULT_MAPPING = UVMapping;

  Object.defineProperty( Texture.prototype, "needsUpdate", {

  	set: function ( value ) {

  		if ( value === true ) { this.version ++; }

  	}

  } );

  Object.assign( Texture.prototype, EventDispatcher.prototype, {

  	constructor: Texture,

  	isTexture: true,

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( source ) {

  		this.name = source.name;

  		this.image = source.image;
  		this.mipmaps = source.mipmaps.slice( 0 );

  		this.mapping = source.mapping;

  		this.wrapS = source.wrapS;
  		this.wrapT = source.wrapT;

  		this.magFilter = source.magFilter;
  		this.minFilter = source.minFilter;

  		this.anisotropy = source.anisotropy;

  		this.format = source.format;
  		this.type = source.type;

  		this.offset.copy( source.offset );
  		this.repeat.copy( source.repeat );
  		this.center.copy( source.center );
  		this.rotation = source.rotation;

  		this.matrixAutoUpdate = source.matrixAutoUpdate;
  		this.matrix.copy( source.matrix );

  		this.generateMipmaps = source.generateMipmaps;
  		this.premultiplyAlpha = source.premultiplyAlpha;
  		this.flipY = source.flipY;
  		this.unpackAlignment = source.unpackAlignment;
  		this.encoding = source.encoding;

  		return this;

  	},

  	toJSON: function ( meta ) {

  		if ( meta.textures[ this.uuid ] !== undefined ) {

  			return meta.textures[ this.uuid ];

  		}

  		function getDataURL( image ) {

  			var canvas;

  			if ( image instanceof HTMLCanvasElement ) {

  				canvas = image;

  			} else {

  				canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
  				canvas.width = image.width;
  				canvas.height = image.height;

  				var context = canvas.getContext( '2d' );

  				if ( image instanceof ImageData ) {

  					context.putImageData( image, 0, 0 );

  				} else {

  					context.drawImage( image, 0, 0, image.width, image.height );

  				}

  			}

  			if ( canvas.width > 2048 || canvas.height > 2048 ) {

  				return canvas.toDataURL( 'image/jpeg', 0.6 );

  			} else {

  				return canvas.toDataURL( 'image/png' );

  			}

  		}

  		var output = {
  			metadata: {
  				version: 4.5,
  				type: 'Texture',
  				generator: 'Texture.toJSON'
  			},

  			uuid: this.uuid,
  			name: this.name,

  			mapping: this.mapping,

  			repeat: [ this.repeat.x, this.repeat.y ],
  			offset: [ this.offset.x, this.offset.y ],
  			center: [ this.center.x, this.center.y ],
  			rotation: this.rotation,

  			wrap: [ this.wrapS, this.wrapT ],

  			minFilter: this.minFilter,
  			magFilter: this.magFilter,
  			anisotropy: this.anisotropy,

  			flipY: this.flipY
  		};

  		if ( this.image !== undefined ) {

  			// TODO: Move to THREE.Image

  			var image = this.image;

  			if ( image.uuid === undefined ) {

  				image.uuid = _Math.generateUUID(); // UGH

  			}

  			if ( meta.images[ image.uuid ] === undefined ) {

  				meta.images[ image.uuid ] = {
  					uuid: image.uuid,
  					url: getDataURL( image )
  				};

  			}

  			output.image = image.uuid;

  		}

  		meta.textures[ this.uuid ] = output;

  		return output;

  	},

  	dispose: function () {

  		this.dispatchEvent( { type: 'dispose' } );

  	},

  	transformUv: function ( uv ) {

  		if ( this.mapping !== UVMapping ) { return; }

  		uv.applyMatrix3( this.matrix );

  		if ( uv.x < 0 || uv.x > 1 ) {

  			switch ( this.wrapS ) {

  				case RepeatWrapping:

  					uv.x = uv.x - Math.floor( uv.x );
  					break;

  				case ClampToEdgeWrapping:

  					uv.x = uv.x < 0 ? 0 : 1;
  					break;

  				case MirroredRepeatWrapping:

  					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

  						uv.x = Math.ceil( uv.x ) - uv.x;

  					} else {

  						uv.x = uv.x - Math.floor( uv.x );

  					}
  					break;

  			}

  		}

  		if ( uv.y < 0 || uv.y > 1 ) {

  			switch ( this.wrapT ) {

  				case RepeatWrapping:

  					uv.y = uv.y - Math.floor( uv.y );
  					break;

  				case ClampToEdgeWrapping:

  					uv.y = uv.y < 0 ? 0 : 1;
  					break;

  				case MirroredRepeatWrapping:

  					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

  						uv.y = Math.ceil( uv.y ) - uv.y;

  					} else {

  						uv.y = uv.y - Math.floor( uv.y );

  					}
  					break;

  			}

  		}

  		if ( this.flipY ) {

  			uv.y = 1 - uv.y;

  		}

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  var Cache = {

  	enabled: false,

  	files: {},

  	add: function ( key, file ) {

  		if ( this.enabled === false ) { return; }

  		// console.log( 'THREE.Cache', 'Adding key:', key );

  		this.files[ key ] = file;

  	},

  	get: function ( key ) {

  		if ( this.enabled === false ) { return; }

  		// console.log( 'THREE.Cache', 'Checking key:', key );

  		return this.files[ key ];

  	},

  	remove: function ( key ) {

  		delete this.files[ key ];

  	},

  	clear: function () {

  		this.files = {};

  	}

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function LoadingManager( onLoad, onProgress, onError ) {

  	var scope = this;

  	var isLoading = false, itemsLoaded = 0, itemsTotal = 0;

  	this.onStart = undefined;
  	this.onLoad = onLoad;
  	this.onProgress = onProgress;
  	this.onError = onError;

  	this.itemStart = function ( url ) {

  		itemsTotal ++;

  		if ( isLoading === false ) {

  			if ( scope.onStart !== undefined ) {

  				scope.onStart( url, itemsLoaded, itemsTotal );

  			}

  		}

  		isLoading = true;

  	};

  	this.itemEnd = function ( url ) {

  		itemsLoaded ++;

  		if ( scope.onProgress !== undefined ) {

  			scope.onProgress( url, itemsLoaded, itemsTotal );

  		}

  		if ( itemsLoaded === itemsTotal ) {

  			isLoading = false;

  			if ( scope.onLoad !== undefined ) {

  				scope.onLoad();

  			}

  		}

  	};

  	this.itemError = function ( url ) {

  		if ( scope.onError !== undefined ) {

  			scope.onError( url );

  		}

  	};

  }

  var DefaultLoadingManager = new LoadingManager();

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function ImageLoader( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  }

  Object.assign( ImageLoader.prototype, {

  	crossOrigin: 'Anonymous',

  	load: function ( url, onLoad, onProgress, onError ) {

  		if ( url === undefined ) { url = ''; }

  		if ( this.path !== undefined ) { url = this.path + url; }

  		var scope = this;

  		var cached = Cache.get( url );

  		if ( cached !== undefined ) {

  			scope.manager.itemStart( url );

  			setTimeout( function () {

  				if ( onLoad ) { onLoad( cached ); }

  				scope.manager.itemEnd( url );

  			}, 0 );

  			return cached;

  		}

  		var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );

  		image.addEventListener( 'load', function () {

  			Cache.add( url, this );

  			if ( onLoad ) { onLoad( this ); }

  			scope.manager.itemEnd( url );

  		}, false );

  		/*
  		image.addEventListener( 'progress', function ( event ) {

  			if ( onProgress ) onProgress( event );

  		}, false );
  		*/

  		image.addEventListener( 'error', function ( event ) {

  			if ( onError ) { onError( event ); }

  			scope.manager.itemEnd( url );
  			scope.manager.itemError( url );

  		}, false );

  		if ( url.substr( 0, 5 ) !== 'data:' ) {

  			if ( this.crossOrigin !== undefined ) { image.crossOrigin = this.crossOrigin; }

  		}

  		scope.manager.itemStart( url );

  		image.src = url;

  		return image;

  	},

  	setCrossOrigin: function ( value ) {

  		this.crossOrigin = value;
  		return this;

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	}

  } );

  /**
   * @author tschw
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   */

  var AnimationUtils = {

  	// same as Array.prototype.slice, but also works on typed arrays
  	arraySlice: function ( array, from, to ) {

  		if ( AnimationUtils.isTypedArray( array ) ) {

  			// in ios9 array.subarray(from, undefined) will return empty array
  			// but array.subarray(from) or array.subarray(from, len) is correct
  			return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

  		}

  		return array.slice( from, to );

  	},

  	// converts an array to a specific type
  	convertArray: function ( array, type, forceClone ) {

  		if ( ! array || // let 'undefined' and 'null' pass
  				! forceClone && array.constructor === type ) { return array; }

  		if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

  			return new type( array ); // create typed array

  		}

  		return Array.prototype.slice.call( array ); // create Array

  	},

  	isTypedArray: function ( object ) {

  		return ArrayBuffer.isView( object ) &&
  				! ( object instanceof DataView );

  	},

  	// returns an array by which times and values can be sorted
  	getKeyframeOrder: function ( times ) {

  		function compareTime( i, j ) {

  			return times[ i ] - times[ j ];

  		}

  		var n = times.length;
  		var result = new Array( n );
  		for ( var i = 0; i !== n; ++ i ) { result[ i ] = i; }

  		result.sort( compareTime );

  		return result;

  	},

  	// uses the array previously returned by 'getKeyframeOrder' to sort data
  	sortedArray: function ( values, stride, order ) {

  		var nValues = values.length;
  		var result = new values.constructor( nValues );

  		for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

  			var srcOffset = order[ i ] * stride;

  			for ( var j = 0; j !== stride; ++ j ) {

  				result[ dstOffset ++ ] = values[ srcOffset + j ];

  			}

  		}

  		return result;

  	},

  	// function for parsing AOS keyframe formats
  	flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {

  		var i = 1, key = jsonKeys[ 0 ];

  		while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

  			key = jsonKeys[ i ++ ];

  		}

  		if ( key === undefined ) { return; } // no data

  		var value = key[ valuePropertyName ];
  		if ( value === undefined ) { return; } // no data

  		if ( Array.isArray( value ) ) {

  			do {

  				value = key[ valuePropertyName ];

  				if ( value !== undefined ) {

  					times.push( key.time );
  					values.push.apply( values, value ); // push all elements

  				}

  				key = jsonKeys[ i ++ ];

  			} while ( key !== undefined );

  		} else if ( value.toArray !== undefined ) {

  			// ...assume THREE.Math-ish

  			do {

  				value = key[ valuePropertyName ];

  				if ( value !== undefined ) {

  					times.push( key.time );
  					value.toArray( values, values.length );

  				}

  				key = jsonKeys[ i ++ ];

  			} while ( key !== undefined );

  		} else {

  			// otherwise push as-is

  			do {

  				value = key[ valuePropertyName ];

  				if ( value !== undefined ) {

  					times.push( key.time );
  					values.push( value );

  				}

  				key = jsonKeys[ i ++ ];

  			} while ( key !== undefined );

  		}

  	}

  };

  /**
   * Abstract base class of interpolants over parametric samples.
   *
   * The parameter domain is one dimensional, typically the time or a path
   * along a curve defined by the data.
   *
   * The sample values can have any dimensionality and derived classes may
   * apply special interpretations to the data.
   *
   * This class provides the interval seek in a Template Method, deferring
   * the actual interpolation to derived classes.
   *
   * Time complexity is O(1) for linear access crossing at most two points
   * and O(log N) for random access, where N is the number of positions.
   *
   * References:
   *
   * 		http://www.oodesign.com/template-method-pattern.html
   *
   * @author tschw
   */

  function Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  	this.parameterPositions = parameterPositions;
  	this._cachedIndex = 0;

  	this.resultBuffer = resultBuffer !== undefined ?
  		resultBuffer : new sampleValues.constructor( sampleSize );
  	this.sampleValues = sampleValues;
  	this.valueSize = sampleSize;

  }

  Object.assign( Interpolant.prototype, {

  	evaluate: function ( t ) {
  		var this$1 = this;


  		var pp = this.parameterPositions,
  			i1 = this._cachedIndex,

  			t1 = pp[ i1 ],
  			t0 = pp[ i1 - 1 ];

  		validate_interval: {

  			seek: {

  				var right;

  				linear_scan: {

  					//- See http://jsperf.com/comparison-to-undefined/3
  					//- slower code:
  					//-
  					//- 				if ( t >= t1 || t1 === undefined ) {
  					forward_scan: if ( ! ( t < t1 ) ) {

  						for ( var giveUpAt = i1 + 2; ; ) {

  							if ( t1 === undefined ) {

  								if ( t < t0 ) { break forward_scan; }

  								// after end

  								i1 = pp.length;
  								this$1._cachedIndex = i1;
  								return this$1.afterEnd_( i1 - 1, t, t0 );

  							}

  							if ( i1 === giveUpAt ) { break; } // this loop

  							t0 = t1;
  							t1 = pp[ ++ i1 ];

  							if ( t < t1 ) {

  								// we have arrived at the sought interval
  								break seek;

  							}

  						}

  						// prepare binary search on the right side of the index
  						right = pp.length;
  						break linear_scan;

  					}

  					//- slower code:
  					//-					if ( t < t0 || t0 === undefined ) {
  					if ( ! ( t >= t0 ) ) {

  						// looping?

  						var t1global = pp[ 1 ];

  						if ( t < t1global ) {

  							i1 = 2; // + 1, using the scan for the details
  							t0 = t1global;

  						}

  						// linear reverse scan

  						for ( var giveUpAt = i1 - 2; ; ) {

  							if ( t0 === undefined ) {

  								// before start

  								this$1._cachedIndex = 0;
  								return this$1.beforeStart_( 0, t, t1 );

  							}

  							if ( i1 === giveUpAt ) { break; } // this loop

  							t1 = t0;
  							t0 = pp[ -- i1 - 1 ];

  							if ( t >= t0 ) {

  								// we have arrived at the sought interval
  								break seek;

  							}

  						}

  						// prepare binary search on the left side of the index
  						right = i1;
  						i1 = 0;
  						break linear_scan;

  					}

  					// the interval is valid

  					break validate_interval;

  				} // linear scan

  				// binary search

  				while ( i1 < right ) {

  					var mid = ( i1 + right ) >>> 1;

  					if ( t < pp[ mid ] ) {

  						right = mid;

  					} else {

  						i1 = mid + 1;

  					}

  				}

  				t1 = pp[ i1 ];
  				t0 = pp[ i1 - 1 ];

  				// check boundary cases, again

  				if ( t0 === undefined ) {

  					this._cachedIndex = 0;
  					return this.beforeStart_( 0, t, t1 );

  				}

  				if ( t1 === undefined ) {

  					i1 = pp.length;
  					this._cachedIndex = i1;
  					return this.afterEnd_( i1 - 1, t0, t );

  				}

  			} // seek

  			this._cachedIndex = i1;

  			this.intervalChanged_( i1, t0, t1 );

  		} // validate_interval

  		return this.interpolate_( i1, t0, t, t1 );

  	},

  	settings: null, // optional, subclass-specific settings structure
  	// Note: The indirection allows central control of many interpolants.

  	// --- Protected interface

  	DefaultSettings_: {},

  	getSettings_: function () {

  		return this.settings || this.DefaultSettings_;

  	},

  	copySampleValue_: function ( index ) {

  		// copies a sample value to the result buffer

  		var result = this.resultBuffer,
  			values = this.sampleValues,
  			stride = this.valueSize,
  			offset = index * stride;

  		for ( var i = 0; i !== stride; ++ i ) {

  			result[ i ] = values[ offset + i ];

  		}

  		return result;

  	},

  	// Template methods for derived classes:

  	interpolate_: function ( /* i1, t0, t, t1 */ ) {

  		throw new Error( 'call to abstract method' );
  		// implementations shall return this.resultBuffer

  	},

  	intervalChanged_: function ( /* i1, t0, t1 */ ) {

  		// empty

  	}

  } );

  //!\ DECLARE ALIAS AFTER assign prototype !
  Object.assign( Interpolant.prototype, {

  	//( 0, t, t0 ), returns this.resultBuffer
  	beforeStart_: Interpolant.prototype.copySampleValue_,

  	//( N-1, tN-1, t ), returns this.resultBuffer
  	afterEnd_: Interpolant.prototype.copySampleValue_,

  } );

  /**
   * Fast and simple cubic spline interpolant.
   *
   * It was derived from a Hermitian construction setting the first derivative
   * at each sample position to the linear slope between neighboring positions
   * over their parameter interval.
   *
   * @author tschw
   */

  function CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

  	this._weightPrev = - 0;
  	this._offsetPrev = - 0;
  	this._weightNext = - 0;
  	this._offsetNext = - 0;

  }

  CubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

  	constructor: CubicInterpolant,

  	DefaultSettings_: {

  		endingStart: ZeroCurvatureEnding,
  		endingEnd: ZeroCurvatureEnding

  	},

  	intervalChanged_: function ( i1, t0, t1 ) {

  		var pp = this.parameterPositions,
  			iPrev = i1 - 2,
  			iNext = i1 + 1,

  			tPrev = pp[ iPrev ],
  			tNext = pp[ iNext ];

  		if ( tPrev === undefined ) {

  			switch ( this.getSettings_().endingStart ) {

  				case ZeroSlopeEnding:

  					// f'(t0) = 0
  					iPrev = i1;
  					tPrev = 2 * t0 - t1;

  					break;

  				case WrapAroundEnding:

  					// use the other end of the curve
  					iPrev = pp.length - 2;
  					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

  					break;

  				default: // ZeroCurvatureEnding

  					// f''(t0) = 0 a.k.a. Natural Spline
  					iPrev = i1;
  					tPrev = t1;

  			}

  		}

  		if ( tNext === undefined ) {

  			switch ( this.getSettings_().endingEnd ) {

  				case ZeroSlopeEnding:

  					// f'(tN) = 0
  					iNext = i1;
  					tNext = 2 * t1 - t0;

  					break;

  				case WrapAroundEnding:

  					// use the other end of the curve
  					iNext = 1;
  					tNext = t1 + pp[ 1 ] - pp[ 0 ];

  					break;

  				default: // ZeroCurvatureEnding

  					// f''(tN) = 0, a.k.a. Natural Spline
  					iNext = i1 - 1;
  					tNext = t0;

  			}

  		}

  		var halfDt = ( t1 - t0 ) * 0.5,
  			stride = this.valueSize;

  		this._weightPrev = halfDt / ( t0 - tPrev );
  		this._weightNext = halfDt / ( tNext - t1 );
  		this._offsetPrev = iPrev * stride;
  		this._offsetNext = iNext * stride;

  	},

  	interpolate_: function ( i1, t0, t, t1 ) {

  		var result = this.resultBuffer,
  			values = this.sampleValues,
  			stride = this.valueSize,

  			o1 = i1 * stride,		o0 = o1 - stride,
  			oP = this._offsetPrev, 	oN = this._offsetNext,
  			wP = this._weightPrev,	wN = this._weightNext,

  			p = ( t - t0 ) / ( t1 - t0 ),
  			pp = p * p,
  			ppp = pp * p;

  		// evaluate polynomials

  		var sP = - wP * ppp + 2 * wP * pp - wP * p;
  		var s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
  		var s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
  		var sN = wN * ppp - wN * pp;

  		// combine data linearly

  		for ( var i = 0; i !== stride; ++ i ) {

  			result[ i ] =
  					sP * values[ oP + i ] +
  					s0 * values[ o0 + i ] +
  					s1 * values[ o1 + i ] +
  					sN * values[ oN + i ];

  		}

  		return result;

  	}

  } );

  /**
   * @author tschw
   */

  function LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

  }

  LinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

  	constructor: LinearInterpolant,

  	interpolate_: function ( i1, t0, t, t1 ) {

  		var result = this.resultBuffer,
  			values = this.sampleValues,
  			stride = this.valueSize,

  			offset1 = i1 * stride,
  			offset0 = offset1 - stride,

  			weight1 = ( t - t0 ) / ( t1 - t0 ),
  			weight0 = 1 - weight1;

  		for ( var i = 0; i !== stride; ++ i ) {

  			result[ i ] =
  					values[ offset0 + i ] * weight0 +
  					values[ offset1 + i ] * weight1;

  		}

  		return result;

  	}

  } );

  /**
   *
   * Interpolant that evaluates to the sample value at the position preceeding
   * the parameter.
   *
   * @author tschw
   */

  function DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

  }

  DiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

  	constructor: DiscreteInterpolant,

  	interpolate_: function ( i1 /* t0, t, t1 */ ) {

  		return this.copySampleValue_( i1 - 1 );

  	}

  } );

  var KeyframeTrackPrototype;

  KeyframeTrackPrototype = {

  	TimeBufferType: Float32Array,
  	ValueBufferType: Float32Array,

  	DefaultInterpolation: InterpolateLinear,

  	InterpolantFactoryMethodDiscrete: function ( result ) {

  		return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

  	},

  	InterpolantFactoryMethodLinear: function ( result ) {

  		return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );

  	},

  	InterpolantFactoryMethodSmooth: function ( result ) {

  		return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );

  	},

  	setInterpolation: function ( interpolation ) {

  		var factoryMethod;

  		switch ( interpolation ) {

  			case InterpolateDiscrete:

  				factoryMethod = this.InterpolantFactoryMethodDiscrete;

  				break;

  			case InterpolateLinear:

  				factoryMethod = this.InterpolantFactoryMethodLinear;

  				break;

  			case InterpolateSmooth:

  				factoryMethod = this.InterpolantFactoryMethodSmooth;

  				break;

  		}

  		if ( factoryMethod === undefined ) {

  			var message = "unsupported interpolation for " +
  					this.ValueTypeName + " keyframe track named " + this.name;

  			if ( this.createInterpolant === undefined ) {

  				// fall back to default, unless the default itself is messed up
  				if ( interpolation !== this.DefaultInterpolation ) {

  					this.setInterpolation( this.DefaultInterpolation );

  				} else {

  					throw new Error( message ); // fatal, in this case

  				}

  			}

  			console.warn( 'THREE.KeyframeTrackPrototype:', message );
  			return;

  		}

  		this.createInterpolant = factoryMethod;

  	},

  	getInterpolation: function () {

  		switch ( this.createInterpolant ) {

  			case this.InterpolantFactoryMethodDiscrete:

  				return InterpolateDiscrete;

  			case this.InterpolantFactoryMethodLinear:

  				return InterpolateLinear;

  			case this.InterpolantFactoryMethodSmooth:

  				return InterpolateSmooth;

  		}

  	},

  	getValueSize: function () {

  		return this.values.length / this.times.length;

  	},

  	// move all keyframes either forwards or backwards in time
  	shift: function ( timeOffset ) {

  		if ( timeOffset !== 0.0 ) {

  			var times = this.times;

  			for ( var i = 0, n = times.length; i !== n; ++ i ) {

  				times[ i ] += timeOffset;

  			}

  		}

  		return this;

  	},

  	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  	scale: function ( timeScale ) {

  		if ( timeScale !== 1.0 ) {

  			var times = this.times;

  			for ( var i = 0, n = times.length; i !== n; ++ i ) {

  				times[ i ] *= timeScale;

  			}

  		}

  		return this;

  	},

  	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  	trim: function ( startTime, endTime ) {

  		var times = this.times,
  			nKeys = times.length,
  			from = 0,
  			to = nKeys - 1;

  		while ( from !== nKeys && times[ from ] < startTime ) { ++ from; }
  		while ( to !== - 1 && times[ to ] > endTime ) { -- to; }

  		++ to; // inclusive -> exclusive bound

  		if ( from !== 0 || to !== nKeys ) {

  			// empty tracks are forbidden, so keep at least one keyframe
  			if ( from >= to ) { to = Math.max( to, 1 ), from = to - 1; }

  			var stride = this.getValueSize();
  			this.times = AnimationUtils.arraySlice( times, from, to );
  			this.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );

  		}

  		return this;

  	},

  	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  	validate: function () {
  		var this$1 = this;


  		var valid = true;

  		var valueSize = this.getValueSize();
  		if ( valueSize - Math.floor( valueSize ) !== 0 ) {

  			console.error( 'THREE.KeyframeTrackPrototype: Invalid value size in track.', this );
  			valid = false;

  		}

  		var times = this.times,
  			values = this.values,

  			nKeys = times.length;

  		if ( nKeys === 0 ) {

  			console.error( 'THREE.KeyframeTrackPrototype: Track is empty.', this );
  			valid = false;

  		}

  		var prevTime = null;

  		for ( var i = 0; i !== nKeys; i ++ ) {

  			var currTime = times[ i ];

  			if ( typeof currTime === 'number' && isNaN( currTime ) ) {

  				console.error( 'THREE.KeyframeTrackPrototype: Time is not a valid number.', this$1, i, currTime );
  				valid = false;
  				break;

  			}

  			if ( prevTime !== null && prevTime > currTime ) {

  				console.error( 'THREE.KeyframeTrackPrototype: Out of order keys.', this$1, i, currTime, prevTime );
  				valid = false;
  				break;

  			}

  			prevTime = currTime;

  		}

  		if ( values !== undefined ) {

  			if ( AnimationUtils.isTypedArray( values ) ) {

  				for ( var i = 0, n = values.length; i !== n; ++ i ) {

  					var value = values[ i ];

  					if ( isNaN( value ) ) {

  						console.error( 'THREE.KeyframeTrackPrototype: Value is not a valid number.', this$1, i, value );
  						valid = false;
  						break;

  					}

  				}

  			}

  		}

  		return valid;

  	},

  	// removes equivalent sequential keys as common in morph target sequences
  	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  	optimize: function () {

  		var times = this.times,
  			values = this.values,
  			stride = this.getValueSize(),

  			smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

  			writeIndex = 1,
  			lastIndex = times.length - 1;

  		for ( var i = 1; i < lastIndex; ++ i ) {

  			var keep = false;

  			var time = times[ i ];
  			var timeNext = times[ i + 1 ];

  			// remove adjacent keyframes scheduled at the same time

  			if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {

  				if ( ! smoothInterpolation ) {

  					// remove unnecessary keyframes same as their neighbors

  					var offset = i * stride,
  						offsetP = offset - stride,
  						offsetN = offset + stride;

  					for ( var j = 0; j !== stride; ++ j ) {

  						var value = values[ offset + j ];

  						if ( value !== values[ offsetP + j ] ||
  								value !== values[ offsetN + j ] ) {

  							keep = true;
  							break;

  						}

  					}

  				} else { keep = true; }

  			}

  			// in-place compaction

  			if ( keep ) {

  				if ( i !== writeIndex ) {

  					times[ writeIndex ] = times[ i ];

  					var readOffset = i * stride,
  						writeOffset = writeIndex * stride;

  					for ( var j = 0; j !== stride; ++ j )

  						{ values[ writeOffset + j ] = values[ readOffset + j ]; }

  				}

  				++ writeIndex;

  			}

  		}

  		// flush last keyframe (compaction looks ahead)

  		if ( lastIndex > 0 ) {

  			times[ writeIndex ] = times[ lastIndex ];

  			for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j )

  				{ values[ writeOffset + j ] = values[ readOffset + j ]; }

  			++ writeIndex;

  		}

  		if ( writeIndex !== times.length ) {

  			this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
  			this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );

  		}

  		return this;

  	}

  };

  function KeyframeTrackConstructor( name, times, values, interpolation ) {

  	if ( name === undefined ) { throw new Error( 'track name is undefined' ); }

  	if ( times === undefined || times.length === 0 ) {

  		throw new Error( 'no keyframes in track named ' + name );

  	}

  	this.name = name;

  	this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
  	this.values = AnimationUtils.convertArray( values, this.ValueBufferType );

  	this.setInterpolation( interpolation || this.DefaultInterpolation );

  	this.validate();
  	this.optimize();

  }

  /**
   *
   * A Track of vectored keyframe values.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function VectorKeyframeTrack( name, times, values, interpolation ) {

  	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

  }

  VectorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrackPrototype ), {

  	constructor: VectorKeyframeTrack,

  	ValueTypeName: 'vector'

  	// ValueBufferType is inherited

  	// DefaultInterpolation is inherited

  } );

  /**
   * Spherical linear unit quaternion interpolant.
   *
   * @author tschw
   */

  function QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

  }

  QuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

  	constructor: QuaternionLinearInterpolant,

  	interpolate_: function ( i1, t0, t, t1 ) {

  		var result = this.resultBuffer,
  			values = this.sampleValues,
  			stride = this.valueSize,

  			offset = i1 * stride,

  			alpha = ( t - t0 ) / ( t1 - t0 );

  		for ( var end = offset + stride; offset !== end; offset += 4 ) {

  			Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

  		}

  		return result;

  	}

  } );

  /**
   *
   * A Track of quaternion keyframe values.
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function QuaternionKeyframeTrack( name, times, values, interpolation ) {

  	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

  }

  QuaternionKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrackPrototype ), {

  	constructor: QuaternionKeyframeTrack,

  	ValueTypeName: 'quaternion',

  	// ValueBufferType is inherited

  	DefaultInterpolation: InterpolateLinear,

  	InterpolantFactoryMethodLinear: function ( result ) {

  		return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

  	},

  	InterpolantFactoryMethodSmooth: undefined // not yet implemented

  } );

  /**
   *
   * A Track of numeric keyframe values.
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function NumberKeyframeTrack( name, times, values, interpolation ) {

  	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

  }

  NumberKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrackPrototype ), {

  	constructor: NumberKeyframeTrack,

  	ValueTypeName: 'number'

  	// ValueBufferType is inherited

  	// DefaultInterpolation is inherited

  } );

  /**
   *
   * A Track that interpolates Strings
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function StringKeyframeTrack( name, times, values, interpolation ) {

  	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

  }

  StringKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrackPrototype ), {

  	constructor: StringKeyframeTrack,

  	ValueTypeName: 'string',
  	ValueBufferType: Array,

  	DefaultInterpolation: InterpolateDiscrete,

  	InterpolantFactoryMethodLinear: undefined,

  	InterpolantFactoryMethodSmooth: undefined

  } );

  /**
   *
   * A Track of Boolean keyframe values.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function BooleanKeyframeTrack( name, times, values ) {

  	KeyframeTrackConstructor.call( this, name, times, values );

  }

  BooleanKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrackPrototype ), {

  	constructor: BooleanKeyframeTrack,

  	ValueTypeName: 'bool',
  	ValueBufferType: Array,

  	DefaultInterpolation: InterpolateDiscrete,

  	InterpolantFactoryMethodLinear: undefined,
  	InterpolantFactoryMethodSmooth: undefined

  	// Note: Actually this track could have a optimized / compressed
  	// representation of a single value and a custom interpolant that
  	// computes "firstValue ^ isOdd( index )".

  } );

  /**
   *
   * A Track of keyframe values that represent color.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function ColorKeyframeTrack( name, times, values, interpolation ) {

  	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

  }

  ColorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrackPrototype ), {

  	constructor: ColorKeyframeTrack,

  	ValueTypeName: 'color'

  	// ValueBufferType is inherited

  	// DefaultInterpolation is inherited


  	// Note: Very basic implementation and nothing special yet.
  	// However, this is the place for color space parameterization.

  } );

  /**
   *
   * A timed sequence of keyframes for a specific property.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function KeyframeTrack( name, times, values, interpolation ) {

  	KeyframeTrackConstructor.apply( this, name, times, values, interpolation );

  }

  KeyframeTrack.prototype = KeyframeTrackPrototype;
  KeyframeTrackPrototype.constructor = KeyframeTrack;

  // Static methods:

  Object.assign( KeyframeTrack, {

  	// Serialization (in static context, because of constructor invocation
  	// and automatic invocation of .toJSON):

  	parse: function ( json ) {

  		if ( json.type === undefined ) {

  			throw new Error( 'track type undefined, can not parse' );

  		}

  		var trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );

  		if ( json.times === undefined ) {

  			var times = [], values = [];

  			AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

  			json.times = times;
  			json.values = values;

  		}

  		// derived classes can define a static parse method
  		if ( trackType.parse !== undefined ) {

  			return trackType.parse( json );

  		} else {

  			// by default, we assume a constructor compatible with the base
  			return new trackType( json.name, json.times, json.values, json.interpolation );

  		}

  	},

  	toJSON: function ( track ) {

  		var trackType = track.constructor;

  		var json;

  		// derived classes can define a static toJSON method
  		if ( trackType.toJSON !== undefined ) {

  			json = trackType.toJSON( track );

  		} else {

  			// by default, we assume the data can be serialized as-is
  			json = {

  				'name': track.name,
  				'times': AnimationUtils.convertArray( track.times, Array ),
  				'values': AnimationUtils.convertArray( track.values, Array )

  			};

  			var interpolation = track.getInterpolation();

  			if ( interpolation !== track.DefaultInterpolation ) {

  				json.interpolation = interpolation;

  			}

  		}

  		json.type = track.ValueTypeName; // mandatory

  		return json;

  	},

  	_getTrackTypeForValueTypeName: function ( typeName ) {

  		switch ( typeName.toLowerCase() ) {

  			case 'scalar':
  			case 'double':
  			case 'float':
  			case 'number':
  			case 'integer':

  				return NumberKeyframeTrack;

  			case 'vector':
  			case 'vector2':
  			case 'vector3':
  			case 'vector4':

  				return VectorKeyframeTrack;

  			case 'color':

  				return ColorKeyframeTrack;

  			case 'quaternion':

  				return QuaternionKeyframeTrack;

  			case 'bool':
  			case 'boolean':

  				return BooleanKeyframeTrack;

  			case 'string':

  				return StringKeyframeTrack;

  		}

  		throw new Error( 'Unsupported typeName: ' + typeName );

  	}

  } );

  /**
   *
   * Reusable set of Tracks that represent an animation.
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   */

  function AnimationClip( name, duration, tracks ) {

  	this.name = name;
  	this.tracks = tracks;
  	this.duration = ( duration !== undefined ) ? duration : - 1;

  	this.uuid = _Math.generateUUID();

  	// this means it should figure out its duration by scanning the tracks
  	if ( this.duration < 0 ) {

  		this.resetDuration();

  	}

  	this.optimize();

  }

  Object.assign( AnimationClip, {

  	parse: function ( json ) {

  		var tracks = [],
  			jsonTracks = json.tracks,
  			frameTime = 1.0 / ( json.fps || 1.0 );

  		for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {

  			tracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );

  		}

  		return new AnimationClip( json.name, json.duration, tracks );

  	},

  	toJSON: function ( clip ) {

  		var tracks = [],
  			clipTracks = clip.tracks;

  		var json = {

  			'name': clip.name,
  			'duration': clip.duration,
  			'tracks': tracks

  		};

  		for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {

  			tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

  		}

  		return json;

  	},

  	CreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {

  		var numMorphTargets = morphTargetSequence.length;
  		var tracks = [];

  		for ( var i = 0; i < numMorphTargets; i ++ ) {

  			var times = [];
  			var values = [];

  			times.push(
  				( i + numMorphTargets - 1 ) % numMorphTargets,
  				i,
  				( i + 1 ) % numMorphTargets );

  			values.push( 0, 1, 0 );

  			var order = AnimationUtils.getKeyframeOrder( times );
  			times = AnimationUtils.sortedArray( times, 1, order );
  			values = AnimationUtils.sortedArray( values, 1, order );

  			// if there is a key at the first frame, duplicate it as the
  			// last frame as well for perfect loop.
  			if ( ! noLoop && times[ 0 ] === 0 ) {

  				times.push( numMorphTargets );
  				values.push( values[ 0 ] );

  			}

  			tracks.push(
  				new NumberKeyframeTrack(
  					'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
  					times, values
  				).scale( 1.0 / fps ) );

  		}

  		return new AnimationClip( name, - 1, tracks );

  	},

  	findByName: function ( objectOrClipArray, name ) {

  		var clipArray = objectOrClipArray;

  		if ( ! Array.isArray( objectOrClipArray ) ) {

  			var o = objectOrClipArray;
  			clipArray = o.geometry && o.geometry.animations || o.animations;

  		}

  		for ( var i = 0; i < clipArray.length; i ++ ) {

  			if ( clipArray[ i ].name === name ) {

  				return clipArray[ i ];

  			}

  		}

  		return null;

  	},

  	CreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {

  		var animationToMorphTargets = {};

  		// tested with https://regex101.com/ on trick sequences
  		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
  		var pattern = /^([\w-]*?)([\d]+)$/;

  		// sort morph target names into animation groups based
  		// patterns like Walk_001, Walk_002, Run_001, Run_002
  		for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

  			var morphTarget = morphTargets[ i ];
  			var parts = morphTarget.name.match( pattern );

  			if ( parts && parts.length > 1 ) {

  				var name = parts[ 1 ];

  				var animationMorphTargets = animationToMorphTargets[ name ];
  				if ( ! animationMorphTargets ) {

  					animationToMorphTargets[ name ] = animationMorphTargets = [];

  				}

  				animationMorphTargets.push( morphTarget );

  			}

  		}

  		var clips = [];

  		for ( var name in animationToMorphTargets ) {

  			clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

  		}

  		return clips;

  	},

  	// parse the animation.hierarchy format
  	parseAnimation: function ( animation, bones ) {

  		if ( ! animation ) {

  			console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
  			return null;

  		}

  		var addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

  			// only return track if there are actually keys.
  			if ( animationKeys.length !== 0 ) {

  				var times = [];
  				var values = [];

  				AnimationUtils.flattenJSON( animationKeys, times, values, propertyName );

  				// empty keys are filtered out, so check again
  				if ( times.length !== 0 ) {

  					destTracks.push( new trackType( trackName, times, values ) );

  				}

  			}

  		};

  		var tracks = [];

  		var clipName = animation.name || 'default';
  		// automatic length determination in AnimationClip.
  		var duration = animation.length || - 1;
  		var fps = animation.fps || 30;

  		var hierarchyTracks = animation.hierarchy || [];

  		for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

  			var animationKeys = hierarchyTracks[ h ].keys;

  			// skip empty tracks
  			if ( ! animationKeys || animationKeys.length === 0 ) { continue; }

  			// process morph targets
  			if ( animationKeys[ 0 ].morphTargets ) {

  				// figure out all morph targets used in this track
  				var morphTargetNames = {};

  				for ( var k = 0; k < animationKeys.length; k ++ ) {

  					if ( animationKeys[ k ].morphTargets ) {

  						for ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

  							morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

  						}

  					}

  				}

  				// create a track for each morph target with all zero
  				// morphTargetInfluences except for the keys in which
  				// the morphTarget is named.
  				for ( var morphTargetName in morphTargetNames ) {

  					var times = [];
  					var values = [];

  					for ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

  						var animationKey = animationKeys[ k ];

  						times.push( animationKey.time );
  						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

  					}

  					tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

  				}

  				duration = morphTargetNames.length * ( fps || 1.0 );

  			} else {

  				// ...assume skeletal animation

  				var boneName = '.bones[' + bones[ h ].name + ']';

  				addNonemptyTrack(
  					VectorKeyframeTrack, boneName + '.position',
  					animationKeys, 'pos', tracks );

  				addNonemptyTrack(
  					QuaternionKeyframeTrack, boneName + '.quaternion',
  					animationKeys, 'rot', tracks );

  				addNonemptyTrack(
  					VectorKeyframeTrack, boneName + '.scale',
  					animationKeys, 'scl', tracks );

  			}

  		}

  		if ( tracks.length === 0 ) {

  			return null;

  		}

  		var clip = new AnimationClip( clipName, duration, tracks );

  		return clip;

  	}

  } );

  Object.assign( AnimationClip.prototype, {

  	resetDuration: function () {
  		var this$1 = this;


  		var tracks = this.tracks, duration = 0;

  		for ( var i = 0, n = tracks.length; i !== n; ++ i ) {

  			var track = this$1.tracks[ i ];

  			duration = Math.max( duration, track.times[ track.times.length - 1 ] );

  		}

  		this.duration = duration;

  	},

  	trim: function () {
  		var this$1 = this;


  		for ( var i = 0; i < this.tracks.length; i ++ ) {

  			this$1.tracks[ i ].trim( 0, this$1.duration );

  		}

  		return this;

  	},

  	optimize: function () {
  		var this$1 = this;


  		for ( var i = 0; i < this.tracks.length; i ++ ) {

  			this$1.tracks[ i ].optimize();

  		}

  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function FileLoader( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  }

  Object.assign( FileLoader.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {
  		var this$1 = this;


  		if ( url === undefined ) { url = ''; }

  		if ( this.path !== undefined ) { url = this.path + url; }

  		var scope = this;

  		var cached = Cache.get( url );

  		if ( cached !== undefined ) {

  			scope.manager.itemStart( url );

  			setTimeout( function () {

  				if ( onLoad ) { onLoad( cached ); }

  				scope.manager.itemEnd( url );

  			}, 0 );

  			return cached;

  		}

  		// Check for data: URI
  		var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
  		var dataUriRegexResult = url.match( dataUriRegex );

  		// Safari can not handle Data URIs through XMLHttpRequest so process manually
  		if ( dataUriRegexResult ) {

  			var mimeType = dataUriRegexResult[ 1 ];
  			var isBase64 = !! dataUriRegexResult[ 2 ];
  			var data = dataUriRegexResult[ 3 ];

  			data = window.decodeURIComponent( data );

  			if ( isBase64 ) { data = window.atob( data ); }

  			try {

  				var response;
  				var responseType = ( this.responseType || '' ).toLowerCase();

  				switch ( responseType ) {

  					case 'arraybuffer':
  					case 'blob':

  						var view = new Uint8Array( data.length );

  						for ( var i = 0; i < data.length; i ++ ) {

  							view[ i ] = data.charCodeAt( i );

  						}

  						if ( responseType === 'blob' ) {

  							response = new Blob( [ view.buffer ], { type: mimeType } );

  						} else {

  							response = view.buffer;

  						}

  						break;

  					case 'document':

  						var parser = new DOMParser();
  						response = parser.parseFromString( data, mimeType );

  						break;

  					case 'json':

  						response = JSON.parse( data );

  						break;

  					default: // 'text' or other

  						response = data;

  						break;

  				}

  				// Wait for next browser tick like standard XMLHttpRequest event dispatching does
  				window.setTimeout( function () {

  					if ( onLoad ) { onLoad( response ); }

  					scope.manager.itemEnd( url );

  				}, 0 );

  			} catch ( error ) {

  				// Wait for next browser tick like standard XMLHttpRequest event dispatching does
  				window.setTimeout( function () {

  					if ( onError ) { onError( error ); }

  					scope.manager.itemEnd( url );
  					scope.manager.itemError( url );

  				}, 0 );

  			}

  		} else {

  			var request = new XMLHttpRequest();
  			request.open( 'GET', url, true );

  			request.addEventListener( 'load', function ( event ) {

  				var response = event.target.response;

  				Cache.add( url, response );

  				if ( this.status === 200 ) {

  					if ( onLoad ) { onLoad( response ); }

  					scope.manager.itemEnd( url );

  				} else if ( this.status === 0 ) {

  					// Some browsers return HTTP Status 0 when using non-http protocol
  					// e.g. 'file://' or 'data://'. Handle as success.

  					console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

  					if ( onLoad ) { onLoad( response ); }

  					scope.manager.itemEnd( url );

  				} else {

  					if ( onError ) { onError( event ); }

  					scope.manager.itemEnd( url );
  					scope.manager.itemError( url );

  				}

  			}, false );

  			if ( onProgress !== undefined ) {

  				request.addEventListener( 'progress', function ( event ) {

  					onProgress( event );

  				}, false );

  			}

  			request.addEventListener( 'error', function ( event ) {

  				if ( onError ) { onError( event ); }

  				scope.manager.itemEnd( url );
  				scope.manager.itemError( url );

  			}, false );

  			if ( this.responseType !== undefined ) { request.responseType = this.responseType; }
  			if ( this.withCredentials !== undefined ) { request.withCredentials = this.withCredentials; }

  			if ( request.overrideMimeType ) { request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' ); }

  			for ( var header in this$1.requestHeader ) {

  				request.setRequestHeader( header, this$1.requestHeader[ header ] );

  			}

  			request.send( null );

  		}

  		scope.manager.itemStart( url );

  		return request;

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	},

  	setResponseType: function ( value ) {

  		this.responseType = value;
  		return this;

  	},

  	setWithCredentials: function ( value ) {

  		this.withCredentials = value;
  		return this;

  	},

  	setMimeType: function ( value ) {

  		this.mimeType = value;
  		return this;

  	},

  	setRequestHeader: function ( value ) {

  		this.requestHeader = value;
  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   *
   * parameters = {
   *  color: <THREE.Color>,
   *  opacity: <float>
   * }
   */

  function ShadowMaterial( parameters ) {

  	Material.call( this );

  	this.type = 'ShadowMaterial';

  	this.color = new Color( 0x000000 );
  	this.opacity = 1.0;

  	this.lights = true;
  	this.transparent = true;

  	this.setValues( parameters );

  }

  ShadowMaterial.prototype = Object.create( Material.prototype );
  ShadowMaterial.prototype.constructor = ShadowMaterial;

  ShadowMaterial.prototype.isShadowMaterial = true;

  /**
   * Uniform Utilities
   */

  var UniformsUtils = {

  	merge: function ( uniforms ) {
  		var this$1 = this;


  		var merged = {};

  		for ( var u = 0; u < uniforms.length; u ++ ) {

  			var tmp = this$1.clone( uniforms[ u ] );

  			for ( var p in tmp ) {

  				merged[ p ] = tmp[ p ];

  			}

  		}

  		return merged;

  	},

  	clone: function ( uniforms_src ) {

  		var uniforms_dst = {};

  		for ( var u in uniforms_src ) {

  			uniforms_dst[ u ] = {};

  			for ( var p in uniforms_src[ u ] ) {

  				var parameter_src = uniforms_src[ u ][ p ];

  				if ( parameter_src && ( parameter_src.isColor ||
  					parameter_src.isMatrix3 || parameter_src.isMatrix4 ||
  					parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||
  					parameter_src.isTexture ) ) {

  					uniforms_dst[ u ][ p ] = parameter_src.clone();

  				} else if ( Array.isArray( parameter_src ) ) {

  					uniforms_dst[ u ][ p ] = parameter_src.slice();

  				} else {

  					uniforms_dst[ u ][ p ] = parameter_src;

  				}

  			}

  		}

  		return uniforms_dst;

  	}

  };

  /**
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  defines: { "label" : "value" },
   *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
   *
   *  fragmentShader: <string>,
   *  vertexShader: <string>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  lights: <bool>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */

  function ShaderMaterial( parameters ) {

  	Material.call( this );

  	this.type = 'ShaderMaterial';

  	this.defines = {};
  	this.uniforms = {};

  	this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
  	this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

  	this.linewidth = 1;

  	this.wireframe = false;
  	this.wireframeLinewidth = 1;

  	this.fog = false; // set to use scene fog
  	this.lights = false; // set to use scene lights
  	this.clipping = false; // set to use user-defined clipping planes

  	this.skinning = false; // set to use skinning attribute streams
  	this.morphTargets = false; // set to use morph targets
  	this.morphNormals = false; // set to use morph normals

  	this.extensions = {
  		derivatives: false, // set to use derivatives
  		fragDepth: false, // set to use fragment depth values
  		drawBuffers: false, // set to use draw buffers
  		shaderTextureLOD: false // set to use shader texture LOD
  	};

  	// When rendered geometry doesn't include these attributes but the material does,
  	// use these default values in WebGL. This avoids errors when buffer data is missing.
  	this.defaultAttributeValues = {
  		'color': [ 1, 1, 1 ],
  		'uv': [ 0, 0 ],
  		'uv2': [ 0, 0 ]
  	};

  	this.index0AttributeName = undefined;

  	if ( parameters !== undefined ) {

  		if ( parameters.attributes !== undefined ) {

  			console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

  		}

  		this.setValues( parameters );

  	}

  }

  ShaderMaterial.prototype = Object.create( Material.prototype );
  ShaderMaterial.prototype.constructor = ShaderMaterial;

  ShaderMaterial.prototype.isShaderMaterial = true;

  ShaderMaterial.prototype.copy = function ( source ) {

  	Material.prototype.copy.call( this, source );

  	this.fragmentShader = source.fragmentShader;
  	this.vertexShader = source.vertexShader;

  	this.uniforms = UniformsUtils.clone( source.uniforms );

  	this.defines = source.defines;

  	this.wireframe = source.wireframe;
  	this.wireframeLinewidth = source.wireframeLinewidth;

  	this.lights = source.lights;
  	this.clipping = source.clipping;

  	this.skinning = source.skinning;

  	this.morphTargets = source.morphTargets;
  	this.morphNormals = source.morphNormals;

  	this.extensions = source.extensions;

  	return this;

  };

  ShaderMaterial.prototype.toJSON = function ( meta ) {

  	var data = Material.prototype.toJSON.call( this, meta );

  	data.uniforms = this.uniforms;
  	data.vertexShader = this.vertexShader;
  	data.fragmentShader = this.fragmentShader;

  	return data;

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function RawShaderMaterial( parameters ) {

  	ShaderMaterial.call( this, parameters );

  	this.type = 'RawShaderMaterial';

  }

  RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
  RawShaderMaterial.prototype.constructor = RawShaderMaterial;

  RawShaderMaterial.prototype.isRawShaderMaterial = true;

  /**
   * @author WestLangley / http://github.com/WestLangley
   *
   * parameters = {
   *  color: <hex>,
   *  roughness: <float>,
   *  metalness: <float>,
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  emissive: <hex>,
   *  emissiveIntensity: <float>
   *  emissiveMap: new THREE.Texture( <Image> ),
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  roughnessMap: new THREE.Texture( <Image> ),
   *
   *  metalnessMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
   *  envMapIntensity: <float>
   *
   *  refractionRatio: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */

  function MeshStandardMaterial( parameters ) {

  	Material.call( this );

  	this.defines = { 'STANDARD': '' };

  	this.type = 'MeshStandardMaterial';

  	this.color = new Color( 0xffffff ); // diffuse
  	this.roughness = 0.5;
  	this.metalness = 0.5;

  	this.map = null;

  	this.lightMap = null;
  	this.lightMapIntensity = 1.0;

  	this.aoMap = null;
  	this.aoMapIntensity = 1.0;

  	this.emissive = new Color( 0x000000 );
  	this.emissiveIntensity = 1.0;
  	this.emissiveMap = null;

  	this.bumpMap = null;
  	this.bumpScale = 1;

  	this.normalMap = null;
  	this.normalScale = new Vector2( 1, 1 );

  	this.displacementMap = null;
  	this.displacementScale = 1;
  	this.displacementBias = 0;

  	this.roughnessMap = null;

  	this.metalnessMap = null;

  	this.alphaMap = null;

  	this.envMap = null;
  	this.envMapIntensity = 1.0;

  	this.refractionRatio = 0.98;

  	this.wireframe = false;
  	this.wireframeLinewidth = 1;
  	this.wireframeLinecap = 'round';
  	this.wireframeLinejoin = 'round';

  	this.skinning = false;
  	this.morphTargets = false;
  	this.morphNormals = false;

  	this.setValues( parameters );

  }

  MeshStandardMaterial.prototype = Object.create( Material.prototype );
  MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;

  MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

  MeshStandardMaterial.prototype.copy = function ( source ) {

  	Material.prototype.copy.call( this, source );

  	this.defines = { 'STANDARD': '' };

  	this.color.copy( source.color );
  	this.roughness = source.roughness;
  	this.metalness = source.metalness;

  	this.map = source.map;

  	this.lightMap = source.lightMap;
  	this.lightMapIntensity = source.lightMapIntensity;

  	this.aoMap = source.aoMap;
  	this.aoMapIntensity = source.aoMapIntensity;

  	this.emissive.copy( source.emissive );
  	this.emissiveMap = source.emissiveMap;
  	this.emissiveIntensity = source.emissiveIntensity;

  	this.bumpMap = source.bumpMap;
  	this.bumpScale = source.bumpScale;

  	this.normalMap = source.normalMap;
  	this.normalScale.copy( source.normalScale );

  	this.displacementMap = source.displacementMap;
  	this.displacementScale = source.displacementScale;
  	this.displacementBias = source.displacementBias;

  	this.roughnessMap = source.roughnessMap;

  	this.metalnessMap = source.metalnessMap;

  	this.alphaMap = source.alphaMap;

  	this.envMap = source.envMap;
  	this.envMapIntensity = source.envMapIntensity;

  	this.refractionRatio = source.refractionRatio;

  	this.wireframe = source.wireframe;
  	this.wireframeLinewidth = source.wireframeLinewidth;
  	this.wireframeLinecap = source.wireframeLinecap;
  	this.wireframeLinejoin = source.wireframeLinejoin;

  	this.skinning = source.skinning;
  	this.morphTargets = source.morphTargets;
  	this.morphNormals = source.morphNormals;

  	return this;

  };

  /**
   * @author WestLangley / http://github.com/WestLangley
   *
   * parameters = {
   *  reflectivity: <float>
   * }
   */

  function MeshPhysicalMaterial( parameters ) {

  	MeshStandardMaterial.call( this );

  	this.defines = { 'PHYSICAL': '' };

  	this.type = 'MeshPhysicalMaterial';

  	this.reflectivity = 0.5; // maps to F0 = 0.04

  	this.clearCoat = 0.0;
  	this.clearCoatRoughness = 0.0;

  	this.setValues( parameters );

  }

  MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
  MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;

  MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

  MeshPhysicalMaterial.prototype.copy = function ( source ) {

  	MeshStandardMaterial.prototype.copy.call( this, source );

  	this.defines = { 'PHYSICAL': '' };

  	this.reflectivity = source.reflectivity;

  	this.clearCoat = source.clearCoat;
  	this.clearCoatRoughness = source.clearCoatRoughness;

  	return this;

  };

  /**
   * @author takahirox / http://github.com/takahirox
   *
   * parameters = {
   *  gradientMap: new THREE.Texture( <Image> )
   * }
   */

  function MeshToonMaterial( parameters ) {

  	MeshPhongMaterial.call( this );

  	this.defines = { 'TOON': '' };

  	this.type = 'MeshToonMaterial';

  	this.gradientMap = null;

  	this.setValues( parameters );

  }

  MeshToonMaterial.prototype = Object.create( MeshPhongMaterial.prototype );
  MeshToonMaterial.prototype.constructor = MeshToonMaterial;

  MeshToonMaterial.prototype.isMeshToonMaterial = true;

  MeshToonMaterial.prototype.copy = function ( source ) {

  	MeshPhongMaterial.prototype.copy.call( this, source );

  	this.gradientMap = source.gradientMap;

  	return this;

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author WestLangley / http://github.com/WestLangley
   *
   * parameters = {
   *  opacity: <float>,
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */

  function MeshNormalMaterial( parameters ) {

  	Material.call( this );

  	this.type = 'MeshNormalMaterial';

  	this.bumpMap = null;
  	this.bumpScale = 1;

  	this.normalMap = null;
  	this.normalScale = new Vector2( 1, 1 );

  	this.displacementMap = null;
  	this.displacementScale = 1;
  	this.displacementBias = 0;

  	this.wireframe = false;
  	this.wireframeLinewidth = 1;

  	this.fog = false;
  	this.lights = false;

  	this.skinning = false;
  	this.morphTargets = false;
  	this.morphNormals = false;

  	this.setValues( parameters );

  }

  MeshNormalMaterial.prototype = Object.create( Material.prototype );
  MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;

  MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

  MeshNormalMaterial.prototype.copy = function ( source ) {

  	Material.prototype.copy.call( this, source );

  	this.bumpMap = source.bumpMap;
  	this.bumpScale = source.bumpScale;

  	this.normalMap = source.normalMap;
  	this.normalScale.copy( source.normalScale );

  	this.displacementMap = source.displacementMap;
  	this.displacementScale = source.displacementScale;
  	this.displacementBias = source.displacementBias;

  	this.wireframe = source.wireframe;
  	this.wireframeLinewidth = source.wireframeLinewidth;

  	this.skinning = source.skinning;
  	this.morphTargets = source.morphTargets;
  	this.morphNormals = source.morphNormals;

  	return this;

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  emissive: <hex>,
   *  emissiveIntensity: <float>
   *  emissiveMap: new THREE.Texture( <Image> ),
   *
   *  specularMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
   *  combine: THREE.Multiply,
   *  reflectivity: <float>,
   *  refractionRatio: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */

  function MeshLambertMaterial( parameters ) {

  	Material.call( this );

  	this.type = 'MeshLambertMaterial';

  	this.color = new Color( 0xffffff ); // diffuse

  	this.map = null;

  	this.lightMap = null;
  	this.lightMapIntensity = 1.0;

  	this.aoMap = null;
  	this.aoMapIntensity = 1.0;

  	this.emissive = new Color( 0x000000 );
  	this.emissiveIntensity = 1.0;
  	this.emissiveMap = null;

  	this.specularMap = null;

  	this.alphaMap = null;

  	this.envMap = null;
  	this.combine = MultiplyOperation;
  	this.reflectivity = 1;
  	this.refractionRatio = 0.98;

  	this.wireframe = false;
  	this.wireframeLinewidth = 1;
  	this.wireframeLinecap = 'round';
  	this.wireframeLinejoin = 'round';

  	this.skinning = false;
  	this.morphTargets = false;
  	this.morphNormals = false;

  	this.setValues( parameters );

  }

  MeshLambertMaterial.prototype = Object.create( Material.prototype );
  MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;

  MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

  MeshLambertMaterial.prototype.copy = function ( source ) {

  	Material.prototype.copy.call( this, source );

  	this.color.copy( source.color );

  	this.map = source.map;

  	this.lightMap = source.lightMap;
  	this.lightMapIntensity = source.lightMapIntensity;

  	this.aoMap = source.aoMap;
  	this.aoMapIntensity = source.aoMapIntensity;

  	this.emissive.copy( source.emissive );
  	this.emissiveMap = source.emissiveMap;
  	this.emissiveIntensity = source.emissiveIntensity;

  	this.specularMap = source.specularMap;

  	this.alphaMap = source.alphaMap;

  	this.envMap = source.envMap;
  	this.combine = source.combine;
  	this.reflectivity = source.reflectivity;
  	this.refractionRatio = source.refractionRatio;

  	this.wireframe = source.wireframe;
  	this.wireframeLinewidth = source.wireframeLinewidth;
  	this.wireframeLinecap = source.wireframeLinecap;
  	this.wireframeLinejoin = source.wireframeLinejoin;

  	this.skinning = source.skinning;
  	this.morphTargets = source.morphTargets;
  	this.morphNormals = source.morphNormals;

  	return this;

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   * @author bhouston / https://clara.io
   * @author WestLangley / http://github.com/WestLangley
   *
   * parameters = {
   *
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>
   * }
   */

  function MeshDepthMaterial( parameters ) {

  	Material.call( this );

  	this.type = 'MeshDepthMaterial';

  	this.depthPacking = BasicDepthPacking;

  	this.skinning = false;
  	this.morphTargets = false;

  	this.map = null;

  	this.alphaMap = null;

  	this.displacementMap = null;
  	this.displacementScale = 1;
  	this.displacementBias = 0;

  	this.wireframe = false;
  	this.wireframeLinewidth = 1;

  	this.fog = false;
  	this.lights = false;

  	this.setValues( parameters );

  }

  MeshDepthMaterial.prototype = Object.create( Material.prototype );
  MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

  MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

  MeshDepthMaterial.prototype.copy = function ( source ) {

  	Material.prototype.copy.call( this, source );

  	this.depthPacking = source.depthPacking;

  	this.skinning = source.skinning;
  	this.morphTargets = source.morphTargets;

  	this.map = source.map;

  	this.alphaMap = source.alphaMap;

  	this.displacementMap = source.displacementMap;
  	this.displacementScale = source.displacementScale;
  	this.displacementBias = source.displacementBias;

  	this.wireframe = source.wireframe;
  	this.wireframeLinewidth = source.wireframeLinewidth;

  	return this;

  };

  /**
   * @author WestLangley / http://github.com/WestLangley
   *
   * parameters = {
   *
   *  referencePosition: <float>,
   *  nearDistance: <float>,
   *  farDistance: <float>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>
   *
   * }
   */

  function MeshDistanceMaterial( parameters ) {

  	Material.call( this );

  	this.type = 'MeshDistanceMaterial';

  	this.referencePosition = new Vector3$1();
  	this.nearDistance = 1;
  	this.farDistance = 1000;

  	this.skinning = false;
  	this.morphTargets = false;

  	this.map = null;

  	this.alphaMap = null;

  	this.displacementMap = null;
  	this.displacementScale = 1;
  	this.displacementBias = 0;

  	this.fog = false;
  	this.lights = false;

  	this.setValues( parameters );

  }

  MeshDistanceMaterial.prototype = Object.create( Material.prototype );
  MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;

  MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

  MeshDistanceMaterial.prototype.copy = function ( source ) {

  	Material.prototype.copy.call( this, source );

  	this.referencePosition.copy( source.referencePosition );
  	this.nearDistance = source.nearDistance;
  	this.farDistance = source.farDistance;

  	this.skinning = source.skinning;
  	this.morphTargets = source.morphTargets;

  	this.map = source.map;

  	this.alphaMap = source.alphaMap;

  	this.displacementMap = source.displacementMap;
  	this.displacementScale = source.displacementScale;
  	this.displacementBias = source.displacementBias;

  	return this;

  };

  /**
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *
   *  linewidth: <float>,
   *
   *  scale: <float>,
   *  dashSize: <float>,
   *  gapSize: <float>
   * }
   */

  function LineDashedMaterial( parameters ) {

  	LineBasicMaterial.call( this );

  	this.type = 'LineDashedMaterial';

  	this.scale = 1;
  	this.dashSize = 3;
  	this.gapSize = 1;

  	this.setValues( parameters );

  }

  LineDashedMaterial.prototype = Object.create( LineBasicMaterial.prototype );
  LineDashedMaterial.prototype.constructor = LineDashedMaterial;

  LineDashedMaterial.prototype.isLineDashedMaterial = true;

  LineDashedMaterial.prototype.copy = function ( source ) {

  	LineBasicMaterial.prototype.copy.call( this, source );

  	this.scale = source.scale;
  	this.dashSize = source.dashSize;
  	this.gapSize = source.gapSize;

  	return this;

  };



  var Materials = Object.freeze({
  	ShadowMaterial: ShadowMaterial,
  	SpriteMaterial: SpriteMaterial,
  	RawShaderMaterial: RawShaderMaterial,
  	ShaderMaterial: ShaderMaterial,
  	PointsMaterial: PointsMaterial,
  	MeshPhysicalMaterial: MeshPhysicalMaterial,
  	MeshStandardMaterial: MeshStandardMaterial,
  	MeshPhongMaterial: MeshPhongMaterial,
  	MeshToonMaterial: MeshToonMaterial,
  	MeshNormalMaterial: MeshNormalMaterial,
  	MeshLambertMaterial: MeshLambertMaterial,
  	MeshDepthMaterial: MeshDepthMaterial,
  	MeshDistanceMaterial: MeshDistanceMaterial,
  	MeshBasicMaterial: MeshBasicMaterial,
  	LineDashedMaterial: LineDashedMaterial,
  	LineBasicMaterial: LineBasicMaterial,
  	Material: Material
  });

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function MaterialLoader( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
  	this.textures = {};

  }

  Object.assign( MaterialLoader.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var loader = new FileLoader( scope.manager );
  		loader.load( url, function ( text ) {

  			onLoad( scope.parse( JSON.parse( text ) ) );

  		}, onProgress, onError );

  	},

  	setTextures: function ( value ) {

  		this.textures = value;

  	},

  	parse: function ( json ) {

  		var textures = this.textures;

  		function getTexture( name ) {

  			if ( textures[ name ] === undefined ) {

  				console.warn( 'THREE.MaterialLoader: Undefined texture', name );

  			}

  			return textures[ name ];

  		}

  		var material = new Materials[ json.type ]();

  		if ( json.uuid !== undefined ) { material.uuid = json.uuid; }
  		if ( json.name !== undefined ) { material.name = json.name; }
  		if ( json.color !== undefined ) { material.color.setHex( json.color ); }
  		if ( json.roughness !== undefined ) { material.roughness = json.roughness; }
  		if ( json.metalness !== undefined ) { material.metalness = json.metalness; }
  		if ( json.emissive !== undefined ) { material.emissive.setHex( json.emissive ); }
  		if ( json.specular !== undefined ) { material.specular.setHex( json.specular ); }
  		if ( json.shininess !== undefined ) { material.shininess = json.shininess; }
  		if ( json.clearCoat !== undefined ) { material.clearCoat = json.clearCoat; }
  		if ( json.clearCoatRoughness !== undefined ) { material.clearCoatRoughness = json.clearCoatRoughness; }
  		if ( json.uniforms !== undefined ) { material.uniforms = json.uniforms; }
  		if ( json.vertexShader !== undefined ) { material.vertexShader = json.vertexShader; }
  		if ( json.fragmentShader !== undefined ) { material.fragmentShader = json.fragmentShader; }
  		if ( json.vertexColors !== undefined ) { material.vertexColors = json.vertexColors; }
  		if ( json.fog !== undefined ) { material.fog = json.fog; }
  		if ( json.flatShading !== undefined ) { material.flatShading = json.flatShading; }
  		if ( json.blending !== undefined ) { material.blending = json.blending; }
  		if ( json.side !== undefined ) { material.side = json.side; }
  		if ( json.opacity !== undefined ) { material.opacity = json.opacity; }
  		if ( json.transparent !== undefined ) { material.transparent = json.transparent; }
  		if ( json.alphaTest !== undefined ) { material.alphaTest = json.alphaTest; }
  		if ( json.depthTest !== undefined ) { material.depthTest = json.depthTest; }
  		if ( json.depthWrite !== undefined ) { material.depthWrite = json.depthWrite; }
  		if ( json.colorWrite !== undefined ) { material.colorWrite = json.colorWrite; }
  		if ( json.wireframe !== undefined ) { material.wireframe = json.wireframe; }
  		if ( json.wireframeLinewidth !== undefined ) { material.wireframeLinewidth = json.wireframeLinewidth; }
  		if ( json.wireframeLinecap !== undefined ) { material.wireframeLinecap = json.wireframeLinecap; }
  		if ( json.wireframeLinejoin !== undefined ) { material.wireframeLinejoin = json.wireframeLinejoin; }

  		if ( json.skinning !== undefined ) { material.skinning = json.skinning; }
  		if ( json.morphTargets !== undefined ) { material.morphTargets = json.morphTargets; }
  		if ( json.dithering !== undefined ) { material.dithering = json.dithering; }

  		if ( json.visible !== undefined ) { material.visible = json.visible; }
  		if ( json.userData !== undefined ) { material.userData = json.userData; }

  		// Deprecated

  		if ( json.shading !== undefined ) { material.flatShading = json.shading === 1; } // THREE.FlatShading

  		// for PointsMaterial

  		if ( json.size !== undefined ) { material.size = json.size; }
  		if ( json.sizeAttenuation !== undefined ) { material.sizeAttenuation = json.sizeAttenuation; }

  		// maps

  		if ( json.map !== undefined ) { material.map = getTexture( json.map ); }

  		if ( json.alphaMap !== undefined ) {

  			material.alphaMap = getTexture( json.alphaMap );
  			material.transparent = true;

  		}

  		if ( json.bumpMap !== undefined ) { material.bumpMap = getTexture( json.bumpMap ); }
  		if ( json.bumpScale !== undefined ) { material.bumpScale = json.bumpScale; }

  		if ( json.normalMap !== undefined ) { material.normalMap = getTexture( json.normalMap ); }
  		if ( json.normalScale !== undefined ) {

  			var normalScale = json.normalScale;

  			if ( Array.isArray( normalScale ) === false ) {

  				// Blender exporter used to export a scalar. See #7459

  				normalScale = [ normalScale, normalScale ];

  			}

  			material.normalScale = new Vector2().fromArray( normalScale );

  		}

  		if ( json.displacementMap !== undefined ) { material.displacementMap = getTexture( json.displacementMap ); }
  		if ( json.displacementScale !== undefined ) { material.displacementScale = json.displacementScale; }
  		if ( json.displacementBias !== undefined ) { material.displacementBias = json.displacementBias; }

  		if ( json.roughnessMap !== undefined ) { material.roughnessMap = getTexture( json.roughnessMap ); }
  		if ( json.metalnessMap !== undefined ) { material.metalnessMap = getTexture( json.metalnessMap ); }

  		if ( json.emissiveMap !== undefined ) { material.emissiveMap = getTexture( json.emissiveMap ); }
  		if ( json.emissiveIntensity !== undefined ) { material.emissiveIntensity = json.emissiveIntensity; }

  		if ( json.specularMap !== undefined ) { material.specularMap = getTexture( json.specularMap ); }

  		if ( json.envMap !== undefined ) { material.envMap = getTexture( json.envMap ); }

  		if ( json.reflectivity !== undefined ) { material.reflectivity = json.reflectivity; }

  		if ( json.lightMap !== undefined ) { material.lightMap = getTexture( json.lightMap ); }
  		if ( json.lightMapIntensity !== undefined ) { material.lightMapIntensity = json.lightMapIntensity; }

  		if ( json.aoMap !== undefined ) { material.aoMap = getTexture( json.aoMap ); }
  		if ( json.aoMapIntensity !== undefined ) { material.aoMapIntensity = json.aoMapIntensity; }

  		if ( json.gradientMap !== undefined ) { material.gradientMap = getTexture( json.gradientMap ); }

  		return material;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function BufferGeometryLoader( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  }

  Object.assign( BufferGeometryLoader.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var loader = new FileLoader( scope.manager );
  		loader.load( url, function ( text ) {

  			onLoad( scope.parse( JSON.parse( text ) ) );

  		}, onProgress, onError );

  	},

  	parse: function ( json ) {

  		var geometry = new BufferGeometry();

  		var index = json.data.index;

  		if ( index !== undefined ) {

  			var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
  			geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

  		}

  		var attributes = json.data.attributes;

  		for ( var key in attributes ) {

  			var attribute = attributes[ key ];
  			var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );

  			geometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );

  		}

  		var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

  		if ( groups !== undefined ) {

  			for ( var i = 0, n = groups.length; i !== n; ++ i ) {

  				var group = groups[ i ];

  				geometry.addGroup( group.start, group.count, group.materialIndex );

  			}

  		}

  		var boundingSphere = json.data.boundingSphere;

  		if ( boundingSphere !== undefined ) {

  			var center = new Vector3$1();

  			if ( boundingSphere.center !== undefined ) {

  				center.fromArray( boundingSphere.center );

  			}

  			geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

  		}

  		return geometry;

  	}

  } );

  var TYPED_ARRAYS = {
  	Int8Array: Int8Array,
  	Uint8Array: Uint8Array,
  	// Workaround for IE11 pre KB2929437. See #11440
  	Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
  	Int16Array: Int16Array,
  	Uint16Array: Uint16Array,
  	Int32Array: Int32Array,
  	Uint32Array: Uint32Array,
  	Float32Array: Float32Array,
  	Float64Array: Float64Array
  };

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function TextureLoader( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  }

  Object.assign( TextureLoader.prototype, {

  	crossOrigin: 'Anonymous',

  	load: function ( url, onLoad, onProgress, onError ) {

  		var loader = new ImageLoader( this.manager );
  		loader.setCrossOrigin( this.crossOrigin );
  		loader.setPath( this.path );

  		var texture = new Texture();
  		texture.image = loader.load( url, function () {

  			// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
  			var isJPEG = url.search( /\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

  			texture.format = isJPEG ? RGBFormat : RGBAFormat;
  			texture.needsUpdate = true;

  			if ( onLoad !== undefined ) {

  				onLoad( texture );

  			}

  		}, onProgress, onError );

  		return texture;

  	},

  	setCrossOrigin: function ( value ) {

  		this.crossOrigin = value;
  		return this;

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	}

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function Loader() {

  	this.onLoadStart = function () {};
  	this.onLoadProgress = function () {};
  	this.onLoadComplete = function () {};

  }

  Loader.Handlers = {

  	handlers: [],

  	add: function ( regex, loader ) {

  		this.handlers.push( regex, loader );

  	},

  	get: function ( file ) {

  		var handlers = this.handlers;

  		for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

  			var regex = handlers[ i ];
  			var loader = handlers[ i + 1 ];

  			if ( regex.test( file ) ) {

  				return loader;

  			}

  		}

  		return null;

  	}

  };

  Object.assign( Loader.prototype, {

  	crossOrigin: undefined,

  	extractUrlBase: function ( url ) {

  		var parts = url.split( '/' );

  		if ( parts.length === 1 ) { return './'; }

  		parts.pop();

  		return parts.join( '/' ) + '/';

  	},

  	initMaterials: function ( materials, texturePath, crossOrigin ) {
  		var this$1 = this;


  		var array = [];

  		for ( var i = 0; i < materials.length; ++ i ) {

  			array[ i ] = this$1.createMaterial( materials[ i ], texturePath, crossOrigin );

  		}

  		return array;

  	},

  	createMaterial: ( function () {

  		var BlendingMode = {
  			NoBlending: NoBlending,
  			NormalBlending: NormalBlending,
  			AdditiveBlending: AdditiveBlending,
  			SubtractiveBlending: SubtractiveBlending,
  			MultiplyBlending: MultiplyBlending,
  			CustomBlending: CustomBlending
  		};

  		var color = new Color();
  		var textureLoader = new TextureLoader();
  		var materialLoader = new MaterialLoader();

  		return function createMaterial( m, texturePath, crossOrigin ) {

  			// convert from old material format

  			var textures = {};

  			function loadTexture( path, repeat, offset, wrap, anisotropy ) {

  				var fullPath = texturePath + path;
  				var loader = Loader.Handlers.get( fullPath );

  				var texture;

  				if ( loader !== null ) {

  					texture = loader.load( fullPath );

  				} else {

  					textureLoader.setCrossOrigin( crossOrigin );
  					texture = textureLoader.load( fullPath );

  				}

  				if ( repeat !== undefined ) {

  					texture.repeat.fromArray( repeat );

  					if ( repeat[ 0 ] !== 1 ) { texture.wrapS = RepeatWrapping; }
  					if ( repeat[ 1 ] !== 1 ) { texture.wrapT = RepeatWrapping; }

  				}

  				if ( offset !== undefined ) {

  					texture.offset.fromArray( offset );

  				}

  				if ( wrap !== undefined ) {

  					if ( wrap[ 0 ] === 'repeat' ) { texture.wrapS = RepeatWrapping; }
  					if ( wrap[ 0 ] === 'mirror' ) { texture.wrapS = MirroredRepeatWrapping; }

  					if ( wrap[ 1 ] === 'repeat' ) { texture.wrapT = RepeatWrapping; }
  					if ( wrap[ 1 ] === 'mirror' ) { texture.wrapT = MirroredRepeatWrapping; }

  				}

  				if ( anisotropy !== undefined ) {

  					texture.anisotropy = anisotropy;

  				}

  				var uuid = _Math.generateUUID();

  				textures[ uuid ] = texture;

  				return uuid;

  			}

  			//

  			var json = {
  				uuid: _Math.generateUUID(),
  				type: 'MeshLambertMaterial'
  			};

  			for ( var name in m ) {

  				var value = m[ name ];

  				switch ( name ) {

  					case 'DbgColor':
  					case 'DbgIndex':
  					case 'opticalDensity':
  					case 'illumination':
  						break;
  					case 'DbgName':
  						json.name = value;
  						break;
  					case 'blending':
  						json.blending = BlendingMode[ value ];
  						break;
  					case 'colorAmbient':
  					case 'mapAmbient':
  						console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
  						break;
  					case 'colorDiffuse':
  						json.color = color.fromArray( value ).getHex();
  						break;
  					case 'colorSpecular':
  						json.specular = color.fromArray( value ).getHex();
  						break;
  					case 'colorEmissive':
  						json.emissive = color.fromArray( value ).getHex();
  						break;
  					case 'specularCoef':
  						json.shininess = value;
  						break;
  					case 'shading':
  						if ( value.toLowerCase() === 'basic' ) { json.type = 'MeshBasicMaterial'; }
  						if ( value.toLowerCase() === 'phong' ) { json.type = 'MeshPhongMaterial'; }
  						if ( value.toLowerCase() === 'standard' ) { json.type = 'MeshStandardMaterial'; }
  						break;
  					case 'mapDiffuse':
  						json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
  						break;
  					case 'mapDiffuseRepeat':
  					case 'mapDiffuseOffset':
  					case 'mapDiffuseWrap':
  					case 'mapDiffuseAnisotropy':
  						break;
  					case 'mapEmissive':
  						json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );
  						break;
  					case 'mapEmissiveRepeat':
  					case 'mapEmissiveOffset':
  					case 'mapEmissiveWrap':
  					case 'mapEmissiveAnisotropy':
  						break;
  					case 'mapLight':
  						json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
  						break;
  					case 'mapLightRepeat':
  					case 'mapLightOffset':
  					case 'mapLightWrap':
  					case 'mapLightAnisotropy':
  						break;
  					case 'mapAO':
  						json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
  						break;
  					case 'mapAORepeat':
  					case 'mapAOOffset':
  					case 'mapAOWrap':
  					case 'mapAOAnisotropy':
  						break;
  					case 'mapBump':
  						json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
  						break;
  					case 'mapBumpScale':
  						json.bumpScale = value;
  						break;
  					case 'mapBumpRepeat':
  					case 'mapBumpOffset':
  					case 'mapBumpWrap':
  					case 'mapBumpAnisotropy':
  						break;
  					case 'mapNormal':
  						json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
  						break;
  					case 'mapNormalFactor':
  						json.normalScale = [ value, value ];
  						break;
  					case 'mapNormalRepeat':
  					case 'mapNormalOffset':
  					case 'mapNormalWrap':
  					case 'mapNormalAnisotropy':
  						break;
  					case 'mapSpecular':
  						json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
  						break;
  					case 'mapSpecularRepeat':
  					case 'mapSpecularOffset':
  					case 'mapSpecularWrap':
  					case 'mapSpecularAnisotropy':
  						break;
  					case 'mapMetalness':
  						json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );
  						break;
  					case 'mapMetalnessRepeat':
  					case 'mapMetalnessOffset':
  					case 'mapMetalnessWrap':
  					case 'mapMetalnessAnisotropy':
  						break;
  					case 'mapRoughness':
  						json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );
  						break;
  					case 'mapRoughnessRepeat':
  					case 'mapRoughnessOffset':
  					case 'mapRoughnessWrap':
  					case 'mapRoughnessAnisotropy':
  						break;
  					case 'mapAlpha':
  						json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
  						break;
  					case 'mapAlphaRepeat':
  					case 'mapAlphaOffset':
  					case 'mapAlphaWrap':
  					case 'mapAlphaAnisotropy':
  						break;
  					case 'flipSided':
  						json.side = BackSide;
  						break;
  					case 'doubleSided':
  						json.side = DoubleSide;
  						break;
  					case 'transparency':
  						console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
  						json.opacity = value;
  						break;
  					case 'depthTest':
  					case 'depthWrite':
  					case 'colorWrite':
  					case 'opacity':
  					case 'reflectivity':
  					case 'transparent':
  					case 'visible':
  					case 'wireframe':
  						json[ name ] = value;
  						break;
  					case 'vertexColors':
  						if ( value === true ) { json.vertexColors = VertexColors; }
  						if ( value === 'face' ) { json.vertexColors = FaceColors; }
  						break;
  					default:
  						console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
  						break;

  				}

  			}

  			if ( json.type === 'MeshBasicMaterial' ) { delete json.emissive; }
  			if ( json.type !== 'MeshPhongMaterial' ) { delete json.specular; }

  			if ( json.opacity < 1 ) { json.transparent = true; }

  			materialLoader.setTextures( textures );

  			return materialLoader.parse( json );

  		};

  	} )()

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  function JSONLoader( manager ) {

  	if ( typeof manager === 'boolean' ) {

  		console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
  		manager = undefined;

  	}

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  	this.withCredentials = false;

  }

  Object.assign( JSONLoader.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : Loader.prototype.extractUrlBase( url );

  		var loader = new FileLoader( this.manager );
  		loader.setWithCredentials( this.withCredentials );
  		loader.load( url, function ( text ) {

  			var json = JSON.parse( text );
  			var metadata = json.metadata;

  			if ( metadata !== undefined ) {

  				var type = metadata.type;

  				if ( type !== undefined ) {

  					if ( type.toLowerCase() === 'object' ) {

  						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
  						return;

  					}

  					if ( type.toLowerCase() === 'scene' ) {

  						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
  						return;

  					}

  				}

  			}

  			var object = scope.parse( json, texturePath );
  			onLoad( object.geometry, object.materials );

  		}, onProgress, onError );

  	},

  	setTexturePath: function ( value ) {

  		this.texturePath = value;

  	},

  	parse: ( function () {

  		function parseModel( json, geometry ) {

  			function isBitSet( value, position ) {

  				return value & ( 1 << position );

  			}

  			var i, j, fi,

  				offset, zLength,

  				colorIndex, normalIndex, uvIndex, materialIndex,

  				type,
  				isQuad,
  				hasMaterial,
  				hasFaceVertexUv,
  				hasFaceNormal, hasFaceVertexNormal,
  				hasFaceColor, hasFaceVertexColor,

  				vertex, face, faceA, faceB, hex, normal,

  				uvLayer, uv, u, v,

  				faces = json.faces,
  				vertices = json.vertices,
  				normals = json.normals,
  				colors = json.colors,

  				scale = json.scale,

  				nUvLayers = 0;


  			if ( json.uvs !== undefined ) {

  				// disregard empty arrays

  				for ( i = 0; i < json.uvs.length; i ++ ) {

  					if ( json.uvs[ i ].length ) { nUvLayers ++; }

  				}

  				for ( i = 0; i < nUvLayers; i ++ ) {

  					geometry.faceVertexUvs[ i ] = [];

  				}

  			}

  			offset = 0;
  			zLength = vertices.length;

  			while ( offset < zLength ) {

  				vertex = new Vector3$1();

  				vertex.x = vertices[ offset ++ ] * scale;
  				vertex.y = vertices[ offset ++ ] * scale;
  				vertex.z = vertices[ offset ++ ] * scale;

  				geometry.vertices.push( vertex );

  			}

  			offset = 0;
  			zLength = faces.length;

  			while ( offset < zLength ) {

  				type = faces[ offset ++ ];

  				isQuad = isBitSet( type, 0 );
  				hasMaterial = isBitSet( type, 1 );
  				hasFaceVertexUv = isBitSet( type, 3 );
  				hasFaceNormal = isBitSet( type, 4 );
  				hasFaceVertexNormal = isBitSet( type, 5 );
  				hasFaceColor = isBitSet( type, 6 );
  				hasFaceVertexColor = isBitSet( type, 7 );

  				// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

  				if ( isQuad ) {

  					faceA = new Face3$1();
  					faceA.a = faces[ offset ];
  					faceA.b = faces[ offset + 1 ];
  					faceA.c = faces[ offset + 3 ];

  					faceB = new Face3$1();
  					faceB.a = faces[ offset + 1 ];
  					faceB.b = faces[ offset + 2 ];
  					faceB.c = faces[ offset + 3 ];

  					offset += 4;

  					if ( hasMaterial ) {

  						materialIndex = faces[ offset ++ ];
  						faceA.materialIndex = materialIndex;
  						faceB.materialIndex = materialIndex;

  					}

  					// to get face <=> uv index correspondence

  					fi = geometry.faces.length;

  					if ( hasFaceVertexUv ) {

  						for ( i = 0; i < nUvLayers; i ++ ) {

  							uvLayer = json.uvs[ i ];

  							geometry.faceVertexUvs[ i ][ fi ] = [];
  							geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

  							for ( j = 0; j < 4; j ++ ) {

  								uvIndex = faces[ offset ++ ];

  								u = uvLayer[ uvIndex * 2 ];
  								v = uvLayer[ uvIndex * 2 + 1 ];

  								uv = new Vector2( u, v );

  								if ( j !== 2 ) { geometry.faceVertexUvs[ i ][ fi ].push( uv ); }
  								if ( j !== 0 ) { geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv ); }

  							}

  						}

  					}

  					if ( hasFaceNormal ) {

  						normalIndex = faces[ offset ++ ] * 3;

  						faceA.normal.set(
  							normals[ normalIndex ++ ],
  							normals[ normalIndex ++ ],
  							normals[ normalIndex ]
  						);

  						faceB.normal.copy( faceA.normal );

  					}

  					if ( hasFaceVertexNormal ) {

  						for ( i = 0; i < 4; i ++ ) {

  							normalIndex = faces[ offset ++ ] * 3;

  							normal = new Vector3$1(
  								normals[ normalIndex ++ ],
  								normals[ normalIndex ++ ],
  								normals[ normalIndex ]
  							);


  							if ( i !== 2 ) { faceA.vertexNormals.push( normal ); }
  							if ( i !== 0 ) { faceB.vertexNormals.push( normal ); }

  						}

  					}


  					if ( hasFaceColor ) {

  						colorIndex = faces[ offset ++ ];
  						hex = colors[ colorIndex ];

  						faceA.color.setHex( hex );
  						faceB.color.setHex( hex );

  					}


  					if ( hasFaceVertexColor ) {

  						for ( i = 0; i < 4; i ++ ) {

  							colorIndex = faces[ offset ++ ];
  							hex = colors[ colorIndex ];

  							if ( i !== 2 ) { faceA.vertexColors.push( new Color( hex ) ); }
  							if ( i !== 0 ) { faceB.vertexColors.push( new Color( hex ) ); }

  						}

  					}

  					geometry.faces.push( faceA );
  					geometry.faces.push( faceB );

  				} else {

  					face = new Face3$1();
  					face.a = faces[ offset ++ ];
  					face.b = faces[ offset ++ ];
  					face.c = faces[ offset ++ ];

  					if ( hasMaterial ) {

  						materialIndex = faces[ offset ++ ];
  						face.materialIndex = materialIndex;

  					}

  					// to get face <=> uv index correspondence

  					fi = geometry.faces.length;

  					if ( hasFaceVertexUv ) {

  						for ( i = 0; i < nUvLayers; i ++ ) {

  							uvLayer = json.uvs[ i ];

  							geometry.faceVertexUvs[ i ][ fi ] = [];

  							for ( j = 0; j < 3; j ++ ) {

  								uvIndex = faces[ offset ++ ];

  								u = uvLayer[ uvIndex * 2 ];
  								v = uvLayer[ uvIndex * 2 + 1 ];

  								uv = new Vector2( u, v );

  								geometry.faceVertexUvs[ i ][ fi ].push( uv );

  							}

  						}

  					}

  					if ( hasFaceNormal ) {

  						normalIndex = faces[ offset ++ ] * 3;

  						face.normal.set(
  							normals[ normalIndex ++ ],
  							normals[ normalIndex ++ ],
  							normals[ normalIndex ]
  						);

  					}

  					if ( hasFaceVertexNormal ) {

  						for ( i = 0; i < 3; i ++ ) {

  							normalIndex = faces[ offset ++ ] * 3;

  							normal = new Vector3$1(
  								normals[ normalIndex ++ ],
  								normals[ normalIndex ++ ],
  								normals[ normalIndex ]
  							);

  							face.vertexNormals.push( normal );

  						}

  					}


  					if ( hasFaceColor ) {

  						colorIndex = faces[ offset ++ ];
  						face.color.setHex( colors[ colorIndex ] );

  					}


  					if ( hasFaceVertexColor ) {

  						for ( i = 0; i < 3; i ++ ) {

  							colorIndex = faces[ offset ++ ];
  							face.vertexColors.push( new Color( colors[ colorIndex ] ) );

  						}

  					}

  					geometry.faces.push( face );

  				}

  			}

  		}

  		function parseSkin( json, geometry ) {

  			var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

  			if ( json.skinWeights ) {

  				for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

  					var x = json.skinWeights[ i ];
  					var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
  					var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
  					var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

  					geometry.skinWeights.push( new Vector4( x, y, z, w ) );

  				}

  			}

  			if ( json.skinIndices ) {

  				for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

  					var a = json.skinIndices[ i ];
  					var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
  					var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
  					var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

  					geometry.skinIndices.push( new Vector4( a, b, c, d ) );

  				}

  			}

  			geometry.bones = json.bones;

  			if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

  				console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
  					geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

  			}

  		}

  		function parseMorphing( json, geometry ) {

  			var scale = json.scale;

  			if ( json.morphTargets !== undefined ) {

  				for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {

  					geometry.morphTargets[ i ] = {};
  					geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
  					geometry.morphTargets[ i ].vertices = [];

  					var dstVertices = geometry.morphTargets[ i ].vertices;
  					var srcVertices = json.morphTargets[ i ].vertices;

  					for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

  						var vertex = new Vector3$1();
  						vertex.x = srcVertices[ v ] * scale;
  						vertex.y = srcVertices[ v + 1 ] * scale;
  						vertex.z = srcVertices[ v + 2 ] * scale;

  						dstVertices.push( vertex );

  					}

  				}

  			}

  			if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {

  				console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );

  				var faces = geometry.faces;
  				var morphColors = json.morphColors[ 0 ].colors;

  				for ( var i = 0, l = faces.length; i < l; i ++ ) {

  					faces[ i ].color.fromArray( morphColors, i * 3 );

  				}

  			}

  		}

  		function parseAnimations( json, geometry ) {

  			var outputAnimations = [];

  			// parse old style Bone/Hierarchy animations
  			var animations = [];

  			if ( json.animation !== undefined ) {

  				animations.push( json.animation );

  			}

  			if ( json.animations !== undefined ) {

  				if ( json.animations.length ) {

  					animations = animations.concat( json.animations );

  				} else {

  					animations.push( json.animations );

  				}

  			}

  			for ( var i = 0; i < animations.length; i ++ ) {

  				var clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );
  				if ( clip ) { outputAnimations.push( clip ); }

  			}

  			// parse implicit morph animations
  			if ( geometry.morphTargets ) {

  				// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
  				var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
  				outputAnimations = outputAnimations.concat( morphAnimationClips );

  			}

  			if ( outputAnimations.length > 0 ) { geometry.animations = outputAnimations; }

  		}

  		return function ( json, texturePath ) {

  			if ( json.data !== undefined ) {

  				// Geometry 4.0 spec
  				json = json.data;

  			}

  			if ( json.scale !== undefined ) {

  				json.scale = 1.0 / json.scale;

  			} else {

  				json.scale = 1.0;

  			}

  			var geometry = new Geometry();

  			parseModel( json, geometry );
  			parseSkin( json, geometry );
  			parseMorphing( json, geometry );
  			parseAnimations( json, geometry );

  			geometry.computeFaceNormals();
  			geometry.computeBoundingSphere();

  			if ( json.materials === undefined || json.materials.length === 0 ) {

  				return { geometry: geometry };

  			} else {

  				var materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

  				return { geometry: geometry, materials: materials };

  			}

  		};

  	} )()

  } );

  /**
   * @author zz85 / https://github.com/zz85
   * @author Mugen87 / https://github.com/Mugen87
   *
   * Parametric Surfaces Geometry
   * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
   */

  // ParametricGeometry

  function ParametricGeometry( func, slices, stacks ) {

  	Geometry.call( this );

  	this.type = 'ParametricGeometry';

  	this.parameters = {
  		func: func,
  		slices: slices,
  		stacks: stacks
  	};

  	this.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );
  	this.mergeVertices();

  }

  ParametricGeometry.prototype = Object.create( Geometry.prototype );
  ParametricGeometry.prototype.constructor = ParametricGeometry;

  // ParametricBufferGeometry

  function ParametricBufferGeometry( func, slices, stacks ) {

  	BufferGeometry.call( this );

  	this.type = 'ParametricBufferGeometry';

  	this.parameters = {
  		func: func,
  		slices: slices,
  		stacks: stacks
  	};

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	var EPS = 0.00001;

  	var normal = new Vector3$1();

  	var p0 = new Vector3$1(), p1 = new Vector3$1();
  	var pu = new Vector3$1(), pv = new Vector3$1();

  	var i, j;

  	// generate vertices, normals and uvs

  	var sliceCount = slices + 1;

  	for ( i = 0; i <= stacks; i ++ ) {

  		var v = i / stacks;

  		for ( j = 0; j <= slices; j ++ ) {

  			var u = j / slices;

  			// vertex

  			p0 = func( u, v, p0 );
  			vertices.push( p0.x, p0.y, p0.z );

  			// normal

  			// approximate tangent vectors via finite differences

  			if ( u - EPS >= 0 ) {

  				p1 = func( u - EPS, v, p1 );
  				pu.subVectors( p0, p1 );

  			} else {

  				p1 = func( u + EPS, v, p1 );
  				pu.subVectors( p1, p0 );

  			}

  			if ( v - EPS >= 0 ) {

  				p1 = func( u, v - EPS, p1 );
  				pv.subVectors( p0, p1 );

  			} else {

  				p1 = func( u, v + EPS, p1 );
  				pv.subVectors( p1, p0 );

  			}

  			// cross product of tangent vectors returns surface normal

  			normal.crossVectors( pu, pv ).normalize();
  			normals.push( normal.x, normal.y, normal.z );

  			// uv

  			uvs.push( u, v );

  		}

  	}

  	// generate indices

  	for ( i = 0; i < stacks; i ++ ) {

  		for ( j = 0; j < slices; j ++ ) {

  			var a = i * sliceCount + j;
  			var b = i * sliceCount + j + 1;
  			var c = ( i + 1 ) * sliceCount + j + 1;
  			var d = ( i + 1 ) * sliceCount + j;

  			// faces one and two

  			indices.push( a, b, d );
  			indices.push( b, c, d );

  		}

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  }

  ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;

  /**
   * @author clockworkgeek / https://github.com/clockworkgeek
   * @author timothypratley / https://github.com/timothypratley
   * @author WestLangley / http://github.com/WestLangley
   * @author Mugen87 / https://github.com/Mugen87
   */

  // PolyhedronGeometry

  function PolyhedronGeometry( vertices, indices, radius, detail ) {

  	Geometry.call( this );

  	this.type = 'PolyhedronGeometry';

  	this.parameters = {
  		vertices: vertices,
  		indices: indices,
  		radius: radius,
  		detail: detail
  	};

  	this.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );
  	this.mergeVertices();

  }

  PolyhedronGeometry.prototype = Object.create( Geometry.prototype );
  PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

  // PolyhedronBufferGeometry

  function PolyhedronBufferGeometry( vertices, indices, radius, detail ) {

  	BufferGeometry.call( this );

  	this.type = 'PolyhedronBufferGeometry';

  	this.parameters = {
  		vertices: vertices,
  		indices: indices,
  		radius: radius,
  		detail: detail
  	};

  	radius = radius || 1;
  	detail = detail || 0;

  	// default buffer data

  	var vertexBuffer = [];
  	var uvBuffer = [];

  	// the subdivision creates the vertex buffer data

  	subdivide( detail );

  	// all vertices should lie on a conceptual sphere with a given radius

  	appplyRadius( radius );

  	// finally, create the uv data

  	generateUVs();

  	// build non-indexed geometry

  	this.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );

  	if ( detail === 0 ) {

  		this.computeVertexNormals(); // flat normals

  	} else {

  		this.normalizeNormals(); // smooth normals

  	}

  	// helper functions

  	function subdivide( detail ) {

  		var a = new Vector3$1();
  		var b = new Vector3$1();
  		var c = new Vector3$1();

  		// iterate over all faces and apply a subdivison with the given detail value

  		for ( var i = 0; i < indices.length; i += 3 ) {

  			// get the vertices of the face

  			getVertexByIndex( indices[ i + 0 ], a );
  			getVertexByIndex( indices[ i + 1 ], b );
  			getVertexByIndex( indices[ i + 2 ], c );

  			// perform subdivision

  			subdivideFace( a, b, c, detail );

  		}

  	}

  	function subdivideFace( a, b, c, detail ) {

  		var cols = Math.pow( 2, detail );

  		// we use this multidimensional array as a data structure for creating the subdivision

  		var v = [];

  		var i, j;

  		// construct all of the vertices for this subdivision

  		for ( i = 0; i <= cols; i ++ ) {

  			v[ i ] = [];

  			var aj = a.clone().lerp( c, i / cols );
  			var bj = b.clone().lerp( c, i / cols );

  			var rows = cols - i;

  			for ( j = 0; j <= rows; j ++ ) {

  				if ( j === 0 && i === cols ) {

  					v[ i ][ j ] = aj;

  				} else {

  					v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

  				}

  			}

  		}

  		// construct all of the faces

  		for ( i = 0; i < cols; i ++ ) {

  			for ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

  				var k = Math.floor( j / 2 );

  				if ( j % 2 === 0 ) {

  					pushVertex( v[ i ][ k + 1 ] );
  					pushVertex( v[ i + 1 ][ k ] );
  					pushVertex( v[ i ][ k ] );

  				} else {

  					pushVertex( v[ i ][ k + 1 ] );
  					pushVertex( v[ i + 1 ][ k + 1 ] );
  					pushVertex( v[ i + 1 ][ k ] );

  				}

  			}

  		}

  	}

  	function appplyRadius( radius ) {

  		var vertex = new Vector3$1();

  		// iterate over the entire buffer and apply the radius to each vertex

  		for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

  			vertex.x = vertexBuffer[ i + 0 ];
  			vertex.y = vertexBuffer[ i + 1 ];
  			vertex.z = vertexBuffer[ i + 2 ];

  			vertex.normalize().multiplyScalar( radius );

  			vertexBuffer[ i + 0 ] = vertex.x;
  			vertexBuffer[ i + 1 ] = vertex.y;
  			vertexBuffer[ i + 2 ] = vertex.z;

  		}

  	}

  	function generateUVs() {

  		var vertex = new Vector3$1();

  		for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

  			vertex.x = vertexBuffer[ i + 0 ];
  			vertex.y = vertexBuffer[ i + 1 ];
  			vertex.z = vertexBuffer[ i + 2 ];

  			var u = azimuth( vertex ) / 2 / Math.PI + 0.5;
  			var v = inclination( vertex ) / Math.PI + 0.5;
  			uvBuffer.push( u, 1 - v );

  		}

  		correctUVs();

  		correctSeam();

  	}

  	function correctSeam() {

  		// handle case when face straddles the seam, see #3269

  		for ( var i = 0; i < uvBuffer.length; i += 6 ) {

  			// uv data of a single face

  			var x0 = uvBuffer[ i + 0 ];
  			var x1 = uvBuffer[ i + 2 ];
  			var x2 = uvBuffer[ i + 4 ];

  			var max = Math.max( x0, x1, x2 );
  			var min = Math.min( x0, x1, x2 );

  			// 0.9 is somewhat arbitrary

  			if ( max > 0.9 && min < 0.1 ) {

  				if ( x0 < 0.2 ) { uvBuffer[ i + 0 ] += 1; }
  				if ( x1 < 0.2 ) { uvBuffer[ i + 2 ] += 1; }
  				if ( x2 < 0.2 ) { uvBuffer[ i + 4 ] += 1; }

  			}

  		}

  	}

  	function pushVertex( vertex ) {

  		vertexBuffer.push( vertex.x, vertex.y, vertex.z );

  	}

  	function getVertexByIndex( index, vertex ) {

  		var stride = index * 3;

  		vertex.x = vertices[ stride + 0 ];
  		vertex.y = vertices[ stride + 1 ];
  		vertex.z = vertices[ stride + 2 ];

  	}

  	function correctUVs() {

  		var a = new Vector3$1();
  		var b = new Vector3$1();
  		var c = new Vector3$1();

  		var centroid = new Vector3$1();

  		var uvA = new Vector2();
  		var uvB = new Vector2();
  		var uvC = new Vector2();

  		for ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

  			a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
  			b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
  			c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

  			uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
  			uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
  			uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

  			centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

  			var azi = azimuth( centroid );

  			correctUV( uvA, j + 0, a, azi );
  			correctUV( uvB, j + 2, b, azi );
  			correctUV( uvC, j + 4, c, azi );

  		}

  	}

  	function correctUV( uv, stride, vector, azimuth ) {

  		if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

  			uvBuffer[ stride ] = uv.x - 1;

  		}

  		if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

  			uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

  		}

  	}

  	// Angle around the Y axis, counter-clockwise when looking from above.

  	function azimuth( vector ) {

  		return Math.atan2( vector.z, - vector.x );

  	}


  	// Angle above the XZ plane.

  	function inclination( vector ) {

  		return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

  	}

  }

  PolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;

  /**
   * @author timothypratley / https://github.com/timothypratley
   * @author Mugen87 / https://github.com/Mugen87
   */

  // TetrahedronGeometry

  function TetrahedronGeometry( radius, detail ) {

  	Geometry.call( this );

  	this.type = 'TetrahedronGeometry';

  	this.parameters = {
  		radius: radius,
  		detail: detail
  	};

  	this.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );
  	this.mergeVertices();

  }

  TetrahedronGeometry.prototype = Object.create( Geometry.prototype );
  TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;

  // TetrahedronBufferGeometry

  function TetrahedronBufferGeometry( radius, detail ) {

  	var vertices = [
  		1, 1, 1, 	- 1, - 1, 1, 	- 1, 1, - 1, 	1, - 1, - 1
  	];

  	var indices = [
  		2, 1, 0, 	0, 3, 2,	1, 3, 0,	2, 3, 1
  	];

  	PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

  	this.type = 'TetrahedronBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		detail: detail
  	};

  }

  TetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
  TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;

  /**
   * @author timothypratley / https://github.com/timothypratley
   * @author Mugen87 / https://github.com/Mugen87
   */

  // OctahedronGeometry

  function OctahedronGeometry( radius, detail ) {

  	Geometry.call( this );

  	this.type = 'OctahedronGeometry';

  	this.parameters = {
  		radius: radius,
  		detail: detail
  	};

  	this.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );
  	this.mergeVertices();

  }

  OctahedronGeometry.prototype = Object.create( Geometry.prototype );
  OctahedronGeometry.prototype.constructor = OctahedronGeometry;

  // OctahedronBufferGeometry

  function OctahedronBufferGeometry( radius, detail ) {

  	var vertices = [
  		1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
  		0, - 1, 0, 	0, 0, 1,	0, 0, - 1
  	];

  	var indices = [
  		0, 2, 4,	0, 4, 3,	0, 3, 5,
  		0, 5, 2,	1, 2, 5,	1, 5, 3,
  		1, 3, 4,	1, 4, 2
  	];

  	PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

  	this.type = 'OctahedronBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		detail: detail
  	};

  }

  OctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
  OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;

  /**
   * @author timothypratley / https://github.com/timothypratley
   * @author Mugen87 / https://github.com/Mugen87
   */

  // IcosahedronGeometry

  function IcosahedronGeometry( radius, detail ) {

  	Geometry.call( this );

  	this.type = 'IcosahedronGeometry';

  	this.parameters = {
  		radius: radius,
  		detail: detail
  	};

  	this.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );
  	this.mergeVertices();

  }

  IcosahedronGeometry.prototype = Object.create( Geometry.prototype );
  IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;

  // IcosahedronBufferGeometry

  function IcosahedronBufferGeometry( radius, detail ) {

  	var t = ( 1 + Math.sqrt( 5 ) ) / 2;

  	var vertices = [
  		- 1, t, 0,  	1, t, 0, 	- 1, - t, 0, 	1, - t, 0,
  		 0, - 1, t, 	0, 1, t,	0, - 1, - t, 	0, 1, - t,
  		 t, 0, - 1, 	t, 0, 1, 	- t, 0, - 1, 	- t, 0, 1
  	];

  	var indices = [
  		 0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
  		 1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
  		 3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
  		 4, 9, 5,  	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
  	];

  	PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

  	this.type = 'IcosahedronBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		detail: detail
  	};

  }

  IcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
  IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;

  /**
   * @author Abe Pazos / https://hamoid.com
   * @author Mugen87 / https://github.com/Mugen87
   */

  // DodecahedronGeometry

  function DodecahedronGeometry( radius, detail ) {

  	Geometry.call( this );

  	this.type = 'DodecahedronGeometry';

  	this.parameters = {
  		radius: radius,
  		detail: detail
  	};

  	this.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );
  	this.mergeVertices();

  }

  DodecahedronGeometry.prototype = Object.create( Geometry.prototype );
  DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;

  // DodecahedronBufferGeometry

  function DodecahedronBufferGeometry( radius, detail ) {

  	var t = ( 1 + Math.sqrt( 5 ) ) / 2;
  	var r = 1 / t;

  	var vertices = [

  		// (1, 1, 1)
  		- 1, - 1, - 1,	- 1, - 1, 1,
  		- 1, 1, - 1, - 1, 1, 1,
  		1, - 1, - 1, 1, - 1, 1,
  		1, 1, - 1, 1, 1, 1,

  		// (0, 1/, )
  		 0, - r, - t, 0, - r, t,
  		 0, r, - t, 0, r, t,

  		// (1/, , 0)
  		- r, - t, 0, - r, t, 0,
  		 r, - t, 0, r, t, 0,

  		// (, 0, 1/)
  		- t, 0, - r, t, 0, - r,
  		- t, 0, r, t, 0, r
  	];

  	var indices = [
  		3, 11, 7, 	3, 7, 15, 	3, 15, 13,
  		7, 19, 17, 	7, 17, 6, 	7, 6, 15,
  		17, 4, 8, 	17, 8, 10, 	17, 10, 6,
  		8, 0, 16, 	8, 16, 2, 	8, 2, 10,
  		0, 12, 1, 	0, 1, 18, 	0, 18, 16,
  		6, 10, 2, 	6, 2, 13, 	6, 13, 15,
  		2, 16, 18, 	2, 18, 3, 	2, 3, 13,
  		18, 1, 9, 	18, 9, 11, 	18, 11, 3,
  		4, 14, 12, 	4, 12, 0, 	4, 0, 8,
  		11, 9, 5, 	11, 5, 19, 	11, 19, 7,
  		19, 5, 14, 	19, 14, 4, 	19, 4, 17,
  		1, 12, 14, 	1, 14, 5, 	1, 5, 9
  	];

  	PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

  	this.type = 'DodecahedronBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		detail: detail
  	};

  }

  DodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
  DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;

  /**
   * @author oosmoxiecode / https://github.com/oosmoxiecode
   * @author WestLangley / https://github.com/WestLangley
   * @author zz85 / https://github.com/zz85
   * @author miningold / https://github.com/miningold
   * @author jonobr1 / https://github.com/jonobr1
   * @author Mugen87 / https://github.com/Mugen87
   *
   */

  // TubeGeometry

  function TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {

  	Geometry.call( this );

  	this.type = 'TubeGeometry';

  	this.parameters = {
  		path: path,
  		tubularSegments: tubularSegments,
  		radius: radius,
  		radialSegments: radialSegments,
  		closed: closed
  	};

  	if ( taper !== undefined ) { console.warn( 'THREE.TubeGeometry: taper has been removed.' ); }

  	var bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );

  	// expose internals

  	this.tangents = bufferGeometry.tangents;
  	this.normals = bufferGeometry.normals;
  	this.binormals = bufferGeometry.binormals;

  	// create geometry

  	this.fromBufferGeometry( bufferGeometry );
  	this.mergeVertices();

  }

  TubeGeometry.prototype = Object.create( Geometry.prototype );
  TubeGeometry.prototype.constructor = TubeGeometry;

  // TubeBufferGeometry

  function TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {

  	BufferGeometry.call( this );

  	this.type = 'TubeBufferGeometry';

  	this.parameters = {
  		path: path,
  		tubularSegments: tubularSegments,
  		radius: radius,
  		radialSegments: radialSegments,
  		closed: closed
  	};

  	tubularSegments = tubularSegments || 64;
  	radius = radius || 1;
  	radialSegments = radialSegments || 8;
  	closed = closed || false;

  	var frames = path.computeFrenetFrames( tubularSegments, closed );

  	// expose internals

  	this.tangents = frames.tangents;
  	this.normals = frames.normals;
  	this.binormals = frames.binormals;

  	// helper variables

  	var vertex = new Vector3$1();
  	var normal = new Vector3$1();
  	var uv = new Vector2();

  	var i, j;

  	// buffer

  	var vertices = [];
  	var normals = [];
  	var uvs = [];
  	var indices = [];

  	// create buffer data

  	generateBufferData();

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  	// functions

  	function generateBufferData() {

  		for ( i = 0; i < tubularSegments; i ++ ) {

  			generateSegment( i );

  		}

  		// if the geometry is not closed, generate the last row of vertices and normals
  		// at the regular position on the given path
  		//
  		// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

  		generateSegment( ( closed === false ) ? tubularSegments : 0 );

  		// uvs are generated in a separate function.
  		// this makes it easy compute correct values for closed geometries

  		generateUVs();

  		// finally create faces

  		generateIndices();

  	}

  	function generateSegment( i ) {

  		// we use getPointAt to sample evenly distributed points from the given path

  		var P = path.getPointAt( i / tubularSegments );

  		// retrieve corresponding normal and binormal

  		var N = frames.normals[ i ];
  		var B = frames.binormals[ i ];

  		// generate normals and vertices for the current segment

  		for ( j = 0; j <= radialSegments; j ++ ) {

  			var v = j / radialSegments * Math.PI * 2;

  			var sin = Math.sin( v );
  			var cos = - Math.cos( v );

  			// normal

  			normal.x = ( cos * N.x + sin * B.x );
  			normal.y = ( cos * N.y + sin * B.y );
  			normal.z = ( cos * N.z + sin * B.z );
  			normal.normalize();

  			normals.push( normal.x, normal.y, normal.z );

  			// vertex

  			vertex.x = P.x + radius * normal.x;
  			vertex.y = P.y + radius * normal.y;
  			vertex.z = P.z + radius * normal.z;

  			vertices.push( vertex.x, vertex.y, vertex.z );

  		}

  	}

  	function generateIndices() {

  		for ( j = 1; j <= tubularSegments; j ++ ) {

  			for ( i = 1; i <= radialSegments; i ++ ) {

  				var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
  				var b = ( radialSegments + 1 ) * j + ( i - 1 );
  				var c = ( radialSegments + 1 ) * j + i;
  				var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

  				// faces

  				indices.push( a, b, d );
  				indices.push( b, c, d );

  			}

  		}

  	}

  	function generateUVs() {

  		for ( i = 0; i <= tubularSegments; i ++ ) {

  			for ( j = 0; j <= radialSegments; j ++ ) {

  				uv.x = i / tubularSegments;
  				uv.y = j / radialSegments;

  				uvs.push( uv.x, uv.y );

  			}

  		}

  	}

  }

  TubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;

  /**
   * @author oosmoxiecode
   * @author Mugen87 / https://github.com/Mugen87
   *
   * based on http://www.blackpawn.com/texts/pqtorus/
   */

  // TorusKnotGeometry

  function TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {

  	Geometry.call( this );

  	this.type = 'TorusKnotGeometry';

  	this.parameters = {
  		radius: radius,
  		tube: tube,
  		tubularSegments: tubularSegments,
  		radialSegments: radialSegments,
  		p: p,
  		q: q
  	};

  	if ( heightScale !== undefined ) { console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' ); }

  	this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
  	this.mergeVertices();

  }

  TorusKnotGeometry.prototype = Object.create( Geometry.prototype );
  TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;

  // TorusKnotBufferGeometry

  function TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {

  	BufferGeometry.call( this );

  	this.type = 'TorusKnotBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		tube: tube,
  		tubularSegments: tubularSegments,
  		radialSegments: radialSegments,
  		p: p,
  		q: q
  	};

  	radius = radius || 100;
  	tube = tube || 40;
  	tubularSegments = Math.floor( tubularSegments ) || 64;
  	radialSegments = Math.floor( radialSegments ) || 8;
  	p = p || 2;
  	q = q || 3;

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// helper variables

  	var i, j;

  	var vertex = new Vector3$1();
  	var normal = new Vector3$1();

  	var P1 = new Vector3$1();
  	var P2 = new Vector3$1();

  	var B = new Vector3$1();
  	var T = new Vector3$1();
  	var N = new Vector3$1();

  	// generate vertices, normals and uvs

  	for ( i = 0; i <= tubularSegments; ++ i ) {

  		// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

  		var u = i / tubularSegments * p * Math.PI * 2;

  		// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
  		// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

  		calculatePositionOnCurve( u, p, q, radius, P1 );
  		calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

  		// calculate orthonormal basis

  		T.subVectors( P2, P1 );
  		N.addVectors( P2, P1 );
  		B.crossVectors( T, N );
  		N.crossVectors( B, T );

  		// normalize B, N. T can be ignored, we don't use it

  		B.normalize();
  		N.normalize();

  		for ( j = 0; j <= radialSegments; ++ j ) {

  			// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
  			// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

  			var v = j / radialSegments * Math.PI * 2;
  			var cx = - tube * Math.cos( v );
  			var cy = tube * Math.sin( v );

  			// now calculate the final vertex position.
  			// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

  			vertex.x = P1.x + ( cx * N.x + cy * B.x );
  			vertex.y = P1.y + ( cx * N.y + cy * B.y );
  			vertex.z = P1.z + ( cx * N.z + cy * B.z );

  			vertices.push( vertex.x, vertex.y, vertex.z );

  			// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

  			normal.subVectors( vertex, P1 ).normalize();

  			normals.push( normal.x, normal.y, normal.z );

  			// uv

  			uvs.push( i / tubularSegments );
  			uvs.push( j / radialSegments );

  		}

  	}

  	// generate indices

  	for ( j = 1; j <= tubularSegments; j ++ ) {

  		for ( i = 1; i <= radialSegments; i ++ ) {

  			// indices

  			var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
  			var b = ( radialSegments + 1 ) * j + ( i - 1 );
  			var c = ( radialSegments + 1 ) * j + i;
  			var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

  			// faces

  			indices.push( a, b, d );
  			indices.push( b, c, d );

  		}

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  	// this function calculates the current position on the torus curve

  	function calculatePositionOnCurve( u, p, q, radius, position ) {

  		var cu = Math.cos( u );
  		var su = Math.sin( u );
  		var quOverP = q / p * u;
  		var cs = Math.cos( quOverP );

  		position.x = radius * ( 2 + cs ) * 0.5 * cu;
  		position.y = radius * ( 2 + cs ) * su * 0.5;
  		position.z = radius * Math.sin( quOverP ) * 0.5;

  	}

  }

  TorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;

  /**
   * @author oosmoxiecode
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */

  // TorusGeometry

  function TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

  	Geometry.call( this );

  	this.type = 'TorusGeometry';

  	this.parameters = {
  		radius: radius,
  		tube: tube,
  		radialSegments: radialSegments,
  		tubularSegments: tubularSegments,
  		arc: arc
  	};

  	this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );
  	this.mergeVertices();

  }

  TorusGeometry.prototype = Object.create( Geometry.prototype );
  TorusGeometry.prototype.constructor = TorusGeometry;

  // TorusBufferGeometry

  function TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

  	BufferGeometry.call( this );

  	this.type = 'TorusBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		tube: tube,
  		radialSegments: radialSegments,
  		tubularSegments: tubularSegments,
  		arc: arc
  	};

  	radius = radius || 100;
  	tube = tube || 40;
  	radialSegments = Math.floor( radialSegments ) || 8;
  	tubularSegments = Math.floor( tubularSegments ) || 6;
  	arc = arc || Math.PI * 2;

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// helper variables

  	var center = new Vector3$1();
  	var vertex = new Vector3$1();
  	var normal = new Vector3$1();

  	var j, i;

  	// generate vertices, normals and uvs

  	for ( j = 0; j <= radialSegments; j ++ ) {

  		for ( i = 0; i <= tubularSegments; i ++ ) {

  			var u = i / tubularSegments * arc;
  			var v = j / radialSegments * Math.PI * 2;

  			// vertex

  			vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
  			vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
  			vertex.z = tube * Math.sin( v );

  			vertices.push( vertex.x, vertex.y, vertex.z );

  			// normal

  			center.x = radius * Math.cos( u );
  			center.y = radius * Math.sin( u );
  			normal.subVectors( vertex, center ).normalize();

  			normals.push( normal.x, normal.y, normal.z );

  			// uv

  			uvs.push( i / tubularSegments );
  			uvs.push( j / radialSegments );

  		}

  	}

  	// generate indices

  	for ( j = 1; j <= radialSegments; j ++ ) {

  		for ( i = 1; i <= tubularSegments; i ++ ) {

  			// indices

  			var a = ( tubularSegments + 1 ) * j + i - 1;
  			var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
  			var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
  			var d = ( tubularSegments + 1 ) * j + i;

  			// faces

  			indices.push( a, b, d );
  			indices.push( b, c, d );

  		}

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  }

  TorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   */

  var ShapeUtils = {

  	// calculate area of the contour polygon

  	area: function ( contour ) {

  		var n = contour.length;
  		var a = 0.0;

  		for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

  			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

  		}

  		return a * 0.5;

  	},

  	triangulate: ( function () {

  		/**
  		 * This code is a quick port of code written in C++ which was submitted to
  		 * flipcode.com by John W. Ratcliff  // July 22, 2000
  		 * See original code and more information here:
  		 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
  		 *
  		 * ported to actionscript by Zevan Rosser
  		 * www.actionsnippet.com
  		 *
  		 * ported to javascript by Joshua Koo
  		 * http://www.lab4games.net/zz85/blog
  		 *
  		 */

  		function snip( contour, u, v, w, n, verts ) {

  			var p;
  			var ax, ay, bx, by;
  			var cx, cy, px, py;

  			ax = contour[ verts[ u ] ].x;
  			ay = contour[ verts[ u ] ].y;

  			bx = contour[ verts[ v ] ].x;
  			by = contour[ verts[ v ] ].y;

  			cx = contour[ verts[ w ] ].x;
  			cy = contour[ verts[ w ] ].y;

  			if ( ( bx - ax ) * ( cy - ay ) - ( by - ay ) * ( cx - ax ) <= 0 ) { return false; }

  			var aX, aY, bX, bY, cX, cY;
  			var apx, apy, bpx, bpy, cpx, cpy;
  			var cCROSSap, bCROSScp, aCROSSbp;

  			aX = cx - bx; aY = cy - by;
  			bX = ax - cx; bY = ay - cy;
  			cX = bx - ax; cY = by - ay;

  			for ( p = 0; p < n; p ++ ) {

  				px = contour[ verts[ p ] ].x;
  				py = contour[ verts[ p ] ].y;

  				if ( ( ( px === ax ) && ( py === ay ) ) ||
  					 ( ( px === bx ) && ( py === by ) ) ||
  					 ( ( px === cx ) && ( py === cy ) ) )	{ continue; }

  				apx = px - ax; apy = py - ay;
  				bpx = px - bx; bpy = py - by;
  				cpx = px - cx; cpy = py - cy;

  				// see if p is inside triangle abc

  				aCROSSbp = aX * bpy - aY * bpx;
  				cCROSSap = cX * apy - cY * apx;
  				bCROSScp = bX * cpy - bY * cpx;

  				if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) { return false; }

  			}

  			return true;

  		}

  		// takes in an contour array and returns

  		return function triangulate( contour, indices ) {

  			var n = contour.length;

  			if ( n < 3 ) { return null; }

  			var result = [],
  				verts = [],
  				vertIndices = [];

  			/* we want a counter-clockwise polygon in verts */

  			var u, v, w;

  			if ( ShapeUtils.area( contour ) > 0.0 ) {

  				for ( v = 0; v < n; v ++ ) { verts[ v ] = v; }

  			} else {

  				for ( v = 0; v < n; v ++ ) { verts[ v ] = ( n - 1 ) - v; }

  			}

  			var nv = n;

  			/*  remove nv - 2 vertices, creating 1 triangle every time */

  			var count = 2 * nv; /* error detection */

  			for ( v = nv - 1; nv > 2; ) {

  				/* if we loop, it is probably a non-simple polygon */

  				if ( ( count -- ) <= 0 ) {

  					//** Triangulate: ERROR - probable bad polygon!

  					//throw ( "Warning, unable to triangulate polygon!" );
  					//return null;
  					// Sometimes warning is fine, especially polygons are triangulated in reverse.
  					console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );

  					if ( indices ) { return vertIndices; }
  					return result;

  				}

  				/* three consecutive vertices in current polygon, <u,v,w> */

  				u = v; if ( nv <= u ) { u = 0; } /* previous */
  				v = u + 1; if ( nv <= v ) { v = 0; } /* new v    */
  				w = v + 1; if ( nv <= w ) { w = 0; } /* next     */

  				if ( snip( contour, u, v, w, nv, verts ) ) {

  					var a, b, c, s, t;

  					/* true names of the vertices */

  					a = verts[ u ];
  					b = verts[ v ];
  					c = verts[ w ];

  					/* output Triangle */

  					result.push( [ contour[ a ],
  						contour[ b ],
  						contour[ c ] ] );


  					vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

  					/* remove v from the remaining polygon */

  					for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {

  						verts[ s ] = verts[ t ];

  					}

  					nv --;

  					/* reset error detection counter */

  					count = 2 * nv;

  				}

  			}

  			if ( indices ) { return vertIndices; }
  			return result;

  		};

  	} )(),

  	triangulateShape: function ( contour, holes ) {

  		function removeDupEndPts( points ) {

  			var l = points.length;

  			if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

  				points.pop();

  			}

  		}

  		removeDupEndPts( contour );
  		holes.forEach( removeDupEndPts );

  		function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {

  			// inOtherPt needs to be collinear to the inSegment
  			if ( inSegPt1.x !== inSegPt2.x ) {

  				if ( inSegPt1.x < inSegPt2.x ) {

  					return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );

  				} else {

  					return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );

  				}

  			} else {

  				if ( inSegPt1.y < inSegPt2.y ) {

  					return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );

  				} else {

  					return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );

  				}

  			}

  		}

  		function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {

  			var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x, seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
  			var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x, seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

  			var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
  			var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

  			var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
  			var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

  			if ( Math.abs( limit ) > Number.EPSILON ) {

  				// not parallel

  				var perpSeg2;
  				if ( limit > 0 ) {

  					if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		{ return []; }
  					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
  					if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		{ return []; }

  				} else {

  					if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		{ return []; }
  					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
  					if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		{ return []; }

  				}

  				// i.e. to reduce rounding errors
  				// intersection at endpoint of segment#1?
  				if ( perpSeg2 === 0 ) {

  					if ( ( inExcludeAdjacentSegs ) &&
  						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		{ return []; }
  					return [ inSeg1Pt1 ];

  				}
  				if ( perpSeg2 === limit ) {

  					if ( ( inExcludeAdjacentSegs ) &&
  						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		{ return []; }
  					return [ inSeg1Pt2 ];

  				}
  				// intersection at endpoint of segment#2?
  				if ( perpSeg1 === 0 )		{ return [ inSeg2Pt1 ]; }
  				if ( perpSeg1 === limit )	{ return [ inSeg2Pt2 ]; }

  				// return real intersection point
  				var factorSeg1 = perpSeg2 / limit;
  				return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx, y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

  			} else {

  				// parallel or collinear
  				if ( ( perpSeg1 !== 0 ) ||
  					 ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			{ return []; }

  				// they are collinear or degenerate
  				var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?
  				var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?
  				// both segments are points
  				if ( seg1Pt && seg2Pt ) {

  					if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
  						 ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		{ return []; }	// they are distinct  points
  					return [ inSeg1Pt1 ];                 						// they are the same point

  				}
  				// segment#1  is a single point
  				if ( seg1Pt ) {

  					if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		{ return []; }		// but not in segment#2
  					return [ inSeg1Pt1 ];

  				}
  				// segment#2  is a single point
  				if ( seg2Pt ) {

  					if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		{ return []; }		// but not in segment#1
  					return [ inSeg2Pt1 ];

  				}

  				// they are collinear segments, which might overlap
  				var seg1min, seg1max, seg1minVal, seg1maxVal;
  				var seg2min, seg2max, seg2minVal, seg2maxVal;
  				if ( seg1dx !== 0 ) {

  					// the segments are NOT on a vertical line
  					if ( inSeg1Pt1.x < inSeg1Pt2.x ) {

  						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
  						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;

  					} else {

  						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
  						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;

  					}
  					if ( inSeg2Pt1.x < inSeg2Pt2.x ) {

  						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
  						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;

  					} else {

  						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
  						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;

  					}

  				} else {

  					// the segments are on a vertical line
  					if ( inSeg1Pt1.y < inSeg1Pt2.y ) {

  						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
  						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;

  					} else {

  						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
  						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;

  					}
  					if ( inSeg2Pt1.y < inSeg2Pt2.y ) {

  						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
  						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;

  					} else {

  						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
  						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;

  					}

  				}
  				if ( seg1minVal <= seg2minVal ) {

  					if ( seg1maxVal < seg2minVal )	{ return []; }
  					if ( seg1maxVal === seg2minVal )	{

  						if ( inExcludeAdjacentSegs )		{ return []; }
  						return [ seg2min ];

  					}
  					if ( seg1maxVal <= seg2maxVal )	{ return [ seg2min, seg1max ]; }
  					return	[ seg2min, seg2max ];

  				} else {

  					if ( seg1minVal > seg2maxVal )	{ return []; }
  					if ( seg1minVal === seg2maxVal )	{

  						if ( inExcludeAdjacentSegs )		{ return []; }
  						return [ seg1min ];

  					}
  					if ( seg1maxVal <= seg2maxVal )	{ return [ seg1min, seg1max ]; }
  					return	[ seg1min, seg2max ];

  				}

  			}

  		}

  		function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {

  			// The order of legs is important

  			// translation of all points, so that Vertex is at (0,0)
  			var legFromPtX	= inLegFromPt.x - inVertex.x, legFromPtY = inLegFromPt.y - inVertex.y;
  			var legToPtX	= inLegToPt.x	- inVertex.x, legToPtY = inLegToPt.y	- inVertex.y;
  			var otherPtX	= inOtherPt.x	- inVertex.x, otherPtY = inOtherPt.y	- inVertex.y;

  			// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
  			var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
  			var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;

  			if ( Math.abs( from2toAngle ) > Number.EPSILON ) {

  				// angle != 180 deg.

  				var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
  				// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

  				if ( from2toAngle > 0 ) {

  					// main angle < 180 deg.
  					return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );

  				} else {

  					// main angle > 180 deg.
  					return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );

  				}

  			} else {

  				// angle == 180 deg.
  				// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
  				return	( from2otherAngle > 0 );

  			}

  		}


  		function removeHoles( contour, holes ) {

  			var shape = contour.concat(); // work on this shape
  			var hole;

  			function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {

  				// Check if hole point lies within angle around shape point
  				var lastShapeIdx = shape.length - 1;

  				var prevShapeIdx = inShapeIdx - 1;
  				if ( prevShapeIdx < 0 )			{ prevShapeIdx = lastShapeIdx; }

  				var nextShapeIdx = inShapeIdx + 1;
  				if ( nextShapeIdx > lastShapeIdx )	{ nextShapeIdx = 0; }

  				var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
  				if ( ! insideAngle ) {

  					// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
  					return	false;

  				}

  				// Check if shape point lies within angle around hole point
  				var lastHoleIdx = hole.length - 1;

  				var prevHoleIdx = inHoleIdx - 1;
  				if ( prevHoleIdx < 0 )			{ prevHoleIdx = lastHoleIdx; }

  				var nextHoleIdx = inHoleIdx + 1;
  				if ( nextHoleIdx > lastHoleIdx )	{ nextHoleIdx = 0; }

  				insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
  				if ( ! insideAngle ) {

  					// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
  					return	false;

  				}

  				return	true;

  			}

  			function intersectsShapeEdge( inShapePt, inHolePt ) {

  				// checks for intersections with shape edges
  				var sIdx, nextIdx, intersection;
  				for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {

  					nextIdx = sIdx + 1; nextIdx %= shape.length;
  					intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
  					if ( intersection.length > 0 )		{ return	true; }

  				}

  				return	false;

  			}

  			var indepHoles = [];

  			function intersectsHoleEdge( inShapePt, inHolePt ) {

  				// checks for intersections with hole edges
  				var ihIdx, chkHole,
  					hIdx, nextIdx, intersection;
  				for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {

  					chkHole = holes[ indepHoles[ ihIdx ] ];
  					for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {

  						nextIdx = hIdx + 1; nextIdx %= chkHole.length;
  						intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
  						if ( intersection.length > 0 )		{ return	true; }

  					}

  				}
  				return	false;

  			}

  			var holeIndex, shapeIndex,
  				shapePt, holePt,
  				holeIdx, cutKey, failedCuts = [],
  				tmpShape1, tmpShape2,
  				tmpHole1, tmpHole2;

  			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

  				indepHoles.push( h );

  			}

  			var minShapeIndex = 0;
  			var counter = indepHoles.length * 2;
  			while ( indepHoles.length > 0 ) {

  				counter --;
  				if ( counter < 0 ) {

  					console.log( 'THREE.ShapeUtils: Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!' );
  					break;

  				}

  				// search for shape-vertex and hole-vertex,
  				// which can be connected without intersections
  				for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

  					shapePt = shape[ shapeIndex ];
  					holeIndex	= - 1;

  					// search for hole which can be reached without intersections
  					for ( var h = 0; h < indepHoles.length; h ++ ) {

  						holeIdx = indepHoles[ h ];

  						// prevent multiple checks
  						cutKey = shapePt.x + ':' + shapePt.y + ':' + holeIdx;
  						if ( failedCuts[ cutKey ] !== undefined )			{ continue; }

  						hole = holes[ holeIdx ];
  						for ( var h2 = 0; h2 < hole.length; h2 ++ ) {

  							holePt = hole[ h2 ];
  							if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		{ continue; }
  							if ( intersectsShapeEdge( shapePt, holePt ) )		{ continue; }
  							if ( intersectsHoleEdge( shapePt, holePt ) )		{ continue; }

  							holeIndex = h2;
  							indepHoles.splice( h, 1 );

  							tmpShape1 = shape.slice( 0, shapeIndex + 1 );
  							tmpShape2 = shape.slice( shapeIndex );
  							tmpHole1 = hole.slice( holeIndex );
  							tmpHole2 = hole.slice( 0, holeIndex + 1 );

  							shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

  							minShapeIndex = shapeIndex;

  							// Debug only, to show the selected cuts
  							// glob_CutLines.push( [ shapePt, holePt ] );

  							break;

  						}
  						if ( holeIndex >= 0 )	{ break; }		// hole-vertex found

  						failedCuts[ cutKey ] = true;			// remember failure

  					}
  					if ( holeIndex >= 0 )	{ break; }		// hole-vertex found

  				}

  			}

  			return shape; 			/* shape with no holes */

  		}


  		var i, il, f, face,
  			key, index,
  			allPointsMap = {};

  		// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

  		var allpoints = contour.concat();

  		for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

  			Array.prototype.push.apply( allpoints, holes[ h ] );

  		}

  		//console.log( "allpoints",allpoints, allpoints.length );

  		// prepare all points map

  		for ( i = 0, il = allpoints.length; i < il; i ++ ) {

  			key = allpoints[ i ].x + ':' + allpoints[ i ].y;

  			if ( allPointsMap[ key ] !== undefined ) {

  				console.warn( 'THREE.ShapeUtils: Duplicate point', key, i );

  			}

  			allPointsMap[ key ] = i;

  		}

  		// remove holes by cutting paths to holes and adding them to the shape
  		var shapeWithoutHoles = removeHoles( contour, holes );

  		var triangles = ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
  		//console.log( "triangles",triangles, triangles.length );

  		// check all face vertices against all points map

  		for ( i = 0, il = triangles.length; i < il; i ++ ) {

  			face = triangles[ i ];

  			for ( f = 0; f < 3; f ++ ) {

  				key = face[ f ].x + ':' + face[ f ].y;

  				index = allPointsMap[ key ];

  				if ( index !== undefined ) {

  					face[ f ] = index;

  				}

  			}

  		}

  		return triangles.concat();

  	},

  	isClockWise: function ( pts ) {

  		return ShapeUtils.area( pts ) < 0;

  	}

  };

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   *
   * Creates extruded geometry from a path shape.
   *
   * parameters = {
   *
   *  curveSegments: <int>, // number of points on the curves
   *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
   *  amount: <int>, // Depth to extrude the shape
   *
   *  bevelEnabled: <bool>, // turn on bevel
   *  bevelThickness: <float>, // how deep into the original shape bevel goes
   *  bevelSize: <float>, // how far from shape outline is bevel
   *  bevelSegments: <int>, // number of bevel layers
   *
   *  extrudePath: <THREE.Curve> // curve to extrude shape along
   *  frames: <Object> // containing arrays of tangents, normals, binormals
   *
   *  UVGenerator: <Object> // object that provides UV generator functions
   *
   * }
   */

  // ExtrudeGeometry

  function ExtrudeGeometry( shapes, options ) {

  	Geometry.call( this );

  	this.type = 'ExtrudeGeometry';

  	this.parameters = {
  		shapes: shapes,
  		options: options
  	};

  	this.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );
  	this.mergeVertices();

  }

  ExtrudeGeometry.prototype = Object.create( Geometry.prototype );
  ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

  // ExtrudeBufferGeometry

  function ExtrudeBufferGeometry( shapes, options ) {

  	if ( typeof ( shapes ) === "undefined" ) {

  		return;

  	}

  	BufferGeometry.call( this );

  	this.type = 'ExtrudeBufferGeometry';

  	shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

  	this.addShapeList( shapes, options );

  	this.computeVertexNormals();

  	// can't really use automatic vertex normals
  	// as then front and back sides get smoothed too
  	// should do separate smoothing just for sides

  	//this.computeVertexNormals();

  	//console.log( "took", ( Date.now() - startTime ) );

  }

  ExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;

  ExtrudeBufferGeometry.prototype.getArrays = function () {

  	var positionAttribute = this.getAttribute( "position" );
  	var verticesArray = positionAttribute ? Array.prototype.slice.call( positionAttribute.array ) : [];

  	var uvAttribute = this.getAttribute( "uv" );
  	var uvArray = uvAttribute ? Array.prototype.slice.call( uvAttribute.array ) : [];

  	var IndexAttribute = this.index;
  	var indicesArray = IndexAttribute ? Array.prototype.slice.call( IndexAttribute.array ) : [];

  	return {
  		position: verticesArray,
  		uv: uvArray,
  		index: indicesArray
  	};

  };

  ExtrudeBufferGeometry.prototype.addShapeList = function ( shapes, options ) {
  	var this$1 = this;


  	var sl = shapes.length;
  	options.arrays = this.getArrays();

  	for ( var s = 0; s < sl; s ++ ) {

  		var shape = shapes[ s ];
  		this$1.addShape( shape, options );

  	}

  	this.setIndex( options.arrays.index );
  	this.addAttribute( 'position', new Float32BufferAttribute( options.arrays.position, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute( options.arrays.uv, 2 ) );

  };

  ExtrudeBufferGeometry.prototype.addShape = function ( shape, options ) {

  	var arrays = options.arrays ? options.arrays : this.getArrays();
  	var verticesArray = arrays.position;
  	var indicesArray = arrays.index;
  	var uvArray = arrays.uv;

  	var placeholder = [];


  	var amount = options.amount !== undefined ? options.amount : 100;

  	var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
  	var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
  	var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

  	var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

  	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

  	var steps = options.steps !== undefined ? options.steps : 1;

  	var extrudePath = options.extrudePath;
  	var extrudePts, extrudeByPath = false;

  	// Use default WorldUVGenerator if no UV generators are specified.
  	var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;

  	var splineTube, binormal, normal, position2;
  	if ( extrudePath ) {

  		extrudePts = extrudePath.getSpacedPoints( steps );

  		extrudeByPath = true;
  		bevelEnabled = false; // bevels not supported for path extrusion

  		// SETUP TNB variables

  		// TODO1 - have a .isClosed in spline?

  		splineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames( steps, false );

  		// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

  		binormal = new Vector3$1();
  		normal = new Vector3$1();
  		position2 = new Vector3$1();

  	}

  	// Safeguards if bevels are not enabled

  	if ( ! bevelEnabled ) {

  		bevelSegments = 0;
  		bevelThickness = 0;
  		bevelSize = 0;

  	}

  	// Variables initialization

  	var ahole, h, hl; // looping of holes
  	var scope = this;

  	var shapePoints = shape.extractPoints( curveSegments );

  	var vertices = shapePoints.shape;
  	var holes = shapePoints.holes;

  	var reverse = ! ShapeUtils.isClockWise( vertices );

  	if ( reverse ) {

  		vertices = vertices.reverse();

  		// Maybe we should also check if holes are in the opposite direction, just to be safe ...

  		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

  			ahole = holes[ h ];

  			if ( ShapeUtils.isClockWise( ahole ) ) {

  				holes[ h ] = ahole.reverse();

  			}

  		}

  	}


  	var faces = ShapeUtils.triangulateShape( vertices, holes );

  	/* Vertices */

  	var contour = vertices; // vertices has all points but contour has only points of circumference

  	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

  		ahole = holes[ h ];

  		vertices = vertices.concat( ahole );

  	}


  	function scalePt2( pt, vec, size ) {

  		if ( ! vec ) { console.error( "THREE.ExtrudeGeometry: vec does not exist" ); }

  		return vec.clone().multiplyScalar( size ).add( pt );

  	}

  	var b, bs, t, z,
  		vert, vlen = vertices.length,
  		face, flen = faces.length;


  	// Find directions for point movement


  	function getBevelVec( inPt, inPrev, inNext ) {

  		// computes for inPt the corresponding point inPt' on a new contour
  		//   shifted by 1 unit (length of normalized vector) to the left
  		// if we walk along contour clockwise, this new contour is outside the old one
  		//
  		// inPt' is the intersection of the two lines parallel to the two
  		//  adjacent edges of inPt at a distance of 1 unit on the left side.

  		var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

  		// good reading for geometry algorithms (here: line-line intersection)
  		// http://geomalgorithms.com/a05-_intersect-1.html

  		var v_prev_x = inPt.x - inPrev.x,
  			v_prev_y = inPt.y - inPrev.y;
  		var v_next_x = inNext.x - inPt.x,
  			v_next_y = inNext.y - inPt.y;

  		var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

  		// check for collinear edges
  		var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

  		if ( Math.abs( collinear0 ) > Number.EPSILON ) {

  			// not collinear

  			// length of vectors for normalizing

  			var v_prev_len = Math.sqrt( v_prev_lensq );
  			var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

  			// shift adjacent points by unit vectors to the left

  			var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
  			var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

  			var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
  			var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

  			// scaling factor for v_prev to intersection point

  			var sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
  					( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
  				( v_prev_x * v_next_y - v_prev_y * v_next_x );

  			// vector from inPt to intersection point

  			v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
  			v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

  			// Don't normalize!, otherwise sharp corners become ugly
  			//  but prevent crazy spikes
  			var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
  			if ( v_trans_lensq <= 2 ) {

  				return new Vector2( v_trans_x, v_trans_y );

  			} else {

  				shrink_by = Math.sqrt( v_trans_lensq / 2 );

  			}

  		} else {

  			// handle special case of collinear edges

  			var direction_eq = false; // assumes: opposite
  			if ( v_prev_x > Number.EPSILON ) {

  				if ( v_next_x > Number.EPSILON ) {

  					direction_eq = true;

  				}

  			} else {

  				if ( v_prev_x < - Number.EPSILON ) {

  					if ( v_next_x < - Number.EPSILON ) {

  						direction_eq = true;

  					}

  				} else {

  					if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

  						direction_eq = true;

  					}

  				}

  			}

  			if ( direction_eq ) {

  				// console.log("Warning: lines are a straight sequence");
  				v_trans_x = - v_prev_y;
  				v_trans_y = v_prev_x;
  				shrink_by = Math.sqrt( v_prev_lensq );

  			} else {

  				// console.log("Warning: lines are a straight spike");
  				v_trans_x = v_prev_x;
  				v_trans_y = v_prev_y;
  				shrink_by = Math.sqrt( v_prev_lensq / 2 );

  			}

  		}

  		return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

  	}


  	var contourMovements = [];

  	for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

  		if ( j === il ) { j = 0; }
  		if ( k === il ) { k = 0; }

  		//  (j)---(i)---(k)
  		// console.log('i,j,k', i, j , k)

  		contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

  	}

  	var holesMovements = [],
  		oneHoleMovements, verticesMovements = contourMovements.concat();

  	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

  		ahole = holes[ h ];

  		oneHoleMovements = [];

  		for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

  			if ( j === il ) { j = 0; }
  			if ( k === il ) { k = 0; }

  			//  (j)---(i)---(k)
  			oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

  		}

  		holesMovements.push( oneHoleMovements );
  		verticesMovements = verticesMovements.concat( oneHoleMovements );

  	}


  	// Loop bevelSegments, 1 for the front, 1 for the back

  	for ( b = 0; b < bevelSegments; b ++ ) {

  		//for ( b = bevelSegments; b > 0; b -- ) {

  		t = b / bevelSegments;
  		z = bevelThickness * Math.cos( t * Math.PI / 2 );
  		bs = bevelSize * Math.sin( t * Math.PI / 2 );

  		// contract shape

  		for ( i = 0, il = contour.length; i < il; i ++ ) {

  			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

  			v( vert.x, vert.y, - z );

  		}

  		// expand holes

  		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

  			ahole = holes[ h ];
  			oneHoleMovements = holesMovements[ h ];

  			for ( i = 0, il = ahole.length; i < il; i ++ ) {

  				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

  				v( vert.x, vert.y, - z );

  			}

  		}

  	}

  	bs = bevelSize;

  	// Back facing vertices

  	for ( i = 0; i < vlen; i ++ ) {

  		vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

  		if ( ! extrudeByPath ) {

  			v( vert.x, vert.y, 0 );

  		} else {

  			// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

  			normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
  			binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

  			position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

  			v( position2.x, position2.y, position2.z );

  		}

  	}

  	// Add stepped vertices...
  	// Including front facing vertices

  	var s;

  	for ( s = 1; s <= steps; s ++ ) {

  		for ( i = 0; i < vlen; i ++ ) {

  			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

  			if ( ! extrudeByPath ) {

  				v( vert.x, vert.y, amount / steps * s );

  			} else {

  				// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

  				normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
  				binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

  				position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

  				v( position2.x, position2.y, position2.z );

  			}

  		}

  	}


  	// Add bevel segments planes

  	//for ( b = 1; b <= bevelSegments; b ++ ) {
  	for ( b = bevelSegments - 1; b >= 0; b -- ) {

  		t = b / bevelSegments;
  		z = bevelThickness * Math.cos( t * Math.PI / 2 );
  		bs = bevelSize * Math.sin( t * Math.PI / 2 );

  		// contract shape

  		for ( i = 0, il = contour.length; i < il; i ++ ) {

  			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
  			v( vert.x, vert.y, amount + z );

  		}

  		// expand holes

  		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

  			ahole = holes[ h ];
  			oneHoleMovements = holesMovements[ h ];

  			for ( i = 0, il = ahole.length; i < il; i ++ ) {

  				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

  				if ( ! extrudeByPath ) {

  					v( vert.x, vert.y, amount + z );

  				} else {

  					v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

  				}

  			}

  		}

  	}

  	/* Faces */

  	// Top and bottom faces

  	buildLidFaces();

  	// Sides faces

  	buildSideFaces();


  	/////  Internal functions

  	function buildLidFaces() {

  		var start = verticesArray.length / 3;

  		if ( bevelEnabled ) {

  			var layer = 0; // steps + 1
  			var offset = vlen * layer;

  			// Bottom faces

  			for ( i = 0; i < flen; i ++ ) {

  				face = faces[ i ];
  				f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

  			}

  			layer = steps + bevelSegments * 2;
  			offset = vlen * layer;

  			// Top faces

  			for ( i = 0; i < flen; i ++ ) {

  				face = faces[ i ];
  				f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

  			}

  		} else {

  			// Bottom faces

  			for ( i = 0; i < flen; i ++ ) {

  				face = faces[ i ];
  				f3( face[ 2 ], face[ 1 ], face[ 0 ] );

  			}

  			// Top faces

  			for ( i = 0; i < flen; i ++ ) {

  				face = faces[ i ];
  				f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

  			}

  		}

  		scope.addGroup( start, verticesArray.length / 3 - start, options.material !== undefined ? options.material : 0 );

  	}

  	// Create faces for the z-sides of the shape

  	function buildSideFaces() {

  		var start = verticesArray.length / 3;
  		var layeroffset = 0;
  		sidewalls( contour, layeroffset );
  		layeroffset += contour.length;

  		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

  			ahole = holes[ h ];
  			sidewalls( ahole, layeroffset );

  			//, true
  			layeroffset += ahole.length;

  		}


  		scope.addGroup( start, verticesArray.length / 3 - start, options.extrudeMaterial !== undefined ? options.extrudeMaterial : 1 );


  	}

  	function sidewalls( contour, layeroffset ) {

  		var j, k;
  		i = contour.length;

  		while ( -- i >= 0 ) {

  			j = i;
  			k = i - 1;
  			if ( k < 0 ) { k = contour.length - 1; }

  			//console.log('b', i,j, i-1, k,vertices.length);

  			var s = 0,
  				sl = steps + bevelSegments * 2;

  			for ( s = 0; s < sl; s ++ ) {

  				var slen1 = vlen * s;
  				var slen2 = vlen * ( s + 1 );

  				var a = layeroffset + j + slen1,
  					b = layeroffset + k + slen1,
  					c = layeroffset + k + slen2,
  					d = layeroffset + j + slen2;

  				f4( a, b, c, d );

  			}

  		}

  	}

  	function v( x, y, z ) {

  		placeholder.push( x );
  		placeholder.push( y );
  		placeholder.push( z );

  	}


  	function f3( a, b, c ) {

  		addVertex( a );
  		addVertex( b );
  		addVertex( c );

  		var nextIndex = verticesArray.length / 3;
  		var uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

  		addUV( uvs[ 0 ] );
  		addUV( uvs[ 1 ] );
  		addUV( uvs[ 2 ] );

  	}

  	function f4( a, b, c, d ) {

  		addVertex( a );
  		addVertex( b );
  		addVertex( d );

  		addVertex( b );
  		addVertex( c );
  		addVertex( d );


  		var nextIndex = verticesArray.length / 3;
  		var uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

  		addUV( uvs[ 0 ] );
  		addUV( uvs[ 1 ] );
  		addUV( uvs[ 3 ] );

  		addUV( uvs[ 1 ] );
  		addUV( uvs[ 2 ] );
  		addUV( uvs[ 3 ] );

  	}

  	function addVertex( index ) {

  		indicesArray.push( verticesArray.length / 3 );
  		verticesArray.push( placeholder[ index * 3 + 0 ] );
  		verticesArray.push( placeholder[ index * 3 + 1 ] );
  		verticesArray.push( placeholder[ index * 3 + 2 ] );

  	}


  	function addUV( vector2 ) {

  		uvArray.push( vector2.x );
  		uvArray.push( vector2.y );

  	}

  	if ( ! options.arrays ) {

  		this.setIndex( indicesArray );
  		this.addAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
  		this.addAttribute( 'uv', new Float32BufferAttribute( options.arrays.uv, 2 ) );

  	}

  };

  ExtrudeGeometry.WorldUVGenerator = {

  	generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

  		var a_x = vertices[ indexA * 3 ];
  		var a_y = vertices[ indexA * 3 + 1 ];
  		var b_x = vertices[ indexB * 3 ];
  		var b_y = vertices[ indexB * 3 + 1 ];
  		var c_x = vertices[ indexC * 3 ];
  		var c_y = vertices[ indexC * 3 + 1 ];

  		return [
  			new Vector2( a_x, a_y ),
  			new Vector2( b_x, b_y ),
  			new Vector2( c_x, c_y )
  		];

  	},

  	generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

  		var a_x = vertices[ indexA * 3 ];
  		var a_y = vertices[ indexA * 3 + 1 ];
  		var a_z = vertices[ indexA * 3 + 2 ];
  		var b_x = vertices[ indexB * 3 ];
  		var b_y = vertices[ indexB * 3 + 1 ];
  		var b_z = vertices[ indexB * 3 + 2 ];
  		var c_x = vertices[ indexC * 3 ];
  		var c_y = vertices[ indexC * 3 + 1 ];
  		var c_z = vertices[ indexC * 3 + 2 ];
  		var d_x = vertices[ indexD * 3 ];
  		var d_y = vertices[ indexD * 3 + 1 ];
  		var d_z = vertices[ indexD * 3 + 2 ];

  		if ( Math.abs( a_y - b_y ) < 0.01 ) {

  			return [
  				new Vector2( a_x, 1 - a_z ),
  				new Vector2( b_x, 1 - b_z ),
  				new Vector2( c_x, 1 - c_z ),
  				new Vector2( d_x, 1 - d_z )
  			];

  		} else {

  			return [
  				new Vector2( a_y, 1 - a_z ),
  				new Vector2( b_y, 1 - b_z ),
  				new Vector2( c_y, 1 - c_z ),
  				new Vector2( d_y, 1 - d_z )
  			];

  		}

  	}
  };

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * @author alteredq / http://alteredqualia.com/
   *
   * Text = 3D Text
   *
   * parameters = {
   *  font: <THREE.Font>, // font
   *
   *  size: <float>, // size of the text
   *  height: <float>, // thickness to extrude text
   *  curveSegments: <int>, // number of points on the curves
   *
   *  bevelEnabled: <bool>, // turn on bevel
   *  bevelThickness: <float>, // how deep into text bevel goes
   *  bevelSize: <float> // how far from text outline is bevel
   * }
   */

  // TextGeometry

  function TextGeometry( text, parameters ) {

  	Geometry.call( this );

  	this.type = 'TextGeometry';

  	this.parameters = {
  		text: text,
  		parameters: parameters
  	};

  	this.fromBufferGeometry( new TextBufferGeometry( text, parameters ) );
  	this.mergeVertices();

  }

  TextGeometry.prototype = Object.create( Geometry.prototype );
  TextGeometry.prototype.constructor = TextGeometry;

  // TextBufferGeometry

  function TextBufferGeometry( text, parameters ) {

  	parameters = parameters || {};

  	var font = parameters.font;

  	if ( ! ( font && font.isFont ) ) {

  		console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
  		return new Geometry();

  	}

  	var shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );

  	// translate parameters to ExtrudeGeometry API

  	parameters.amount = parameters.height !== undefined ? parameters.height : 50;

  	// defaults

  	if ( parameters.bevelThickness === undefined ) { parameters.bevelThickness = 10; }
  	if ( parameters.bevelSize === undefined ) { parameters.bevelSize = 8; }
  	if ( parameters.bevelEnabled === undefined ) { parameters.bevelEnabled = false; }

  	ExtrudeBufferGeometry.call( this, shapes, parameters );

  	this.type = 'TextBufferGeometry';

  }

  TextBufferGeometry.prototype = Object.create( ExtrudeBufferGeometry.prototype );
  TextBufferGeometry.prototype.constructor = TextBufferGeometry;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author benaadams / https://twitter.com/ben_a_adams
   * @author Mugen87 / https://github.com/Mugen87
   */

  // SphereGeometry

  function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

  	Geometry.call( this );

  	this.type = 'SphereGeometry';

  	this.parameters = {
  		radius: radius,
  		widthSegments: widthSegments,
  		heightSegments: heightSegments,
  		phiStart: phiStart,
  		phiLength: phiLength,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  	this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );
  	this.mergeVertices();

  }

  SphereGeometry.prototype = Object.create( Geometry.prototype );
  SphereGeometry.prototype.constructor = SphereGeometry;

  // SphereBufferGeometry

  function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

  	BufferGeometry.call( this );

  	this.type = 'SphereBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		widthSegments: widthSegments,
  		heightSegments: heightSegments,
  		phiStart: phiStart,
  		phiLength: phiLength,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  	radius = radius || 50;

  	widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
  	heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

  	phiStart = phiStart !== undefined ? phiStart : 0;
  	phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

  	thetaStart = thetaStart !== undefined ? thetaStart : 0;
  	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

  	var thetaEnd = thetaStart + thetaLength;

  	var ix, iy;

  	var index = 0;
  	var grid = [];

  	var vertex = new Vector3$1();
  	var normal = new Vector3$1();

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// generate vertices, normals and uvs

  	for ( iy = 0; iy <= heightSegments; iy ++ ) {

  		var verticesRow = [];

  		var v = iy / heightSegments;

  		for ( ix = 0; ix <= widthSegments; ix ++ ) {

  			var u = ix / widthSegments;

  			// vertex

  			vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
  			vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
  			vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

  			vertices.push( vertex.x, vertex.y, vertex.z );

  			// normal

  			normal.set( vertex.x, vertex.y, vertex.z ).normalize();
  			normals.push( normal.x, normal.y, normal.z );

  			// uv

  			uvs.push( u, 1 - v );

  			verticesRow.push( index ++ );

  		}

  		grid.push( verticesRow );

  	}

  	// indices

  	for ( iy = 0; iy < heightSegments; iy ++ ) {

  		for ( ix = 0; ix < widthSegments; ix ++ ) {

  			var a = grid[ iy ][ ix + 1 ];
  			var b = grid[ iy ][ ix ];
  			var c = grid[ iy + 1 ][ ix ];
  			var d = grid[ iy + 1 ][ ix + 1 ];

  			if ( iy !== 0 || thetaStart > 0 ) { indices.push( a, b, d ); }
  			if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) { indices.push( b, c, d ); }

  		}

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  }

  SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;

  /**
   * @author Kaleb Murphy
   * @author Mugen87 / https://github.com/Mugen87
   */

  // RingGeometry

  function RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

  	Geometry.call( this );

  	this.type = 'RingGeometry';

  	this.parameters = {
  		innerRadius: innerRadius,
  		outerRadius: outerRadius,
  		thetaSegments: thetaSegments,
  		phiSegments: phiSegments,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  	this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );
  	this.mergeVertices();

  }

  RingGeometry.prototype = Object.create( Geometry.prototype );
  RingGeometry.prototype.constructor = RingGeometry;

  // RingBufferGeometry

  function RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

  	BufferGeometry.call( this );

  	this.type = 'RingBufferGeometry';

  	this.parameters = {
  		innerRadius: innerRadius,
  		outerRadius: outerRadius,
  		thetaSegments: thetaSegments,
  		phiSegments: phiSegments,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  	innerRadius = innerRadius || 20;
  	outerRadius = outerRadius || 50;

  	thetaStart = thetaStart !== undefined ? thetaStart : 0;
  	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

  	thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
  	phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// some helper variables

  	var segment;
  	var radius = innerRadius;
  	var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
  	var vertex = new Vector3$1();
  	var uv = new Vector2();
  	var j, i;

  	// generate vertices, normals and uvs

  	for ( j = 0; j <= phiSegments; j ++ ) {

  		for ( i = 0; i <= thetaSegments; i ++ ) {

  			// values are generate from the inside of the ring to the outside

  			segment = thetaStart + i / thetaSegments * thetaLength;

  			// vertex

  			vertex.x = radius * Math.cos( segment );
  			vertex.y = radius * Math.sin( segment );

  			vertices.push( vertex.x, vertex.y, vertex.z );

  			// normal

  			normals.push( 0, 0, 1 );

  			// uv

  			uv.x = ( vertex.x / outerRadius + 1 ) / 2;
  			uv.y = ( vertex.y / outerRadius + 1 ) / 2;

  			uvs.push( uv.x, uv.y );

  		}

  		// increase the radius for next row of vertices

  		radius += radiusStep;

  	}

  	// indices

  	for ( j = 0; j < phiSegments; j ++ ) {

  		var thetaSegmentLevel = j * ( thetaSegments + 1 );

  		for ( i = 0; i < thetaSegments; i ++ ) {

  			segment = i + thetaSegmentLevel;

  			var a = segment;
  			var b = segment + thetaSegments + 1;
  			var c = segment + thetaSegments + 2;
  			var d = segment + 1;

  			// faces

  			indices.push( a, b, d );
  			indices.push( b, c, d );

  		}

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  }

  RingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  RingBufferGeometry.prototype.constructor = RingBufferGeometry;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */

  // PlaneGeometry

  function PlaneGeometry( width, height, widthSegments, heightSegments ) {

  	Geometry.call( this );

  	this.type = 'PlaneGeometry';

  	this.parameters = {
  		width: width,
  		height: height,
  		widthSegments: widthSegments,
  		heightSegments: heightSegments
  	};

  	this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );
  	this.mergeVertices();

  }

  PlaneGeometry.prototype = Object.create( Geometry.prototype );
  PlaneGeometry.prototype.constructor = PlaneGeometry;

  // PlaneBufferGeometry

  function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {

  	BufferGeometry.call( this );

  	this.type = 'PlaneBufferGeometry';

  	this.parameters = {
  		width: width,
  		height: height,
  		widthSegments: widthSegments,
  		heightSegments: heightSegments
  	};

  	var width_half = width / 2;
  	var height_half = height / 2;

  	var gridX = Math.floor( widthSegments ) || 1;
  	var gridY = Math.floor( heightSegments ) || 1;

  	var gridX1 = gridX + 1;
  	var gridY1 = gridY + 1;

  	var segment_width = width / gridX;
  	var segment_height = height / gridY;

  	var ix, iy;

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// generate vertices, normals and uvs

  	for ( iy = 0; iy < gridY1; iy ++ ) {

  		var y = iy * segment_height - height_half;

  		for ( ix = 0; ix < gridX1; ix ++ ) {

  			var x = ix * segment_width - width_half;

  			vertices.push( x, - y, 0 );

  			normals.push( 0, 0, 1 );

  			uvs.push( ix / gridX );
  			uvs.push( 1 - ( iy / gridY ) );

  		}

  	}

  	// indices

  	for ( iy = 0; iy < gridY; iy ++ ) {

  		for ( ix = 0; ix < gridX; ix ++ ) {

  			var a = ix + gridX1 * iy;
  			var b = ix + gridX1 * ( iy + 1 );
  			var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
  			var d = ( ix + 1 ) + gridX1 * iy;

  			// faces

  			indices.push( a, b, d );
  			indices.push( b, c, d );

  		}

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  }

  PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;

  /**
   * @author astrodud / http://astrodud.isgreat.org/
   * @author zz85 / https://github.com/zz85
   * @author bhouston / http://clara.io
   * @author Mugen87 / https://github.com/Mugen87
   */

  // LatheGeometry

  function LatheGeometry( points, segments, phiStart, phiLength ) {

  	Geometry.call( this );

  	this.type = 'LatheGeometry';

  	this.parameters = {
  		points: points,
  		segments: segments,
  		phiStart: phiStart,
  		phiLength: phiLength
  	};

  	this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );
  	this.mergeVertices();

  }

  LatheGeometry.prototype = Object.create( Geometry.prototype );
  LatheGeometry.prototype.constructor = LatheGeometry;

  // LatheBufferGeometry

  function LatheBufferGeometry( points, segments, phiStart, phiLength ) {

  	BufferGeometry.call( this );

  	this.type = 'LatheBufferGeometry';

  	this.parameters = {
  		points: points,
  		segments: segments,
  		phiStart: phiStart,
  		phiLength: phiLength
  	};

  	segments = Math.floor( segments ) || 12;
  	phiStart = phiStart || 0;
  	phiLength = phiLength || Math.PI * 2;

  	// clamp phiLength so it's in range of [ 0, 2PI ]

  	phiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );


  	// buffers

  	var indices = [];
  	var vertices = [];
  	var uvs = [];

  	// helper variables

  	var base;
  	var inverseSegments = 1.0 / segments;
  	var vertex = new Vector3$1();
  	var uv = new Vector2();
  	var i, j;

  	// generate vertices and uvs

  	for ( i = 0; i <= segments; i ++ ) {

  		var phi = phiStart + i * inverseSegments * phiLength;

  		var sin = Math.sin( phi );
  		var cos = Math.cos( phi );

  		for ( j = 0; j <= ( points.length - 1 ); j ++ ) {

  			// vertex

  			vertex.x = points[ j ].x * sin;
  			vertex.y = points[ j ].y;
  			vertex.z = points[ j ].x * cos;

  			vertices.push( vertex.x, vertex.y, vertex.z );

  			// uv

  			uv.x = i / segments;
  			uv.y = j / ( points.length - 1 );

  			uvs.push( uv.x, uv.y );


  		}

  	}

  	// indices

  	for ( i = 0; i < segments; i ++ ) {

  		for ( j = 0; j < ( points.length - 1 ); j ++ ) {

  			base = j + i * points.length;

  			var a = base;
  			var b = base + points.length;
  			var c = base + points.length + 1;
  			var d = base + 1;

  			// faces

  			indices.push( a, b, d );
  			indices.push( b, c, d );

  		}

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  	// generate normals

  	this.computeVertexNormals();

  	// if the geometry is closed, we need to average the normals along the seam.
  	// because the corresponding vertices are identical (but still have different UVs).

  	if ( phiLength === Math.PI * 2 ) {

  		var normals = this.attributes.normal.array;
  		var n1 = new Vector3$1();
  		var n2 = new Vector3$1();
  		var n = new Vector3$1();

  		// this is the buffer offset for the last line of vertices

  		base = segments * points.length * 3;

  		for ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {

  			// select the normal of the vertex in the first line

  			n1.x = normals[ j + 0 ];
  			n1.y = normals[ j + 1 ];
  			n1.z = normals[ j + 2 ];

  			// select the normal of the vertex in the last line

  			n2.x = normals[ base + j + 0 ];
  			n2.y = normals[ base + j + 1 ];
  			n2.z = normals[ base + j + 2 ];

  			// average normals

  			n.addVectors( n1, n2 ).normalize();

  			// assign the new values to both normals

  			normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
  			normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
  			normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

  		}

  	}

  }

  LatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;

  /**
   * @author jonobr1 / http://jonobr1.com
   * @author Mugen87 / https://github.com/Mugen87
   */

  // ShapeGeometry

  function ShapeGeometry( shapes, curveSegments ) {

  	Geometry.call( this );

  	this.type = 'ShapeGeometry';

  	if ( typeof curveSegments === 'object' ) {

  		console.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );

  		curveSegments = curveSegments.curveSegments;

  	}

  	this.parameters = {
  		shapes: shapes,
  		curveSegments: curveSegments
  	};

  	this.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );
  	this.mergeVertices();

  }

  ShapeGeometry.prototype = Object.create( Geometry.prototype );
  ShapeGeometry.prototype.constructor = ShapeGeometry;

  // ShapeBufferGeometry

  function ShapeBufferGeometry( shapes, curveSegments ) {
  	var this$1 = this;


  	BufferGeometry.call( this );

  	this.type = 'ShapeBufferGeometry';

  	this.parameters = {
  		shapes: shapes,
  		curveSegments: curveSegments
  	};

  	curveSegments = curveSegments || 12;

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// helper variables

  	var groupStart = 0;
  	var groupCount = 0;

  	// allow single and array values for "shapes" parameter

  	if ( Array.isArray( shapes ) === false ) {

  		addShape( shapes );

  	} else {

  		for ( var i = 0; i < shapes.length; i ++ ) {

  			addShape( shapes[ i ] );

  			this$1.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

  			groupStart += groupCount;
  			groupCount = 0;

  		}

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );


  	// helper functions

  	function addShape( shape ) {

  		var i, l, shapeHole;

  		var indexOffset = vertices.length / 3;
  		var points = shape.extractPoints( curveSegments );

  		var shapeVertices = points.shape;
  		var shapeHoles = points.holes;

  		// check direction of vertices

  		if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

  			shapeVertices = shapeVertices.reverse();

  			// also check if holes are in the opposite direction

  			for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

  				shapeHole = shapeHoles[ i ];

  				if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

  					shapeHoles[ i ] = shapeHole.reverse();

  				}

  			}

  		}

  		var faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

  		// join vertices of inner and outer paths to a single array

  		for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

  			shapeHole = shapeHoles[ i ];
  			shapeVertices = shapeVertices.concat( shapeHole );

  		}

  		// vertices, normals, uvs

  		for ( i = 0, l = shapeVertices.length; i < l; i ++ ) {

  			var vertex = shapeVertices[ i ];

  			vertices.push( vertex.x, vertex.y, 0 );
  			normals.push( 0, 0, 1 );
  			uvs.push( vertex.x, vertex.y ); // world uvs

  		}

  		// incides

  		for ( i = 0, l = faces.length; i < l; i ++ ) {

  			var face = faces[ i ];

  			var a = face[ 0 ] + indexOffset;
  			var b = face[ 1 ] + indexOffset;
  			var c = face[ 2 ] + indexOffset;

  			indices.push( a, b, c );
  			groupCount += 3;

  		}

  	}

  }

  ShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;

  /**
   * @author WestLangley / http://github.com/WestLangley
   * @author Mugen87 / https://github.com/Mugen87
   */

  function EdgesGeometry( geometry, thresholdAngle ) {

  	BufferGeometry.call( this );

  	this.type = 'EdgesGeometry';

  	this.parameters = {
  		thresholdAngle: thresholdAngle
  	};

  	thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

  	// buffer

  	var vertices = [];

  	// helper variables

  	var thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );
  	var edge = [ 0, 0 ], edges = {}, edge1, edge2;
  	var key, keys = [ 'a', 'b', 'c' ];

  	// prepare source geometry

  	var geometry2;

  	if ( geometry.isBufferGeometry ) {

  		geometry2 = new Geometry();
  		geometry2.fromBufferGeometry( geometry );

  	} else {

  		geometry2 = geometry.clone();

  	}

  	geometry2.mergeVertices();
  	geometry2.computeFaceNormals();

  	var sourceVertices = geometry2.vertices;
  	var faces = geometry2.faces;

  	// now create a data structure where each entry represents an edge with its adjoining faces

  	for ( var i = 0, l = faces.length; i < l; i ++ ) {

  		var face = faces[ i ];

  		for ( var j = 0; j < 3; j ++ ) {

  			edge1 = face[ keys[ j ] ];
  			edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
  			edge[ 0 ] = Math.min( edge1, edge2 );
  			edge[ 1 ] = Math.max( edge1, edge2 );

  			key = edge[ 0 ] + ',' + edge[ 1 ];

  			if ( edges[ key ] === undefined ) {

  				edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };

  			} else {

  				edges[ key ].face2 = i;

  			}

  		}

  	}

  	// generate vertices

  	for ( key in edges ) {

  		var e = edges[ key ];

  		// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.

  		if ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {

  			var vertex = sourceVertices[ e.index1 ];
  			vertices.push( vertex.x, vertex.y, vertex.z );

  			vertex = sourceVertices[ e.index2 ];
  			vertices.push( vertex.x, vertex.y, vertex.z );

  		}

  	}

  	// build geometry

  	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

  }

  EdgesGeometry.prototype = Object.create( BufferGeometry.prototype );
  EdgesGeometry.prototype.constructor = EdgesGeometry;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */

  // CylinderGeometry

  function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

  	Geometry.call( this );

  	this.type = 'CylinderGeometry';

  	this.parameters = {
  		radiusTop: radiusTop,
  		radiusBottom: radiusBottom,
  		height: height,
  		radialSegments: radialSegments,
  		heightSegments: heightSegments,
  		openEnded: openEnded,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  	this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
  	this.mergeVertices();

  }

  CylinderGeometry.prototype = Object.create( Geometry.prototype );
  CylinderGeometry.prototype.constructor = CylinderGeometry;

  // CylinderBufferGeometry

  function CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

  	BufferGeometry.call( this );

  	this.type = 'CylinderBufferGeometry';

  	this.parameters = {
  		radiusTop: radiusTop,
  		radiusBottom: radiusBottom,
  		height: height,
  		radialSegments: radialSegments,
  		heightSegments: heightSegments,
  		openEnded: openEnded,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  	var scope = this;

  	radiusTop = radiusTop !== undefined ? radiusTop : 20;
  	radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
  	height = height !== undefined ? height : 100;

  	radialSegments = Math.floor( radialSegments ) || 8;
  	heightSegments = Math.floor( heightSegments ) || 1;

  	openEnded = openEnded !== undefined ? openEnded : false;
  	thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
  	thetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// helper variables

  	var index = 0;
  	var indexArray = [];
  	var halfHeight = height / 2;
  	var groupStart = 0;

  	// generate geometry

  	generateTorso();

  	if ( openEnded === false ) {

  		if ( radiusTop > 0 ) { generateCap( true ); }
  		if ( radiusBottom > 0 ) { generateCap( false ); }

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  	function generateTorso() {

  		var x, y;
  		var normal = new Vector3$1();
  		var vertex = new Vector3$1();

  		var groupCount = 0;

  		// this will be used to calculate the normal
  		var slope = ( radiusBottom - radiusTop ) / height;

  		// generate vertices, normals and uvs

  		for ( y = 0; y <= heightSegments; y ++ ) {

  			var indexRow = [];

  			var v = y / heightSegments;

  			// calculate the radius of the current row

  			var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

  			for ( x = 0; x <= radialSegments; x ++ ) {

  				var u = x / radialSegments;

  				var theta = u * thetaLength + thetaStart;

  				var sinTheta = Math.sin( theta );
  				var cosTheta = Math.cos( theta );

  				// vertex

  				vertex.x = radius * sinTheta;
  				vertex.y = - v * height + halfHeight;
  				vertex.z = radius * cosTheta;
  				vertices.push( vertex.x, vertex.y, vertex.z );

  				// normal

  				normal.set( sinTheta, slope, cosTheta ).normalize();
  				normals.push( normal.x, normal.y, normal.z );

  				// uv

  				uvs.push( u, 1 - v );

  				// save index of vertex in respective row

  				indexRow.push( index ++ );

  			}

  			// now save vertices of the row in our index array

  			indexArray.push( indexRow );

  		}

  		// generate indices

  		for ( x = 0; x < radialSegments; x ++ ) {

  			for ( y = 0; y < heightSegments; y ++ ) {

  				// we use the index array to access the correct indices

  				var a = indexArray[ y ][ x ];
  				var b = indexArray[ y + 1 ][ x ];
  				var c = indexArray[ y + 1 ][ x + 1 ];
  				var d = indexArray[ y ][ x + 1 ];

  				// faces

  				indices.push( a, b, d );
  				indices.push( b, c, d );

  				// update group counter

  				groupCount += 6;

  			}

  		}

  		// add a group to the geometry. this will ensure multi material support

  		scope.addGroup( groupStart, groupCount, 0 );

  		// calculate new start value for groups

  		groupStart += groupCount;

  	}

  	function generateCap( top ) {

  		var x, centerIndexStart, centerIndexEnd;

  		var uv = new Vector2();
  		var vertex = new Vector3$1();

  		var groupCount = 0;

  		var radius = ( top === true ) ? radiusTop : radiusBottom;
  		var sign = ( top === true ) ? 1 : - 1;

  		// save the index of the first center vertex
  		centerIndexStart = index;

  		// first we generate the center vertex data of the cap.
  		// because the geometry needs one set of uvs per face,
  		// we must generate a center vertex per face/segment

  		for ( x = 1; x <= radialSegments; x ++ ) {

  			// vertex

  			vertices.push( 0, halfHeight * sign, 0 );

  			// normal

  			normals.push( 0, sign, 0 );

  			// uv

  			uvs.push( 0.5, 0.5 );

  			// increase index

  			index ++;

  		}

  		// save the index of the last center vertex

  		centerIndexEnd = index;

  		// now we generate the surrounding vertices, normals and uvs

  		for ( x = 0; x <= radialSegments; x ++ ) {

  			var u = x / radialSegments;
  			var theta = u * thetaLength + thetaStart;

  			var cosTheta = Math.cos( theta );
  			var sinTheta = Math.sin( theta );

  			// vertex

  			vertex.x = radius * sinTheta;
  			vertex.y = halfHeight * sign;
  			vertex.z = radius * cosTheta;
  			vertices.push( vertex.x, vertex.y, vertex.z );

  			// normal

  			normals.push( 0, sign, 0 );

  			// uv

  			uv.x = ( cosTheta * 0.5 ) + 0.5;
  			uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
  			uvs.push( uv.x, uv.y );

  			// increase index

  			index ++;

  		}

  		// generate indices

  		for ( x = 0; x < radialSegments; x ++ ) {

  			var c = centerIndexStart + x;
  			var i = centerIndexEnd + x;

  			if ( top === true ) {

  				// face top

  				indices.push( i, i + 1, c );

  			} else {

  				// face bottom

  				indices.push( i + 1, i, c );

  			}

  			groupCount += 3;

  		}

  		// add a group to the geometry. this will ensure multi material support

  		scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

  		// calculate new start value for groups

  		groupStart += groupCount;

  	}

  }

  CylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;

  /**
   * @author abelnation / http://github.com/abelnation
   */

  // ConeGeometry

  function ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

  	CylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

  	this.type = 'ConeGeometry';

  	this.parameters = {
  		radius: radius,
  		height: height,
  		radialSegments: radialSegments,
  		heightSegments: heightSegments,
  		openEnded: openEnded,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  }

  ConeGeometry.prototype = Object.create( CylinderGeometry.prototype );
  ConeGeometry.prototype.constructor = ConeGeometry;

  // ConeBufferGeometry

  function ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

  	CylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

  	this.type = 'ConeBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		height: height,
  		radialSegments: radialSegments,
  		heightSegments: heightSegments,
  		openEnded: openEnded,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  }

  ConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );
  ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;

  /**
   * @author benaadams / https://twitter.com/ben_a_adams
   * @author Mugen87 / https://github.com/Mugen87
   * @author hughes
   */

  // CircleGeometry

  function CircleGeometry( radius, segments, thetaStart, thetaLength ) {

  	Geometry.call( this );

  	this.type = 'CircleGeometry';

  	this.parameters = {
  		radius: radius,
  		segments: segments,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  	this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );
  	this.mergeVertices();

  }

  CircleGeometry.prototype = Object.create( Geometry.prototype );
  CircleGeometry.prototype.constructor = CircleGeometry;

  // CircleBufferGeometry

  function CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {

  	BufferGeometry.call( this );

  	this.type = 'CircleBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		segments: segments,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  	radius = radius || 50;
  	segments = segments !== undefined ? Math.max( 3, segments ) : 8;

  	thetaStart = thetaStart !== undefined ? thetaStart : 0;
  	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// helper variables

  	var i, s;
  	var vertex = new Vector3$1();
  	var uv = new Vector2();

  	// center point

  	vertices.push( 0, 0, 0 );
  	normals.push( 0, 0, 1 );
  	uvs.push( 0.5, 0.5 );

  	for ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {

  		var segment = thetaStart + s / segments * thetaLength;

  		// vertex

  		vertex.x = radius * Math.cos( segment );
  		vertex.y = radius * Math.sin( segment );

  		vertices.push( vertex.x, vertex.y, vertex.z );

  		// normal

  		normals.push( 0, 0, 1 );

  		// uvs

  		uv.x = ( vertices[ i ] / radius + 1 ) / 2;
  		uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

  		uvs.push( uv.x, uv.y );

  	}

  	// indices

  	for ( i = 1; i <= segments; i ++ ) {

  		indices.push( i, i + 1, 0 );

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  }

  CircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */

  // BoxGeometry

  function BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

  	Geometry.call( this );

  	this.type = 'BoxGeometry';

  	this.parameters = {
  		width: width,
  		height: height,
  		depth: depth,
  		widthSegments: widthSegments,
  		heightSegments: heightSegments,
  		depthSegments: depthSegments
  	};

  	this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
  	this.mergeVertices();

  }

  BoxGeometry.prototype = Object.create( Geometry.prototype );
  BoxGeometry.prototype.constructor = BoxGeometry;

  // BoxBufferGeometry

  function BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

  	BufferGeometry.call( this );

  	this.type = 'BoxBufferGeometry';

  	this.parameters = {
  		width: width,
  		height: height,
  		depth: depth,
  		widthSegments: widthSegments,
  		heightSegments: heightSegments,
  		depthSegments: depthSegments
  	};

  	var scope = this;

  	// segments

  	widthSegments = Math.floor( widthSegments ) || 1;
  	heightSegments = Math.floor( heightSegments ) || 1;
  	depthSegments = Math.floor( depthSegments ) || 1;

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// helper variables

  	var numberOfVertices = 0;
  	var groupStart = 0;

  	// build each side of the box geometry

  	buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
  	buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
  	buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
  	buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
  	buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
  	buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  	function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

  		var segmentWidth = width / gridX;
  		var segmentHeight = height / gridY;

  		var widthHalf = width / 2;
  		var heightHalf = height / 2;
  		var depthHalf = depth / 2;

  		var gridX1 = gridX + 1;
  		var gridY1 = gridY + 1;

  		var vertexCounter = 0;
  		var groupCount = 0;

  		var ix, iy;

  		var vector = new Vector3$1();

  		// generate vertices, normals and uvs

  		for ( iy = 0; iy < gridY1; iy ++ ) {

  			var y = iy * segmentHeight - heightHalf;

  			for ( ix = 0; ix < gridX1; ix ++ ) {

  				var x = ix * segmentWidth - widthHalf;

  				// set values to correct vector component

  				vector[ u ] = x * udir;
  				vector[ v ] = y * vdir;
  				vector[ w ] = depthHalf;

  				// now apply vector to vertex buffer

  				vertices.push( vector.x, vector.y, vector.z );

  				// set values to correct vector component

  				vector[ u ] = 0;
  				vector[ v ] = 0;
  				vector[ w ] = depth > 0 ? 1 : - 1;

  				// now apply vector to normal buffer

  				normals.push( vector.x, vector.y, vector.z );

  				// uvs

  				uvs.push( ix / gridX );
  				uvs.push( 1 - ( iy / gridY ) );

  				// counters

  				vertexCounter += 1;

  			}

  		}

  		// indices

  		// 1. you need three indices to draw a single face
  		// 2. a single segment consists of two faces
  		// 3. so we need to generate six (2*3) indices per segment

  		for ( iy = 0; iy < gridY; iy ++ ) {

  			for ( ix = 0; ix < gridX; ix ++ ) {

  				var a = numberOfVertices + ix + gridX1 * iy;
  				var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
  				var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
  				var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

  				// faces

  				indices.push( a, b, d );
  				indices.push( b, c, d );

  				// increase counter

  				groupCount += 6;

  			}

  		}

  		// add a group to the geometry. this will ensure multi material support

  		scope.addGroup( groupStart, groupCount, materialIndex );

  		// calculate new start value for groups

  		groupStart += groupCount;

  		// update total number of vertices

  		numberOfVertices += vertexCounter;

  	}

  }

  BoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;



  var Geometries = Object.freeze({
  	WireframeGeometry: WireframeGeometry,
  	ParametricGeometry: ParametricGeometry,
  	ParametricBufferGeometry: ParametricBufferGeometry,
  	TetrahedronGeometry: TetrahedronGeometry,
  	TetrahedronBufferGeometry: TetrahedronBufferGeometry,
  	OctahedronGeometry: OctahedronGeometry,
  	OctahedronBufferGeometry: OctahedronBufferGeometry,
  	IcosahedronGeometry: IcosahedronGeometry,
  	IcosahedronBufferGeometry: IcosahedronBufferGeometry,
  	DodecahedronGeometry: DodecahedronGeometry,
  	DodecahedronBufferGeometry: DodecahedronBufferGeometry,
  	PolyhedronGeometry: PolyhedronGeometry,
  	PolyhedronBufferGeometry: PolyhedronBufferGeometry,
  	TubeGeometry: TubeGeometry,
  	TubeBufferGeometry: TubeBufferGeometry,
  	TorusKnotGeometry: TorusKnotGeometry,
  	TorusKnotBufferGeometry: TorusKnotBufferGeometry,
  	TorusGeometry: TorusGeometry,
  	TorusBufferGeometry: TorusBufferGeometry,
  	TextGeometry: TextGeometry,
  	TextBufferGeometry: TextBufferGeometry,
  	SphereGeometry: SphereGeometry,
  	SphereBufferGeometry: SphereBufferGeometry,
  	RingGeometry: RingGeometry,
  	RingBufferGeometry: RingBufferGeometry,
  	PlaneGeometry: PlaneGeometry,
  	PlaneBufferGeometry: PlaneBufferGeometry,
  	LatheGeometry: LatheGeometry,
  	LatheBufferGeometry: LatheBufferGeometry,
  	ShapeGeometry: ShapeGeometry,
  	ShapeBufferGeometry: ShapeBufferGeometry,
  	ExtrudeGeometry: ExtrudeGeometry,
  	ExtrudeBufferGeometry: ExtrudeBufferGeometry,
  	EdgesGeometry: EdgesGeometry,
  	ConeGeometry: ConeGeometry,
  	ConeBufferGeometry: ConeBufferGeometry,
  	CylinderGeometry: CylinderGeometry,
  	CylinderBufferGeometry: CylinderBufferGeometry,
  	CircleGeometry: CircleGeometry,
  	CircleBufferGeometry: CircleBufferGeometry,
  	BoxGeometry: BoxGeometry,
  	BoxBufferGeometry: BoxBufferGeometry
  });

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function ObjectLoader( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
  	this.texturePath = '';

  }

  Object.assign( ObjectLoader.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {

  		if ( this.texturePath === '' ) {

  			this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

  		}

  		var scope = this;

  		var loader = new FileLoader( scope.manager );
  		loader.load( url, function ( text ) {

  			var json = null;

  			try {

  				json = JSON.parse( text );

  			} catch ( error ) {

  				if ( onError !== undefined ) { onError( error ); }

  				console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );

  				return;

  			}

  			var metadata = json.metadata;

  			if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

  				console.error( 'THREE.ObjectLoader: Can\'t load ' + url + '. Use THREE.JSONLoader instead.' );
  				return;

  			}

  			scope.parse( json, onLoad );

  		}, onProgress, onError );

  	},

  	setTexturePath: function ( value ) {

  		this.texturePath = value;

  	},

  	setCrossOrigin: function ( value ) {

  		this.crossOrigin = value;

  	},

  	parse: function ( json, onLoad ) {

  		var geometries = this.parseGeometries( json.geometries );

  		var images = this.parseImages( json.images, function () {

  			if ( onLoad !== undefined ) { onLoad( object ); }

  		} );

  		var textures = this.parseTextures( json.textures, images );
  		var materials = this.parseMaterials( json.materials, textures );

  		var object = this.parseObject( json.object, geometries, materials );

  		if ( json.animations ) {

  			object.animations = this.parseAnimations( json.animations );

  		}

  		if ( json.images === undefined || json.images.length === 0 ) {

  			if ( onLoad !== undefined ) { onLoad( object ); }

  		}

  		return object;

  	},

  	parseGeometries: function ( json ) {
  		var this$1 = this;


  		var geometries = {};

  		if ( json !== undefined ) {

  			var geometryLoader = new JSONLoader();
  			var bufferGeometryLoader = new BufferGeometryLoader();

  			for ( var i = 0, l = json.length; i < l; i ++ ) {

  				var geometry;
  				var data = json[ i ];

  				switch ( data.type ) {

  					case 'PlaneGeometry':
  					case 'PlaneBufferGeometry':

  						geometry = new Geometries[ data.type ](
  							data.width,
  							data.height,
  							data.widthSegments,
  							data.heightSegments
  						);

  						break;

  					case 'BoxGeometry':
  					case 'BoxBufferGeometry':
  					case 'CubeGeometry': // backwards compatible

  						geometry = new Geometries[ data.type ](
  							data.width,
  							data.height,
  							data.depth,
  							data.widthSegments,
  							data.heightSegments,
  							data.depthSegments
  						);

  						break;

  					case 'CircleGeometry':
  					case 'CircleBufferGeometry':

  						geometry = new Geometries[ data.type ](
  							data.radius,
  							data.segments,
  							data.thetaStart,
  							data.thetaLength
  						);

  						break;

  					case 'CylinderGeometry':
  					case 'CylinderBufferGeometry':

  						geometry = new Geometries[ data.type ](
  							data.radiusTop,
  							data.radiusBottom,
  							data.height,
  							data.radialSegments,
  							data.heightSegments,
  							data.openEnded,
  							data.thetaStart,
  							data.thetaLength
  						);

  						break;

  					case 'ConeGeometry':
  					case 'ConeBufferGeometry':

  						geometry = new Geometries[ data.type ](
  							data.radius,
  							data.height,
  							data.radialSegments,
  							data.heightSegments,
  							data.openEnded,
  							data.thetaStart,
  							data.thetaLength
  						);

  						break;

  					case 'SphereGeometry':
  					case 'SphereBufferGeometry':

  						geometry = new Geometries[ data.type ](
  							data.radius,
  							data.widthSegments,
  							data.heightSegments,
  							data.phiStart,
  							data.phiLength,
  							data.thetaStart,
  							data.thetaLength
  						);

  						break;

  					case 'DodecahedronGeometry':
  					case 'IcosahedronGeometry':
  					case 'OctahedronGeometry':
  					case 'TetrahedronGeometry':

  						geometry = new Geometries[ data.type ](
  							data.radius,
  							data.detail
  						);

  						break;

  					case 'RingGeometry':
  					case 'RingBufferGeometry':

  						geometry = new Geometries[ data.type ](
  							data.innerRadius,
  							data.outerRadius,
  							data.thetaSegments,
  							data.phiSegments,
  							data.thetaStart,
  							data.thetaLength
  						);

  						break;

  					case 'TorusGeometry':
  					case 'TorusBufferGeometry':

  						geometry = new Geometries[ data.type ](
  							data.radius,
  							data.tube,
  							data.radialSegments,
  							data.tubularSegments,
  							data.arc
  						);

  						break;

  					case 'TorusKnotGeometry':
  					case 'TorusKnotBufferGeometry':

  						geometry = new Geometries[ data.type ](
  							data.radius,
  							data.tube,
  							data.tubularSegments,
  							data.radialSegments,
  							data.p,
  							data.q
  						);

  						break;

  					case 'LatheGeometry':
  					case 'LatheBufferGeometry':

  						geometry = new Geometries[ data.type ](
  							data.points,
  							data.segments,
  							data.phiStart,
  							data.phiLength
  						);

  						break;

  					case 'BufferGeometry':

  						geometry = bufferGeometryLoader.parse( data );

  						break;

  					case 'Geometry':

  						geometry = geometryLoader.parse( data, this$1.texturePath ).geometry;

  						break;

  					default:

  						console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

  						continue;

  				}

  				geometry.uuid = data.uuid;

  				if ( data.name !== undefined ) { geometry.name = data.name; }

  				geometries[ data.uuid ] = geometry;

  			}

  		}

  		return geometries;

  	},

  	parseMaterials: function ( json, textures ) {

  		var materials = {};

  		if ( json !== undefined ) {

  			var loader = new MaterialLoader();
  			loader.setTextures( textures );

  			for ( var i = 0, l = json.length; i < l; i ++ ) {

  				var data = json[ i ];

  				if ( data.type === 'MultiMaterial' ) {

  					// Deprecated

  					var array = [];

  					for ( var j = 0; j < data.materials.length; j ++ ) {

  						array.push( loader.parse( data.materials[ j ] ) );

  					}

  					materials[ data.uuid ] = array;

  				} else {

  					materials[ data.uuid ] = loader.parse( data );

  				}

  			}

  		}

  		return materials;

  	},

  	parseAnimations: function ( json ) {

  		var animations = [];

  		for ( var i = 0; i < json.length; i ++ ) {

  			var clip = AnimationClip.parse( json[ i ] );

  			animations.push( clip );

  		}

  		return animations;

  	},

  	parseImages: function ( json, onLoad ) {

  		var scope = this;
  		var images = {};

  		function loadImage( url ) {

  			scope.manager.itemStart( url );

  			return loader.load( url, function () {

  				scope.manager.itemEnd( url );

  			}, undefined, function () {

  				scope.manager.itemEnd( url );
  				scope.manager.itemError( url );

  			} );

  		}

  		if ( json !== undefined && json.length > 0 ) {

  			var manager = new LoadingManager( onLoad );

  			var loader = new ImageLoader( manager );
  			loader.setCrossOrigin( this.crossOrigin );

  			for ( var i = 0, l = json.length; i < l; i ++ ) {

  				var image = json[ i ];
  				var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

  				images[ image.uuid ] = loadImage( path );

  			}

  		}

  		return images;

  	},

  	parseTextures: function ( json, images ) {

  		function parseConstant( value, type ) {

  			if ( typeof value === 'number' ) { return value; }

  			console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

  			return type[ value ];

  		}

  		var textures = {};

  		if ( json !== undefined ) {

  			for ( var i = 0, l = json.length; i < l; i ++ ) {

  				var data = json[ i ];

  				if ( data.image === undefined ) {

  					console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

  				}

  				if ( images[ data.image ] === undefined ) {

  					console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

  				}

  				var texture = new Texture( images[ data.image ] );
  				texture.needsUpdate = true;

  				texture.uuid = data.uuid;

  				if ( data.name !== undefined ) { texture.name = data.name; }

  				if ( data.mapping !== undefined ) { texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING ); }

  				if ( data.offset !== undefined ) { texture.offset.fromArray( data.offset ); }
  				if ( data.repeat !== undefined ) { texture.repeat.fromArray( data.repeat ); }
  				if ( data.center !== undefined ) { texture.center.fromArray( data.center ); }
  				if ( data.rotation !== undefined ) { texture.rotation = data.rotation; }

  				if ( data.wrap !== undefined ) {

  					texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
  					texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );

  				}

  				if ( data.minFilter !== undefined ) { texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER ); }
  				if ( data.magFilter !== undefined ) { texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER ); }
  				if ( data.anisotropy !== undefined ) { texture.anisotropy = data.anisotropy; }

  				if ( data.flipY !== undefined ) { texture.flipY = data.flipY; }

  				textures[ data.uuid ] = texture;

  			}

  		}

  		return textures;

  	},

  	parseObject: function () {

  		var matrix = new Matrix4();

  		return function parseObject( data, geometries, materials ) {
  			var this$1 = this;


  			var object;

  			function getGeometry( name ) {

  				if ( geometries[ name ] === undefined ) {

  					console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

  				}

  				return geometries[ name ];

  			}

  			function getMaterial( name ) {

  				if ( name === undefined ) { return undefined; }

  				if ( Array.isArray( name ) ) {

  					var array = [];

  					for ( var i = 0, l = name.length; i < l; i ++ ) {

  						var uuid = name[ i ];

  						if ( materials[ uuid ] === undefined ) {

  							console.warn( 'THREE.ObjectLoader: Undefined material', uuid );

  						}

  						array.push( materials[ uuid ] );

  					}

  					return array;

  				}

  				if ( materials[ name ] === undefined ) {

  					console.warn( 'THREE.ObjectLoader: Undefined material', name );

  				}

  				return materials[ name ];

  			}

  			switch ( data.type ) {

  				case 'Scene':

  					object = new Scene();

  					if ( data.background !== undefined ) {

  						if ( Number.isInteger( data.background ) ) {

  							object.background = new Color( data.background );

  						}

  					}

  					if ( data.fog !== undefined ) {

  						if ( data.fog.type === 'Fog' ) {

  							object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

  						} else if ( data.fog.type === 'FogExp2' ) {

  							object.fog = new FogExp2( data.fog.color, data.fog.density );

  						}

  					}

  					break;

  				case 'PerspectiveCamera':

  					object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

  					if ( data.focus !== undefined ) { object.focus = data.focus; }
  					if ( data.zoom !== undefined ) { object.zoom = data.zoom; }
  					if ( data.filmGauge !== undefined ) { object.filmGauge = data.filmGauge; }
  					if ( data.filmOffset !== undefined ) { object.filmOffset = data.filmOffset; }
  					if ( data.view !== undefined ) { object.view = Object.assign( {}, data.view ); }

  					break;

  				case 'OrthographicCamera':

  					object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

  					break;

  				case 'AmbientLight':

  					object = new AmbientLight( data.color, data.intensity );

  					break;

  				case 'DirectionalLight':

  					object = new DirectionalLight( data.color, data.intensity );

  					break;

  				case 'PointLight':

  					object = new PointLight( data.color, data.intensity, data.distance, data.decay );

  					break;

  				case 'RectAreaLight':

  					object = new RectAreaLight( data.color, data.intensity, data.width, data.height );

  					break;

  				case 'SpotLight':

  					object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

  					break;

  				case 'HemisphereLight':

  					object = new HemisphereLight( data.color, data.groundColor, data.intensity );

  					break;

  				case 'SkinnedMesh':

  					console.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' );

  				case 'Mesh':

  					var geometry = getGeometry( data.geometry );
  					var material = getMaterial( data.material );

  					if ( geometry.bones && geometry.bones.length > 0 ) {

  						object = new SkinnedMesh( geometry, material );

  					} else {

  						object = new Mesh( geometry, material );

  					}

  					break;

  				case 'LOD':

  					object = new LOD();

  					break;

  				case 'Line':

  					object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

  					break;

  				case 'LineLoop':

  					object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );

  					break;

  				case 'LineSegments':

  					object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

  					break;

  				case 'PointCloud':
  				case 'Points':

  					object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

  					break;

  				case 'Sprite':

  					object = new Sprite( getMaterial( data.material ) );

  					break;

  				case 'Group':

  					object = new Group();

  					break;

  				default:

  					object = new Object3D();

  			}

  			object.uuid = data.uuid;

  			if ( data.name !== undefined ) { object.name = data.name; }
  			if ( data.matrix !== undefined ) {

  				matrix.fromArray( data.matrix );
  				matrix.decompose( object.position, object.quaternion, object.scale );

  			} else {

  				if ( data.position !== undefined ) { object.position.fromArray( data.position ); }
  				if ( data.rotation !== undefined ) { object.rotation.fromArray( data.rotation ); }
  				if ( data.quaternion !== undefined ) { object.quaternion.fromArray( data.quaternion ); }
  				if ( data.scale !== undefined ) { object.scale.fromArray( data.scale ); }

  			}

  			if ( data.castShadow !== undefined ) { object.castShadow = data.castShadow; }
  			if ( data.receiveShadow !== undefined ) { object.receiveShadow = data.receiveShadow; }

  			if ( data.shadow ) {

  				if ( data.shadow.bias !== undefined ) { object.shadow.bias = data.shadow.bias; }
  				if ( data.shadow.radius !== undefined ) { object.shadow.radius = data.shadow.radius; }
  				if ( data.shadow.mapSize !== undefined ) { object.shadow.mapSize.fromArray( data.shadow.mapSize ); }
  				if ( data.shadow.camera !== undefined ) { object.shadow.camera = this.parseObject( data.shadow.camera ); }

  			}

  			if ( data.visible !== undefined ) { object.visible = data.visible; }
  			if ( data.userData !== undefined ) { object.userData = data.userData; }

  			if ( data.children !== undefined ) {

  				var children = data.children;

  				for ( var i = 0; i < children.length; i ++ ) {

  					object.add( this$1.parseObject( children[ i ], geometries, materials ) );

  				}

  			}

  			if ( data.type === 'LOD' ) {

  				var levels = data.levels;

  				for ( var l = 0; l < levels.length; l ++ ) {

  					var level = levels[ l ];
  					var child = object.getObjectByProperty( 'uuid', level.object );

  					if ( child !== undefined ) {

  						object.addLevel( child, level.distance );

  					}

  				}

  			}

  			return object;

  		};

  	}()

  } );

  var TEXTURE_MAPPING = {
  	UVMapping: UVMapping,
  	CubeReflectionMapping: CubeReflectionMapping,
  	CubeRefractionMapping: CubeRefractionMapping,
  	EquirectangularReflectionMapping: EquirectangularReflectionMapping,
  	EquirectangularRefractionMapping: EquirectangularRefractionMapping,
  	SphericalReflectionMapping: SphericalReflectionMapping,
  	CubeUVReflectionMapping: CubeUVReflectionMapping,
  	CubeUVRefractionMapping: CubeUVRefractionMapping
  };

  var TEXTURE_WRAPPING = {
  	RepeatWrapping: RepeatWrapping,
  	ClampToEdgeWrapping: ClampToEdgeWrapping,
  	MirroredRepeatWrapping: MirroredRepeatWrapping
  };

  var TEXTURE_FILTER = {
  	NearestFilter: NearestFilter,
  	NearestMipMapNearestFilter: NearestMipMapNearestFilter,
  	NearestMipMapLinearFilter: NearestMipMapLinearFilter,
  	LinearFilter: LinearFilter,
  	LinearMipMapNearestFilter: LinearMipMapNearestFilter,
  	LinearMipMapLinearFilter: LinearMipMapLinearFilter
  };

  /**
   * @author bhouston / http://clara.io
   * @author WestLangley / http://github.com/WestLangley
   *
   * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
   *
   * The poles (phi) are at the positive and negative y axis.
   * The equator starts at positive z.
   */

  function Spherical( radius, phi, theta ) {

  	this.radius = ( radius !== undefined ) ? radius : 1.0;
  	this.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole
  	this.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere

  	return this;

  }

  Object.assign( Spherical.prototype, {

  	set: function ( radius, phi, theta ) {

  		this.radius = radius;
  		this.phi = phi;
  		this.theta = theta;

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( other ) {

  		this.radius = other.radius;
  		this.phi = other.phi;
  		this.theta = other.theta;

  		return this;

  	},

  	// restrict phi to be betwee EPS and PI-EPS
  	makeSafe: function () {

  		var EPS = 0.000001;
  		this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

  		return this;

  	},

  	setFromVector3: function ( vec3 ) {

  		this.radius = vec3.length();

  		if ( this.radius === 0 ) {

  			this.theta = 0;
  			this.phi = 0;

  		} else {

  			this.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis
  			this.phi = Math.acos( _Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle

  		}

  		return this;

  	}

  } );

  /**
   * @author qiao / https://github.com/qiao
   * @author mrdoob / http://mrdoob.com
   * @author alteredq / http://alteredqualia.com/
   * @author WestLangley / http://github.com/WestLangley
   * @author erich666 / http://erichaines.com
   */

  // This set of controls performs orbiting, dollying (zooming), and panning.
  // Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
  //
  //    Orbit - left mouse / touch: one finger move
  //    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
  //    Pan - right mouse, or arrow keys / touch: three finger swipe

  var OrbitControls = function ( object, domElement ) {

  	this.object = object;

  	this.domElement = ( domElement !== undefined ) ? domElement : document;

  	// Set to false to disable this control
  	this.enabled = true;

  	// "target" sets the location of focus, where the object orbits around
  	this.target = new Vector3$1();

  	// How far you can dolly in and out ( PerspectiveCamera only )
  	this.minDistance = 0;
  	this.maxDistance = Infinity;

  	// How far you can zoom in and out ( OrthographicCamera only )
  	this.minZoom = 0;
  	this.maxZoom = Infinity;

  	// How far you can orbit vertically, upper and lower limits.
  	// Range is 0 to Math.PI radians.
  	this.minPolarAngle = 0; // radians
  	this.maxPolarAngle = Math.PI; // radians

  	// How far you can orbit horizontally, upper and lower limits.
  	// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
  	this.minAzimuthAngle = - Infinity; // radians
  	this.maxAzimuthAngle = Infinity; // radians

  	// Set to true to enable damping (inertia)
  	// If damping is enabled, you must call controls.update() in your animation loop
  	this.enableDamping = false;
  	this.dampingFactor = 0.25;

  	// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
  	// Set to false to disable zooming
  	this.enableZoom = true;
  	this.zoomSpeed = 1.0;

  	// Set to false to disable rotating
  	this.enableRotate = true;
  	this.rotateSpeed = 1.0;

  	// Set to false to disable panning
  	this.enablePan = true;
  	this.keyPanSpeed = 7.0;	// pixels moved per arrow key push

  	// Set to true to automatically rotate around the target
  	// If auto-rotate is enabled, you must call controls.update() in your animation loop
  	this.autoRotate = false;
  	this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

  	// Set to false to disable use of the keys
  	this.enableKeys = true;

  	// The four arrow keys
  	this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

  	// Mouse buttons
  	this.mouseButtons = { ORBIT: MOUSE.LEFT, ZOOM: MOUSE.MIDDLE, PAN: MOUSE.RIGHT };

  	// for reset
  	this.target0 = this.target.clone();
  	this.position0 = this.object.position.clone();
  	this.zoom0 = this.object.zoom;

  	//
  	// public methods
  	//

  	this.getPolarAngle = function () {

  		return spherical.phi;

  	};

  	this.getAzimuthalAngle = function () {

  		return spherical.theta;

  	};

  	this.saveState = function () {

  		scope.target0.copy( scope.target );
  		scope.position0.copy( scope.object.position );
  		scope.zoom0 = scope.object.zoom;

  	};

  	this.reset = function () {

  		scope.target.copy( scope.target0 );
  		scope.object.position.copy( scope.position0 );
  		scope.object.zoom = scope.zoom0;

  		scope.object.updateProjectionMatrix();
  		scope.dispatchEvent( changeEvent );

  		scope.update();

  		state = STATE.NONE;

  	};

  	// this method is exposed, but perhaps it would be better if we can make it private...
  	this.update = function () {

  		var offset = new Vector3$1();

  		// so camera.up is the orbit axis
  		var quat = new Quaternion().setFromUnitVectors( object.up, new Vector3$1( 0, 1, 0 ) );
  		var quatInverse = quat.clone().inverse();

  		var lastPosition = new Vector3$1();
  		var lastQuaternion = new Quaternion();

  		return function update() {

  			var position = scope.object.position;

  			offset.copy( position ).sub( scope.target );

  			// rotate offset to "y-axis-is-up" space
  			offset.applyQuaternion( quat );

  			// angle from z-axis around y-axis
  			spherical.setFromVector3( offset );

  			if ( scope.autoRotate && state === STATE.NONE ) {

  				rotateLeft( getAutoRotationAngle() );

  			}

  			spherical.theta += sphericalDelta.theta;
  			spherical.phi += sphericalDelta.phi;

  			// restrict theta to be between desired limits
  			spherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );

  			// restrict phi to be between desired limits
  			spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );

  			spherical.makeSafe();


  			spherical.radius *= scale;

  			// restrict radius to be between desired limits
  			spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );

  			// move target to panned location
  			scope.target.add( panOffset );

  			offset.setFromSpherical( spherical );

  			// rotate offset back to "camera-up-vector-is-up" space
  			offset.applyQuaternion( quatInverse );

  			position.copy( scope.target ).add( offset );

  			scope.object.lookAt( scope.target );

  			if ( scope.enableDamping === true ) {

  				sphericalDelta.theta *= ( 1 - scope.dampingFactor );
  				sphericalDelta.phi *= ( 1 - scope.dampingFactor );

  			} else {

  				sphericalDelta.set( 0, 0, 0 );

  			}

  			scale = 1;
  			panOffset.set( 0, 0, 0 );

  			// update condition is:
  			// min(camera displacement, camera rotation in radians)^2 > EPS
  			// using small-angle approximation cos(x/2) = 1 - x^2 / 8

  			if ( zoomChanged ||
  				lastPosition.distanceToSquared( scope.object.position ) > EPS ||
  				8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {

  				scope.dispatchEvent( changeEvent );

  				lastPosition.copy( scope.object.position );
  				lastQuaternion.copy( scope.object.quaternion );
  				zoomChanged = false;

  				return true;

  			}

  			return false;

  		};

  	}();

  	this.dispose = function () {

  		scope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );
  		scope.domElement.removeEventListener( 'mousedown', onMouseDown, false );
  		scope.domElement.removeEventListener( 'wheel', onMouseWheel, false );

  		scope.domElement.removeEventListener( 'touchstart', onTouchStart, false );
  		scope.domElement.removeEventListener( 'touchend', onTouchEnd, false );
  		scope.domElement.removeEventListener( 'touchmove', onTouchMove, false );

  		document.removeEventListener( 'mousemove', onMouseMove, false );
  		document.removeEventListener( 'mouseup', onMouseUp, false );

  		window.removeEventListener( 'keydown', onKeyDown, false );

  		//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

  	};

  	//
  	// internals
  	//

  	var scope = this;

  	var changeEvent = { type: 'change' };
  	var startEvent = { type: 'start' };
  	var endEvent = { type: 'end' };

  	var STATE = { NONE: - 1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 };

  	var state = STATE.NONE;

  	var EPS = 0.000001;

  	// current position in spherical coordinates
  	var spherical = new Spherical();
  	var sphericalDelta = new Spherical();

  	var scale = 1;
  	var panOffset = new Vector3$1();
  	var zoomChanged = false;

  	var rotateStart = new Vector2();
  	var rotateEnd = new Vector2();
  	var rotateDelta = new Vector2();

  	var panStart = new Vector2();
  	var panEnd = new Vector2();
  	var panDelta = new Vector2();

  	var dollyStart = new Vector2();
  	var dollyEnd = new Vector2();
  	var dollyDelta = new Vector2();

  	function getAutoRotationAngle() {

  		return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

  	}

  	function getZoomScale() {

  		return Math.pow( 0.95, scope.zoomSpeed );

  	}

  	function rotateLeft( angle ) {

  		sphericalDelta.theta -= angle;

  	}

  	function rotateUp( angle ) {

  		sphericalDelta.phi -= angle;

  	}

  	var panLeft = function () {

  		var v = new Vector3$1();

  		return function panLeft( distance, objectMatrix ) {

  			v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
  			v.multiplyScalar( - distance );

  			panOffset.add( v );

  		};

  	}();

  	var panUp = function () {

  		var v = new Vector3$1();

  		return function panUp( distance, objectMatrix ) {

  			v.setFromMatrixColumn( objectMatrix, 1 ); // get Y column of objectMatrix
  			v.multiplyScalar( distance );

  			panOffset.add( v );

  		};

  	}();

  	// deltaX and deltaY are in pixels; right and down are positive
  	var pan = function () {

  		var offset = new Vector3$1();

  		return function pan( deltaX, deltaY ) {

  			var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

  			if ( scope.object instanceof PerspectiveCamera ) {

  				// perspective
  				var position = scope.object.position;
  				offset.copy( position ).sub( scope.target );
  				var targetDistance = offset.length();

  				// half of the fov is center to top of screen
  				targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

  				// we actually don't use screenWidth, since perspective camera is fixed to screen height
  				panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
  				panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );

  			} else if ( scope.object instanceof OrthographicCamera ) {

  				// orthographic
  				panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
  				panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );

  			} else {

  				// camera neither orthographic nor perspective
  				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
  				scope.enablePan = false;

  			}

  		};

  	}();

  	function dollyIn( dollyScale ) {

  		if ( scope.object instanceof PerspectiveCamera ) {

  			scale /= dollyScale;

  		} else if ( scope.object instanceof OrthographicCamera ) {

  			scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );
  			scope.object.updateProjectionMatrix();
  			zoomChanged = true;

  		} else {

  			console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
  			scope.enableZoom = false;

  		}

  	}

  	function dollyOut( dollyScale ) {

  		if ( scope.object instanceof PerspectiveCamera ) {

  			scale *= dollyScale;

  		} else if ( scope.object instanceof OrthographicCamera ) {

  			scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );
  			scope.object.updateProjectionMatrix();
  			zoomChanged = true;

  		} else {

  			console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
  			scope.enableZoom = false;

  		}

  	}

  	//
  	// event callbacks - update the object state
  	//

  	function handleMouseDownRotate( event ) {

  		//console.log( 'handleMouseDownRotate' );

  		rotateStart.set( event.clientX, event.clientY );

  	}

  	function handleMouseDownDolly( event ) {

  		//console.log( 'handleMouseDownDolly' );

  		dollyStart.set( event.clientX, event.clientY );

  	}

  	function handleMouseDownPan( event ) {

  		//console.log( 'handleMouseDownPan' );

  		panStart.set( event.clientX, event.clientY );

  	}

  	function handleMouseMoveRotate( event ) {

  		//console.log( 'handleMouseMoveRotate' );

  		rotateEnd.set( event.clientX, event.clientY );
  		rotateDelta.subVectors( rotateEnd, rotateStart );

  		var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

  		// rotating across whole screen goes 360 degrees around
  		rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );

  		// rotating up and down along whole screen attempts to go 360, but limited to 180
  		rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

  		rotateStart.copy( rotateEnd );
  //[TV - PATCH - 28/11/2016] Emit rotate event
  scope.dispatchEvent( { type: 'rotate' } );

  		scope.update();

  	}

  	function handleMouseMoveDolly( event ) {

  		//console.log( 'handleMouseMoveDolly' );

  		dollyEnd.set( event.clientX, event.clientY );

  		dollyDelta.subVectors( dollyEnd, dollyStart );

  		if ( dollyDelta.y > 0 ) {

  			dollyIn( getZoomScale() );

  		} else if ( dollyDelta.y < 0 ) {

  			dollyOut( getZoomScale() );

  		}

  		dollyStart.copy( dollyEnd );
  //[TV - PATCH - 28/11/2016] Emit zoom event
  scope.dispatchEvent( { type: 'zoom' } );

  		scope.update();

  	}

  	function handleMouseMovePan( event ) {

  		//console.log( 'handleMouseMovePan' );

  		panEnd.set( event.clientX, event.clientY );

  		panDelta.subVectors( panEnd, panStart );

  		pan( panDelta.x, panDelta.y );

  		panStart.copy( panEnd );
  //[TV - PATCH - 28/11/2016] Emit pan event
  scope.dispatchEvent( { type: 'pan' } );

  		scope.update();

  	}

  	function handleMouseWheel( event ) {

  		// console.log( 'handleMouseWheel' );

  		if ( event.deltaY < 0 ) {

  			dollyOut( getZoomScale() );

  		} else if ( event.deltaY > 0 ) {

  			dollyIn( getZoomScale() );

  		}

  		scope.update();

  	}

  	function handleKeyDown( event ) {

  		//console.log( 'handleKeyDown' );

  		switch ( event.keyCode ) {

  			case scope.keys.UP:
  				pan( 0, scope.keyPanSpeed );
  				scope.update();
  				break;

  			case scope.keys.BOTTOM:
  				pan( 0, - scope.keyPanSpeed );
  				scope.update();
  				break;

  			case scope.keys.LEFT:
  				pan( scope.keyPanSpeed, 0 );
  				scope.update();
  				break;

  			case scope.keys.RIGHT:
  				pan( - scope.keyPanSpeed, 0 );
  				scope.update();
  				break;

  		}

  	}

  	function handleTouchStartRotate( event ) {

  		//console.log( 'handleTouchStartRotate' );

  		rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

  	}

  	function handleTouchStartDolly( event ) {

  		//console.log( 'handleTouchStartDolly' );

  		var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
  		var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

  		var distance = Math.sqrt( dx * dx + dy * dy );

  		dollyStart.set( 0, distance );

  	}

  	function handleTouchStartPan( event ) {

  		//console.log( 'handleTouchStartPan' );

  		panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

  	}

  	function handleTouchMoveRotate( event ) {

  		//console.log( 'handleTouchMoveRotate' );

  		rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
  		rotateDelta.subVectors( rotateEnd, rotateStart );

  		var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

  		// rotating across whole screen goes 360 degrees around
  		rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );

  		// rotating up and down along whole screen attempts to go 360, but limited to 180
  		rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

  		rotateStart.copy( rotateEnd );
  //[TV - PATCH - 28/11/2016] Emit rotate event
  scope.dispatchEvent( { type: 'rotate' } );

  		scope.update();

  	}

  	function handleTouchMoveDolly( event ) {

  		//console.log( 'handleTouchMoveDolly' );

  		var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
  		var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

  		var distance = Math.sqrt( dx * dx + dy * dy );

  		dollyEnd.set( 0, distance );

  		dollyDelta.subVectors( dollyEnd, dollyStart );

  		if ( dollyDelta.y > 0 ) {

  			dollyOut( getZoomScale() );

  		} else if ( dollyDelta.y < 0 ) {

  			dollyIn( getZoomScale() );

  		}

  		dollyStart.copy( dollyEnd );
  //[TV - PATCH - 28/11/2016] Emit zoom event
  scope.dispatchEvent( { type: 'zoom' } );

  		scope.update();

  	}

  	function handleTouchMovePan( event ) {

  		//console.log( 'handleTouchMovePan' );

  		panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

  		panDelta.subVectors( panEnd, panStart );

  		pan( panDelta.x, panDelta.y );

  		panStart.copy( panEnd );
  //[TV - PATCH - 28/11/2016] Emit pan event
  scope.dispatchEvent( { type: 'pan' } );

  		scope.update();

  	}

  	function onMouseDown( event ) {

  		if ( scope.enabled === false ) { return; }

  		event.preventDefault();

  		switch ( event.button ) {

  			case scope.mouseButtons.ORBIT:

  				if ( scope.enableRotate === false ) { return; }

  				handleMouseDownRotate( event );

  				state = STATE.ROTATE;

  				break;

  			case scope.mouseButtons.ZOOM:

  				if ( scope.enableZoom === false ) { return; }

  				handleMouseDownDolly( event );

  				state = STATE.DOLLY;

  				break;

  			case scope.mouseButtons.PAN:

  				if ( scope.enablePan === false ) { return; }

  				handleMouseDownPan( event );

  				state = STATE.PAN;

  				break;

  		}

  		if ( state !== STATE.NONE ) {

  			document.addEventListener( 'mousemove', onMouseMove, false );
  			document.addEventListener( 'mouseup', onMouseUp, false );

  			scope.dispatchEvent( startEvent );

  		}

  	}

  	function onMouseMove( event ) {

  		if ( scope.enabled === false ) { return; }

  		event.preventDefault();

  		switch ( state ) {

  			case STATE.ROTATE:

  				if ( scope.enableRotate === false ) { return; }

  				handleMouseMoveRotate( event );

  				break;

  			case STATE.DOLLY:

  				if ( scope.enableZoom === false ) { return; }

  				handleMouseMoveDolly( event );

  				break;

  			case STATE.PAN:

  				if ( scope.enablePan === false ) { return; }

  				handleMouseMovePan( event );

  				break;

  		}

  	}

  	function onMouseUp( event ) {

  		if ( scope.enabled === false ) { return; }

  		document.removeEventListener( 'mousemove', onMouseMove, false );
  		document.removeEventListener( 'mouseup', onMouseUp, false );

  		scope.dispatchEvent( endEvent );

  		state = STATE.NONE;

  	}

  	function onMouseWheel( event ) {

  		if ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) { return; }

  		event.preventDefault();
  		event.stopPropagation();

  		handleMouseWheel( event );

  		scope.dispatchEvent( startEvent ); // not sure why these are here...
  		scope.dispatchEvent( endEvent );

  	}

  	function onKeyDown( event ) {

  		if ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) { return; }

  		handleKeyDown( event );

  	}

  	function onTouchStart( event ) {

  		if ( scope.enabled === false ) { return; }

  		switch ( event.touches.length ) {

  			case 1:	// one-fingered touch: rotate

  				if ( scope.enableRotate === false ) { return; }

  				handleTouchStartRotate( event );

  				state = STATE.TOUCH_ROTATE;

  				break;

  			case 2:	// two-fingered touch: dolly

  				if ( scope.enableZoom === false ) { return; }

  				handleTouchStartDolly( event );

  				state = STATE.TOUCH_DOLLY;

  				break;

  			case 3: // three-fingered touch: pan

  				if ( scope.enablePan === false ) { return; }

  				handleTouchStartPan( event );

  				state = STATE.TOUCH_PAN;

  				break;

  			default:

  				state = STATE.NONE;

  		}

  		if ( state !== STATE.NONE ) {

  			scope.dispatchEvent( startEvent );

  		}

  	}

  	function onTouchMove( event ) {

  		if ( scope.enabled === false ) { return; }

  		event.preventDefault();
  		event.stopPropagation();

  		switch ( event.touches.length ) {

  			case 1: // one-fingered touch: rotate

  				if ( scope.enableRotate === false ) { return; }
  				if ( state !== STATE.TOUCH_ROTATE ) { return; } // is this needed?...

  				handleTouchMoveRotate( event );

  				break;

  			case 2: // two-fingered touch: dolly

  				if ( scope.enableZoom === false ) { return; }
  				if ( state !== STATE.TOUCH_DOLLY ) { return; } // is this needed?...

  				handleTouchMoveDolly( event );

  				break;

  			case 3: // three-fingered touch: pan

  				if ( scope.enablePan === false ) { return; }
  				if ( state !== STATE.TOUCH_PAN ) { return; } // is this needed?...

  				handleTouchMovePan( event );

  				break;

  			default:

  				state = STATE.NONE;

  		}

  	}

  	function onTouchEnd( event ) {

  		if ( scope.enabled === false ) { return; }

  		scope.dispatchEvent( endEvent );

  		state = STATE.NONE;

  	}

  	function onContextMenu( event ) {

  		if ( scope.enabled === false ) { return; }

  		event.preventDefault();

  	}

  	//

  	scope.domElement.addEventListener( 'contextmenu', onContextMenu, false );

  	scope.domElement.addEventListener( 'mousedown', onMouseDown, false );
  	scope.domElement.addEventListener( 'wheel', onMouseWheel, false );

  	scope.domElement.addEventListener( 'touchstart', onTouchStart, false );
  	scope.domElement.addEventListener( 'touchend', onTouchEnd, false );
  	scope.domElement.addEventListener( 'touchmove', onTouchMove, false );

  	window.addEventListener( 'keydown', onKeyDown, false );

  	// force an update at start

  	this.update();

  };

  OrbitControls.prototype = Object.create( EventDispatcher.prototype );
  OrbitControls.prototype.constructor = OrbitControls;

  Object.defineProperties( OrbitControls.prototype, {

  	center: {

  		get: function () {

  			console.warn( 'OrbitControls: .center has been renamed to .target' );
  			return this.target;

  		}

  	},

  	// backward compatibility

  	noZoom: {

  		get: function () {

  			console.warn( 'OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );
  			return ! this.enableZoom;

  		},

  		set: function ( value ) {

  			console.warn( 'OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );
  			this.enableZoom = ! value;

  		}

  	},

  	noRotate: {

  		get: function () {

  			console.warn( 'OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );
  			return ! this.enableRotate;

  		},

  		set: function ( value ) {

  			console.warn( 'OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );
  			this.enableRotate = ! value;

  		}

  	},

  	noPan: {

  		get: function () {

  			console.warn( 'OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );
  			return ! this.enablePan;

  		},

  		set: function ( value ) {

  			console.warn( 'OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );
  			this.enablePan = ! value;

  		}

  	},

  	noKeys: {

  		get: function () {

  			console.warn( 'OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );
  			return ! this.enableKeys;

  		},

  		set: function ( value ) {

  			console.warn( 'OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );
  			this.enableKeys = ! value;

  		}

  	},

  	staticMoving: {

  		get: function () {

  			console.warn( 'OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );
  			return ! this.enableDamping;

  		},

  		set: function ( value ) {

  			console.warn( 'OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );
  			this.enableDamping = ! value;

  		}

  	},

  	dynamicDampingFactor: {

  		get: function () {

  			console.warn( 'OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );
  			return this.dampingFactor;

  		},

  		set: function ( value ) {

  			console.warn( 'OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );
  			this.dampingFactor = value;

  		}

  	}

  } );

  /**
   * @author [Tristan Valcke]{@link https://github.com/Itee}
   * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
   */

  /**
   * Store the platform endianness to make correct parsing of buffer
   *
   * from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView#Endianness
   */
  var endianness = (function () {

      return false

      //    var buffer = new ArrayBuffer( 2 );
      //    new DataView( buffer ).setInt16( 0, 256, true );
      //
      //    return new Int16Array( buffer )[ 0 ] === 256;

  })();

  /**
   * The MeshManager allow to automate the database call to get/update/delete
   * mesh data.
   *
   * It manage the mesh resolution in function of the camera distance.
   *
   * @param viewport - The viewport to populate with meshes
   * @constructor
   */
  function MeshManager ( viewport ) {

      if ( !viewport ) { throw new Error( 'Unable to create mesh manager for null or undefined viewport !' ) }

      this._viewport = viewport;

      this._orchestrator = singletonInstance;

      this._objectLoader      = new ObjectLoader();
      this._textureLoader     = new TextureLoader();
      this._meshResolutionMap = new Map();
      this._resolutionMap     = [
          {
              min:   15,
              max:   Infinity,
              value: 0
          },
          {
              min:   5,
              max:   15,
              value: 256
          },
          {
              min:   0,
              max:   5,
              value: 4096
          }
      ];

      this._defaultResolution = 0;
      this._meshesGroup       = new Group();
      this._meshesGroup.name  = 'MeshesGroup';
      this._underRequest      = false;

      //    this.allowGround = ( allowGround !== undefined && allowGround !== null ) ? allowGround : true
      //    if ( this.allowGround ) {
      //
      //        this._groundLayer      = new Group()
      //        this._groundLayer.name = 'GroundLayer'
      //        this._meshesGroup.add( this._groundLayer )
      //
      //    }
      //
      //    this._undergroundLayer = new Group()
      //    this._undergroundLayer.name = 'UndergroundLayer'
      //    this._meshesGroup.add( this._undergroundLayer )

      this._viewport.scene.add( this._meshesGroup );

      this._geometriesCache = {};
      this._materialsCache  = {};

  }

  Object.assign( MeshManager.prototype, {

      setResolutionMap: function setResolutionMap ( resolutionMap ) {
          this._resolutionMap = resolutionMap;
      },

      setDefaultResoltion: function setDefaultResoltion ( resolution ) {

          this._defaultResolution = resolution;

      },

      getMeshWithId: function getMeshWithId ( meshId, callback ) {

          var self = this;

          self.requestServer( 'GET', ("/3d/objects/" + meshId), null, onLoad, onProgress, onError );

          //        self.requestServer( 'POST', '../../meshes/' + meshId, null, onLoad, onProgress, onError, 'arraybuffer' )

          function onLoad ( loadEvent ) {

              if ( !self.statusOk( loadEvent.target.status ) ) {
                  return
              }

              var data = ( loadEvent.target.response ) ? JSON.parse( loadEvent.target.response ) : null;
              if ( !data ) {
                  console.error( 'MeshManager: No data receive !' );
                  return
              }

              self.convertJsonToObject3D( data, function (child) {

                  self.retrieveChildrenFor( child, data.children );

                  callback( child );

              } );

          }

          //        function onLoad ( loadEvent ) {
          //
          //            var object = ( loadEvent.target.response ) ? loadEvent.target.response : new Uint8Array()
          //            //            var object = ( loadEvent.target.response ) ? JSON.parse( loadEvent.target.response ) : {}
          //
          //            if ( loadEvent.target.status !== 200 ) {
          //
          //                console.error( object )
          //                return
          //
          //            }
          //
          //            var meshData = self._meshResolutionMap.get( meshId )
          //
          //            self.createMeshFromBuffer( object, meshData )
          //
          //        }

          function onProgress ( progressEvent ) {

              var progressValue = Math.ceil( (progressEvent.loaded / progressEvent.total ) * 100 ) + '%';
              console.log( "Mesh progress: " + progressValue );

          }

          function onError ( errorEvent ) {

              alert( "Une erreur " + errorEvent.target.status + " s'est produite au cours de la rception du document." );

          }

      },

      createMeshFromBuffer: function createMeshFromBuffer ( arraybuffer ) {

          if ( !arraybuffer ) {
              console.error( 'Unable to create mesh from empty, null or undefined buffer !' );
              return
          }

          var ONE_BYTE  = 1;
          var FOUR_BYTE = 4;

          var dataView   = new DataView( arraybuffer );
          var dataOffset = 0;

          // Extract id from buffer
          var ID_BYTES_LENGTH = 24;
          var id              = "";
          for ( var i = 0 ; i < ID_BYTES_LENGTH ; i++ ) {
              id += String.fromCharCode( dataView.getUint8( getAndUpdateOffsetBy( ONE_BYTE ), endianness ) );
          }
          var meshData = this._meshResolutionMap.get( id );

          // Header In
          var header = {
              position:         {
                  x: dataView.getFloat32( getAndUpdateOffsetBy( FOUR_BYTE ), endianness ),
                  y: dataView.getFloat32( getAndUpdateOffsetBy( FOUR_BYTE ), endianness ),
                  z: dataView.getFloat32( getAndUpdateOffsetBy( FOUR_BYTE ), endianness )
              },
              numberOfTexture:  dataView.getUint32( getAndUpdateOffsetBy( FOUR_BYTE ), endianness ),
              numberOfPosition: dataView.getUint32( getAndUpdateOffsetBy( FOUR_BYTE ), endianness ),
              numberOfNormal:   dataView.getUint32( getAndUpdateOffsetBy( FOUR_BYTE ), endianness ),
              numberOfUv:       dataView.getUint32( getAndUpdateOffsetBy( FOUR_BYTE ), endianness )
          };

          // Data In

          // Texture name in
          var texturesName = [];
          for ( var i = 0 ; i < header.numberOfTexture ; i++ ) {

              var textureName       = '';
              var textureNameLength = dataView.getUint8( getAndUpdateOffsetBy( ONE_BYTE ), endianness );

              for ( var j = 0 ; j < textureNameLength ; j++ ) {
                  textureName += String.fromCharCode( dataView.getUint8( getAndUpdateOffsetBy( ONE_BYTE ), endianness ) );
              }

              texturesName.push( textureName );

          }

          // Positions in
          var positions = new Float32Array( header.numberOfPosition );
          for ( var pi = 0 ; pi < header.numberOfPosition ; pi++ ) {
              positions[ pi ] = dataView.getFloat32( getAndUpdateOffsetBy( FOUR_BYTE ), endianness );
          }

          // Normals in
          var normals = new Float32Array( header.numberOfNormal );
          for ( var ni = 0 ; ni < header.numberOfNormal ; ni++ ) {
              normals[ ni ] = dataView.getFloat32( getAndUpdateOffsetBy( FOUR_BYTE ), endianness );
          }

          // UVs in
          var uvs = new Float32Array( header.numberOfUv );
          for ( var uvi = 0 ; uvi < header.numberOfUv ; uvi++ ) {
              uvs[ uvi ] = dataView.getFloat32( getAndUpdateOffsetBy( FOUR_BYTE ), endianness );
          }

          // Create Mesh from data

          var materials = [];
          var material  = undefined;
          if ( header.numberOfTexture > 0 ) {

              for ( var i = 0 ; i < header.numberOfTexture ; i++ ) {

                  if ( meshData.resolution === 0 ) {
                      console.error( 'meshData.resolution for texture load === 0' );
                  }

                  material     = new MeshPhongMaterial();
                  material.map = new TextureLoader().load( '../resources/textures/' + meshData.resolution + '/' + texturesName[ i ] );

                  materials.push( material );

              }

          } else {

              material = new MeshPhongMaterial();
              materials.push( material );

          }

          var geometry = new BufferGeometry();
          geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );
          //        geometry.addAttribute('normal', new BufferAttribute(normals, 3))
          geometry.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

          var mesh = undefined;
          if ( materials.length > 1 ) {

              mesh = new Mesh( geometry, materials );
              // Todo: need to compute BugfferGeometry groups to assign correctly material to buffer geometry !!!

          } else {

              mesh = new Mesh( geometry, materials[ 0 ] );

          }

          mesh.position.copy( header.position );

          // Update meshData
          meshData.textureName = textureName;
          meshData.coordinates = header.position;
          meshData.uuid        = mesh.uuid;

          if ( meshData.layer === 0 ) {

              this._undergroundLayer.add( mesh );

          } else if ( meshData.layer === 1 ) {

              if ( this.allowGround ) { this._groundLayer.add( mesh ); }

          } else {

              console.error( 'Unknown layer for mesh add to top level group !' );
              this._meshesGroup.add( mesh );

          }

          function getAndUpdateOffsetBy ( increment ) {

              var previousDataOffset = dataOffset;
              dataOffset += increment;

              return previousDataOffset;

          }

      },

      createMeshFromJSON: function createMeshFromJSON ( jsonObject ) {
          var this$1 = this;


          var meshData = this._meshResolutionMap.get( jsonObject._id );

          // Check for texture if exist and preload it
          var textures = jsonObject.data.textures;
          if ( jsonObject.data.textures ) {

              // Check if image for texture exist
              if ( !jsonObject.data.images ) {
                  jsonObject.data.images = [];
              }

              // Process texture
              var texture     = undefined;
              var textureName = undefined;
              for ( var textureIndex = 0, numberOfTextures = jsonObject.data.textures.length ; textureIndex < numberOfTextures ; textureIndex++ ) {

                  texture     = jsonObject.data.textures[ textureIndex ];
                  textureName = texture.name;

                  // Update mesh data with texture
                  meshData.textureName = textureName;

                  var url = "../resources/textures/" + this$1._defaultResolution + '/' + textureName;
                  jsonObject.data.images.push( {
                      uuid: textureName,
                      url:  url
                  } );

                  texture.image = textureName;

              }

          }

          // Parse json object
          var object = this._objectLoader.parse( jsonObject.data );
          var child  = object.children[ 0 ];

          child.rotation.x -= Math.PI / 2;
          child.geometry.computeBoundingSphere();

          var boundingSphereCenter = child.geometry.boundingSphere.center;
          meshData.coordinates     = {
              x: boundingSphereCenter.x,
              y: boundingSphereCenter.z,
              z: -(boundingSphereCenter.y)
          };
          meshData.uuid            = child.uuid;

          this._meshesGroup.add( child );

      },

      getMeshesFromIds: function getMeshesFromIds ( meshesIds ) {

          var self = this;

          var MAX_SIMULTANEOUSE_REQUEST = 6;
          var numberOfMeshes            = meshesIds.length;
          var numberOfMeshesPerRequest  = Math.floor( numberOfMeshes / MAX_SIMULTANEOUSE_REQUEST );
          var numberOfRequestToSend     = ( numberOfMeshesPerRequest > 0 ) ? MAX_SIMULTANEOUSE_REQUEST : 1;
          var numberOfReturnRequest     = 0;

          var idsSplit = [];
          var formData = undefined;
          for ( var requestIndex = 1 ; requestIndex <= numberOfRequestToSend ; requestIndex++ ) {

              // Got the rest on last request
              if ( requestIndex === numberOfRequestToSend ) {
                  idsSplit = meshesIds;
              } else {
                  idsSplit = meshesIds.splice( meshesIds.length - numberOfMeshesPerRequest, numberOfMeshesPerRequest );
              }

              formData = new FormData();
              formData.append( 'ids', JSON.stringify( idsSplit ) );

              self.requestServer( 'POST', '../../meshes/all', formData, onLoad, onProgress, onError, 'arraybuffer' );

          }

          function checkEndOfRequests () {

              numberOfReturnRequest++;

              if ( numberOfReturnRequest === numberOfRequestToSend ) {
                  self._underRequest = false;
              }

          }

          function onLoad ( loadEvent ) {

              var binaryMeshes = ( loadEvent.target.response ) ? loadEvent.target.response : new Uint8Array();

              if ( loadEvent.target.status !== 200 ) {

                  var jsonMessage = convertArrayBufferToUTF8String( binaryMeshes );
                  var message     = JSON.parse( jsonMessage );
                  console.error( message );
                  return

              }

              var dataView = new DataView( binaryMeshes );

              // Header In
              var numberOfBuffers = dataView.getUint32( 0 );
              if ( numberOfBuffers === 0 ) { return }
              //            console.log( 'numberOfBuffers to extract: ' + numberOfBuffers )

              var numberOfBuffersBytesLength = numberOfBuffers * 4; // UInt32
              var dataOffset                 = 4 + numberOfBuffersBytesLength;
              var bufferLength               = 0;
              var byteArray                  = undefined;
              for ( var bufferIndex = 4 ; bufferIndex <= numberOfBuffersBytesLength ; bufferIndex += 4 ) {

                  bufferLength = dataView.getUint32( bufferIndex );

                  //                console.log('header: ' + bufferLength )
                  byteArray = binaryMeshes.slice( dataOffset, dataOffset + bufferLength );
                  self.createMeshFromBuffer( byteArray );

                  dataOffset += bufferLength;

              }

              checkEndOfRequests();

          }

          function onProgress ( progressEvent ) {

              var progressValue = Math.ceil( (progressEvent.loaded / progressEvent.total ) * 100 ) + '%';
              //            console.log( "progressValue: " + progressValue );

          }

          function onError ( errorEvent ) {

              alert( "Une erreur " + errorEvent.target.status + " s'est produite au cours de la rception du document." );
              checkEndOfRequests();

          }

          function convertArrayBufferToUTF8String ( arrayBuffer ) {

              return String.fromCharCode.apply( null, new Uint8Array( arrayBuffer ) )

          }

      },

      getMeshes: function getMeshes ( onSuccess ) {

          var self = this;

          self.requestServer( 'POST', '/worldcells/meshes/', null, onLoad, onProgress, onError );

          function onLoad ( loadEvent ) {

              var meshes = ( loadEvent.target.response ) ? JSON.parse( loadEvent.target.response ) : {};

              //Todo: manage all status !!!
              if ( loadEvent.target.status === 204 || !meshes ) {

                  console.warn( 'Unable to retrieve meshes...' );
                  return

              } else if ( loadEvent.target.status !== 200 ) {

                  console.error( meshes );
                  return

              } else {

                  console.log( 'Get ' + meshes.length + ' meshes infos from database.' );

              }

              self.createResolutionMap( meshes );

              onSuccess();

          }

          function onProgress ( progressEvent ) {

              var progressValue = Math.ceil( (progressEvent.loaded / progressEvent.total ) * 100 ) + '%';
              //            console.log( "progressValue: " + progressValue );

          }

          function onError ( errorEvent ) {

              alert( "Une erreur " + errorEvent.target.status + " s'est produite au cours de la rception du document." );

          }

      },

      statusOk: function statusOk ( status ) {

          var statusOk = false;

          if ( status === 204 ) {

              console.warn( 'Unable to retrieve data...' );

          } else if ( status !== 200 ) {

              console.error( 'An error occurs when retrieve data from database !!!' );

          } else {

              //            console.log( 'Get data from database.' )
              statusOk = true;

          }

          return statusOk

      },

      getScenes: function getScenes ( onSuccess ) {

          var self = this;

          self.requestServer( 'POST', '/scenes', null, onLoadScene, onProgressScene, onErrorScene );

          function onLoadScene ( loadEvent ) {

              if ( !self.statusOk( loadEvent.target.status ) ) {
                  return
              }

              ///////////////////////////////

              var data = ( loadEvent.target.response ) ? JSON.parse( loadEvent.target.response ) : null;
              if ( !data ) {
                  console.error( 'MeshManager: No data receive !' );
                  return
              }

              var childrenIds = [];
              for ( var sceneIndex = 0, numberOfScenes = data.length ; sceneIndex < numberOfScenes ; ++sceneIndex ) {

                  var scene    = data[ sceneIndex ];
                  var children = scene.children;
                  if ( children ) {
                      Array.prototype.push.apply( childrenIds, children );
                  } else {
                      console.error( ("No children in " + (scene.name)) );
                  }

              }

              self.retrieveChildrenFor( self._viewport.scene, childrenIds );

              ///////////////////////////////

              onSuccess();

          }

          function onProgressScene ( progressEvent ) {

              var progressValue = Math.ceil( (progressEvent.loaded / progressEvent.total ) * 100 );
              console.log( ("Load scene: " + progressValue + "%") );

          }

          function onErrorScene ( errorEvent ) {

              console.error( errorEvent );

          }

      },

      getSceneWithId: function getScenes ( sceneId, onSuccess ) {

          var self = this;

          self.requestServer( 'POST', ("/scenes/" + sceneId), null, onLoadScene, onProgressScene, onErrorScene );

          function onLoadScene ( loadEvent ) {

              if ( !self.statusOk( loadEvent.target.status ) ) {
                  return
              }

              ///////////////////////////////

              var scenes = ( loadEvent.target.response ) ? JSON.parse( loadEvent.target.response ) : null;
              if ( !scenes ) {
                  console.error( 'MeshManager: No scene receive !' );
                  return
              }

              var childrenIds = [];
              for ( var sceneIndex = 0, numberOfScenes = scenes.length ; sceneIndex < numberOfScenes ; ++sceneIndex ) {

                  var scene    = scenes[ sceneIndex ];
                  var children = scene.children;
                  if ( children ) {
                      Array.prototype.push.apply( childrenIds, children );
                  } else {
                      console.error( ("No children in " + (scene.name)) );
                  }

              }

              self.retrieveChildrenFor( self._viewport.scene, childrenIds );

  //            const children  = scene.children
  //            let childrenIds = []
  //            if ( children ) {
  //                Array.prototype.push.apply( childrenIds, children )
  //            } else {
  //                console.error( `No children in ${scene.name}` )
  //            }
  //            self.retrieveChildrenFor( self._viewport.scene, childrenIds )

              ///////////////////////////////

              onSuccess();

          }

          function onProgressScene ( progressEvent ) {

              var progressValue = Math.ceil( (progressEvent.loaded / progressEvent.total ) * 100 );
              console.log( ("Load scene: " + progressValue + "%") );

          }

          function onErrorScene ( errorEvent ) {

              console.error( errorEvent );

          }

      },

      retrieveChildrenFor: function retrieveChildrenFor ( object, childrenIds ) {

          var self      = this;
          var bunchSize = 25;

          var idBunch = [];
          for ( var childrenIndex = 0, numberOfChilds = childrenIds.length ; childrenIndex < numberOfChilds ; ++childrenIndex ) {

              idBunch.push( childrenIds[ childrenIndex ] );

              if ( idBunch.length < bunchSize ) { continue }

              self.requestServer( 'POST', '/objects', JSON.stringify( idBunch ), onLoadChildren, onProgressChildren, onErrorChildren );
  //            self.requestServer( 'POST', '/objects', JSON.stringify( { ids: idBunch } ), onLoadChildren, onProgressChildren, onErrorChildren )

              idBunch = [];
          }

          function onLoadChildren ( loadEvent ) {

              if ( !self.statusOk( loadEvent.target.status ) ) {
                  return
              }

              var data = ( loadEvent.target.response ) ? JSON.parse( loadEvent.target.response ) : null;
              if ( !data ) {
                  console.error( 'MeshManager: No data receive !' );
                  return
              }

              if ( Array.isArray( data ) ) {

                  var element = undefined;
                  for ( var dataIndex = 0, numberOfDatas = data.length ; dataIndex < numberOfDatas ; dataIndex++ ) {

                      element = data[ dataIndex ];
                      processChild( object, element );

                  }

              } else {

                  processChild( object, data );

              }

          }

          function onProgressChildren ( progressEvent ) {

              //            const progressValue = Math.ceil( (progressEvent.loaded / progressEvent.total ) * 100 )
              //            console.log( `Load children: ${progressValue}%` )

          }

          function onErrorChildren ( errorEvent ) {

              console.error( errorEvent );

          }

          function processChild ( object, data ) {

              self.convertJsonToObject3D( data, function (child) {

                  self.retrieveChildrenFor( child, data.children );

                  child.parent = null;

                  if ( child.type === 'Mesh' ) {

  //                    var wireframe = new LineSegments(
  //                        new WireframeGeometry( child.geometry ),
  //                        new LineBasicMaterial( { color: 0x000000 } )
  //                    )
  //
  //                    child.add( wireframe )

                      self._viewport.addRaycastables( [ child ] );

                  }

                  object.add( child );

              } );

          }

      },

      retrieveChildrenOneByOneFor: function retrieveChildrenFor ( object, childrenIds ) {

          var self = this;

          for ( var childrenIndex = 0, numberOfChilds = childrenIds.length ; childrenIndex < numberOfChilds ; ++childrenIndex ) {

              self.requestServer( 'POST', ("/objects/" + (childrenIds[ childrenIndex ])), null, onLoadChildren, onProgressChildren, onErrorChildren );

          }

          function onLoadChildren ( loadEvent ) {

              if ( !self.statusOk( loadEvent.target.status ) ) {
                  return
              }

              var data = ( loadEvent.target.response ) ? JSON.parse( loadEvent.target.response ) : null;
              if ( !data ) {
                  console.error( 'MeshManager: No data receive !' );
                  return
              }

              self.convertJsonToObject3D( data, function (child) {

                  self.retrieveChildrenFor( child, data.children );

                  child.parent = null;

                  if ( child.type === 'Mesh' ) {

                      //                var wireframe = new LineSegments(
                      //                    new WireframeGeometry( child.geometry ),
                      //                    new LineBasicMaterial( { color: 0x000000 } )
                      //                )
                      //
                      //                child.add( wireframe )
                      self._viewport.addRaycastables( [ child ] );

                  }

                  object.add( child );

              } );

          }

          function onProgressChildren ( progressEvent ) {

              //            const progressValue = Math.ceil( (progressEvent.loaded / progressEvent.total ) * 100 )
              //            console.log( `Load children: ${progressValue}%` )

          }

          function onErrorChildren ( errorEvent ) {

              console.error( errorEvent );

          }

      },

      convertJsonToObject3D: function convertJsonToObject3D ( jsonData, callback ) {

          // Todo factory
          var self       = this;
          var data       = jsonData;
          var objectType = data.type;

          if ( objectType === 'Object3D' ) {

              var object3d            = new Object3D();
              object3d.uuid           = data.uuid;
              object3d.name           = data.name;
              object3d.type           = data.type;
              object3d.parent         = data.parent;
              object3d.children       = [];
              object3d.up.x           = data.up.x;
              object3d.up.y           = data.up.y;
              object3d.up.z           = data.up.z;
              object3d.position.x     = data.position.x;
              object3d.position.y     = data.position.y;
              object3d.position.z     = data.position.z;
              object3d.rotation.x     = data.rotation.x;
              object3d.rotation.y     = data.rotation.y;
              object3d.rotation.z     = data.rotation.z;
              object3d.rotation.order = data.rotation.order;
              object3d.quaternion.x   = data.quaternion.x;
              object3d.quaternion.y   = data.quaternion.y;
              object3d.quaternion.z   = data.quaternion.z;
              object3d.quaternion.w   = data.quaternion.w;
              object3d.scale.x        = data.scale.x;
              object3d.scale.y        = data.scale.y;
              object3d.scale.z        = data.scale.z;
              object3d.modelViewMatrix.fromArray( data.modelViewMatrix );
              object3d.normalMatrix.fromArray( data.normalMatrix );
              object3d.matrix.fromArray( data.matrix );
              object3d.matrixWorld.fromArray( data.matrixWorld );
              object3d.matrixAutoUpdate       = data.matrixAutoUpdate;
              object3d.matrixWorldNeedsUpdate = data.matrixWorldNeedsUpdate;
              object3d.layers.mask            = data.layers;
              object3d.visible                = data.visible;
              object3d.castShadow             = data.castShadow;
              object3d.receiveShadow          = data.receiveShadow;
              object3d.frustumCulled          = data.frustumCulled;
              object3d.renderOrder            = data.renderOrder;
              object3d.userData               = data.userData;

              return object3d

          } else if ( objectType === 'Mesh' ) {

              var mesh            = new Mesh();
              mesh.uuid           = data.uuid;
              mesh.name           = data.name;
              mesh.type           = data.type;
              mesh.parent         = data.parent;
              mesh.children       = [];
              mesh.up.x           = data.up.x;
              mesh.up.y           = data.up.y;
              mesh.up.z           = data.up.z;
              mesh.position.x     = data.position.x;
              mesh.position.y     = data.position.y;
              mesh.position.z     = data.position.z;
              mesh.rotation.x     = data.rotation.x;
              mesh.rotation.y     = data.rotation.y;
              mesh.rotation.z     = data.rotation.z;
              mesh.rotation.order = data.rotation.order;
              mesh.quaternion.x   = data.quaternion.x;
              mesh.quaternion.y   = data.quaternion.y;
              mesh.quaternion.z   = data.quaternion.z;
              mesh.quaternion.w   = data.quaternion.w;
              mesh.scale.x        = data.scale.x;
              mesh.scale.y        = data.scale.y;
              mesh.scale.z        = data.scale.z;
              mesh.modelViewMatrix.fromArray( data.modelViewMatrix );
              mesh.normalMatrix.fromArray( data.normalMatrix );
              mesh.matrix.fromArray( data.matrix );
              mesh.matrixWorld.fromArray( data.matrixWorld );
              mesh.matrixAutoUpdate       = data.matrixAutoUpdate;
              mesh.matrixWorldNeedsUpdate = data.matrixWorldNeedsUpdate;
              mesh.layers.mask            = data.layers;
              mesh.visible                = data.visible;
              mesh.castShadow             = data.castShadow;
              mesh.receiveShadow          = data.receiveShadow;
              mesh.frustumCulled          = data.frustumCulled;
              mesh.renderOrder            = data.renderOrder;
              mesh.userData               = data.userData;
              //            mesh.geometry = self.convertJsonToGeometry( data.geometry )
              //            mesh.material = self.convertJsonToMaterial( data.material )

              var haveGeometry = false;
              self.retrieveGeometryFor( mesh, data.geometry, function ( geometry ) {

                  mesh.geometry = geometry;
                  haveGeometry  = true;

                  if ( !haveGeometry || !haveMaterial ) { return }

                  callback( mesh );

              } );

              var haveMaterial = false;
              self.retrieveMaterialFor( mesh, data.material, function ( materials ) {

                  mesh.material = materials;
                  haveMaterial  = true;

                  if ( !haveGeometry || !haveMaterial ) { return }

                  callback( mesh );

              } );

          }

      },

      retrieveGeometryFor: function retrieveGeometryFor ( mesh, geometryId, callback ) {

          var self = this;

          var geometry = self._geometriesCache[ geometryId ];
          if ( geometry ) {

              callback( geometry );

          } else {

              self.requestServer( 'POST', ("/geometries/" + geometryId), null, onLoadGeometry, onProgressGeometry, onErrorGeometry );

              function onLoadGeometry ( loadEvent ) {

                  if ( !self.statusOk( loadEvent.target.status ) ) {
                      return
                  }

                  var jsonData = ( loadEvent.target.response ) ? JSON.parse( loadEvent.target.response ) : null;
                  if ( !jsonData ) {
                      console.error( 'MeshManager: No data receive !' );
                      return
                  }

                  var geometry = undefined;

                  if ( Array.isArray( jsonData ) ) {

                      geometry = self.convertJsonToGeometry( jsonData[0], onErrorGeometry );
                      if ( geometry ) {callback( geometry );}

                  } else {

                      geometry = self.convertJsonToGeometry( jsonData, onErrorGeometry );
                      if ( geometry ) {callback( geometry );}

                  }

              }

              function onProgressGeometry ( progressEvent ) {

                  //                const progressValue = Math.ceil( (progressEvent.loaded / progressEvent.total ) * 100 )
                  //                console.log( `Load geometry: ${progressValue}%` )

              }

              function onErrorGeometry ( errorEvent ) {

                  console.error( errorEvent );

              }

          }

      },

      convertJsonToGeometry: function convertJsonToGeometry ( jsonGeometry ) {

          var geometry = null;

          if ( jsonGeometry.isGeometry ) {

              geometry = new Geometry();

              geometry.uuid = jsonGeometry.uuid;
              geometry.name = jsonGeometry.name;
              geometry.type = jsonGeometry.type;

              var vertices = [];
              var vertex   = undefined;
              for ( var index = 0, numberOfVertices = jsonGeometry.vertices.length ; index < numberOfVertices ; ++index ) {

                  vertex = jsonGeometry.vertices[ index ];
                  vertices.push( new Vector3$1( vertex.x / 100, vertex.y / 100, vertex.z / 100 ) );

              }
              geometry.vertices = vertices;
              //                geometry.colors                  = jsonGeometry.colors

              var faces = [];
              var face  = undefined;
              for ( var faceIndex = 0, numberOfFaces = jsonGeometry.faces.length ; faceIndex < numberOfFaces ; faceIndex++ ) {
                  face = jsonGeometry.faces[ faceIndex ];
                  faces.push( new Face3$1( face.a, face.b, face.c, face.normal, face.color, face.materialIndex ) );
              }
              geometry.faces         = faces;
              //                geometry.faceVertexUvs           = [ [ Number ] ]
              geometry.morphTargets  = [];
              geometry.morphNormals  = [];
              geometry.skinWeights   = [];
              geometry.skinIndices   = [];
              geometry.lineDistances = [];

              //                geometry.computeBoundingBox()
              //                geometry.boundingBox.min.x       = jsonGeometry.boundingBox.min.x
              //                geometry.boundingBox.min.y       = jsonGeometry.boundingBox.min.y
              //                geometry.boundingBox.min.z       = jsonGeometry.boundingBox.min.z
              //                geometry.boundingBox.max.x       = jsonGeometry.boundingBox.max.x
              //                geometry.boundingBox.max.y       = jsonGeometry.boundingBox.max.y
              //                geometry.boundingBox.max.z       = jsonGeometry.boundingBox.max.z
              //
              //                geometry.computeBoundingSphere()
              //                geometry.boundingSphere.center.x = jsonGeometry.boundingSphere.center.x
              //                geometry.boundingSphere.center.y = jsonGeometry.boundingSphere.center.y
              //                geometry.boundingSphere.center.z = jsonGeometry.boundingSphere.center.z
              //                geometry.boundingSphere.radius                  = jsonGeometry.boundingSphere.radius

              geometry.elementsNeedUpdate      = true; //jsonGeometry.elementsNeedUpdate
              geometry.verticesNeedUpdate      = true; //jsonGeometry.verticesNeedUpdate
              geometry.uvsNeedUpdate           = true; //jsonGeometry.uvsNeedUpdate
              geometry.normalsNeedUpdate       = true; //jsonGeometry.normalsNeedUpdate
              geometry.colorsNeedUpdate        = true; //jsonGeometry.colorsNeedUpdate
              geometry.lineDistancesNeedUpdate = true; //jsonGeometry.lineDistancesNeedUpdate
              geometry.groupsNeedUpdate        = true; //jsonGeometry.groupsNeedUpdate

          } else if ( jsonGeometry.isBufferGeometry ) {

              geometry = new BufferGeometry();

              geometry.uuid   = jsonGeometry.uuid;
              geometry.name   = jsonGeometry.name;
              geometry.type   = jsonGeometry.type;
              //            geometry.drawRange = jsonGeometry.drawRange
              geometry.groups = jsonGeometry.groups;

              // Extract attributes
              var jsonGeometryAttributes = jsonGeometry.attributes;
              if ( jsonGeometryAttributes ) {

                  var attributes = {};

                  // TODO: make the rest or using loop !!
                  var positionAttributes = jsonGeometryAttributes.position;
                  if ( positionAttributes ) {
                      attributes[ 'position' ] = new BufferAttribute( new Float32Array( positionAttributes.array ), positionAttributes.itemSize, positionAttributes.normalized );
                  }

                  geometry.attributes = attributes;

              }

              // Extract index
              var jsonGeometryIndexes = jsonGeometry.index;
              if ( jsonGeometryIndexes ) {
                  geometry.index = new BufferAttribute( new Uint32Array( jsonGeometryIndexes.array ), jsonGeometryIndexes.itemSize, jsonGeometryIndexes.normalized );
              }

          } else {
              console.error( 'Unable to retrieve geometry type !!!' );
          }

          geometry.computeFaceNormals();
          geometry.computeVertexNormals();

          // Cache geometry
          this._geometriesCache[ jsonGeometry._id ] = geometry;

          return geometry

      },

      retrieveMaterialFor: function retrieveMaterialFor ( mesh, materialIds, callback ) {

          var self = this;

          var materials               = undefined;
          var numberOfLoadedMaterials = 0; // required because array will be init with a length

          if ( Array.isArray( materialIds ) ) {

              // We need to init array with correct length for correct lazy insert ordering
              materials      = new Array( materialIds.length );
              var materialId = undefined;
              for ( var materialIndex = 0, numberOfMaterials = materialIds.length ; materialIndex < numberOfMaterials ; materialIndex++ ) {
                  materialId = materialIds[ materialIndex ];

                  var material = self._materialsCache[ materialId ];
                  if ( material ) {

                      // We need to take care about the material order in array
                      var indexOfMaterial = materialIds.indexOf( materialId );

                      materials[ indexOfMaterial ] = material;

                      numberOfLoadedMaterials++;

                      if ( numberOfLoadedMaterials === materialIds.length ) {

                          callback( materials );

                      }

                  } else {

                      self.requestServer( 'POST', ("/materials/" + materialId), null, onLoadMultiMaterial, onProgressMaterial, onErrorMaterial );

                  }

              }

          } else {

              var material = self._materialsCache[ materialIds ];
              if ( material ) {

                  callback( material );

              } else {

                  self.requestServer( 'POST', ("/materials/" + materialIds), null, onLoadMaterial, onProgressMaterial, onErrorMaterial );

              }

          }

          function onLoadMaterial ( loadEvent ) {

              if ( !self.statusOk( loadEvent.target.status ) ) {
                  return
              }

              var data = ( loadEvent.target.response ) ? JSON.parse( loadEvent.target.response ) : null;
              if ( !data ) {
                  console.error( 'MeshManager: No data receive !' );
                  return
              }

              var material = self.convertJsonToMaterial( data );

              // Cache material
              self._materialsCache[ data._id ] = material;

              callback( material );
          }

          function onLoadMultiMaterial ( loadEvent ) {

              if ( !self.statusOk( loadEvent.target.status ) ) {
                  return
              }

              var data = ( loadEvent.target.response ) ? JSON.parse( loadEvent.target.response ) : null;
              if ( !data ) {
                  console.error( 'MeshManager: No data receive !' );
                  return
              }

              var jsonMat = undefined;
              for ( var iMat = 0, numMat = data.length ; iMat < numMat ; iMat++ ) {
                  jsonMat = data[ iMat ];

                  var material = self.convertJsonToMaterial( jsonMat );


                  // Cache material
                  self._materialsCache[ jsonMat._id ] = material;

                  // We need to take care about the material order in array
                  var indexOfMaterial = materialIds.indexOf( jsonMat._id );

                  materials[ indexOfMaterial ] = material;

                  numberOfLoadedMaterials++;

              }



              if ( numberOfLoadedMaterials === materialIds.length ) {

                  callback( materials );

              }
          }

          function onProgressMaterial ( progressEvent ) {

              //            const progressValue = Math.ceil( (progressEvent.loaded / progressEvent.total ) * 100 );
              //            console.log( `Load material: ${progressValue}%` );

          }

          function onErrorMaterial ( errorEvent ) {

              console.error( errorEvent );

          }

      },

      convertJsonToMaterial: function convertJsonToMaterial ( jsonMaterials ) {

          if ( Array.isArray( jsonMaterials ) ) {

              var materials    = [];
              var jsonMaterial = undefined;

              for ( var materialIndex = 0, numberOfMaterials = jsonMaterials.length ; materialIndex < numberOfMaterials ; materialIndex++ ) {
                  jsonMaterial = jsonMaterials[ materialIndex ];

                  var materialType = jsonMaterial.type;

                  switch ( materialType ) {

                      case 'MeshPhongMaterial': {
                          var material                 = new MeshPhongMaterial();
                          material.uuid                = jsonMaterial.uuid;
                          material.name                = jsonMaterial.name;
                          material.type                = jsonMaterial.type;
                          material.fog                 = jsonMaterial.fog;
                          material.lights              = jsonMaterial.lights;
                          material.blending            = jsonMaterial.blending;
                          material.side                = jsonMaterial.side;
                          material.flatShading         = jsonMaterial.flatShading;
                          material.vertexColors        = jsonMaterial.vertexColors;
                          material.opacity             = jsonMaterial.opacity;
                          material.transparent         = jsonMaterial.transparent;
                          material.blendSrc            = jsonMaterial.blendSrc;
                          material.blendDst            = jsonMaterial.blendDst;
                          material.blendEquation       = jsonMaterial.blendEquation;
                          material.blendSrcAlpha       = jsonMaterial.blendSrcAlpha;
                          material.blendDstAlpha       = jsonMaterial.blendDstAlpha;
                          material.blendEquationAlpha  = jsonMaterial.blendEquationAlpha;
                          material.depthFunc           = jsonMaterial.depthFunc;
                          material.depthTest           = jsonMaterial.depthTest;
                          material.depthWrite          = jsonMaterial.depthWrite;
                          material.clippingPlanes      = jsonMaterial.clippingPlanes;
                          material.clipIntersection    = jsonMaterial.clipIntersection;
                          material.clipShadows         = jsonMaterial.clipShadows;
                          material.colorWrite          = jsonMaterial.colorWrite;
                          material.precision           = jsonMaterial.precision;
                          material.polygonOffset       = jsonMaterial.polygonOffset;
                          material.polygonOffsetFactor = jsonMaterial.polygonOffsetFactor;
                          material.polygonOffsetUnits  = jsonMaterial.polygonOffsetUnits;
                          material.dithering           = jsonMaterial.dithering;
                          material.alphaTest           = jsonMaterial.alphaTest;
                          material.premultipliedAlpha  = jsonMaterial.premultipliedAlpha;
                          material.overdraw            = jsonMaterial.overdraw;
                          material.visible             = jsonMaterial.visible;
                          material.userData            = jsonMaterial.userData;
                          material.needsUpdate         = jsonMaterial.needsUpdate;
                          material.color               = new Color( jsonMaterial.color.r, jsonMaterial.color.g, jsonMaterial.color.b );
                          material.specular            = new Color( jsonMaterial.specular.r, jsonMaterial.specular.g, jsonMaterial.specular.b );
                          material.shininess           = jsonMaterial.shininess;
                          material.map                 = jsonMaterial.map;
                          material.lightMap            = jsonMaterial.lightMap;
                          material.lightMapIntensity   = jsonMaterial.lightMapIntensity;
                          material.aoMap               = jsonMaterial.aoMap;
                          material.aoMapIntensity      = jsonMaterial.aoMapIntensity;
                          material.emissive            = new Color( jsonMaterial.emissive.r, jsonMaterial.emissive.g, jsonMaterial.emissive.b );
                          material.emissiveIntensity   = jsonMaterial.emissiveIntensity;
                          material.emissiveMap         = jsonMaterial.emissiveMap;
                          material.bumpMap             = jsonMaterial.bumpMap;
                          material.bumpScale           = jsonMaterial.bumpScale;
                          material.normalMap           = jsonMaterial.normalMap;
                          material.normalScale         = jsonMaterial.normalScale;
                          material.displacementMap     = jsonMaterial.displacementMap;
                          material.displacementScale   = jsonMaterial.displacementScale;
                          material.displacementBias    = jsonMaterial.displacementBias;
                          material.specularMap         = jsonMaterial.specularMap;
                          material.alphaMap            = jsonMaterial.alphaMap;
                          material.envMap              = jsonMaterial.alphaMap;
                          material.combine             = jsonMaterial.combine;
                          material.reflectivity        = jsonMaterial.reflectivity;
                          material.refractionRatio     = jsonMaterial.refractionRatio;
                          material.wireframe           = jsonMaterial.wireframe;
                          material.wireframeLinewidth  = jsonMaterial.wireframeLinewidth;
                          material.wireframeLinecap    = jsonMaterial.wireframeLinecap;
                          material.wireframeLinejoin   = jsonMaterial.wireframeLinejoin;
                          material.skinning            = jsonMaterial.skinning;
                          material.morphTargets        = jsonMaterial.morphTargets;
                          material.morphNormals        = jsonMaterial.morphNormals;

                          materials.push( material );
                      }
                          break;

                      case 'LineBasicMaterial': {
                          var material$1  = new LineBasicMaterial();
                          material$1.uuid = jsonMaterial.uuid;
                          material$1.name = jsonMaterial.name;
                          material$1.type = jsonMaterial.type;
                          //                    material.color               = new Color( jsonMaterial.color.r, jsonMaterial.color.g, jsonMaterial.color.b )

                          materials.push( material$1 );
                      }
                          break;

                      default:
                          console.error( 'Unknown material type !' );
                          break;

                  }

              }

              return materials

          } else {

              var materialType$1 = jsonMaterials.type;
              var material$2       = undefined;

              switch ( materialType$1 ) {

                  case 'MeshPhongMaterial': {
                      material$2                     = new MeshPhongMaterial();
                      material$2.uuid                = jsonMaterials.uuid;
                      material$2.name                = jsonMaterials.name;
                      material$2.type                = jsonMaterials.type;
                      material$2.fog                 = jsonMaterials.fog;
                      material$2.lights              = jsonMaterials.lights;
                      material$2.blending            = jsonMaterials.blending;
                      material$2.side                = jsonMaterials.side;
                      material$2.flatShading         = jsonMaterials.flatShading;
                      material$2.vertexColors        = jsonMaterials.vertexColors;
                      material$2.opacity             = jsonMaterials.opacity;
                      material$2.transparent         = jsonMaterials.transparent;
                      material$2.blendSrc            = jsonMaterials.blendSrc;
                      material$2.blendDst            = jsonMaterials.blendDst;
                      material$2.blendEquation       = jsonMaterials.blendEquation;
                      material$2.blendSrcAlpha       = jsonMaterials.blendSrcAlpha;
                      material$2.blendDstAlpha       = jsonMaterials.blendDstAlpha;
                      material$2.blendEquationAlpha  = jsonMaterials.blendEquationAlpha;
                      material$2.depthFunc           = jsonMaterials.depthFunc;
                      material$2.depthTest           = jsonMaterials.depthTest;
                      material$2.depthWrite          = jsonMaterials.depthWrite;
                      material$2.clippingPlanes      = jsonMaterials.clippingPlanes;
                      material$2.clipIntersection    = jsonMaterials.clipIntersection;
                      material$2.clipShadows         = jsonMaterials.clipShadows;
                      material$2.colorWrite          = jsonMaterials.colorWrite;
                      material$2.precision           = jsonMaterials.precision;
                      material$2.polygonOffset       = jsonMaterials.polygonOffset;
                      material$2.polygonOffsetFactor = jsonMaterials.polygonOffsetFactor;
                      material$2.polygonOffsetUnits  = jsonMaterials.polygonOffsetUnits;
                      material$2.dithering           = jsonMaterials.dithering;
                      material$2.alphaTest           = jsonMaterials.alphaTest;
                      material$2.premultipliedAlpha  = jsonMaterials.premultipliedAlpha;
                      material$2.overdraw            = jsonMaterials.overdraw;
                      material$2.visible             = jsonMaterials.visible;
                      material$2.userData            = jsonMaterials.userData;
                      material$2.needsUpdate         = jsonMaterials.needsUpdate;
                      material$2.color               = new Color( jsonMaterials.color.r, jsonMaterials.color.g, jsonMaterials.color.b );
                      material$2.specular            = new Color( jsonMaterials.specular.r, jsonMaterials.specular.g, jsonMaterials.specular.b );
                      material$2.shininess           = jsonMaterials.shininess;
                      material$2.map                 = jsonMaterials.map;
                      material$2.lightMap            = jsonMaterials.lightMap;
                      material$2.lightMapIntensity   = jsonMaterials.lightMapIntensity;
                      material$2.aoMap               = jsonMaterials.aoMap;
                      material$2.aoMapIntensity      = jsonMaterials.aoMapIntensity;
                      material$2.emissive            = new Color( jsonMaterials.emissive.r, jsonMaterials.emissive.g, jsonMaterials.emissive.b );
                      material$2.emissiveIntensity   = jsonMaterials.emissiveIntensity;
                      material$2.emissiveMap         = jsonMaterials.emissiveMap;
                      material$2.bumpMap             = jsonMaterials.bumpMap;
                      material$2.bumpScale           = jsonMaterials.bumpScale;
                      material$2.normalMap           = jsonMaterials.normalMap;
                      material$2.normalScale         = jsonMaterials.normalScale;
                      material$2.displacementMap     = jsonMaterials.displacementMap;
                      material$2.displacementScale   = jsonMaterials.displacementScale;
                      material$2.displacementBias    = jsonMaterials.displacementBias;
                      material$2.specularMap         = jsonMaterials.specularMap;
                      material$2.alphaMap            = jsonMaterials.alphaMap;
                      material$2.envMap              = jsonMaterials.alphaMap;
                      material$2.combine             = jsonMaterials.combine;
                      material$2.reflectivity        = jsonMaterials.reflectivity;
                      material$2.refractionRatio     = jsonMaterials.refractionRatio;
                      material$2.wireframe           = jsonMaterials.wireframe;
                      material$2.wireframeLinewidth  = jsonMaterials.wireframeLinewidth;
                      material$2.wireframeLinecap    = jsonMaterials.wireframeLinecap;
                      material$2.wireframeLinejoin   = jsonMaterials.wireframeLinejoin;
                      material$2.skinning            = jsonMaterials.skinning;
                      material$2.morphTargets        = jsonMaterials.morphTargets;
                      material$2.morphNormals        = jsonMaterials.morphNormals;
                  }
                      break;

                  case 'LineBasicMaterial': {
                      material$2      = new LineBasicMaterial();
                      material$2.uuid = jsonMaterials.uuid;
                      material$2.name = jsonMaterials.name;
                      material$2.type = jsonMaterials.type;
                      //                    material.color               = new Color( jsonMaterial.color.r, jsonMaterial.color.g, jsonMaterial.color.b )
                  }
                      break;

                  default:
                      console.error( 'Unknown material type !' );
                      break;

              }

              return material$2

          }

      },

      requestServer: function requestServer ( method, url, data, onLoad, onProgress, onError, responseType ) {

          this._orchestrator.queue( {
              method: method,
              url: url,
              data: data,
              onLoad: onLoad,
              onProgress: onProgress,
              onError: onError,
              responseType: responseType || null
          } );

          //        const request = new XMLHttpRequest()
          //        if ( responseType ) { request.responseType = responseType }
          //        request.onload     = onLoad
          //        request.onprogress = onProgress
          //        request.onerror    = onError
          //
          //        request.open( method, url )
          //        request.send( data )

      },

      createResolutionMap: function createResolutionMap ( meshes ) {
          var this$1 = this;


          var self = this;

          var mesh         = undefined;
          var meshId       = undefined;
          var meshPosition = undefined;
          var meshLayer    = undefined;

          for ( var meshIndex = 0, numberOfMeshes = meshes.length ; meshIndex < numberOfMeshes ; meshIndex++ ) {

              mesh         = meshes[ meshIndex ];
              meshId       = mesh.id;
              meshPosition = mesh.coordinates;
              meshLayer    = mesh.layer;

              this$1._meshResolutionMap.set( meshId, {
                  id:          meshId,
                  position:    meshPosition,
                  layer:       meshLayer,
                  textureName: '',
                  resolution:  self._defaultResolution,
                  needsUpdate: false // True if resolution change
              } );

          }

      },

      updateMeshes: function updateMeshes () {

          console.log( 'Update meshes call !' );

          var cameraWorldPosition = ( this._viewport.cameraControlType === "path" ) ? this._viewport.camera.getWorldPosition() : this._viewport.cameraControl.target;
          var loadGround          = loadGround || ( this._viewport.cameraControl instanceof OrbitControls );
          var meshObject          = undefined;
          var resolution          = undefined;
          var meshesId            = [];

          this._meshResolutionMap.forEach( function ( meshData ) {

              meshObject = this._meshesGroup.getObjectByProperty( "uuid", meshData.uuid );
              resolution = this.getMeshResolution( meshData.position, cameraWorldPosition );

              if ( meshObject ) {

                  if ( !loadGround && meshData.layer === 1 ) {

                      meshObject.visible              = false;
                      meshObject.material.map         = null;
                      meshObject.material.needsUpdate = true;
                      meshData.resolution             = 0;
                      return

                  }

                  if ( resolution !== 0 && resolution === meshData.resolution ) { return }

                  if ( resolution === 0 ) {

                      meshObject.visible              = false;
                      meshObject.material.map         = null;
                      meshObject.material.needsUpdate = true;
                      meshData.resolution             = 0;

                  } else {

                      meshData.resolution = resolution;
                      this.updateMesh( meshData );

                  }

              } else {

                  if ( !loadGround && meshData.layer === 1 ) { return }

                  if ( resolution === 0 ) { return }

                  meshData.resolution = resolution;
                  meshesId.push( meshData.id );

              }

          }.bind( this ) );

          if ( meshesId.length > 0 && !this._underRequest ) {
              this._underRequest = true;
              this.getMeshesFromIds( meshesId );
          }

      },

      getMeshResolution: function getMeshResolution ( meshCoordinates, cameraWorldPosition ) {
          var this$1 = this;


          if ( !meshCoordinates ) { return '0' }

          // TODO: Could be only power of two instead of a Sqrt !!!
          var distanceToCamera = Math.sqrt(
              Math.pow( (meshCoordinates.x - cameraWorldPosition.x), 2 ) +
              Math.pow( (meshCoordinates.y - cameraWorldPosition.y), 2 ) +
              Math.pow( (meshCoordinates.z - cameraWorldPosition.z), 2 )
          );

          var resolution       = 0;
          var resolutionEntity = undefined;
          for ( var resolutionEntityIndex = 0, numberOfEntities = this._resolutionMap.length ; resolutionEntityIndex < numberOfEntities ; resolutionEntityIndex++ ) {

              resolutionEntity = this$1._resolutionMap[ resolutionEntityIndex ];
              if ( distanceToCamera > resolutionEntity.min && distanceToCamera <= resolutionEntity.max ) {
                  resolution = resolutionEntity.value;
                  break
              }

          }
          return resolution

      },

      updateMesh: function updateMesh ( meshData ) {

          if ( !meshData ) { return }

          var _DEBUG = false;

          var meshObject = this._meshesGroup.getObjectByProperty( "uuid", meshData.uuid );

          if ( !meshObject ) {

              this.getMeshWithId( meshData.id );

          } else { // Just update texture resolution

              if ( !meshObject.visible ) {

                  meshObject.visible = true;

              }

              if ( !meshData.textureName || _DEBUG ) {

                  //                var color = undefined
                  //
                  //                switch (meshData.resolution) {
                  //
                  //                    case 256:
                  //                        color = new Color( 0xff0000 )
                  //                        break
                  //
                  //                    case 512:
                  //                        color = new Color( 0x00ff00 )
                  //                        break
                  //
                  //                    case 1024:
                  //                        color = new Color( 0x0000ff )
                  //                        break
                  //
                  //                    case 2048:
                  //                        color = new Color( 0xffff00 )
                  //                        break
                  //
                  //                    case 4096:
                  //                        color = new Color( 0xff00ff )
                  //                        break
                  //
                  //                    default:
                  //                        color = new Color( 0xffffff )
                  //                        break
                  //
                  //                }
                  //
                  //                meshObject.material.color = color
                  //                meshObject.material.needsUpdate = true

              } else {

                  var url = "../resources/textures/" + meshData.resolution + '/' + meshData.textureName;
                  this._textureLoader.load( url, function ( texture ) {

                      meshObject.material.map         = texture;
                      meshObject.material.needsUpdate = true;

                  } );

              }

          }

      }

  } );

  var dockspawn = {version: "0.0.2"};

  /**
   * A tab handle represents the tab button on the tab strip
   */
  dockspawn.TabHandle = function(parent)
  {
      this.parent = parent;
      var undockHandler = dockspawn.TabHandle.prototype._performUndock.bind(this);
      this.elementBase = document.createElement('div');
      this.elementText = document.createElement('div');
      this.elementCloseButton = document.createElement('div');
      this.elementBase.classList.add("tab-handle");
      this.elementBase.classList.add("disable-selection"); // Disable text selection
      this.elementText.classList.add("tab-handle-text");
      this.elementCloseButton.classList.add("tab-handle-close-button");
      this.elementBase.appendChild(this.elementText);
      if (this.parent.host.displayCloseButton)
          { this.elementBase.appendChild(this.elementCloseButton); }

      this.parent.host.tabListElement.appendChild(this.elementBase);

      var panel = parent.container;
      var title = panel.getRawTitle();
      this.elementText.innerHTML = title;

      // Set the close button text (font awesome)
      var closeIcon = "fa fa-times";
      this.elementCloseButton.innerHTML = '<i class="' + closeIcon + '"></i>';

      this._bringToFront(this.elementBase);

      this.undockInitiator = new dockspawn.UndockInitiator(this.elementBase, undockHandler);
      this.undockInitiator.enabled = true;

      this.mouseClickHandler = new dockspawn.EventHandler(this.elementBase, 'click', this.onMouseClicked.bind(this));                     // Button click handler for the tab handle
      this.closeButtonHandler = new dockspawn.EventHandler(this.elementCloseButton, 'mousedown', this.onCloseButtonClicked.bind(this));   // Button click handler for the close button

      this.zIndexCounter = 1000;
  };

  dockspawn.TabHandle.prototype.updateTitle = function()
  {
      if (this.parent.container instanceof dockspawn.PanelContainer)
      {
          var panel = this.parent.container;
          var title = panel.getRawTitle();
          this.elementText.innerHTML = title;
      }
  };

  dockspawn.TabHandle.prototype.destroy = function()
  {
      this.mouseClickHandler.cancel();
      this.closeButtonHandler.cancel();
      removeNode(this.elementBase);
      removeNode(this.elementCloseButton);
      delete this.elementBase;
      delete this.elementCloseButton;
  };

  dockspawn.TabHandle.prototype._performUndock = function(e, dragOffset)
  {
      if (this.parent.container.containerType == "panel")
      {
          this.undockInitiator.enabled = false;
          var panel = this.parent.container;
          return panel.performUndockToDialog(e, dragOffset);
      }
      else
          { return null; }
  };

  dockspawn.TabHandle.prototype.onMouseClicked = function()
  {
      this.parent.onSelected();
  };

  dockspawn.TabHandle.prototype.onCloseButtonClicked = function()
  {
      // If the page contains a panel element, undock it and destroy it
      if (this.parent.container.containerType == "panel")
      {
          this.undockInitiator.enabled = false;
          var panel = this.parent.container;
          panel.performUndock();
      }
  };

  dockspawn.TabHandle.prototype.setSelected = function(selected)
  {
      var selectedClassName = "tab-handle-selected";
      if (selected)
          { this.elementBase.classList.add(selectedClassName); }
      else
          { this.elementBase.classList.remove(selectedClassName); }
  };

  dockspawn.TabHandle.prototype.setZIndex = function(zIndex)
  {
      this.elementBase.style.zIndex = zIndex;
  };

  dockspawn.TabHandle.prototype._bringToFront = function(element)
  {
      element.style.zIndex = this.zIndexCounter;
      this.zIndexCounter++;
  };
  /**
   * Tab Host control contains tabs known as TabPages.
   * The tab strip can be aligned in different orientations
   */
  dockspawn.TabHost = function(tabStripDirection, displayCloseButton)
  {
      /**
       * Create a tab host with the tab strip aligned in the [tabStripDirection] direciton
       * Only dockspawn.TabHost.DIRECTION_BOTTOM and dockspawn.TabHost.DIRECTION_TOP are supported
       */
      if (tabStripDirection === undefined)
          { tabStripDirection = dockspawn.TabHost.DIRECTION_BOTTOM; }
      if (displayCloseButton === undefined)
          { displayCloseButton = false; }

      this.tabStripDirection = tabStripDirection;
      this.displayCloseButton = displayCloseButton;           // Indicates if the close button next to the tab handle should be displayed
      this.pages = [];
      this.hostElement = document.createElement('div');       // The main tab host DOM element
      this.tabListElement = document.createElement('div');    // Hosts the tab handles
      this.separatorElement = document.createElement('div');  // A seperator line between the tabs and content
      this.contentElement = document.createElement('div');    // Hosts the active tab content
      this.createTabPage = this._createDefaultTabPage;        // Factory for creating tab pages

      if (this.tabStripDirection == dockspawn.TabHost.DIRECTION_BOTTOM)
      {
          this.hostElement.appendChild(this.contentElement);
          this.hostElement.appendChild(this.separatorElement);
          this.hostElement.appendChild(this.tabListElement);
      }
      else if (this.tabStripDirection == dockspawn.TabHost.DIRECTION_TOP)
      {
          this.hostElement.appendChild(this.tabListElement);
          this.hostElement.appendChild(this.separatorElement);
          this.hostElement.appendChild(this.contentElement);
      }
      else
          { throw new dockspawn.Exception("Only top and bottom tab strip orientations are supported"); }

      this.hostElement.classList.add("tab-host");
      this.tabListElement.classList.add("tab-handle-list-container");
      this.separatorElement.classList.add("tab-handle-content-seperator");
      this.contentElement.classList.add("tab-content");
  };

  // constants
  dockspawn.TabHost.DIRECTION_TOP = 0;
  dockspawn.TabHost.DIRECTION_BOTTOM = 1;
  dockspawn.TabHost.DIRECTION_LEFT = 2;
  dockspawn.TabHost.DIRECTION_RIGHT = 3;

  dockspawn.TabHost.prototype._createDefaultTabPage = function(tabHost, container)
  {
      return new dockspawn.TabPage(tabHost, container);
  };

  dockspawn.TabHost.prototype.setActiveTab = function(container)
  {
      var self = this;
      this.pages.forEach(function(page)
      {
          if (page.container === container)
          {
              self.onTabPageSelected(page);
              return;
          }
      });
  };

  dockspawn.TabHost.prototype.resize = function(width, height)
  {
      this.hostElement.style.width = width + "px";
      this.hostElement.style.height = height + "px";

      var tabHeight = this.tabListElement.clientHeight;
      var separatorHeight = this.separatorElement.clientHeight;
      var contentHeight = height - tabHeight - separatorHeight;
      this.contentElement.style.height = contentHeight + "px";

      if (this.activeTab)
          { this.activeTab.resize(width, contentHeight); }
  };

  dockspawn.TabHost.prototype.performLayout = function(children)
  {
      // Destroy all existing tab pages
      this.pages.forEach(function(tab)
      {
          tab.destroy();
      });
      this.pages.length = 0;

      var oldActiveTab = this.activeTab;
      delete this.activeTab;

      var childPanels = children.filter(function(child)
      {
          return child.containerType == "panel";
      });

      if (childPanels.length > 0)
      {
          // Rebuild new tab pages
          var self = this;
          childPanels.forEach(function(child)
          {
              var page = self.createTabPage(self, child);
              self.pages.push(page);

              // Restore the active selected tab
              if (oldActiveTab && page.container === oldActiveTab.container)
                  { self.activeTab = page; }
          });
          this._setTabHandlesVisible(true);
      }
      else
      // Do not show an empty tab handle host with zero tabs
          { this._setTabHandlesVisible(false); }

      if (this.activeTab)
          { this.onTabPageSelected(this.activeTab); }
  };

  dockspawn.TabHost.prototype._setTabHandlesVisible = function(visible)
  {
      this.tabListElement.style.display = visible ? "block" : "none";
      this.separatorElement.style.display = visible ? "block" : "none";
  };

  dockspawn.TabHost.prototype.onTabPageSelected = function(page)
  {
      this.activeTab = page;
      this.pages.forEach(function(tabPage)
      {
          var selected = (tabPage === page);
          tabPage.setSelected(selected);
      });

      // adjust the zIndex of the tabs to have proper shadow/depth effect
      var zIndexDelta = 1;
      var zIndex = 1000;
      this.pages.forEach(function(tabPage)
      {
          tabPage.handle.setZIndex(zIndex);
          var selected = (tabPage == page);
          if (selected)
              { zIndexDelta = -1; }
          zIndex += zIndexDelta;
      });

      // If a callback is defined, then notify it of this event
      //if (this.onTabChanged)
      //    this.onTabChanged(this, page);
  };

  dockspawn.TabPage = function(host, container)
  {
      if (arguments.length == 0)
          { return; }

      this.selected = false;
      this.host = host;
      this.container = container;

      this.handle = new dockspawn.TabHandle(this);
      this.containerElement = container.containerElement;

      if (container instanceof dockspawn.PanelContainer)
      {
          var panel = container;
          panel.onTitleChanged = this.onTitleChanged.bind(this);
      }
  };

  dockspawn.TabPage.prototype.onTitleChanged = function(sender, title)
  {
      this.handle.updateTitle();
  };

  dockspawn.TabPage.prototype.destroy = function()
  {
      this.handle.destroy();

      if (this.container instanceof dockspawn.PanelContainer)
      {
          var panel = this.container;
          delete panel.onTitleChanged;
      }
  };

  dockspawn.TabPage.prototype.onSelected = function()
  {
      this.host.onTabPageSelected(this);
  };

  dockspawn.TabPage.prototype.setSelected = function(flag)
  {
      this.selected = flag;
      this.handle.setSelected(flag);

      if (this.selected)
      {
          this.host.contentElement.appendChild(this.containerElement);
          // force a resize again
          var width = this.host.contentElement.clientWidth;
          var height = this.host.contentElement.clientHeight;
          this.container.resize(width, height);
      }
      else
          { removeNode(this.containerElement); }
  };

  dockspawn.TabPage.prototype.resize = function(width, height)
  {
      this.container.resize(width, height);
  };
  dockspawn.Dialog = function(panel, dockManager)
  {
      this.panel = panel;
      this.zIndexCounter = 1000;
      this.dockManager = dockManager;
      this.eventListener = dockManager;
      this._initialize();
  };

  dockspawn.Dialog.fromElement = function(id, dockManager)
  {
      return new dockspawn.Dialog(new dockspawn.PanelContainer(document.getElementById(id), dockManager), dockManager);
  };

  dockspawn.Dialog.prototype._initialize = function()
  {
      this.panel.floatingDialog = this;
      this.elementDialog = document.createElement('div');
      this.elementDialog.appendChild(this.panel.elementPanel);
      this.draggable = new dockspawn.DraggableContainer(this, this.panel, this.elementDialog, this.panel.elementTitle);
      this.resizable = new dockspawn.ResizableContainer(this, this.draggable, this.draggable.topLevelElement);

      document.body.appendChild(this.elementDialog);
      this.elementDialog.classList.add("dialog-floating");
      this.elementDialog.classList.add("rounded-corner-top");
      this.panel.elementTitle.classList.add("rounded-corner-top");

      this.mouseDownHandler = new dockspawn.EventHandler(this.elementDialog, 'mousedown', this.onMouseDown.bind(this));
      this.resize(this.panel.elementPanel.clientWidth, this.panel.elementPanel.clientHeight);
      this.bringToFront();
  };

  dockspawn.Dialog.prototype.setPosition = function(x, y)
  {
      this.elementDialog.style.left = x + "px";
      this.elementDialog.style.top = y + "px";
  };

  dockspawn.Dialog.prototype.onMouseDown = function(e)
  {
      this.bringToFront();
  };

  dockspawn.Dialog.prototype.destroy = function()
  {
      if (this.mouseDownHandler)
      {
          this.mouseDownHandler.cancel();
          delete this.mouseDownHandler;
      }
      this.elementDialog.classList.remove("rounded-corner-top");
      this.panel.elementTitle.classList.remove("rounded-corner-top");
      removeNode(this.elementDialog);
      this.draggable.removeDecorator();
      removeNode(this.panel.elementPanel);
      delete this.panel.floatingDialog;
  };

  dockspawn.Dialog.prototype.resize = function(width, height)
  {
      this.resizable.resize(width, height);
  };

  dockspawn.Dialog.prototype.setTitle = function(title)
  {
      this.panel.setTitle(title);
  };

  dockspawn.Dialog.prototype.setTitleIcon = function(iconName)
  {
      this.panel.setTitleIcon(iconName);
  };

  dockspawn.Dialog.prototype.bringToFront = function()
  {
      this.elementDialog.style.zIndex = this.zIndexCounter++;
  };
  dockspawn.DraggableContainer = function(dialog, delegate, topLevelElement, dragHandle)
  {
      this.dialog = dialog;
      this.delegate = delegate;
      this.containerElement = delegate.containerElement;
      this.dockManager = delegate.dockManager;
      this.topLevelElement = topLevelElement;
      this.containerType = delegate.containerType;
      this.mouseDownHandler = new dockspawn.EventHandler(dragHandle, 'mousedown', this.onMouseDown.bind(this));
      this.topLevelElement.style.marginLeft = topLevelElement.offsetLeft + "px";
      this.topLevelElement.style.marginTop = topLevelElement.offsetTop + "px";
      this.minimumAllowedChildNodes = delegate.minimumAllowedChildNodes;
  };

  dockspawn.DraggableContainer.prototype.destroy = function()
  {
      this.removeDecorator();
      this.delegate.destroy();
  };

  dockspawn.DraggableContainer.prototype.saveState = function(state)
  {
      this.delegate.saveState(state);
  };

  dockspawn.DraggableContainer.prototype.loadState = function(state)
  {
      this.delegate.loadState(state);
  };

  dockspawn.DraggableContainer.prototype.setActiveChild = function(child)
  {
  };

  Object.defineProperty(dockspawn.DraggableContainer.prototype, "width", {
      get: function() { return this.delegate.width; }
  });

  Object.defineProperty(dockspawn.DraggableContainer.prototype, "height", {
      get: function() { return this.delegate.height; }
  });

  dockspawn.DraggableContainer.prototype.name = function(value)
  {
      if (value)
          { this.delegate.name = value; }
      return this.delegate.name;
  };

  dockspawn.DraggableContainer.prototype.resize = function(width, height)
  {
      this.delegate.resize(width, height);
  };

  dockspawn.DraggableContainer.prototype.performLayout = function(children)
  {
      this.delegate.performLayout(children);
  };

  dockspawn.DraggableContainer.prototype.removeDecorator = function()
  {
      if (this.mouseDownHandler)
      {
          this.mouseDownHandler.cancel();
          delete this.mouseDownHandler;
      }
  };

  dockspawn.DraggableContainer.prototype.onMouseDown = function(event)
  {
      this._startDragging(event);
      this.previousMousePosition = { x: event.pageX, y: event.pageY };
      if (this.mouseMoveHandler)
      {
          this.mouseMoveHandler.cancel();
          delete this.mouseMoveHandler;
      }
      if (this.mouseUpHandler)
      {
          this.mouseUpHandler.cancel();
          delete this.mouseUpHandler;
      }

      this.mouseMoveHandler = new dockspawn.EventHandler(window, 'mousemove', this.onMouseMove.bind(this));
      this.mouseUpHandler = new dockspawn.EventHandler(window, 'mouseup', this.onMouseUp.bind(this));
  };

  dockspawn.DraggableContainer.prototype.onMouseUp = function(event)
  {
      this._stopDragging(event);
      this.mouseMoveHandler.cancel();
      delete this.mouseMoveHandler;
      this.mouseUpHandler.cancel();
      delete this.mouseUpHandler;
  };

  dockspawn.DraggableContainer.prototype._startDragging = function(event)
  {
      if (this.dialog.eventListener)
          { this.dialog.eventListener.onDialogDragStarted(this.dialog, event); }
      document.body.classList.add("disable-selection");
  };

  dockspawn.DraggableContainer.prototype._stopDragging = function(event)
  {
      if (this.dialog.eventListener)
          { this.dialog.eventListener.onDialogDragEnded(this.dialog, event); }
      document.body.classList.remove("disable-selection");
  };

  dockspawn.DraggableContainer.prototype.onMouseMove = function(event)
  {
      var currentMousePosition = new Point(event.pageX, event.pageY);
      var dx = Math.floor(currentMousePosition.x - this.previousMousePosition.x);
      var dy = Math.floor(currentMousePosition.y - this.previousMousePosition.y);
      this._performDrag(dx, dy);
      this.previousMousePosition = currentMousePosition;
  };

  dockspawn.DraggableContainer.prototype._performDrag = function(dx, dy)
  {
      var left = dx + getPixels(this.topLevelElement.style.marginLeft);
      var top = dy + getPixels(this.topLevelElement.style.marginTop);
      this.topLevelElement.style.marginLeft = left + "px";
      this.topLevelElement.style.marginTop = top + "px";
  };
  /**
   * Decorates a dock container with resizer handles around its base element
   * This enables the container to be resized from all directions
   */
  dockspawn.ResizableContainer = function(dialog, delegate, topLevelElement)
  {
      this.dialog = dialog;
      this.delegate = delegate;
      this.containerElement = delegate.containerElement;
      this.dockManager = delegate.dockManager;
      this.topLevelElement = topLevelElement;
      this.containerType = delegate.containerType;
      this.topLevelElement.style.marginLeft = this.topLevelElement.offsetLeft + "px";
      this.topLevelElement.style.marginTop = this.topLevelElement.offsetTop + "px";
      this.minimumAllowedChildNodes = delegate.minimumAllowedChildNodes;
      this._buildResizeHandles();
      this.readyToProcessNextResize = true;
  };

  dockspawn.ResizableContainer.prototype.setActiveChild = function(child)
  {
  };

  dockspawn.ResizableContainer.prototype._buildResizeHandles = function()
  {
      this.resizeHandles = [];
      //    this._buildResizeHandle(true, false, true, false); // Dont need the corner resizer near the close button
      this._buildResizeHandle(false, true, true, false);
      this._buildResizeHandle(true, false, false, true);
      this._buildResizeHandle(false, true, false, true);

      this._buildResizeHandle(true, false, false, false);
      this._buildResizeHandle(false, true, false, false);
      this._buildResizeHandle(false, false, true, false);
      this._buildResizeHandle(false, false, false, true);
  };

  dockspawn.ResizableContainer.prototype._buildResizeHandle = function(east, west, north, south)
  {
      var handle = new ResizeHandle();
      handle.east = east;
      handle.west = west;
      handle.north = north;
      handle.south = south;

      // Create an invisible div for the handle
      handle.element = document.createElement('div');
      this.topLevelElement.appendChild(handle.element);

      // Build the class name for the handle
      var verticalClass = "";
      var horizontalClass = "";
      if (north) { verticalClass = "n"; }
      if (south) { verticalClass = "s"; }
      if (east) { horizontalClass = "e"; }
      if (west) { horizontalClass = "w"; }
      var cssClass = "resize-handle-" + verticalClass + horizontalClass;
      if (verticalClass.length > 0 && horizontalClass.length > 0)
          { handle.corner = true; }

      handle.element.classList.add(handle.corner ? "resize-handle-corner" : "resize-handle");
      handle.element.classList.add(cssClass);
      this.resizeHandles.push(handle);

      var self = this;
      handle.mouseDownHandler = new dockspawn.EventHandler(handle.element, 'mousedown', function(e) { self.onMouseDown(handle, e); });
  };

  dockspawn.ResizableContainer.prototype.saveState = function(state)
  {
      this.delegate.saveState(state);
  };

  dockspawn.ResizableContainer.prototype.loadState = function(state)
  {
      this.delegate.loadState(state);
  };

  Object.defineProperty(dockspawn.ResizableContainer.prototype, "width", {
      get: function() { return this.delegate.width; }
  });

  Object.defineProperty(dockspawn.ResizableContainer.prototype, "height", {
      get: function() { return this.delegate.height; }
  });

  dockspawn.ResizableContainer.prototype.name = function(value)
  {
      if (value)
          { this.delegate.name = value; }
      return this.delegate.name;
  };

  dockspawn.ResizableContainer.prototype.resize = function(width, height)
  {
      this.delegate.resize(width, height);
      this._adjustResizeHandles(width, height);
  };

  dockspawn.ResizableContainer.prototype._adjustResizeHandles = function(width, height)
  {
      var self = this;
      this.resizeHandles.forEach(function(handle) {
          handle.adjustSize(self.topLevelElement, width, height);
      });
  };

  dockspawn.ResizableContainer.prototype.performLayout = function(children)
  {
      this.delegate.performLayout(children);
  };

  dockspawn.ResizableContainer.prototype.destroy = function()
  {
      this.removeDecorator();
      this.delegate.destroy();
  };

  dockspawn.ResizableContainer.prototype.removeDecorator = function()
  {
  };

  dockspawn.ResizableContainer.prototype.onMouseMoved = function(handle, e)
  {
      if (!this.readyToProcessNextResize)
          { return; }
      this.readyToProcessNextResize = false;

      //    window.requestLayoutFrame(() {
      this.dockManager.suspendLayout();
      var currentMousePosition = new Point(e.pageX, e.pageY);
      var dx = Math.floor(currentMousePosition.x - this.previousMousePosition.x);
      var dy = Math.floor(currentMousePosition.y - this.previousMousePosition.y);
      this._performDrag(handle, dx, dy);
      this.previousMousePosition = currentMousePosition;
      this.readyToProcessNextResize = true;
      this.dockManager.resumeLayout();
      //    });
  };

  dockspawn.ResizableContainer.prototype.onMouseDown = function(handle, event)
  {
      this.previousMousePosition = new Point(event.pageX, event.pageY);
      if (handle.mouseMoveHandler)
      {
          handle.mouseMoveHandler.cancel();
          delete handle.mouseMoveHandler;
      }
      if (handle.mouseUpHandler)
      {
          handle.mouseUpHandler.cancel();
          delete handle.mouseUpHandler;
      }

      // Create the mouse event handlers
      var self = this;
      handle.mouseMoveHandler = new dockspawn.EventHandler(window, 'mousemove', function(e) { self.onMouseMoved(handle, e); });
      handle.mouseUpHandler = new dockspawn.EventHandler(window, 'mouseup', function(e) { self.onMouseUp(handle, e); });

      document.body.classList.add("disable-selection");
  };

  dockspawn.ResizableContainer.prototype.onMouseUp = function(handle, event)
  {
      handle.mouseMoveHandler.cancel();
      handle.mouseUpHandler.cancel();
      delete handle.mouseMoveHandler;
      delete handle.mouseUpHandler;

      document.body.classList.remove("disable-selection");
  };

  dockspawn.ResizableContainer.prototype._performDrag = function(handle, dx, dy)
  {
      var bounds = {};
      bounds.left = getPixels(this.topLevelElement.style.marginLeft);
      bounds.top = getPixels(this.topLevelElement.style.marginTop);
      bounds.width = this.topLevelElement.clientWidth;
      bounds.height = this.topLevelElement.clientHeight;

      if (handle.east) { this._resizeEast(dx, bounds); }
      if (handle.west) { this._resizeWest(dx, bounds); }
      if (handle.north) { this._resizeNorth(dy, bounds); }
      if (handle.south) { this._resizeSouth(dy, bounds); }
  };

  dockspawn.ResizableContainer.prototype._resizeWest = function(dx, bounds)
  {
      this._resizeContainer(dx, 0, -dx, 0, bounds);
  };

  dockspawn.ResizableContainer.prototype._resizeEast = function(dx, bounds)
  {
      this._resizeContainer(0, 0, dx, 0, bounds);
  };

  dockspawn.ResizableContainer.prototype._resizeNorth = function(dy, bounds)
  {
      this._resizeContainer(0, dy, 0, -dy, bounds);
  };

  dockspawn.ResizableContainer.prototype._resizeSouth = function(dy, bounds)
  {
      this._resizeContainer(0, 0, 0, dy, bounds);
  };

  dockspawn.ResizableContainer.prototype._resizeContainer = function(leftDelta, topDelta, widthDelta, heightDelta, bounds)
  {
      bounds.left += leftDelta;
      bounds.top += topDelta;
      bounds.width += widthDelta;
      bounds.height += heightDelta;

      var minWidth = 50;  // TODO: Move to external configuration
      var minHeight = 50;  // TODO: Move to external configuration
      bounds.width = Math.max(bounds.width, minWidth);
      bounds.height = Math.max(bounds.height, minHeight);

      this.topLevelElement.style.marginLeft = bounds.left + "px";
      this.topLevelElement.style.marginTop = bounds.top + "px";

      this.resize(bounds.width, bounds.height);
  };


  function ResizeHandle()
  {
      this.element = undefined;
      this.handleSize = 6;   // TODO: Get this from DOM
      this.cornerSize = 12;  // TODO: Get this from DOM
      this.east = false;
      this.west = false;
      this.north = false;
      this.south = false;
      this.corner = false;
  }

  ResizeHandle.prototype.adjustSize = function(container, clientWidth, clientHeight)
  {
      if (this.corner)
      {
          if (this.west) { this.element.style.left = "0px"; }
          if (this.east) { this.element.style.left = (clientWidth - this.cornerSize) + "px"; }
          if (this.north) { this.element.style.top = "0px"; }
          if (this.south) { this.element.style.top = (clientHeight - this.cornerSize) + "px"; }
      }
      else
      {
          if (this.west)
          {
              this.element.style.left = "0px";
              this.element.style.top = this.cornerSize + "px";
          }
          if (this.east) {
              this.element.style.left = (clientWidth - this.handleSize) + "px";
              this.element.style.top = this.cornerSize + "px";
          }
          if (this.north) {
              this.element.style.left = this.cornerSize + "px";
              this.element.style.top = "0px";
          }
          if (this.south) {
              this.element.style.left = this.cornerSize + "px";
              this.element.style.top = (clientHeight - this.handleSize) + "px";
          }

          if (this.west || this.east) {
              this.element.style.height = (clientHeight - this.cornerSize * 2) + "px";
          } else {
              this.element.style.width = (clientWidth - this.cornerSize * 2) + "px";
          }
      }
  };
  dockspawn.Exception = function(message)
  {
      this.message = message;
  };

  dockspawn.Exception.prototype.toString = function()
  {
      return this.message;
  };
  /**
   * Dock manager manages all the dock panels in a hierarchy, similar to visual studio.
   * It owns a Html Div element inside which all panels are docked
   * Initially the document manager takes up the central space and acts as the root node
   */

  dockspawn.DockManager = function(element)
  {
      if (element === undefined)
          { throw new dockspawn.Exception("Invalid Dock Manager element provided"); }

      this.element = element;
      this.context = this.dockWheel = this.layoutEngine = this.mouseMoveHandler = undefined;
      this.layoutEventListeners = [];
  };

  dockspawn.DockManager.prototype.initialize = function()
  {
      this.context = new dockspawn.DockManagerContext(this);
      var documentNode = new dockspawn.DockNode(this.context.documentManagerView);
      this.context.model.rootNode = documentNode;
      this.context.model.documentManagerNode = documentNode;
      this.setRootNode(this.context.model.rootNode);
      // Resize the layout
      this.resize(this.element.clientWidth, this.element.clientHeight);
      this.dockWheel = new dockspawn.DockWheel(this);
      this.layoutEngine = new dockspawn.DockLayoutEngine(this);

      this.rebuildLayout(this.context.model.rootNode);
  };

  dockspawn.DockManager.prototype.rebuildLayout = function(node)
  {
      var self = this;
      node.children.forEach(function(child) { self.rebuildLayout(child); });
      node.performLayout();
  };

  dockspawn.DockManager.prototype.invalidate = function()
  {
      this.resize(this.element.clientWidth, this.element.clientHeight);
  };

  dockspawn.DockManager.prototype.resize = function(width, height)
  {
      this.element.style.width = width + "px";
      this.element.style.height = height + "px";
      this.context.model.rootNode.container.resize(width, height);
  };

  /**
   * Reset the dock model . This happens when the state is loaded from json
   */
  dockspawn.DockManager.prototype.setModel = function(model)
  {
      removeNode(this.context.documentManagerView.containerElement);
      this.context.model = model;
      this.setRootNode(model.rootNode);

      this.rebuildLayout(model.rootNode);
      this.invalidate();
  };

  dockspawn.DockManager.prototype.setRootNode = function(node)
  {
      if (this.context.model.rootNode)
      {
          // detach it from the dock manager's base element
          //      context.model.rootNode.detachFromParent();
      }

      // Attach the new node to the dock manager's base element and set as root node
      node.detachFromParent();
      this.context.model.rootNode = node;
      this.element.appendChild(node.container.containerElement);
  };


  dockspawn.DockManager.prototype.onDialogDragStarted = function(sender, e)
  {
      this.dockWheel.activeNode = this._findNodeOnPoint(e.pageX, e.pageY);
      this.dockWheel.activeDialog = sender;
      this.dockWheel.showWheel();
      if (this.mouseMoveHandler)
      {
          this.mouseMoveHandler.cancel();
          delete this.mouseMoveHandler;
      }
      this.mouseMoveHandler = new dockspawn.EventHandler(window, 'mousemove', this.onMouseMoved.bind(this));
  };

  dockspawn.DockManager.prototype.onDialogDragEnded = function(sender, e)
  {
      if (this.mouseMoveHandler)
      {
          this.mouseMoveHandler.cancel();
          delete this.mouseMoveHandler;
      }
      this.dockWheel.onDialogDropped(sender);
      this.dockWheel.hideWheel();
      delete this.dockWheel.activeDialog;
  };

  dockspawn.DockManager.prototype.onMouseMoved = function(e)
  {
      this.dockWheel.activeNode = this._findNodeOnPoint(e.clientX, e.clientY);
  };

  /**
   * Perform a DFS on the dock model's tree to find the
   * deepest level panel (i.e. the top-most non-overlapping panel)
   * that is under the mouse cursor
   * Retuns null if no node is found under this point
   */
  dockspawn.DockManager.prototype._findNodeOnPoint = function(x, y)
  {
      var stack = [];
      stack.push(this.context.model.rootNode);
      var bestMatch;

      while (stack.length > 0)
      {
          var topNode = stack.pop();

          if (isPointInsideNode(x, y, topNode))
          {
              // This node contains the point.
              bestMatch = topNode;

              // Keep looking future down
              [].push.apply(stack, topNode.children);
          }
      }
      return bestMatch;
  };

  /** Dock the [dialog] to the left of the [referenceNode] node */
  dockspawn.DockManager.prototype.dockDialogLeft = function(referenceNode, dialog)
  {
      return this._requestDockDialog(referenceNode, dialog, this.layoutEngine.dockLeft.bind(this.layoutEngine));
  };

  /** Dock the [dialog] to the right of the [referenceNode] node */
  dockspawn.DockManager.prototype.dockDialogRight = function(referenceNode, dialog)
  {
      return this._requestDockDialog(referenceNode, dialog, this.layoutEngine.dockRight.bind(this.layoutEngine));
  };

  /** Dock the [dialog] above the [referenceNode] node */
  dockspawn.DockManager.prototype.dockDialogUp = function(referenceNode, dialog)
  {
      return this._requestDockDialog(referenceNode, dialog, this.layoutEngine.dockUp.bind(this.layoutEngine));
  };

  /** Dock the [dialog] below the [referenceNode] node */
  dockspawn.DockManager.prototype.dockDialogDown = function(referenceNode, dialog)
  {
      return this._requestDockDialog(referenceNode, dialog, this.layoutEngine.dockDown.bind(this.layoutEngine));
  };

  /** Dock the [dialog] as a tab inside the [referenceNode] node */
  dockspawn.DockManager.prototype.dockDialogFill = function(referenceNode, dialog)
  {
      return this._requestDockDialog(referenceNode, dialog, this.layoutEngine.dockFill.bind(this.layoutEngine));
  };

  /** Dock the [container] to the left of the [referenceNode] node */
  dockspawn.DockManager.prototype.dockLeft = function(referenceNode, container, ratio)
  {
      return this._requestDockContainer(referenceNode, container, this.layoutEngine.dockLeft.bind(this.layoutEngine), ratio);
  };

  /** Dock the [container] to the right of the [referenceNode] node */
  dockspawn.DockManager.prototype.dockRight = function(referenceNode,  container, ratio)
  {
      return this._requestDockContainer(referenceNode, container, this.layoutEngine.dockRight.bind(this.layoutEngine), ratio);
  };

  /** Dock the [container] above the [referenceNode] node */
  dockspawn.DockManager.prototype.dockUp = function(referenceNode,  container, ratio)
  {
      return this._requestDockContainer(referenceNode, container, this.layoutEngine.dockUp.bind(this.layoutEngine), ratio);
  };

  /** Dock the [container] below the [referenceNode] node */
  dockspawn.DockManager.prototype.dockDown = function(referenceNode,  container, ratio)
  {
      return this._requestDockContainer(referenceNode, container, this.layoutEngine.dockDown.bind(this.layoutEngine), ratio);
  };

  /** Dock the [container] as a tab inside the [referenceNode] node */
  dockspawn.DockManager.prototype.dockFill = function(referenceNode, container)
  {
      return this._requestDockContainer(referenceNode, container, this.layoutEngine.dockFill.bind(this.layoutEngine));
  };

  dockspawn.DockManager.prototype._requestDockDialog = function(referenceNode, dialog, layoutDockFunction)
  {
      // Get the active dialog that was dragged on to the dock wheel
      var panel = dialog.panel;
      var newNode = new dockspawn.DockNode(panel);
      panel.prepareForDocking();
      dialog.destroy();
      layoutDockFunction(referenceNode, newNode);
      this.invalidate();
      return newNode;
  };

  dockspawn.DockManager.prototype._requestDockContainer = function(referenceNode, container, layoutDockFunction, ratio)
  {
      // Get the active dialog that was dragged on to the dock wheel
      var newNode = new dockspawn.DockNode(container);
      if (container.containerType == "panel")
      {
          var panel = container;
          panel.prepareForDocking();
          removeNode(panel.elementPanel);
      }
      layoutDockFunction(referenceNode, newNode);

      if (ratio && newNode.parent &&
          (newNode.parent.container.containerType == "vertical" || newNode.parent.container.containerType == "horizontal"))
      {
          var splitter = newNode.parent.container;
          splitter.setContainerRatio(container, ratio);
      }

      this.rebuildLayout(this.context.model.rootNode);
      this.invalidate();
      return newNode;
  };

  /**
   * Undocks a panel and converts it into a floating dialog window
   * It is assumed that only leaf nodes (panels) can be undocked
   */
  dockspawn.DockManager.prototype.requestUndockToDialog = function(container, event, dragOffset)
  {
      var node = this._findNodeFromContainer(container);
      this.layoutEngine.undock(node);

      // Create a new dialog window for the undocked panel
      var dialog = new dockspawn.Dialog(node.container, this);

      // Adjust the relative position
      var dialogWidth = dialog.elementDialog.clientWidth;
      if (dragOffset.x > dialogWidth)
          { dragOffset.x = 0.75 * dialogWidth; }
      dialog.setPosition(
          event.clientX - dragOffset.x,
          event.clientY - dragOffset.y);
      dialog.draggable.onMouseDown(event);

      return dialog;
  };

  /** Undocks a panel and converts it into a floating dialog window
   * It is assumed that only leaf nodes (panels) can be undocked
   */
  dockspawn.DockManager.prototype.requestUndock = function(container)
  {
      var node = this._findNodeFromContainer(container);
      this.layoutEngine.undock(node);
  };

  /**
   * Removes a dock container from the dock layout hierarcy
   * Returns the node that was removed from the dock tree
   */
  dockspawn.DockManager.prototype.requestRemove = function(container)
  {
      var node = this._findNodeFromContainer(container);
      var parent = node.parent;
      node.detachFromParent();
      if (parent)
          { this.rebuildLayout(parent); }
      return node;
  };

  /** Finds the node that owns the specified [container] */
  dockspawn.DockManager.prototype._findNodeFromContainer = function(container)
  {
      //this.context.model.rootNode.debug_DumpTree();

      var stack = [];
      stack.push(this.context.model.rootNode);

      while (stack.length > 0)
      {
          var topNode = stack.pop();

          if (topNode.container === container)
              { return topNode; }
          [].push.apply(stack, topNode.children);
      }

      throw new dockspawn.Exception("Cannot find dock node belonging to the element");
  };

  dockspawn.DockManager.prototype.addLayoutListener = function(listener)
  {
      this.layoutEventListeners.push(listener);
  };

  dockspawn.DockManager.prototype.removeLayoutListener = function(listener)
  {
      this.layoutEventListeners.splice(this.layoutEventListeners.indexOf(listener), 1);
  };

  dockspawn.DockManager.prototype.suspendLayout = function()
  {
      var self = this;
      this.layoutEventListeners.forEach(function(listener) {
          if (listener.onSuspendLayout) { listener.onSuspendLayout(self); }
      });
  };

  dockspawn.DockManager.prototype.resumeLayout = function()
  {
      var self = this;
      this.layoutEventListeners.forEach(function(listener) {
          if (listener.onResumeLayout) { listener.onResumeLayout(self); }
      });
  };

  dockspawn.DockManager.prototype.notifyOnDock = function(dockNode)
  {
      var self = this;
      this.layoutEventListeners.forEach(function(listener) {
          if (listener.onDock) {
              listener.onDock(self, dockNode);
          }
      });
  };

  dockspawn.DockManager.prototype.notifyOnUnDock = function(dockNode)
  {
      var self = this;
      this.layoutEventListeners.forEach(function(listener) {
          if (listener.onUndock) {
              listener.onUndock(self, dockNode);
          }
      });
  };

  dockspawn.DockManager.prototype.saveState = function()
  {
      var serializer = new dockspawn.DockGraphSerializer();
      return serializer.serialize(this.context.model);
  };

  dockspawn.DockManager.prototype.loadState = function(json)
  {
      var deserializer = new dockspawn.DockGraphDeserializer(this);
      this.context.model = deserializer.deserialize(json);
      this.setModel(this.context.model);
  };

  //typedef void LayoutEngineDockFunction(dockspawn.DockNode referenceNode, dockspawn.DockNode newNode);

  /**
   * The Dock Manager notifies the listeners of layout changes so client containers that have
   * costly layout structures can detach and reattach themself to avoid reflow
   */
  //abstract class LayoutEventListener {
  //void onSuspendLayout(dockspawn.DockManager dockManager);
  //void onResumeLayout(dockspawn.DockManager dockManager);
  //}

  dockspawn.DockLayoutEngine = function(dockManager)
  {
      this.dockManager = dockManager;
  };

  /** docks the [newNode] to the left of [referenceNode] */
  dockspawn.DockLayoutEngine.prototype.dockLeft = function(referenceNode, newNode)
  {
      this._performDock(referenceNode, newNode, "horizontal", true);
  };

  /** docks the [newNode] to the right of [referenceNode] */
  dockspawn.DockLayoutEngine.prototype.dockRight = function(referenceNode, newNode) {
      this._performDock(referenceNode, newNode, "horizontal", false);
  };

  /** docks the [newNode] to the top of [referenceNode] */
  dockspawn.DockLayoutEngine.prototype.dockUp = function(referenceNode, newNode) {
      this._performDock(referenceNode, newNode, "vertical", true);
  };

  /** docks the [newNode] to the bottom of [referenceNode] */
  dockspawn.DockLayoutEngine.prototype.dockDown = function(referenceNode, newNode) {
      this._performDock(referenceNode, newNode, "vertical", false);
  };

  /** docks the [newNode] by creating a new tab inside [referenceNode] */
  dockspawn.DockLayoutEngine.prototype.dockFill = function(referenceNode, newNode) {
      this._performDock(referenceNode, newNode, "fill", false);
  };

  dockspawn.DockLayoutEngine.prototype.undock = function(node)
  {
      var this$1 = this;

      var parentNode = node.parent;
      if (!parentNode)
          { throw new dockspawn.Exception("Cannot undock.  panel is not a leaf node"); }

      // Get the position of the node relative to it's siblings
      var siblingIndex = parentNode.children.indexOf(node);

      // Detach the node from the dock manager's tree hierarchy
      node.detachFromParent();

      // Fix the node's parent hierarchy
      if (parentNode.children.length < parentNode.container.minimumAllowedChildNodes) {
          // If the child count falls below the minimum threshold, destroy the parent and merge
          // the children with their grandparents
          var grandParent = parentNode.parent;
          for (var i = 0; i < parentNode.children.length; i++)
          {
              var otherChild = parentNode.children[i];
              if (grandParent)
              {
                  // parent node is not a root node
                  grandParent.addChildAfter(parentNode, otherChild);
                  parentNode.detachFromParent();
                  parentNode.container.destroy();
                  grandParent.performLayout();
              }
              else
              {
                  // Parent is a root node.
                  // Make the other child the root node
                  parentNode.detachFromParent();
                  parentNode.container.destroy();
                  this$1.dockManager.setRootNode(otherChild);
              }
          }
      }
      else
      {
          // the node to be removed has 2 or more other siblings. So it is safe to continue
          // using the parent composite container.
          parentNode.performLayout();

          // Set the next sibling as the active child (e.g. for a Tab host, it would select it as the active tab)
          if (parentNode.children.length > 0)
          {
              var nextActiveSibling = parentNode.children[Math.max(0, siblingIndex - 1)];
              parentNode.container.setActiveChild(nextActiveSibling.container);
          }
      }
      this.dockManager.invalidate();
      this.dockManager.notifyOnUnDock(node);
  };

  dockspawn.DockLayoutEngine.prototype._performDock = function(referenceNode, newNode, direction, insertBeforeReference)
  {
      if (referenceNode.parent && referenceNode.parent.container.containerType == "fill")
          { referenceNode = referenceNode.parent; }

      if (direction == "fill" && referenceNode.container.containerType == "fill")
      {
          referenceNode.addChild(newNode);
          referenceNode.performLayout();
          referenceNode.container.setActiveChild(newNode.container);
          return;
      }

      // Check if reference node is root node
      var model = this.dockManager.context.model;
      if (referenceNode === model.rootNode)
      {
          var compositeContainer = this._createDockContainer(direction, newNode, referenceNode);
          var compositeNode = new dockspawn.DockNode(compositeContainer);

          if (insertBeforeReference)
          {
              compositeNode.addChild(newNode);
              compositeNode.addChild(referenceNode);
          }
          else
          {
              compositeNode.addChild(referenceNode);
              compositeNode.addChild(newNode);
          }

          // Attach the root node to the dock manager's DOM
          this.dockManager.setRootNode(compositeNode);
          this.dockManager.rebuildLayout(this.dockManager.context.model.rootNode);
          compositeNode.container.setActiveChild(newNode.container);
          return;
      }

      if (referenceNode.parent.container.containerType != direction) {
          var referenceParent = referenceNode.parent;

          // Get the dimensions of the reference node, for resizing later on
          var referenceNodeWidth = referenceNode.container.containerElement.clientWidth;
          var referenceNodeHeight = referenceNode.container.containerElement.clientHeight;

          // Get the dimensions of the reference node, for resizing later on
          var referenceNodeParentWidth = referenceParent.container.containerElement.clientWidth;
          var referenceNodeParentHeight = referenceParent.container.containerElement.clientHeight;

          // Replace the reference node with a new composite node with the reference and new node as it's children
          var compositeContainer = this._createDockContainer(direction, newNode, referenceNode);
          var compositeNode = new dockspawn.DockNode(compositeContainer);

          referenceParent.addChildAfter(referenceNode, compositeNode);
          referenceNode.detachFromParent();
          removeNode(referenceNode.container.containerElement);

          if (insertBeforeReference)
          {
              compositeNode.addChild(newNode);
              compositeNode.addChild(referenceNode);
          }
          else
          {
              compositeNode.addChild(referenceNode);
              compositeNode.addChild(newNode);
          }

          referenceParent.performLayout();
          compositeNode.performLayout();

          compositeNode.container.setActiveChild(newNode.container);
          compositeNode.container.resize(referenceNodeWidth, referenceNodeHeight);
          referenceParent.container.resize(referenceNodeParentWidth, referenceNodeParentHeight);
      }
      else
      {
          // Add as a sibling, since the parent of the reference node is of the right composite type
          var referenceParent = referenceNode.parent;
          if (insertBeforeReference)
              { referenceParent.addChildBefore(referenceNode, newNode); }
          else
              { referenceParent.addChildAfter(referenceNode, newNode); }
          referenceParent.performLayout();
          referenceParent.container.setActiveChild(newNode.container);
      }

      // force resize the panel
      var containerWidth = newNode.container.containerElement.clientWidth;
      var containerHeight = newNode.container.containerElement.clientHeight;
      newNode.container.resize(containerWidth, containerHeight);

      this.dockManager.notifyOnDock(newNode);
  };

  dockspawn.DockLayoutEngine.prototype._forceResizeCompositeContainer = function(container)
  {
      var width = container.containerElement.clientWidth;
      var height = container.containerElement.clientHeight;
      container.resize(width, height);
  };

  dockspawn.DockLayoutEngine.prototype._createDockContainer = function(containerType, newNode, referenceNode)
  {
      if (containerType == "horizontal")
          { return new dockspawn.HorizontalDockContainer(this.dockManager, [newNode.container, referenceNode.container]); }
      if (containerType == "vertical")
          { return new dockspawn.VerticalDockContainer(this.dockManager, [newNode.container, referenceNode.container]); }
      if (containerType == "fill")
          { return new dockspawn.FillDockContainer(this.dockManager); }
      throw new dockspawn.Exception("Failed to create dock container of type: " + containerType);
  };


  /**
   * Gets the bounds of the new node if it were to dock with the specified configuration
   * The state is not modified in this function.  It is used for showing a preview of where
   * the panel would be docked when hovered over a dock wheel button
   */
  dockspawn.DockLayoutEngine.prototype.getDockBounds = function(referenceNode, containerToDock, direction, insertBeforeReference)
  {
      var this$1 = this;

      var compositeNode; // The node that contains the splitter / fill node
      var childCount;
      var childPosition;
      if (direction == "fill")
      {
          // Since this is a fill operation, the highlight bounds is the same as the reference node
          // TODO: Create a tab handle highlight to show that it's going to be docked in a tab
          var targetElement = referenceNode.container.containerElement;
          var bounds = new Rectangle();
          bounds.x = targetElement.offsetLeft;
          bounds.y = targetElement.offsetTop;
          bounds.width = targetElement.clientWidth;
          bounds.height= targetElement.clientHeight;
          return bounds;
      }

      if (referenceNode.parent && referenceNode.parent.container.containerType == "fill")
      // Ignore the fill container's child and move one level up
          { referenceNode = referenceNode.parent; }

      // Flag to indicate of the renference node was replaced with a new composite node with 2 children
      var hierarchyModified = false;
      if (referenceNode.parent && referenceNode.parent.container.containerType == direction) {
          // The parent already is of the desired composite type.  Will be inserted as sibling to the reference node
          compositeNode = referenceNode.parent;
          childCount = compositeNode.children.length;
          childPosition = compositeNode.children.indexOf(referenceNode) + (insertBeforeReference ? 0 : 1);
      } else {
          // The reference node will be replaced with a new composite node of the desired type with 2 children
          compositeNode = referenceNode;
          childCount = 1;   // The newly inserted composite node will contain the reference node
          childPosition = (insertBeforeReference ? 0 : 1);
          hierarchyModified = true;
      }

      var splitBarSize = 5;  // TODO: Get from DOM
      var targetPanelSize = 0;
      var targetPanelStart = 0;
      if (direction == "vertical" || direction == "horizontal")
      {
          // Existing size of the composite container (without the splitter bars).
          // This will also be the final size of the composite (splitter / fill)
          // container after the new panel has been docked
          var compositeSize = this._getVaringDimension(compositeNode.container, direction) - (childCount - 1) * splitBarSize;

          // size of the newly added panel
          var newPanelOriginalSize = this._getVaringDimension(containerToDock, direction);
          var scaleMultiplier = compositeSize / (compositeSize + newPanelOriginalSize);

          // Size of the panel after it has been docked and scaled
          targetPanelSize = newPanelOriginalSize * scaleMultiplier;
          if (hierarchyModified)
              { targetPanelStart = insertBeforeReference ? 0 : compositeSize * scaleMultiplier; }
          else
          {
              for (var i = 0; i < childPosition; i++)
                  { targetPanelStart += this$1._getVaringDimension(compositeNode.children[i].container, direction); }
              targetPanelStart *= scaleMultiplier;
          }
      }

      var bounds = new Rectangle();
      if (direction == "vertical")
      {
          bounds.x = compositeNode.container.containerElement.offsetLeft;
          bounds.y = compositeNode.container.containerElement.offsetTop + targetPanelStart;
          bounds.width = compositeNode.container.width;
          bounds.height = targetPanelSize;
      } else if (direction == "horizontal") {
          bounds.x = compositeNode.container.containerElement.offsetLeft + targetPanelStart;
          bounds.y = compositeNode.container.containerElement.offsetTop;
          bounds.width = targetPanelSize;
          bounds.height = compositeNode.container.height;
      }

      return bounds;
  };

  dockspawn.DockLayoutEngine.prototype._getVaringDimension = function(container, direction)
  {
      if (direction == "vertical")
          { return container.height; }
      if (direction == "horizontal")
          { return container.width; }
      return 0;
  };
  dockspawn.DockManagerContext = function(dockManager)
  {
      this.dockManager = dockManager;
      this.model = new dockspawn.DockModel();
      this.documentManagerView = new dockspawn.DocumentManagerContainer(this.dockManager);
  };
  /**
   * The Dock Model contains the tree hierarchy that represents the state of the
   * panel placement within the dock manager.
   */
  dockspawn.DockModel = function()
  {
      this.rootNode = this.documentManagerNode = undefined;
  };

  dockspawn.DockNode = function(container)
  {
      /** The dock container represented by this node */
      this.container = container;
      this.children = [];
  };

  dockspawn.DockNode.prototype.detachFromParent = function()
  {
      if (this.parent)
      {
          this.parent.removeChild(this);
          delete this.parent;
      }
  };

  dockspawn.DockNode.prototype.removeChild = function(childNode)
  {
      var index = this.children.indexOf(childNode);
      if (index >= 0)
          { this.children.splice(index, 1); }
  };

  dockspawn.DockNode.prototype.addChild = function(childNode)
  {
      childNode.detachFromParent();
      childNode.parent = this;
      this.children.push(childNode);
  };

  dockspawn.DockNode.prototype.addChildBefore = function(referenceNode, childNode)
  {
      this._addChildWithDirection(referenceNode, childNode, true);
  };

  dockspawn.DockNode.prototype.addChildAfter = function(referenceNode, childNode)
  {
      this._addChildWithDirection(referenceNode, childNode, false);
  };

  dockspawn.DockNode.prototype._addChildWithDirection = function(referenceNode, childNode, before)
  {
      // Detach this node from it's parent first
      childNode.detachFromParent();
      childNode.parent = this;

      var referenceIndex = this.children.indexOf(referenceNode);
      var preList = this.children.slice(0, referenceIndex);
      var postList = this.children.slice(referenceIndex + 1, this.children.length);

      this.children = preList.slice(0);
      if (before)
      {
          this.children.push(childNode);
          this.children.push(referenceNode);
      }
      else
      {
          this.children.push(referenceNode);
          this.children.push(childNode);
      }
      Array.prototype.push.apply(this.children, postList);
  };

  dockspawn.DockNode.prototype.performLayout = function()
  {
      var childContainers = this.children.map(function(childNode) { return childNode.container; });
      this.container.performLayout(childContainers);
  };

  dockspawn.DockNode.prototype.debug_DumpTree = function(indent)
  {
      if (indent === undefined)
          { indent = 0; }

      var message = this.container.name;
      for (var i = 0; i < indent; i++)
          { message = "\t" + message; }

      var parentType = this.parent === undefined ? "null" : this.parent.container.containerType;
      console.log(">>" + message + " [" + parentType + "]");

      this.children.forEach(function(childNode) { childNode.debug_DumpTree(indent + 1); });
  };
  /**
   * Manages the dock overlay buttons that are displayed over the dock manager
   */
  dockspawn.DockWheel = function(dockManager)
  {
      this.dockManager = dockManager;
      this.elementMainWheel = document.createElement("div");    // Contains the main wheel's 5 dock buttons
      this.elementSideWheel = document.createElement("div");    // Contains the 4 buttons on the side
      this.wheelItems = {};
      var wheelTypes = [
          "left", "right", "top", "down", "fill",     // Main dock wheel buttons
          "left-s", "right-s", "top-s", "down-s"      // Buttons on the extreme 4 sides
      ];
      var self = this;
      wheelTypes.forEach(function(wheelType)
      {
          self.wheelItems[wheelType] = new DockWheelItem(self, wheelType);
          if (wheelType.substr(-2, 2) == "-s")
          // Side button
              { self.elementSideWheel.appendChild(self.wheelItems[wheelType].element); }
          else
          // Main dock wheel button
              { self.elementMainWheel.appendChild(self.wheelItems[wheelType].element); }
      });

      var zIndex = 100000;
      this.elementMainWheel.classList.add("dock-wheel-base");
      this.elementSideWheel.classList.add("dock-wheel-base");
      this.elementMainWheel.style.zIndex = zIndex + 1;
      this.elementSideWheel.style.zIndex = zIndex;
      this.elementPanelPreview = document.createElement("div");  // Used for showing the preview of where the panel would be docked
      this.elementPanelPreview.classList.add("dock-wheel-panel-preview");
      this.elementPanelPreview.style.zIndex = zIndex - 1;
      this.activeDialog = undefined;  // The dialog being dragged, when the wheel is visible
      this._activeNode = undefined;
      this._visible = false;
  };

  /** The node over which the dock wheel is being displayed on */
  Object.defineProperty(dockspawn.DockWheel.prototype, "activeNode", {
      get: function() { return this._activeNode; },
      set: function(value)
           {
               var previousValue = this._activeNode;
               this._activeNode = value;

               if (previousValue !== this._activeNode)
               {
                   // The active node has been changed.
                   // Reattach the wheel to the new node's element and show it again
                   if (this._visible)
                       { this.showWheel(); }
               }
           }
  });

  dockspawn.DockWheel.prototype.showWheel = function()
  {
      this._visible = true;
      if (!this.activeNode)
      {
          // No active node selected. make sure the wheel is invisible
          removeNode(this.elementMainWheel);
          removeNode(this.elementSideWheel);
          return;
      }
      var element = this.activeNode.container.containerElement;
      var containerWidth = element.clientWidth;
      var containerHeight = element.clientHeight;
      var baseX = Math.floor(containerWidth / 2) + element.offsetLeft;
      var baseY = Math.floor(containerHeight / 2) + element.offsetTop;
      this.elementMainWheel.style.left = baseX + "px";
      this.elementMainWheel.style.top = baseY + "px";

      // The positioning of the main dock wheel buttons is done automatically through CSS
      // Dynamically calculate the positions of the buttons on the extreme sides of the dock manager
      var sideMargin = 20;
      var dockManagerWidth = this.dockManager.element.clientWidth;
      var dockManagerHeight = this.dockManager.element.clientHeight;
      var dockManagerOffsetX = this.dockManager.element.offsetLeft;
      var dockManagerOffsetY = this.dockManager.element.offsetTop;

      removeNode(this.elementMainWheel);
      removeNode(this.elementSideWheel);
      element.appendChild(this.elementMainWheel);
      this.dockManager.element.appendChild(this.elementSideWheel);

      this._setWheelButtonPosition("left-s",   sideMargin, -dockManagerHeight / 2);
      this._setWheelButtonPosition("right-s",  dockManagerWidth - sideMargin * 2, -dockManagerHeight / 2);
      this._setWheelButtonPosition("top-s",    dockManagerWidth / 2, -dockManagerHeight + sideMargin);
      this._setWheelButtonPosition("down-s",   dockManagerWidth / 2, -sideMargin);
  };

  dockspawn.DockWheel.prototype._setWheelButtonPosition = function(wheelId, left, top)
  {
      var item = this.wheelItems[wheelId];
      var itemHalfWidth = item.element.clientWidth / 2;
      var itemHalfHeight = item.element.clientHeight / 2;

      var x = Math.floor(left - itemHalfWidth);
      var y = Math.floor(top - itemHalfHeight);
      //    item.element.style.left = "${x}px";
      //    item.element.style.top = "${y}px";
      item.element.style.marginLeft = x + "px";
      item.element.style.marginTop = y + "px";
  };

  dockspawn.DockWheel.prototype.hideWheel = function()
  {
      var this$1 = this;

      this._visible = false;
      this.activeNode = undefined;
      removeNode(this.elementMainWheel);
      removeNode(this.elementSideWheel);
      removeNode(this.elementPanelPreview);

      // deactivate all wheels
      for (var wheelType in this$1.wheelItems)
          { this$1.wheelItems[wheelType].active = false; }
  };

  dockspawn.DockWheel.prototype.onMouseOver = function(wheelItem, e)
  {
      if (!this.activeDialog)
          { return; }

      // Display the preview panel to show where the panel would be docked
      var rootNode = this.dockManager.context.model.rootNode;
      var bounds;
      if (wheelItem.id == "top") {
          bounds = this.dockManager.layoutEngine.getDockBounds(this.activeNode, this.activeDialog.panel, "vertical", true);
      } else if (wheelItem.id == "down") {
          bounds = this.dockManager.layoutEngine.getDockBounds(this.activeNode, this.activeDialog.panel, "vertical", false);
      } else if (wheelItem.id == "left") {
          bounds = this.dockManager.layoutEngine.getDockBounds(this.activeNode, this.activeDialog.panel, "horizontal", true);
      } else if (wheelItem.id == "right") {
          bounds = this.dockManager.layoutEngine.getDockBounds(this.activeNode, this.activeDialog.panel, "horizontal", false);
      } else if (wheelItem.id == "fill") {
          bounds = this.dockManager.layoutEngine.getDockBounds(this.activeNode, this.activeDialog.panel, "fill", false);
      } else if (wheelItem.id == "top-s") {
          bounds = this.dockManager.layoutEngine.getDockBounds(rootNode, this.activeDialog.panel, "vertical", true);
      } else if (wheelItem.id == "down-s") {
          bounds = this.dockManager.layoutEngine.getDockBounds(rootNode, this.activeDialog.panel, "vertical", false);
      } else if (wheelItem.id == "left-s") {
          bounds = this.dockManager.layoutEngine.getDockBounds(rootNode, this.activeDialog.panel, "horizontal", true);
      } else if (wheelItem.id == "right-s") {
          bounds = this.dockManager.layoutEngine.getDockBounds(rootNode, this.activeDialog.panel, "horizontal", false);
      }

      if (bounds)
      {
          this.dockManager.element.appendChild(this.elementPanelPreview);
          this.elementPanelPreview.style.left = Math.round(bounds.x) + "px";
          this.elementPanelPreview.style.top = Math.round(bounds.y) + "px";
          this.elementPanelPreview.style.width = Math.round(bounds.width) + "px";
          this.elementPanelPreview.style.height = Math.round(bounds.height) + "px";
      }
  };

  dockspawn.DockWheel.prototype.onMouseOut = function(wheelItem, e)
  {
      removeNode(this.elementPanelPreview);
  };

  /**
   * Called if the dialog is dropped in a dock panel.
   * The dialog might not necessarily be dropped in one of the dock wheel buttons,
   * in which case the request will be ignored
   */
  dockspawn.DockWheel.prototype.onDialogDropped = function(dialog)
  {
      // Check if the dialog was dropped in one of the wheel items
      var wheelItem = this._getActiveWheelItem();
      if (wheelItem)
          { this._handleDockRequest(wheelItem, dialog); }
  };

  /**
   * Returns the wheel item which has the mouse cursor on top of it
   */
  dockspawn.DockWheel.prototype._getActiveWheelItem = function()
  {
      var this$1 = this;

      for (var wheelType in this$1.wheelItems)
      {
          var wheelItem = this$1.wheelItems[wheelType];
          if (wheelItem.active)
              { return wheelItem; }
      }
      return undefined;
  };

  dockspawn.DockWheel.prototype._handleDockRequest = function(wheelItem, dialog)
  {
      if (!this.activeNode)
          { return; }
      if (wheelItem.id == "left") {
          this.dockManager.dockDialogLeft(this.activeNode, dialog);
      } else if (wheelItem.id == "right") {
          this.dockManager.dockDialogRight(this.activeNode, dialog);
      } else if (wheelItem.id == "top") {
          this.dockManager.dockDialogUp(this.activeNode, dialog);
      } else if (wheelItem.id == "down") {
          this.dockManager.dockDialogDown(this.activeNode, dialog);
      } else if (wheelItem.id == "fill") {
          this.dockManager.dockDialogFill(this.activeNode, dialog);
      } else if (wheelItem.id == "left-s") {
          this.dockManager.dockDialogLeft(this.dockManager.context.model.rootNode, dialog);
      } else if (wheelItem.id == "right-s") {
          this.dockManager.dockDialogRight(this.dockManager.context.model.rootNode, dialog);
      } else if (wheelItem.id == "top-s") {
          this.dockManager.dockDialogUp(this.dockManager.context.model.rootNode, dialog);
      } else if (wheelItem.id == "down-s") {
          this.dockManager.dockDialogDown(this.dockManager.context.model.rootNode, dialog);
      }
  };

  function DockWheelItem(wheel, id)
  {
      this.wheel = wheel;
      this.id = id;
      var wheelType = id.replace("-s", "");
      this.element = document.createElement("div");
      this.element.classList.add("dock-wheel-item");
      this.element.classList.add("disable-selection");
      this.element.classList.add("dock-wheel-" + wheelType);
      this.element.classList.add("dock-wheel-" + wheelType + "-icon");
      this.hoverIconClass = "dock-wheel-" + wheelType + "-icon-hover";
      this.mouseOverHandler = new dockspawn.EventHandler(this.element, 'mouseover', this.onMouseMoved.bind(this));
      this.mouseOutHandler = new dockspawn.EventHandler(this.element, 'mouseout', this.onMouseOut.bind(this));
      this.active = false;    // Becomes active when the mouse is hovered over it
  }

  DockWheelItem.prototype.onMouseMoved = function(e)
  {
      this.active = true;
      this.element.classList.add(this.hoverIconClass);
      this.wheel.onMouseOver(this, e);
  };

  DockWheelItem.prototype.onMouseOut = function(e)
  {
      this.active = false;
      this.element.classList.remove(this.hoverIconClass);
      this.wheel.onMouseOut(this, e);
  };

  dockspawn.FillDockContainer = function(dockManager, tabStripDirection)
  {
      if (arguments.length == 0)
          { return; }

      if (tabStripDirection === undefined)
          { tabStripDirection = dockspawn.TabHost.DIRECTION_BOTTOM; }

      this.dockManager = dockManager;
      this.tabOrientation = tabStripDirection;
      this.name = getNextId("fill_");
      this.element = document.createElement("div");
      this.containerElement = this.element;
      this.containerType = "fill";
      this.minimumAllowedChildNodes = 2;
      this.element.classList.add("dock-container");
      this.element.classList.add("dock-container-fill");
      this.tabHost = new dockspawn.TabHost(this.tabOrientation);
      this.element.appendChild(this.tabHost.hostElement);
  };

  dockspawn.FillDockContainer.prototype.setActiveChild = function(child)
  {
      this.tabHost.setActiveTab(child);
  };

  dockspawn.FillDockContainer.prototype.resize = function(width, height)
  {
      this.element.style.width = width + "px";
      this.element.style.height = height + "px";
      this.tabHost.resize(width, height);
  };

  dockspawn.FillDockContainer.prototype.performLayout = function(children)
  {
      this.tabHost.performLayout(children);
  };

  dockspawn.FillDockContainer.prototype.destroy = function()
  {
      if (removeNode(this.element))
          { delete this.element; }
  };

  dockspawn.FillDockContainer.prototype.saveState = function(state)
  {
      state.width = this.width;
      state.height = this.height;
  };

  dockspawn.FillDockContainer.prototype.loadState = function(state)
  {
      this.width = state.width;
      this.height = state.height;
  };

  Object.defineProperty(dockspawn.FillDockContainer.prototype, "width", {
      get: function() { return this.element.clientWidth; },
      set: function(value) { this.element.style.width = value + "px"; }
  });

  Object.defineProperty(dockspawn.FillDockContainer.prototype, "height", {
      get: function() { return this.element.clientHeight; },
      set: function(value) { this.element.style.height = value + "px"; }
  });

  /**
   * The document manager is then central area of the dock layout hierarchy.
   * This is where more important panels are placed (e.g. the text editor in an IDE,
   * 3D view in a modelling package etc
   */
  dockspawn.DocumentManagerContainer = function(dockManager)
  {
      dockspawn.FillDockContainer.call(this, dockManager, dockspawn.TabHost.DIRECTION_TOP);
      this.minimumAllowedChildNodes = 0;
      this.element.classList.add("document-manager");
      this.tabHost.createTabPage = this._createDocumentTabPage;
      this.tabHost.displayCloseButton = true;
  };
  dockspawn.DocumentManagerContainer.prototype = new dockspawn.FillDockContainer();
  dockspawn.DocumentManagerContainer.prototype.constructor = dockspawn.DocumentManagerContainer;

  dockspawn.DocumentManagerContainer.prototype._createDocumentTabPage = function(tabHost, container)
  {
      return new dockspawn.DocumentTabPage(tabHost, container);
  };

  dockspawn.DocumentManagerContainer.prototype.saveState = function(state)
  {
      dockspawn.FillDockContainer.prototype.saveState.call(this, state);
      state.documentManager = true;
  };

  /** Returns the selected document tab */
  dockspawn.DocumentManagerContainer.prototype.selectedTab = function()
  {
      return this.tabHost.activeTab;
  };

  /**
   * Specialized tab page that doesn't display the panel's frame when docked in a tab page
   */
  dockspawn.DocumentTabPage = function(host, container)
  {
      dockspawn.TabPage.call(this, host, container);

      // If the container is a panel, extract the content element and set it as the tab's content
      if (this.container.containerType == "panel")
      {
          this.panel = container;
          this.containerElement = this.panel.elementContent;

          // detach the container element from the panel's frame.
          // It will be reattached when this tab page is destroyed
          // This enables the panel's frame (title bar etc) to be hidden
          // inside the tab page
          removeNode(this.containerElement);
      }
  };
  dockspawn.DocumentTabPage.prototype = new dockspawn.TabPage();
  dockspawn.DocumentTabPage.prototype.constructor = dockspawn.DocumentTabPage;

  dockspawn.DocumentTabPage.prototype.destroy = function()
  {
      dockspawn.TabPage.prototype.destroy.call(this);

      // Restore the panel content element back into the panel frame
      removeNode(this.containerElement);
      this.panel.elementContentHost.appendChild(this.containerElement);
  };
  /**
   * A splitter panel manages the child containers inside it with splitter bars.
   * It can be stacked horizontally or vertically
   */
  dockspawn.SplitterPanel = function(childContainers, stackedVertical)
  {
      this.childContainers = childContainers;
      this.stackedVertical = stackedVertical;
      this.panelElement = document.createElement('div');
      this.spiltterBars = [];
      this._buildSplitterDOM();
  };

  dockspawn.SplitterPanel.prototype._buildSplitterDOM = function()
  {
      var this$1 = this;

      if (this.childContainers.length <= 1)
          { throw new dockspawn.Exception("Splitter panel should contain atleast 2 panels"); }

      this.spiltterBars = [];
      for (var i = 0; i < this.childContainers.length - 1; i++)
      {
          var previousContainer = this$1.childContainers[i];
          var nextContainer = this$1.childContainers[i + 1];
          var splitterBar = new dockspawn.SplitterBar(previousContainer, nextContainer, this$1.stackedVertical);
          this$1.spiltterBars.push(splitterBar);

          // Add the container and split bar to the panel's base div element
          this$1._insertContainerIntoPanel(previousContainer);
          this$1.panelElement.appendChild(splitterBar.barElement);
      }
      this._insertContainerIntoPanel(this.childContainers.slice(-1)[0]);
  };

  dockspawn.SplitterPanel.prototype.performLayout = function(children)
  {
      this.removeFromDOM();

      // rebuild
      this.childContainers = children;
      this._buildSplitterDOM();
  };

  dockspawn.SplitterPanel.prototype.removeFromDOM = function()
  {
      this.childContainers.forEach(function(container)
      {
          if (container.containerElement)
          {
              container.containerElement.classList.remove("splitter-container-vertical");
              container.containerElement.classList.remove("splitter-container-horizontal");
              removeNode(container.containerElement);
          }
      });
      this.spiltterBars.forEach(function(bar) { removeNode(bar.barElement); });
  };

  dockspawn.SplitterPanel.prototype.destroy = function()
  {
      this.removeFromDOM();
      this.panelElement.parentNode.removeChild(this.panelElement);
  };

  dockspawn.SplitterPanel.prototype._insertContainerIntoPanel = function(container)
  {
      if (!container)
      {
          console.log('undefined');
      }

      removeNode(container.containerElement);
      this.panelElement.appendChild(container.containerElement);
      container.containerElement.classList.add(this.stackedVertical ? "splitter-container-vertical" : "splitter-container-horizontal");
  };

  /**
   * Sets the percentage of space the specified [container] takes in the split panel
   * The percentage is specified in [ratio] and is between 0..1
   */
  dockspawn.SplitterPanel.prototype.setContainerRatio = function(container, ratio)
  {
      var this$1 = this;

      var splitPanelSize = this.stackedVertical ? this.panelElement.clientHeight : this.panelElement.clientWidth;
      var newContainerSize = splitPanelSize * ratio;
      var barSize = this.stackedVertical ? this.spiltterBars[0].barElement.clientHeight : this.spiltterBars[0].barElement.clientWidth;

      var otherPanelSizeQuota = splitPanelSize - newContainerSize - barSize * this.spiltterBars.length;
      var otherPanelScaleMultipler = otherPanelSizeQuota / splitPanelSize;

      for (var i = 0; i < this.childContainers.length; i++)
      {
          var child = this$1.childContainers[i];
          var size;
          if (child !== container)
          {
              size = this$1.stackedVertical ? child.containerElement.clientHeight : child.containerElement.clientWidth;
              size *= otherPanelScaleMultipler;
          }
          else
              { size = newContainerSize; }

          if (this$1.stackedVertical)
              { child.resize(child.width, Math.floor(size)); }
          else
              { child.resize(Math.floor(size), child.height); }
      }
  };

  dockspawn.SplitterPanel.prototype.resize = function(width, height)
  {
      var this$1 = this;

      if (this.childContainers.length <= 1)
          { return; }

      // Adjust the fixed dimension that is common to all (i.e. width, if stacked vertical; height, if stacked horizontally)
      for (var i = 0; i < this.childContainers.length; i++)
      {
          var childContainer = this$1.childContainers[i];
          if (this$1.stackedVertical)
              { childContainer.resize(width, childContainer.height); }
          else
              { childContainer.resize(childContainer.width, height); }

          if (i < this$1.spiltterBars.length) {
              var splitBar = this$1.spiltterBars[i];
              if (this$1.stackedVertical)
                  { splitBar.barElement.style.width = width + "px"; }
              else
                  { splitBar.barElement.style.height = height + "px"; }
          }
      }

      // Adjust the varying dimension
      var totalChildPanelSize = 0;
      // Find out how much space existing child containers take up (excluding the splitter bars)
      var self = this;
      this.childContainers.forEach(function(container)
      {
          var size = self.stackedVertical ?
              container.height :
              container.width;
          totalChildPanelSize += size;
      });

      // Get the thickness of the bar
      var barSize = this.stackedVertical ? this.spiltterBars[0].barElement.clientHeight : this.spiltterBars[0].barElement.clientWidth;

      // Find out how much space existing child containers will take after being resized (excluding the splitter bars)
      var targetTotalChildPanelSize = this.stackedVertical ? height : width;
      targetTotalChildPanelSize -= barSize * this.spiltterBars.length;

      // Get the scale multiplier
      totalChildPanelSize = Math.max(totalChildPanelSize, 1);
      var scaleMultiplier = targetTotalChildPanelSize / totalChildPanelSize;

      // Update the size with this multiplier
      var updatedTotalChildPanelSize = 0;
      for (var i = 0; i < this.childContainers.length; i++)
      {
          var child = this$1.childContainers[i];
          var original = this$1.stackedVertical ?
              child.containerElement.clientHeight :
              child.containerElement.clientWidth;

          var newSize = Math.floor(original * scaleMultiplier);
          updatedTotalChildPanelSize += newSize;

          // If this is the last node, add any extra pixels to fix the rounding off errors and match the requested size
          if (i == this$1.childContainers.length - 1)
              { newSize += targetTotalChildPanelSize - updatedTotalChildPanelSize; }

          // Set the size of the panel
          if (this$1.stackedVertical)
              { child.resize(child.width, newSize); }
          else
              { child.resize(newSize, child.height); }
      }

      this.panelElement.style.width = width + "px";
      this.panelElement.style.height = height + "px";
  };

  dockspawn.SplitterDockContainer = function(name, dockManager, childContainers)
  {
      // for prototype inheritance purposes only
      if (arguments.length == 0)
          { return; }

      this.name = name;
      this.dockManager = dockManager;
      this.splitterPanel = new dockspawn.SplitterPanel(childContainers, this.stackedVertical);
      this.containerElement = this.splitterPanel.panelElement;
      this.minimumAllowedChildNodes = 2;
  };

  dockspawn.SplitterDockContainer.prototype.resize = function(width, height)
  {
      //    if (_cachedWidth == _cachedWidth && _cachedHeight == _height) {
      //      // No need to resize
      //      return;
      //    }
      this.splitterPanel.resize(width, height);
      this._cachedWidth = width;
      this._cachedHeight = height;
  };

  dockspawn.SplitterDockContainer.prototype.performLayout = function(childContainers)
  {
      this.splitterPanel.performLayout(childContainers);
  };

  dockspawn.SplitterDockContainer.prototype.setActiveChild = function(child)
  {
  };

  dockspawn.SplitterDockContainer.prototype.destroy = function()
  {
      this.splitterPanel.destroy();
  };

  /**
   * Sets the percentage of space the specified [container] takes in the split panel
   * The percentage is specified in [ratio] and is between 0..1
   */
  dockspawn.SplitterDockContainer.prototype.setContainerRatio = function(container, ratio)
  {
      this.splitterPanel.setContainerRatio(container, ratio);
      this.resize(this.width, this.height);
  };

  dockspawn.SplitterDockContainer.prototype.saveState = function(state)
  {
      state.width = this.width;
      state.height = this.height;
  };

  dockspawn.SplitterDockContainer.prototype.loadState = function(state)
  {
      this.resize(state.width, state.height);
  };

  Object.defineProperty(dockspawn.SplitterDockContainer.prototype, "width", {
      get: function()
           {
               if (this._cachedWidth === undefined)
                   { this._cachedWidth = this.splitterPanel.panelElement.clientWidth; }
               return this._cachedWidth;
           }
  });

  Object.defineProperty(dockspawn.SplitterDockContainer.prototype, "height", {
      get: function()
           {
               if (this._cachedHeight === undefined)
                   { this._cachedHeight = this.splitterPanel.panelElement.clientHeight; }
               return this._cachedHeight;
           }
  });

  dockspawn.HorizontalDockContainer = function(dockManager, childContainers)
  {
      this.stackedVertical = false;
      dockspawn.SplitterDockContainer.call(this, getNextId("horizontal_splitter_"), dockManager, childContainers);
      this.containerType = "horizontal";
  };
  dockspawn.HorizontalDockContainer.prototype = new dockspawn.SplitterDockContainer();
  dockspawn.HorizontalDockContainer.prototype.constructor = dockspawn.HorizontalDockContainer;
  /**
   * This dock container wraps the specified element on a panel frame with a title bar and close button
   */
  dockspawn.PanelContainer = function(elementContent, dockManager, title)
  {
      if (!title)
          { title = "Panel"; }
      this.elementContent = elementContent;
      this.dockManager = dockManager;
      this.title = title;
      this.containerType = "panel";
      this.iconName = "fa fa-arrow-circle-right";
      this.minimumAllowedChildNodes = 0;
      this._floatingDialog = undefined;
      this._initialize();
  };

  Object.defineProperty(dockspawn.PanelContainer.prototype, "floatingDialog", {
      get: function() { return this._floatingDialog; },
      set: function(value)
           {
               this._floatingDialog = value;
               var canUndock = (this._floatingDialog === undefined);
               this.undockInitiator.enabled = canUndock;
           }
  });

  dockspawn.PanelContainer.loadFromState = function(state, dockManager)
  {
      var elementName = state.element;
      var elementContent = document.getElementById(elementName);
      var ret = new dockspawn.PanelContainer(elementContent, dockManager);
      ret.elementContent = elementContent;
      ret._initialize();
      ret.loadState(state);
      return ret;
  };

  dockspawn.PanelContainer.prototype.saveState = function(state)
  {
      state.element = this.elementContent.id;
      state.width = this.width;
      state.height = this.height;
  };

  dockspawn.PanelContainer.prototype.loadState = function(state)
  {
      this.width = state.width;
      this.height = state.height;
      this.resize(this.width, this.height);
  };

  dockspawn.PanelContainer.prototype.setActiveChild = function(child)
  {
  };

  Object.defineProperty(dockspawn.PanelContainer.prototype, "containerElement", {
      get: function() { return this.elementPanel; }
  });

  dockspawn.PanelContainer.prototype._initialize = function()
  {
      this.name = getNextId("panel_");
      this.elementPanel = document.createElement('div');
      this.elementTitle = document.createElement('div');
      this.elementTitleText = document.createElement('div');
      this.elementContentHost = document.createElement('div');
      this.elementButtonClose = document.createElement('div');

      this.elementPanel.appendChild(this.elementTitle);
      this.elementTitle.appendChild(this.elementTitleText);
      this.elementTitle.appendChild(this.elementButtonClose);
      this.elementButtonClose.innerHTML = '<i class="fa fa-times"></i>';
      this.elementButtonClose.classList.add("panel-titlebar-button-close");
      this.elementPanel.appendChild(this.elementContentHost);

      this.elementPanel.classList.add("panel-base");
      this.elementTitle.classList.add("panel-titlebar");
      this.elementTitle.classList.add("disable-selection");
      this.elementTitleText.classList.add("panel-titlebar-text");
      this.elementContentHost.classList.add("panel-content");

      // set the size of the dialog elements based on the panel's size
      var panelWidth = this.elementContent.clientWidth;
      var panelHeight = this.elementContent.clientHeight;
      var titleHeight = this.elementTitle.clientHeight;
      this._setPanelDimensions(panelWidth, panelHeight + titleHeight);

      // Add the panel to the body
      document.body.appendChild(this.elementPanel);

      this.closeButtonClickedHandler = new dockspawn.EventHandler(this.elementButtonClose, 'click', this.onCloseButtonClicked.bind(this));

      removeNode(this.elementContent);
      this.elementContentHost.appendChild(this.elementContent);

      // Extract the title from the content element's attribute
      var contentTitle = this.elementContent.getAttribute('caption');
      var contentIcon = this.elementContent.getAttribute('icon');
      if (contentTitle != null) { this.title = contentTitle; }
      if (contentIcon != null) { this.iconName = contentIcon; }
      this._updateTitle();

      this.undockInitiator = new dockspawn.UndockInitiator(this.elementTitle, this.performUndockToDialog.bind(this));
      delete this.floatingDialog;
  };

  dockspawn.PanelContainer.prototype.destroy = function()
  {
      removeNode(this.elementPanel);
      if (this.closeButtonClickedHandler)
      {
          this.closeButtonClickedHandler.cancel();
          delete this.closeButtonClickedHandler;
      }
  };

  /**
   * Undocks the panel and and converts it to a dialog box
   */
  dockspawn.PanelContainer.prototype.performUndockToDialog = function(e, dragOffset)
  {
      this.undockInitiator.enabled = false;
      return this.dockManager.requestUndockToDialog(this, e, dragOffset);
  };

  /**
   * Undocks the container and from the layout hierarchy
   * The container would be removed from the DOM
   */
  dockspawn.PanelContainer.prototype.performUndock = function()
  {
      this.undockInitiator.enabled = false;
      this.dockManager.requestUndock(this);
  };

  dockspawn.PanelContainer.prototype.prepareForDocking = function()
  {
      this.undockInitiator.enabled = true;
  };

  Object.defineProperty(dockspawn.PanelContainer.prototype, "width", {
      get: function() { return this._cachedWidth; },
      set: function(value)
           {
               if (value !== this._cachedWidth)
               {
                   this._cachedWidth = value;
                   this.elementPanel.style.width = value + "px";
               }
           }
  });

  Object.defineProperty(dockspawn.PanelContainer.prototype, "height", {
      get: function() { return this._cachedHeight; },
      set: function(value)
           {
               if (value !== this._cachedHeight)
               {
                   this._cachedHeight = value;
                   this.elementPanel.style.height = value + "px";
               }
           }
  });

  dockspawn.PanelContainer.prototype.resize = function(width,  height)
  {
      if (this._cachedWidth == width && this._cachedHeight == height)
      {
          // Already in the desired size
          return;
      }
      this._setPanelDimensions(width, height);
      this._cachedWidth = width;
      this._cachedHeight = height;
  };

  dockspawn.PanelContainer.prototype._setPanelDimensions = function(width, height)
  {
      this.elementTitle.style.width = width + "px";
      this.elementContentHost.style.width = width + "px";
      this.elementContent.style.width = width + "px";
      this.elementPanel.style.width = width + "px";

      var titleBarHeight = this.elementTitle.clientHeight;
      var contentHeight = height - titleBarHeight;
      this.elementContentHost.style.height = contentHeight + "px";
      this.elementContent.style.height = contentHeight + "px";
      this.elementPanel.style.height = height + "px";
  };

  dockspawn.PanelContainer.prototype.setTitle = function(title)
  {
      this.title = title;
      this._updateTitle();
      if (this.onTitleChanged)
          { this.onTitleChanged(this, title); }
  };

  dockspawn.PanelContainer.prototype.setTitleIcon = function(iconName)
  {
      this.iconName = iconName;
      this._updateTitle();
  };

  dockspawn.PanelContainer.prototype._updateTitle = function()
  {
      this.elementTitleText.innerHTML = '<i class="' + this.iconName + '"></i> ' + this.title;
  };

  dockspawn.PanelContainer.prototype.getRawTitle = function()
  {
      return this.elementTitleText.innerHTML;
  };

  dockspawn.PanelContainer.prototype.performLayout = function(children)
  {
  };

  dockspawn.PanelContainer.prototype.onCloseButtonClicked = function(e)
  {
      if (this.floatingDialog)
          { this.floatingDialog.destroy(); }
      else
      {
          this.performUndock();
          this.destroy();
      }
  };

  dockspawn.VerticalDockContainer = function(dockManager, childContainers)
  {
      this.stackedVertical = true;
      dockspawn.SplitterDockContainer.call(this, getNextId("vertical_splitter_"), dockManager, childContainers);
      this.containerType = "vertical";
  };
  dockspawn.VerticalDockContainer.prototype = new dockspawn.SplitterDockContainer();
  dockspawn.VerticalDockContainer.prototype.constructor = dockspawn.VerticalDockContainer;
  dockspawn.SplitterBar = function(previousContainer, nextContainer, stackedVertical)
  {
      this.previousContainer = previousContainer; // The panel to the left/top side of the bar, depending on the bar orientation
      this.nextContainer = nextContainer;         // The panel to the right/bottom side of the bar, depending on the bar orientation
      this.stackedVertical = stackedVertical;
      this.barElement = document.createElement('div');
      this.barElement.classList.add(stackedVertical ? "splitbar-horizontal" : "splitbar-vertical");
      this.mouseDownHandler = new dockspawn.EventHandler(this.barElement, 'mousedown', this.onMouseDown.bind(this));
      this.minPanelSize = 50; // TODO: Get from container configuration
      this.readyToProcessNextDrag = true;
  };

  dockspawn.SplitterBar.prototype.onMouseDown = function(e)
  {
      this._startDragging(e);
  };

  dockspawn.SplitterBar.prototype.onMouseUp = function(e)
  {
      this._stopDragging(e);
  };

  dockspawn.SplitterBar.prototype.onMouseMoved = function(e)
  {
      if (!this.readyToProcessNextDrag)
          { return; }
      this.readyToProcessNextDrag = false;

      var dockManager = this.previousContainer.dockManager;
      dockManager.suspendLayout();
      var dx = e.pageX - this.previousMouseEvent.pageX;
      var dy = e.pageY - this.previousMouseEvent.pageY;
      this._performDrag(dx, dy);
      this.previousMouseEvent = e;
      this.readyToProcessNextDrag = true;
      dockManager.resumeLayout();
  };

  dockspawn.SplitterBar.prototype._performDrag = function(dx, dy)
  {
      var previousWidth = this.previousContainer.containerElement.clientWidth;
      var previousHeight = this.previousContainer.containerElement.clientHeight;
      var nextWidth = this.nextContainer.containerElement.clientWidth;
      var nextHeight = this.nextContainer.containerElement.clientHeight;

      var previousPanelSize = this.stackedVertical ? previousHeight : previousWidth;
      var nextPanelSize = this.stackedVertical ? nextHeight : nextWidth;
      var deltaMovement = this.stackedVertical ? dy : dx;
      var newPreviousPanelSize = previousPanelSize + deltaMovement;
      var newNextPanelSize = nextPanelSize - deltaMovement;

      if (newPreviousPanelSize < this.minPanelSize || newNextPanelSize < this.minPanelSize)
      {
          // One of the panels is smaller than it should be.
          // In that case, check if the small panel's size is being increased
          var continueProcessing = (newPreviousPanelSize < this.minPanelSize && newPreviousPanelSize > previousPanelSize) ||
              (newNextPanelSize < this.minPanelSize && newNextPanelSize > nextPanelSize);

          if (!continueProcessing)
              { return; }
      }

      if (this.stackedVertical)
      {
          this.previousContainer.resize(previousWidth, newPreviousPanelSize);
          this.nextContainer.resize(nextWidth, newNextPanelSize);
      }
      else
      {
          this.previousContainer.resize(newPreviousPanelSize, previousHeight);
          this.nextContainer.resize(newNextPanelSize, nextHeight);
      }
  };

  dockspawn.SplitterBar.prototype._startDragging = function(e)
  {
      disableGlobalTextSelection();
      if (this.mouseMovedHandler)
      {
          this.mouseMovedHandler.cancel();
          delete this.mouseMovedHandler;
      }
      if (this.mouseUpHandler)
      {
          this.mouseUpHandler.cancel();
          delete this.mouseUpHandler;
      }
      this.mouseMovedHandler = new dockspawn.EventHandler(window, 'mousemove', this.onMouseMoved.bind(this));
      this.mouseUpHandler = new dockspawn.EventHandler(window, 'mouseup', this.onMouseUp.bind(this));
      this.previousMouseEvent = e;
  };

  dockspawn.SplitterBar.prototype._stopDragging = function(e)
  {
      enableGlobalTextSelection();
      document.body.classList.remove("disable-selection");
      if (this.mouseMovedHandler)
      {
          this.mouseMovedHandler.cancel();
          delete this.mouseMovedHandler;
      }
      if (this.mouseUpHandler)
      {
          this.mouseUpHandler.cancel();
          delete this.mouseUpHandler;
      }
  };
  /**
   * Deserializes the dock layout hierarchy from JSON and creates a dock hierarhcy graph
   */
  dockspawn.DockGraphDeserializer = function(dockManager)
  {
      this.dockManager = dockManager;
  };

  dockspawn.DockGraphDeserializer.prototype.deserialize = function(json)
  {
      var graphInfo = JSON.parse(_json);
      var model = new dockspawn.DockModel();
      model.rootNode = this._buildGraph(graphInfo);
      return model;
  };

  dockspawn.DockGraphDeserializer.prototype._buildGraph = function(nodeInfo)
  {
      var childrenInfo = nodeInfo.children;
      var children = [];
      var self = this;
      childrenInfo.forEach(function(childInfo)
      {
          var childNode = self._buildGraph(childInfo);
          children.push(childNode);
      });

      // Build the container owned by this node
      var container = this._createContainer(nodeInfo, children);

      // Build the node for this container and attach it's children
      var node = new dockspawn.DockNode(container);
      node.children = children;
      node.children.forEach(function(childNode) { childNode.parent = node; });

      return node;
  };

  dockspawn.DockGraphDeserializer.prototype._createContainer = function(nodeInfo, children)
  {
      var containerType = nodeInfo.containerType;
      var containerState = nodeInfo.state;
      var container;

      var childContainers = [];
      children.forEach(function(childNode) { childContainers.push(childNode.container); });
      childContainers = [];

      if (containerType == "panel")
          { container = new dockspawn.PanelContainer.loadFromState(containerState, this.dockManager); }
      else if (containerType == "horizontal")
          { container = new dockspawn.HorizontalDockContainer(this.dockManager, childContainers); }
      else if (containerType == "vertical")
          { container = new dockspawn.VerticalDockContainer(this.dockManager, childContainers); }
      else if (containerType == "fill")
      {
          // Check if this is a document manager

          // TODO: Layout engine compares the string "fill", so cannot create another subclass type
          // called document_manager and have to resort to this hack. use RTTI in layout engine
          var typeDocumentManager = containerState.documentManager;
          if (typeDocumentManager)
              { container = new DocumentManagerContainer(this.dockManager); }
          else
              { container = new dockspawn.FillDockContainer(this.dockManager); }
      }
      else
          { throw new dockspawn.Exception("Cannot create dock container of unknown type: " + containerType); }

      // Restore the state of the container
      container.loadState(containerState);
      container.performLayout(childContainers);
      return container;
  };
  /**
   * The serializer saves / loads the state of the dock layout hierarchy
   */
  dockspawn.DockGraphSerializer = function()
  {
  };

  dockspawn.DockGraphSerializer.prototype.serialize = function(model)
  {
      var graphInfo = this._buildGraphInfo(model.rootNode);
      return JSON.stringify(graphInfo);
  };

  dockspawn.DockGraphSerializer.prototype._buildGraphInfo = function(node)
  {
      var nodeState = {};
      node.container.saveState(nodeState);

      var childrenInfo = [];
      var self = this;
      node.childNodes.forEach(function(childNode) {
          childrenInfo.push(self._buildGraphInfo(childNode));
      });

      var nodeInfo = {};
      nodeInfo.containerType = node.container.containerType;
      nodeInfo.state = nodeState;
      nodeInfo.children = childrenInfo;
      return nodeInfo;
  };
  function getPixels(pixels)
  {
      if (pixels == null)
          { return 0; }
      return parseInt(pixels.replace("px", ""));
  }

  function disableGlobalTextSelection()
  {
      document.body.classList.add("disable-selection");
  }

  function enableGlobalTextSelection()
  {
      document.body.classList.remove("disable-selection");
  }

  function isPointInsideNode(px, py, node)
  {
      var element = node.container.containerElement;
      var x = element.offsetLeft;
      var y = element.offsetTop;
      var width = element.clientWidth;
      var height = element.clientHeight;

      return (px >= x && px <= x + width && py >= y && py <= y + height);
  }

  function Rectangle()
  {
      //    num x;
      //    num y;
      //    num width;
      //    num height;
  }

  function getNextId(prefix)
  {
      return prefix + getNextId.counter++;
  }
  getNextId.counter = 0;

  function removeNode(node)
  {
      if (node.parentNode == null)
          { return false; }
      node.parentNode.removeChild(node);
      return true;
  }

  function Point(x, y)
  {
      this.x = x;
      this.y = y;
  }
  dockspawn.EventHandler = function(source, eventName, target)
  {
      // wrap the target
      this.target = target;
      this.eventName = eventName;
      this.source = source;

      this.source.addEventListener(eventName, this.target);
  };

  dockspawn.EventHandler.prototype.cancel = function()
  {
      this.source.removeEventListener(this.eventName, this.target);
  };
  /**
   * Listens for events on the [element] and notifies the [listener]
   * if an undock event has been invoked.  An undock event is invoked
   * when the user clicks on the event and drags is beyond the
   * specified [thresholdPixels]
   */
  dockspawn.UndockInitiator = function(element, listener, thresholdPixels)
  {
      if (!thresholdPixels)
          { thresholdPixels = 10; }

      this.element = element;
      this.listener = listener;
      this.thresholdPixels = thresholdPixels;
      this._enabled = false;
  };

  Object.defineProperty(dockspawn.UndockInitiator.prototype, "enabled", {
      get: function() { return this._enabled; },
      set: function(value)
           {
               this._enabled = value;
               if (this._enabled)
               {
                   if (this.mouseDownHandler)
                   {
                       this.mouseDownHandler.cancel();
                       delete this.mouseDownHandler;
                   }
                   this.mouseDownHandler = new dockspawn.EventHandler(this.element, 'mousedown', this.onMouseDown.bind(this));
               }
               else
               {
                   if (this.mouseDownHandler)
                   {
                       this.mouseDownHandler.cancel();
                       delete this.mouseDownHandler;
                   }
                   if (this.mouseUpHandler)
                   {
                       this.mouseUpHandler.cancel();
                       delete this.mouseUpHandler;
                   }
                   if (this.mouseMoveHandler)
                   {
                       this.mouseMoveHandler.cancel();
                       delete this.mouseMoveHandler;
                   }
               }
           }
  });

  dockspawn.UndockInitiator.prototype.onMouseDown = function(e)
  {
      // Make sure we dont do this on floating dialogs
      if (this.enabled)
      {
          if (this.mouseUpHandler)
          {
              this.mouseUpHandler.cancel();
              delete this.mouseUpHandler;
          }
          if (this.mouseMoveHandler)
          {
              this.mouseMoveHandler.cancel();
              delete this.mouseMoveHandler;
          }
          this.mouseUpHandler = new dockspawn.EventHandler(window, 'mouseup', this.onMouseUp.bind(this));
          this.mouseMoveHandler = new dockspawn.EventHandler(window, 'mousemove', this.onMouseMove.bind(this));
          this.dragStartPosition = new Point(e.pageX, e.pageY);
      }
  };

  dockspawn.UndockInitiator.prototype.onMouseUp = function(e)
  {
      if (this.mouseUpHandler)
      {
          this.mouseUpHandler.cancel();
          delete this.mouseUpHandler;
      }
      if (this.mouseMoveHandler)
      {
          this.mouseMoveHandler.cancel();
          delete this.mouseMoveHandler;
      }
  };

  dockspawn.UndockInitiator.prototype.onMouseMove = function(e)
  {
      var position = new Point(e.pageX, e.pageY);
      var dx = position.x - this.dragStartPosition.x;
      var dy = position.y - this.dragStartPosition.y;
      var distance = Math.sqrt(dx * dx + dy * dy);

      if (distance > this.thresholdPixels)
      {
          this.enabled = false;
          this._requestUndock(e);
      }
  };

  dockspawn.UndockInitiator.prototype._requestUndock = function(e)
  {
      var dragOffsetX = this.dragStartPosition.x - this.element.offsetLeft;
      var dragOffsetY = this.dragStartPosition.y - this.element.offsetTop;
      var dragOffset = new Point(dragOffsetX, dragOffsetY);
      this.listener(e, dragOffset);
  };

  // Polyfills

  if ( Number.EPSILON === undefined ) {

  	Number.EPSILON = Math.pow( 2, - 52 );

  }

  if ( Number.isInteger === undefined ) {

  	// Missing in IE
  	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger

  	Number.isInteger = function ( value ) {

  		return typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value;

  	};

  }

  //

  if ( Math.sign === undefined ) {

  	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

  	Math.sign = function ( x ) {

  		return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

  	};

  }

  if ( Function.prototype.name === undefined ) {

  	// Missing in IE
  	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

  	Object.defineProperty( Function.prototype, 'name', {

  		get: function () {

  			return this.toString().match( /^\s*function\s*([^\(\s]*)/ )[ 1 ];

  		}

  	} );

  }

  if ( Object.assign === undefined ) {

  	// Missing in IE
  	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

  	( function () {

  		Object.assign = function ( target ) {

  			var arguments$1 = arguments;


  			if ( target === undefined || target === null ) {

  				throw new TypeError( 'Cannot convert undefined or null to object' );

  			}

  			var output = Object( target );

  			for ( var index = 1; index < arguments.length; index ++ ) {

  				var source = arguments$1[ index ];

  				if ( source !== undefined && source !== null ) {

  					for ( var nextKey in source ) {

  						if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {

  							output[ nextKey ] = source[ nextKey ];

  						}

  					}

  				}

  			}

  			return output;

  		};

  	} )();

  }

  /**
   * https://github.com/mrdoob/eventdispatcher.js/
   */

  function EventDispatcher$1() {}

  Object.assign( EventDispatcher$1.prototype, {

  	addEventListener: function ( type, listener ) {

  		if ( this._listeners === undefined ) { this._listeners = {}; }

  		var listeners = this._listeners;

  		if ( listeners[ type ] === undefined ) {

  			listeners[ type ] = [];

  		}

  		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

  			listeners[ type ].push( listener );

  		}

  	},

  	hasEventListener: function ( type, listener ) {

  		if ( this._listeners === undefined ) { return false; }

  		var listeners = this._listeners;

  		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

  	},

  	removeEventListener: function ( type, listener ) {

  		if ( this._listeners === undefined ) { return; }

  		var listeners = this._listeners;
  		var listenerArray = listeners[ type ];

  		if ( listenerArray !== undefined ) {

  			var index = listenerArray.indexOf( listener );

  			if ( index !== - 1 ) {

  				listenerArray.splice( index, 1 );

  			}

  		}

  	},

  	dispatchEvent: function ( event ) {
  		var this$1 = this;


  		if ( this._listeners === undefined ) { return; }

  		var listeners = this._listeners;
  		var listenerArray = listeners[ event.type ];

  		if ( listenerArray !== undefined ) {

  			event.target = this;

  			var array = listenerArray.slice( 0 );

  			for ( var i = 0, l = array.length; i < l; i ++ ) {

  				array[ i ].call( this$1, event );

  			}

  		}

  	}

  } );

  var REVISION$1 = '88dev';
  var CullFaceNone$1 = 0;
  var CullFaceBack$1 = 1;
  var CullFaceFront$1 = 2;
  var FrontFaceDirectionCW$1 = 0;
  var PCFShadowMap$1 = 1;
  var PCFSoftShadowMap$1 = 2;
  var FrontSide$1 = 0;
  var BackSide$1 = 1;
  var DoubleSide$1 = 2;
  var FlatShading$1 = 1;
  var NoColors$1 = 0;
  var FaceColors$1 = 1;
  var VertexColors$1 = 2;
  var NoBlending$1 = 0;
  var NormalBlending$1 = 1;
  var AdditiveBlending$1 = 2;
  var SubtractiveBlending$1 = 3;
  var MultiplyBlending$1 = 4;
  var CustomBlending$1 = 5;
  var AddEquation$1 = 100;
  var SubtractEquation$1 = 101;
  var ReverseSubtractEquation$1 = 102;
  var MinEquation$1 = 103;
  var MaxEquation$1 = 104;
  var ZeroFactor$1 = 200;
  var OneFactor$1 = 201;
  var SrcColorFactor$1 = 202;
  var OneMinusSrcColorFactor$1 = 203;
  var SrcAlphaFactor$1 = 204;
  var OneMinusSrcAlphaFactor$1 = 205;
  var DstAlphaFactor$1 = 206;
  var OneMinusDstAlphaFactor$1 = 207;
  var DstColorFactor$1 = 208;
  var OneMinusDstColorFactor$1 = 209;
  var SrcAlphaSaturateFactor$1 = 210;
  var NeverDepth$1 = 0;
  var AlwaysDepth$1 = 1;
  var LessDepth$1 = 2;
  var LessEqualDepth$1 = 3;
  var EqualDepth$1 = 4;
  var GreaterEqualDepth$1 = 5;
  var GreaterDepth$1 = 6;
  var NotEqualDepth$1 = 7;
  var MultiplyOperation$1 = 0;
  var MixOperation$1 = 1;
  var AddOperation$1 = 2;
  var NoToneMapping$1 = 0;
  var LinearToneMapping$1 = 1;
  var ReinhardToneMapping$1 = 2;
  var Uncharted2ToneMapping$1 = 3;
  var CineonToneMapping$1 = 4;
  var UVMapping$1 = 300;
  var CubeReflectionMapping$1 = 301;
  var CubeRefractionMapping$1 = 302;
  var EquirectangularReflectionMapping$1 = 303;
  var EquirectangularRefractionMapping$1 = 304;
  var SphericalReflectionMapping$1 = 305;
  var CubeUVReflectionMapping$1 = 306;
  var CubeUVRefractionMapping$1 = 307;
  var RepeatWrapping$1 = 1000;
  var ClampToEdgeWrapping$1 = 1001;
  var MirroredRepeatWrapping$1 = 1002;
  var NearestFilter$1 = 1003;
  var NearestMipMapNearestFilter$1 = 1004;
  var NearestMipMapLinearFilter$1 = 1005;
  var LinearFilter$1 = 1006;
  var LinearMipMapNearestFilter$1 = 1007;
  var LinearMipMapLinearFilter$1 = 1008;
  var UnsignedByteType$1 = 1009;
  var ByteType$1 = 1010;
  var ShortType$1 = 1011;
  var UnsignedShortType$1 = 1012;
  var IntType$1 = 1013;
  var UnsignedIntType$1 = 1014;
  var FloatType$1 = 1015;
  var HalfFloatType$1 = 1016;
  var UnsignedShort4444Type$1 = 1017;
  var UnsignedShort5551Type$1 = 1018;
  var UnsignedShort565Type$1 = 1019;
  var UnsignedInt248Type$1 = 1020;
  var AlphaFormat$1 = 1021;
  var RGBFormat$1 = 1022;
  var RGBAFormat$1 = 1023;
  var LuminanceFormat$1 = 1024;
  var LuminanceAlphaFormat$1 = 1025;
  var DepthFormat$1 = 1026;
  var DepthStencilFormat$1 = 1027;
  var RGB_S3TC_DXT1_Format$1 = 2001;
  var RGBA_S3TC_DXT1_Format$1 = 2002;
  var RGBA_S3TC_DXT3_Format$1 = 2003;
  var RGBA_S3TC_DXT5_Format$1 = 2004;
  var RGB_PVRTC_4BPPV1_Format$1 = 2100;
  var RGB_PVRTC_2BPPV1_Format$1 = 2101;
  var RGBA_PVRTC_4BPPV1_Format$1 = 2102;
  var RGBA_PVRTC_2BPPV1_Format$1 = 2103;
  var RGB_ETC1_Format$1 = 2151;
  var LoopOnce$1 = 2200;
  var LoopRepeat$1 = 2201;
  var LoopPingPong$1 = 2202;
  var InterpolateDiscrete$1 = 2300;
  var InterpolateLinear$1 = 2301;
  var InterpolateSmooth$1 = 2302;
  var ZeroCurvatureEnding$1 = 2400;
  var ZeroSlopeEnding$1 = 2401;
  var WrapAroundEnding$1 = 2402;
  var TrianglesDrawMode$1 = 0;
  var TriangleStripDrawMode$1 = 1;
  var TriangleFanDrawMode$1 = 2;
  var LinearEncoding$1 = 3000;
  var sRGBEncoding$1 = 3001;
  var GammaEncoding$1 = 3007;
  var RGBEEncoding$1 = 3002;
  var RGBM7Encoding$1 = 3004;
  var RGBM16Encoding$1 = 3005;
  var RGBDEncoding$1 = 3006;
  var BasicDepthPacking$1 = 3200;
  var RGBADepthPacking$1 = 3201;

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   */

  var _Math$1 = {

  	DEG2RAD: Math.PI / 180,
  	RAD2DEG: 180 / Math.PI,

  	generateUUID: function () {

  		// http://www.broofa.com/Tools/Math.uuid.htm

  		var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
  		var uuid = new Array( 36 );
  		var rnd = 0, r;

  		return function generateUUID() {

  			for ( var i = 0; i < 36; i ++ ) {

  				if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

  					uuid[ i ] = '-';

  				} else if ( i === 14 ) {

  					uuid[ i ] = '4';

  				} else {

  					if ( rnd <= 0x02 ) { rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0; }
  					r = rnd & 0xf;
  					rnd = rnd >> 4;
  					uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

  				}

  			}

  			return uuid.join( '' );

  		};

  	}(),

  	clamp: function ( value, min, max ) {

  		return Math.max( min, Math.min( max, value ) );

  	},

  	// compute euclidian modulo of m % n
  	// https://en.wikipedia.org/wiki/Modulo_operation

  	euclideanModulo: function ( n, m ) {

  		return ( ( n % m ) + m ) % m;

  	},

  	// Linear mapping from range <a1, a2> to range <b1, b2>

  	mapLinear: function ( x, a1, a2, b1, b2 ) {

  		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

  	},

  	// https://en.wikipedia.org/wiki/Linear_interpolation

  	lerp: function ( x, y, t ) {

  		return ( 1 - t ) * x + t * y;

  	},

  	// http://en.wikipedia.org/wiki/Smoothstep

  	smoothstep: function ( x, min, max ) {

  		if ( x <= min ) { return 0; }
  		if ( x >= max ) { return 1; }

  		x = ( x - min ) / ( max - min );

  		return x * x * ( 3 - 2 * x );

  	},

  	smootherstep: function ( x, min, max ) {

  		if ( x <= min ) { return 0; }
  		if ( x >= max ) { return 1; }

  		x = ( x - min ) / ( max - min );

  		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

  	},

  	// Random integer from <low, high> interval

  	randInt: function ( low, high ) {

  		return low + Math.floor( Math.random() * ( high - low + 1 ) );

  	},

  	// Random float from <low, high> interval

  	randFloat: function ( low, high ) {

  		return low + Math.random() * ( high - low );

  	},

  	// Random float from <-range/2, range/2> interval

  	randFloatSpread: function ( range ) {

  		return range * ( 0.5 - Math.random() );

  	},

  	degToRad: function ( degrees ) {

  		return degrees * _Math$1.DEG2RAD;

  	},

  	radToDeg: function ( radians ) {

  		return radians * _Math$1.RAD2DEG;

  	},

  	isPowerOfTwo: function ( value ) {

  		return ( value & ( value - 1 ) ) === 0 && value !== 0;

  	},

  	ceilPowerOfTwo: function ( value ) {

  		return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

  	},

  	floorPowerOfTwo: function ( value ) {

  		return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

  	}

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author philogb / http://blog.thejit.org/
   * @author egraether / http://egraether.com/
   * @author zz85 / http://www.lab4games.net/zz85/blog
   */

  function Vector2$1( x, y ) {

  	this.x = x || 0;
  	this.y = y || 0;

  }

  Object.defineProperties( Vector2$1.prototype, {

  	"width": {

  		get: function () {

  			return this.x;

  		},

  		set: function ( value ) {

  			this.x = value;

  		}

  	},

  	"height": {

  		get: function () {

  			return this.y;

  		},

  		set: function ( value ) {

  			this.y = value;

  		}

  	}

  } );

  Object.assign( Vector2$1.prototype, {

  	isVector2: true,

  	set: function ( x, y ) {

  		this.x = x;
  		this.y = y;

  		return this;

  	},

  	setScalar: function ( scalar ) {

  		this.x = scalar;
  		this.y = scalar;

  		return this;

  	},

  	setX: function ( x ) {

  		this.x = x;

  		return this;

  	},

  	setY: function ( y ) {

  		this.y = y;

  		return this;

  	},

  	setComponent: function ( index, value ) {

  		switch ( index ) {

  			case 0: this.x = value; break;
  			case 1: this.y = value; break;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  		return this;

  	},

  	getComponent: function ( index ) {

  		switch ( index ) {

  			case 0: return this.x;
  			case 1: return this.y;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  	},

  	clone: function () {

  		return new this.constructor( this.x, this.y );

  	},

  	copy: function ( v ) {

  		this.x = v.x;
  		this.y = v.y;

  		return this;

  	},

  	add: function ( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
  			return this.addVectors( v, w );

  		}

  		this.x += v.x;
  		this.y += v.y;

  		return this;

  	},

  	addScalar: function ( s ) {

  		this.x += s;
  		this.y += s;

  		return this;

  	},

  	addVectors: function ( a, b ) {

  		this.x = a.x + b.x;
  		this.y = a.y + b.y;

  		return this;

  	},

  	addScaledVector: function ( v, s ) {

  		this.x += v.x * s;
  		this.y += v.y * s;

  		return this;

  	},

  	sub: function ( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
  			return this.subVectors( v, w );

  		}

  		this.x -= v.x;
  		this.y -= v.y;

  		return this;

  	},

  	subScalar: function ( s ) {

  		this.x -= s;
  		this.y -= s;

  		return this;

  	},

  	subVectors: function ( a, b ) {

  		this.x = a.x - b.x;
  		this.y = a.y - b.y;

  		return this;

  	},

  	multiply: function ( v ) {

  		this.x *= v.x;
  		this.y *= v.y;

  		return this;

  	},

  	multiplyScalar: function ( scalar ) {

  		this.x *= scalar;
  		this.y *= scalar;

  		return this;

  	},

  	divide: function ( v ) {

  		this.x /= v.x;
  		this.y /= v.y;

  		return this;

  	},

  	divideScalar: function ( scalar ) {

  		return this.multiplyScalar( 1 / scalar );

  	},

  	applyMatrix3: function ( m ) {

  		var x = this.x, y = this.y;
  		var e = m.elements;

  		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
  		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

  		return this;

  	},

  	min: function ( v ) {

  		this.x = Math.min( this.x, v.x );
  		this.y = Math.min( this.y, v.y );

  		return this;

  	},

  	max: function ( v ) {

  		this.x = Math.max( this.x, v.x );
  		this.y = Math.max( this.y, v.y );

  		return this;

  	},

  	clamp: function ( min, max ) {

  		// assumes min < max, componentwise

  		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
  		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

  		return this;

  	},

  	clampScalar: function () {

  		var min = new Vector2$1();
  		var max = new Vector2$1();

  		return function clampScalar( minVal, maxVal ) {

  			min.set( minVal, minVal );
  			max.set( maxVal, maxVal );

  			return this.clamp( min, max );

  		};

  	}(),

  	clampLength: function ( min, max ) {

  		var length = this.length();

  		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

  	},

  	floor: function () {

  		this.x = Math.floor( this.x );
  		this.y = Math.floor( this.y );

  		return this;

  	},

  	ceil: function () {

  		this.x = Math.ceil( this.x );
  		this.y = Math.ceil( this.y );

  		return this;

  	},

  	round: function () {

  		this.x = Math.round( this.x );
  		this.y = Math.round( this.y );

  		return this;

  	},

  	roundToZero: function () {

  		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
  		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

  		return this;

  	},

  	negate: function () {

  		this.x = - this.x;
  		this.y = - this.y;

  		return this;

  	},

  	dot: function ( v ) {

  		return this.x * v.x + this.y * v.y;

  	},

  	lengthSq: function () {

  		return this.x * this.x + this.y * this.y;

  	},

  	length: function () {

  		return Math.sqrt( this.x * this.x + this.y * this.y );

  	},

  	lengthManhattan: function () {

  		return Math.abs( this.x ) + Math.abs( this.y );

  	},

  	normalize: function () {

  		return this.divideScalar( this.length() || 1 );

  	},

  	angle: function () {

  		// computes the angle in radians with respect to the positive x-axis

  		var angle = Math.atan2( this.y, this.x );

  		if ( angle < 0 ) { angle += 2 * Math.PI; }

  		return angle;

  	},

  	distanceTo: function ( v ) {

  		return Math.sqrt( this.distanceToSquared( v ) );

  	},

  	distanceToSquared: function ( v ) {

  		var dx = this.x - v.x, dy = this.y - v.y;
  		return dx * dx + dy * dy;

  	},

  	distanceToManhattan: function ( v ) {

  		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

  	},

  	setLength: function ( length ) {

  		return this.normalize().multiplyScalar( length );

  	},

  	lerp: function ( v, alpha ) {

  		this.x += ( v.x - this.x ) * alpha;
  		this.y += ( v.y - this.y ) * alpha;

  		return this;

  	},

  	lerpVectors: function ( v1, v2, alpha ) {

  		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

  	},

  	equals: function ( v ) {

  		return ( ( v.x === this.x ) && ( v.y === this.y ) );

  	},

  	fromArray: function ( array, offset ) {

  		if ( offset === undefined ) { offset = 0; }

  		this.x = array[ offset ];
  		this.y = array[ offset + 1 ];

  		return this;

  	},

  	toArray: function ( array, offset ) {

  		if ( array === undefined ) { array = []; }
  		if ( offset === undefined ) { offset = 0; }

  		array[ offset ] = this.x;
  		array[ offset + 1 ] = this.y;

  		return array;

  	},

  	fromBufferAttribute: function ( attribute, index, offset ) {

  		if ( offset !== undefined ) {

  			console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

  		}

  		this.x = attribute.getX( index );
  		this.y = attribute.getY( index );

  		return this;

  	},

  	rotateAround: function ( center, angle ) {

  		var c = Math.cos( angle ), s = Math.sin( angle );

  		var x = this.x - center.x;
  		var y = this.y - center.y;

  		this.x = x * c - y * s + center.x;
  		this.y = x * s + y * c + center.y;

  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author supereggbert / http://www.paulbrunt.co.uk/
   * @author philogb / http://blog.thejit.org/
   * @author jordi_ros / http://plattsoft.com
   * @author D1plo1d / http://github.com/D1plo1d
   * @author alteredq / http://alteredqualia.com/
   * @author mikael emtinger / http://gomo.se/
   * @author timknip / http://www.floorplanner.com/
   * @author bhouston / http://clara.io
   * @author WestLangley / http://github.com/WestLangley
   */

  function Matrix4$1() {

  	this.elements = [

  		1, 0, 0, 0,
  		0, 1, 0, 0,
  		0, 0, 1, 0,
  		0, 0, 0, 1

  	];

  	if ( arguments.length > 0 ) {

  		console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

  	}

  }

  Object.assign( Matrix4$1.prototype, {

  	isMatrix4: true,

  	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

  		var te = this.elements;

  		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
  		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
  		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
  		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

  		return this;

  	},

  	identity: function () {

  		this.set(

  			1, 0, 0, 0,
  			0, 1, 0, 0,
  			0, 0, 1, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	},

  	clone: function () {

  		return new Matrix4$1().fromArray( this.elements );

  	},

  	copy: function ( m ) {

  		var te = this.elements;
  		var me = m.elements;

  		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
  		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
  		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
  		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

  		return this;

  	},

  	copyPosition: function ( m ) {

  		var te = this.elements, me = m.elements;

  		te[ 12 ] = me[ 12 ];
  		te[ 13 ] = me[ 13 ];
  		te[ 14 ] = me[ 14 ];

  		return this;

  	},

  	extractBasis: function ( xAxis, yAxis, zAxis ) {

  		xAxis.setFromMatrixColumn( this, 0 );
  		yAxis.setFromMatrixColumn( this, 1 );
  		zAxis.setFromMatrixColumn( this, 2 );

  		return this;

  	},

  	makeBasis: function ( xAxis, yAxis, zAxis ) {

  		this.set(
  			xAxis.x, yAxis.x, zAxis.x, 0,
  			xAxis.y, yAxis.y, zAxis.y, 0,
  			xAxis.z, yAxis.z, zAxis.z, 0,
  			0, 0, 0, 1
  		);

  		return this;

  	},

  	extractRotation: function () {

  		var v1 = new Vector3$2();

  		return function extractRotation( m ) {

  			var te = this.elements;
  			var me = m.elements;

  			var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
  			var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
  			var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();

  			te[ 0 ] = me[ 0 ] * scaleX;
  			te[ 1 ] = me[ 1 ] * scaleX;
  			te[ 2 ] = me[ 2 ] * scaleX;

  			te[ 4 ] = me[ 4 ] * scaleY;
  			te[ 5 ] = me[ 5 ] * scaleY;
  			te[ 6 ] = me[ 6 ] * scaleY;

  			te[ 8 ] = me[ 8 ] * scaleZ;
  			te[ 9 ] = me[ 9 ] * scaleZ;
  			te[ 10 ] = me[ 10 ] * scaleZ;

  			return this;

  		};

  	}(),

  	makeRotationFromEuler: function ( euler ) {

  		if ( ! ( euler && euler.isEuler ) ) {

  			console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

  		}

  		var te = this.elements;

  		var x = euler.x, y = euler.y, z = euler.z;
  		var a = Math.cos( x ), b = Math.sin( x );
  		var c = Math.cos( y ), d = Math.sin( y );
  		var e = Math.cos( z ), f = Math.sin( z );

  		if ( euler.order === 'XYZ' ) {

  			var ae = a * e, af = a * f, be = b * e, bf = b * f;

  			te[ 0 ] = c * e;
  			te[ 4 ] = - c * f;
  			te[ 8 ] = d;

  			te[ 1 ] = af + be * d;
  			te[ 5 ] = ae - bf * d;
  			te[ 9 ] = - b * c;

  			te[ 2 ] = bf - ae * d;
  			te[ 6 ] = be + af * d;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'YXZ' ) {

  			var ce = c * e, cf = c * f, de = d * e, df = d * f;

  			te[ 0 ] = ce + df * b;
  			te[ 4 ] = de * b - cf;
  			te[ 8 ] = a * d;

  			te[ 1 ] = a * f;
  			te[ 5 ] = a * e;
  			te[ 9 ] = - b;

  			te[ 2 ] = cf * b - de;
  			te[ 6 ] = df + ce * b;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'ZXY' ) {

  			var ce = c * e, cf = c * f, de = d * e, df = d * f;

  			te[ 0 ] = ce - df * b;
  			te[ 4 ] = - a * f;
  			te[ 8 ] = de + cf * b;

  			te[ 1 ] = cf + de * b;
  			te[ 5 ] = a * e;
  			te[ 9 ] = df - ce * b;

  			te[ 2 ] = - a * d;
  			te[ 6 ] = b;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'ZYX' ) {

  			var ae = a * e, af = a * f, be = b * e, bf = b * f;

  			te[ 0 ] = c * e;
  			te[ 4 ] = be * d - af;
  			te[ 8 ] = ae * d + bf;

  			te[ 1 ] = c * f;
  			te[ 5 ] = bf * d + ae;
  			te[ 9 ] = af * d - be;

  			te[ 2 ] = - d;
  			te[ 6 ] = b * c;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'YZX' ) {

  			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

  			te[ 0 ] = c * e;
  			te[ 4 ] = bd - ac * f;
  			te[ 8 ] = bc * f + ad;

  			te[ 1 ] = f;
  			te[ 5 ] = a * e;
  			te[ 9 ] = - b * e;

  			te[ 2 ] = - d * e;
  			te[ 6 ] = ad * f + bc;
  			te[ 10 ] = ac - bd * f;

  		} else if ( euler.order === 'XZY' ) {

  			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

  			te[ 0 ] = c * e;
  			te[ 4 ] = - f;
  			te[ 8 ] = d * e;

  			te[ 1 ] = ac * f + bd;
  			te[ 5 ] = a * e;
  			te[ 9 ] = ad * f - bc;

  			te[ 2 ] = bc * f - ad;
  			te[ 6 ] = b * e;
  			te[ 10 ] = bd * f + ac;

  		}

  		// last column
  		te[ 3 ] = 0;
  		te[ 7 ] = 0;
  		te[ 11 ] = 0;

  		// bottom row
  		te[ 12 ] = 0;
  		te[ 13 ] = 0;
  		te[ 14 ] = 0;
  		te[ 15 ] = 1;

  		return this;

  	},

  	makeRotationFromQuaternion: function ( q ) {

  		var te = this.elements;

  		var x = q._x, y = q._y, z = q._z, w = q._w;
  		var x2 = x + x, y2 = y + y, z2 = z + z;
  		var xx = x * x2, xy = x * y2, xz = x * z2;
  		var yy = y * y2, yz = y * z2, zz = z * z2;
  		var wx = w * x2, wy = w * y2, wz = w * z2;

  		te[ 0 ] = 1 - ( yy + zz );
  		te[ 4 ] = xy - wz;
  		te[ 8 ] = xz + wy;

  		te[ 1 ] = xy + wz;
  		te[ 5 ] = 1 - ( xx + zz );
  		te[ 9 ] = yz - wx;

  		te[ 2 ] = xz - wy;
  		te[ 6 ] = yz + wx;
  		te[ 10 ] = 1 - ( xx + yy );

  		// last column
  		te[ 3 ] = 0;
  		te[ 7 ] = 0;
  		te[ 11 ] = 0;

  		// bottom row
  		te[ 12 ] = 0;
  		te[ 13 ] = 0;
  		te[ 14 ] = 0;
  		te[ 15 ] = 1;

  		return this;

  	},

  	lookAt: function () {

  		var x = new Vector3$2();
  		var y = new Vector3$2();
  		var z = new Vector3$2();

  		return function lookAt( eye, target, up ) {

  			var te = this.elements;

  			z.subVectors( eye, target );

  			if ( z.lengthSq() === 0 ) {

  				// eye and target are in the same position

  				z.z = 1;

  			}

  			z.normalize();
  			x.crossVectors( up, z );

  			if ( x.lengthSq() === 0 ) {

  				// up and z are parallel

  				if ( Math.abs( up.z ) === 1 ) {

  					z.x += 0.0001;

  				} else {

  					z.z += 0.0001;

  				}

  				z.normalize();
  				x.crossVectors( up, z );

  			}

  			x.normalize();
  			y.crossVectors( z, x );

  			te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
  			te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
  			te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

  			return this;

  		};

  	}(),

  	multiply: function ( m, n ) {

  		if ( n !== undefined ) {

  			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
  			return this.multiplyMatrices( m, n );

  		}

  		return this.multiplyMatrices( this, m );

  	},

  	premultiply: function ( m ) {

  		return this.multiplyMatrices( m, this );

  	},

  	multiplyMatrices: function ( a, b ) {

  		var ae = a.elements;
  		var be = b.elements;
  		var te = this.elements;

  		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
  		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
  		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
  		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

  		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
  		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
  		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
  		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

  		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
  		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
  		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
  		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

  		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
  		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
  		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
  		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

  		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
  		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
  		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
  		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

  		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
  		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
  		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
  		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

  		return this;

  	},

  	multiplyScalar: function ( s ) {

  		var te = this.elements;

  		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
  		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
  		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
  		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

  		return this;

  	},

  	applyToBufferAttribute: function () {

  		var v1 = new Vector3$2();

  		return function applyToBufferAttribute( attribute ) {
  			var this$1 = this;


  			for ( var i = 0, l = attribute.count; i < l; i ++ ) {

  				v1.x = attribute.getX( i );
  				v1.y = attribute.getY( i );
  				v1.z = attribute.getZ( i );

  				v1.applyMatrix4( this$1 );

  				attribute.setXYZ( i, v1.x, v1.y, v1.z );

  			}

  			return attribute;

  		};

  	}(),

  	determinant: function () {

  		var te = this.elements;

  		var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
  		var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
  		var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
  		var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

  		//TODO: make this more efficient
  		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

  		return (
  			n41 * (
  				+ n14 * n23 * n32
  				 - n13 * n24 * n32
  				 - n14 * n22 * n33
  				 + n12 * n24 * n33
  				 + n13 * n22 * n34
  				 - n12 * n23 * n34
  			) +
  			n42 * (
  				+ n11 * n23 * n34
  				 - n11 * n24 * n33
  				 + n14 * n21 * n33
  				 - n13 * n21 * n34
  				 + n13 * n24 * n31
  				 - n14 * n23 * n31
  			) +
  			n43 * (
  				+ n11 * n24 * n32
  				 - n11 * n22 * n34
  				 - n14 * n21 * n32
  				 + n12 * n21 * n34
  				 + n14 * n22 * n31
  				 - n12 * n24 * n31
  			) +
  			n44 * (
  				- n13 * n22 * n31
  				 - n11 * n23 * n32
  				 + n11 * n22 * n33
  				 + n13 * n21 * n32
  				 - n12 * n21 * n33
  				 + n12 * n23 * n31
  			)

  		);

  	},

  	transpose: function () {

  		var te = this.elements;
  		var tmp;

  		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
  		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
  		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

  		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
  		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
  		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

  		return this;

  	},

  	setPosition: function ( v ) {

  		var te = this.elements;

  		te[ 12 ] = v.x;
  		te[ 13 ] = v.y;
  		te[ 14 ] = v.z;

  		return this;

  	},

  	getInverse: function ( m, throwOnDegenerate ) {

  		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
  		var te = this.elements,
  			me = m.elements,

  			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
  			n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
  			n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
  			n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

  			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
  			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
  			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
  			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

  		var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

  		if ( det === 0 ) {

  			var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";

  			if ( throwOnDegenerate === true ) {

  				throw new Error( msg );

  			} else {

  				console.warn( msg );

  			}

  			return this.identity();

  		}

  		var detInv = 1 / det;

  		te[ 0 ] = t11 * detInv;
  		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
  		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
  		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

  		te[ 4 ] = t12 * detInv;
  		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
  		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
  		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

  		te[ 8 ] = t13 * detInv;
  		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
  		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
  		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

  		te[ 12 ] = t14 * detInv;
  		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
  		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
  		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

  		return this;

  	},

  	scale: function ( v ) {

  		var te = this.elements;
  		var x = v.x, y = v.y, z = v.z;

  		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
  		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
  		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
  		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

  		return this;

  	},

  	getMaxScaleOnAxis: function () {

  		var te = this.elements;

  		var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
  		var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
  		var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

  		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

  	},

  	makeTranslation: function ( x, y, z ) {

  		this.set(

  			1, 0, 0, x,
  			0, 1, 0, y,
  			0, 0, 1, z,
  			0, 0, 0, 1

  		);

  		return this;

  	},

  	makeRotationX: function ( theta ) {

  		var c = Math.cos( theta ), s = Math.sin( theta );

  		this.set(

  			1, 0, 0, 0,
  			0, c, - s, 0,
  			0, s, c, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	},

  	makeRotationY: function ( theta ) {

  		var c = Math.cos( theta ), s = Math.sin( theta );

  		this.set(

  			 c, 0, s, 0,
  			 0, 1, 0, 0,
  			- s, 0, c, 0,
  			 0, 0, 0, 1

  		);

  		return this;

  	},

  	makeRotationZ: function ( theta ) {

  		var c = Math.cos( theta ), s = Math.sin( theta );

  		this.set(

  			c, - s, 0, 0,
  			s, c, 0, 0,
  			0, 0, 1, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	},

  	makeRotationAxis: function ( axis, angle ) {

  		// Based on http://www.gamedev.net/reference/articles/article1199.asp

  		var c = Math.cos( angle );
  		var s = Math.sin( angle );
  		var t = 1 - c;
  		var x = axis.x, y = axis.y, z = axis.z;
  		var tx = t * x, ty = t * y;

  		this.set(

  			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
  			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
  			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
  			0, 0, 0, 1

  		);

  		 return this;

  	},

  	makeScale: function ( x, y, z ) {

  		this.set(

  			x, 0, 0, 0,
  			0, y, 0, 0,
  			0, 0, z, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	},

  	makeShear: function ( x, y, z ) {

  		this.set(

  			1, y, z, 0,
  			x, 1, z, 0,
  			x, y, 1, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	},

  	compose: function ( position, quaternion, scale ) {

  		this.makeRotationFromQuaternion( quaternion );
  		this.scale( scale );
  		this.setPosition( position );

  		return this;

  	},

  	decompose: function () {

  		var vector = new Vector3$2();
  		var matrix = new Matrix4$1();

  		return function decompose( position, quaternion, scale ) {

  			var te = this.elements;

  			var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
  			var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
  			var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

  			// if determine is negative, we need to invert one scale
  			var det = this.determinant();
  			if ( det < 0 ) { sx = - sx; }

  			position.x = te[ 12 ];
  			position.y = te[ 13 ];
  			position.z = te[ 14 ];

  			// scale the rotation part
  			matrix.copy( this );

  			var invSX = 1 / sx;
  			var invSY = 1 / sy;
  			var invSZ = 1 / sz;

  			matrix.elements[ 0 ] *= invSX;
  			matrix.elements[ 1 ] *= invSX;
  			matrix.elements[ 2 ] *= invSX;

  			matrix.elements[ 4 ] *= invSY;
  			matrix.elements[ 5 ] *= invSY;
  			matrix.elements[ 6 ] *= invSY;

  			matrix.elements[ 8 ] *= invSZ;
  			matrix.elements[ 9 ] *= invSZ;
  			matrix.elements[ 10 ] *= invSZ;

  			quaternion.setFromRotationMatrix( matrix );

  			scale.x = sx;
  			scale.y = sy;
  			scale.z = sz;

  			return this;

  		};

  	}(),

  	makePerspective: function ( left, right, top, bottom, near, far ) {

  		if ( far === undefined ) {

  			console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

  		}

  		var te = this.elements;
  		var x = 2 * near / ( right - left );
  		var y = 2 * near / ( top - bottom );

  		var a = ( right + left ) / ( right - left );
  		var b = ( top + bottom ) / ( top - bottom );
  		var c = - ( far + near ) / ( far - near );
  		var d = - 2 * far * near / ( far - near );

  		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
  		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
  		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
  		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

  		return this;

  	},

  	makeOrthographic: function ( left, right, top, bottom, near, far ) {

  		var te = this.elements;
  		var w = 1.0 / ( right - left );
  		var h = 1.0 / ( top - bottom );
  		var p = 1.0 / ( far - near );

  		var x = ( right + left ) * w;
  		var y = ( top + bottom ) * h;
  		var z = ( far + near ) * p;

  		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
  		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
  		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
  		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

  		return this;

  	},

  	equals: function ( matrix ) {

  		var te = this.elements;
  		var me = matrix.elements;

  		for ( var i = 0; i < 16; i ++ ) {

  			if ( te[ i ] !== me[ i ] ) { return false; }

  		}

  		return true;

  	},

  	fromArray: function ( array, offset ) {
  		var this$1 = this;


  		if ( offset === undefined ) { offset = 0; }

  		for ( var i = 0; i < 16; i ++ ) {

  			this$1.elements[ i ] = array[ i + offset ];

  		}

  		return this;

  	},

  	toArray: function ( array, offset ) {

  		if ( array === undefined ) { array = []; }
  		if ( offset === undefined ) { offset = 0; }

  		var te = this.elements;

  		array[ offset ] = te[ 0 ];
  		array[ offset + 1 ] = te[ 1 ];
  		array[ offset + 2 ] = te[ 2 ];
  		array[ offset + 3 ] = te[ 3 ];

  		array[ offset + 4 ] = te[ 4 ];
  		array[ offset + 5 ] = te[ 5 ];
  		array[ offset + 6 ] = te[ 6 ];
  		array[ offset + 7 ] = te[ 7 ];

  		array[ offset + 8 ] = te[ 8 ];
  		array[ offset + 9 ] = te[ 9 ];
  		array[ offset + 10 ] = te[ 10 ];
  		array[ offset + 11 ] = te[ 11 ];

  		array[ offset + 12 ] = te[ 12 ];
  		array[ offset + 13 ] = te[ 13 ];
  		array[ offset + 14 ] = te[ 14 ];
  		array[ offset + 15 ] = te[ 15 ];

  		return array;

  	}

  } );

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author WestLangley / http://github.com/WestLangley
   * @author bhouston / http://clara.io
   */

  function Quaternion$1( x, y, z, w ) {

  	this._x = x || 0;
  	this._y = y || 0;
  	this._z = z || 0;
  	this._w = ( w !== undefined ) ? w : 1;

  }

  Object.assign( Quaternion$1, {

  	slerp: function ( qa, qb, qm, t ) {

  		return qm.copy( qa ).slerp( qb, t );

  	},

  	slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

  		// fuzz-free, array-based Quaternion SLERP operation

  		var x0 = src0[ srcOffset0 + 0 ],
  			y0 = src0[ srcOffset0 + 1 ],
  			z0 = src0[ srcOffset0 + 2 ],
  			w0 = src0[ srcOffset0 + 3 ],

  			x1 = src1[ srcOffset1 + 0 ],
  			y1 = src1[ srcOffset1 + 1 ],
  			z1 = src1[ srcOffset1 + 2 ],
  			w1 = src1[ srcOffset1 + 3 ];

  		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

  			var s = 1 - t,

  				cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

  				dir = ( cos >= 0 ? 1 : - 1 ),
  				sqrSin = 1 - cos * cos;

  			// Skip the Slerp for tiny steps to avoid numeric problems:
  			if ( sqrSin > Number.EPSILON ) {

  				var sin = Math.sqrt( sqrSin ),
  					len = Math.atan2( sin, cos * dir );

  				s = Math.sin( s * len ) / sin;
  				t = Math.sin( t * len ) / sin;

  			}

  			var tDir = t * dir;

  			x0 = x0 * s + x1 * tDir;
  			y0 = y0 * s + y1 * tDir;
  			z0 = z0 * s + z1 * tDir;
  			w0 = w0 * s + w1 * tDir;

  			// Normalize in case we just did a lerp:
  			if ( s === 1 - t ) {

  				var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

  				x0 *= f;
  				y0 *= f;
  				z0 *= f;
  				w0 *= f;

  			}

  		}

  		dst[ dstOffset ] = x0;
  		dst[ dstOffset + 1 ] = y0;
  		dst[ dstOffset + 2 ] = z0;
  		dst[ dstOffset + 3 ] = w0;

  	}

  } );

  Object.defineProperties( Quaternion$1.prototype, {

  	x: {

  		get: function () {

  			return this._x;

  		},

  		set: function ( value ) {

  			this._x = value;
  			this.onChangeCallback();

  		}

  	},

  	y: {

  		get: function () {

  			return this._y;

  		},

  		set: function ( value ) {

  			this._y = value;
  			this.onChangeCallback();

  		}

  	},

  	z: {

  		get: function () {

  			return this._z;

  		},

  		set: function ( value ) {

  			this._z = value;
  			this.onChangeCallback();

  		}

  	},

  	w: {

  		get: function () {

  			return this._w;

  		},

  		set: function ( value ) {

  			this._w = value;
  			this.onChangeCallback();

  		}

  	}

  } );

  Object.assign( Quaternion$1.prototype, {

  	set: function ( x, y, z, w ) {

  		this._x = x;
  		this._y = y;
  		this._z = z;
  		this._w = w;

  		this.onChangeCallback();

  		return this;

  	},

  	clone: function () {

  		return new this.constructor( this._x, this._y, this._z, this._w );

  	},

  	copy: function ( quaternion ) {

  		this._x = quaternion.x;
  		this._y = quaternion.y;
  		this._z = quaternion.z;
  		this._w = quaternion.w;

  		this.onChangeCallback();

  		return this;

  	},

  	setFromEuler: function ( euler, update ) {

  		if ( ! ( euler && euler.isEuler ) ) {

  			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

  		}

  		var x = euler._x, y = euler._y, z = euler._z, order = euler.order;

  		// http://www.mathworks.com/matlabcentral/fileexchange/
  		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
  		//	content/SpinCalc.m

  		var cos = Math.cos;
  		var sin = Math.sin;

  		var c1 = cos( x / 2 );
  		var c2 = cos( y / 2 );
  		var c3 = cos( z / 2 );

  		var s1 = sin( x / 2 );
  		var s2 = sin( y / 2 );
  		var s3 = sin( z / 2 );

  		if ( order === 'XYZ' ) {

  			this._x = s1 * c2 * c3 + c1 * s2 * s3;
  			this._y = c1 * s2 * c3 - s1 * c2 * s3;
  			this._z = c1 * c2 * s3 + s1 * s2 * c3;
  			this._w = c1 * c2 * c3 - s1 * s2 * s3;

  		} else if ( order === 'YXZ' ) {

  			this._x = s1 * c2 * c3 + c1 * s2 * s3;
  			this._y = c1 * s2 * c3 - s1 * c2 * s3;
  			this._z = c1 * c2 * s3 - s1 * s2 * c3;
  			this._w = c1 * c2 * c3 + s1 * s2 * s3;

  		} else if ( order === 'ZXY' ) {

  			this._x = s1 * c2 * c3 - c1 * s2 * s3;
  			this._y = c1 * s2 * c3 + s1 * c2 * s3;
  			this._z = c1 * c2 * s3 + s1 * s2 * c3;
  			this._w = c1 * c2 * c3 - s1 * s2 * s3;

  		} else if ( order === 'ZYX' ) {

  			this._x = s1 * c2 * c3 - c1 * s2 * s3;
  			this._y = c1 * s2 * c3 + s1 * c2 * s3;
  			this._z = c1 * c2 * s3 - s1 * s2 * c3;
  			this._w = c1 * c2 * c3 + s1 * s2 * s3;

  		} else if ( order === 'YZX' ) {

  			this._x = s1 * c2 * c3 + c1 * s2 * s3;
  			this._y = c1 * s2 * c3 + s1 * c2 * s3;
  			this._z = c1 * c2 * s3 - s1 * s2 * c3;
  			this._w = c1 * c2 * c3 - s1 * s2 * s3;

  		} else if ( order === 'XZY' ) {

  			this._x = s1 * c2 * c3 - c1 * s2 * s3;
  			this._y = c1 * s2 * c3 - s1 * c2 * s3;
  			this._z = c1 * c2 * s3 + s1 * s2 * c3;
  			this._w = c1 * c2 * c3 + s1 * s2 * s3;

  		}

  		if ( update !== false ) { this.onChangeCallback(); }

  		return this;

  	},

  	setFromAxisAngle: function ( axis, angle ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

  		// assumes axis is normalized

  		var halfAngle = angle / 2, s = Math.sin( halfAngle );

  		this._x = axis.x * s;
  		this._y = axis.y * s;
  		this._z = axis.z * s;
  		this._w = Math.cos( halfAngle );

  		this.onChangeCallback();

  		return this;

  	},

  	setFromRotationMatrix: function ( m ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		var te = m.elements,

  			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
  			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
  			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

  			trace = m11 + m22 + m33,
  			s;

  		if ( trace > 0 ) {

  			s = 0.5 / Math.sqrt( trace + 1.0 );

  			this._w = 0.25 / s;
  			this._x = ( m32 - m23 ) * s;
  			this._y = ( m13 - m31 ) * s;
  			this._z = ( m21 - m12 ) * s;

  		} else if ( m11 > m22 && m11 > m33 ) {

  			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

  			this._w = ( m32 - m23 ) / s;
  			this._x = 0.25 * s;
  			this._y = ( m12 + m21 ) / s;
  			this._z = ( m13 + m31 ) / s;

  		} else if ( m22 > m33 ) {

  			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

  			this._w = ( m13 - m31 ) / s;
  			this._x = ( m12 + m21 ) / s;
  			this._y = 0.25 * s;
  			this._z = ( m23 + m32 ) / s;

  		} else {

  			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

  			this._w = ( m21 - m12 ) / s;
  			this._x = ( m13 + m31 ) / s;
  			this._y = ( m23 + m32 ) / s;
  			this._z = 0.25 * s;

  		}

  		this.onChangeCallback();

  		return this;

  	},

  	setFromUnitVectors: function () {

  		// assumes direction vectors vFrom and vTo are normalized

  		var v1 = new Vector3$2();
  		var r;

  		var EPS = 0.000001;

  		return function setFromUnitVectors( vFrom, vTo ) {

  			if ( v1 === undefined ) { v1 = new Vector3$2(); }

  			r = vFrom.dot( vTo ) + 1;

  			if ( r < EPS ) {

  				r = 0;

  				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

  					v1.set( - vFrom.y, vFrom.x, 0 );

  				} else {

  					v1.set( 0, - vFrom.z, vFrom.y );

  				}

  			} else {

  				v1.crossVectors( vFrom, vTo );

  			}

  			this._x = v1.x;
  			this._y = v1.y;
  			this._z = v1.z;
  			this._w = r;

  			return this.normalize();

  		};

  	}(),

  	inverse: function () {

  		return this.conjugate().normalize();

  	},

  	conjugate: function () {

  		this._x *= - 1;
  		this._y *= - 1;
  		this._z *= - 1;

  		this.onChangeCallback();

  		return this;

  	},

  	dot: function ( v ) {

  		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

  	},

  	lengthSq: function () {

  		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

  	},

  	length: function () {

  		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

  	},

  	normalize: function () {

  		var l = this.length();

  		if ( l === 0 ) {

  			this._x = 0;
  			this._y = 0;
  			this._z = 0;
  			this._w = 1;

  		} else {

  			l = 1 / l;

  			this._x = this._x * l;
  			this._y = this._y * l;
  			this._z = this._z * l;
  			this._w = this._w * l;

  		}

  		this.onChangeCallback();

  		return this;

  	},

  	multiply: function ( q, p ) {

  		if ( p !== undefined ) {

  			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
  			return this.multiplyQuaternions( q, p );

  		}

  		return this.multiplyQuaternions( this, q );

  	},

  	premultiply: function ( q ) {

  		return this.multiplyQuaternions( q, this );

  	},

  	multiplyQuaternions: function ( a, b ) {

  		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

  		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
  		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

  		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
  		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
  		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
  		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

  		this.onChangeCallback();

  		return this;

  	},

  	slerp: function ( qb, t ) {

  		if ( t === 0 ) { return this; }
  		if ( t === 1 ) { return this.copy( qb ); }

  		var x = this._x, y = this._y, z = this._z, w = this._w;

  		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

  		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

  		if ( cosHalfTheta < 0 ) {

  			this._w = - qb._w;
  			this._x = - qb._x;
  			this._y = - qb._y;
  			this._z = - qb._z;

  			cosHalfTheta = - cosHalfTheta;

  		} else {

  			this.copy( qb );

  		}

  		if ( cosHalfTheta >= 1.0 ) {

  			this._w = w;
  			this._x = x;
  			this._y = y;
  			this._z = z;

  			return this;

  		}

  		var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

  		if ( Math.abs( sinHalfTheta ) < 0.001 ) {

  			this._w = 0.5 * ( w + this._w );
  			this._x = 0.5 * ( x + this._x );
  			this._y = 0.5 * ( y + this._y );
  			this._z = 0.5 * ( z + this._z );

  			return this;

  		}

  		var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
  		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
  			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

  		this._w = ( w * ratioA + this._w * ratioB );
  		this._x = ( x * ratioA + this._x * ratioB );
  		this._y = ( y * ratioA + this._y * ratioB );
  		this._z = ( z * ratioA + this._z * ratioB );

  		this.onChangeCallback();

  		return this;

  	},

  	equals: function ( quaternion ) {

  		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

  	},

  	fromArray: function ( array, offset ) {

  		if ( offset === undefined ) { offset = 0; }

  		this._x = array[ offset ];
  		this._y = array[ offset + 1 ];
  		this._z = array[ offset + 2 ];
  		this._w = array[ offset + 3 ];

  		this.onChangeCallback();

  		return this;

  	},

  	toArray: function ( array, offset ) {

  		if ( array === undefined ) { array = []; }
  		if ( offset === undefined ) { offset = 0; }

  		array[ offset ] = this._x;
  		array[ offset + 1 ] = this._y;
  		array[ offset + 2 ] = this._z;
  		array[ offset + 3 ] = this._w;

  		return array;

  	},

  	onChange: function ( callback ) {

  		this.onChangeCallback = callback;

  		return this;

  	},

  	onChangeCallback: function () {}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author kile / http://kile.stravaganza.org/
   * @author philogb / http://blog.thejit.org/
   * @author mikael emtinger / http://gomo.se/
   * @author egraether / http://egraether.com/
   * @author WestLangley / http://github.com/WestLangley
   */

  function Vector3$2( x, y, z ) {

  	this.x = x || 0;
  	this.y = y || 0;
  	this.z = z || 0;

  }

  Object.assign( Vector3$2.prototype, {

  	isVector3: true,

  	set: function ( x, y, z ) {

  		this.x = x;
  		this.y = y;
  		this.z = z;

  		return this;

  	},

  	setScalar: function ( scalar ) {

  		this.x = scalar;
  		this.y = scalar;
  		this.z = scalar;

  		return this;

  	},

  	setX: function ( x ) {

  		this.x = x;

  		return this;

  	},

  	setY: function ( y ) {

  		this.y = y;

  		return this;

  	},

  	setZ: function ( z ) {

  		this.z = z;

  		return this;

  	},

  	setComponent: function ( index, value ) {

  		switch ( index ) {

  			case 0: this.x = value; break;
  			case 1: this.y = value; break;
  			case 2: this.z = value; break;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  		return this;

  	},

  	getComponent: function ( index ) {

  		switch ( index ) {

  			case 0: return this.x;
  			case 1: return this.y;
  			case 2: return this.z;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  	},

  	clone: function () {

  		return new this.constructor( this.x, this.y, this.z );

  	},

  	copy: function ( v ) {

  		this.x = v.x;
  		this.y = v.y;
  		this.z = v.z;

  		return this;

  	},

  	add: function ( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
  			return this.addVectors( v, w );

  		}

  		this.x += v.x;
  		this.y += v.y;
  		this.z += v.z;

  		return this;

  	},

  	addScalar: function ( s ) {

  		this.x += s;
  		this.y += s;
  		this.z += s;

  		return this;

  	},

  	addVectors: function ( a, b ) {

  		this.x = a.x + b.x;
  		this.y = a.y + b.y;
  		this.z = a.z + b.z;

  		return this;

  	},

  	addScaledVector: function ( v, s ) {

  		this.x += v.x * s;
  		this.y += v.y * s;
  		this.z += v.z * s;

  		return this;

  	},

  	sub: function ( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
  			return this.subVectors( v, w );

  		}

  		this.x -= v.x;
  		this.y -= v.y;
  		this.z -= v.z;

  		return this;

  	},

  	subScalar: function ( s ) {

  		this.x -= s;
  		this.y -= s;
  		this.z -= s;

  		return this;

  	},

  	subVectors: function ( a, b ) {

  		this.x = a.x - b.x;
  		this.y = a.y - b.y;
  		this.z = a.z - b.z;

  		return this;

  	},

  	multiply: function ( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
  			return this.multiplyVectors( v, w );

  		}

  		this.x *= v.x;
  		this.y *= v.y;
  		this.z *= v.z;

  		return this;

  	},

  	multiplyScalar: function ( scalar ) {

  		this.x *= scalar;
  		this.y *= scalar;
  		this.z *= scalar;

  		return this;

  	},

  	multiplyVectors: function ( a, b ) {

  		this.x = a.x * b.x;
  		this.y = a.y * b.y;
  		this.z = a.z * b.z;

  		return this;

  	},

  	applyEuler: function () {

  		var quaternion = new Quaternion$1();

  		return function applyEuler( euler ) {

  			if ( ! ( euler && euler.isEuler ) ) {

  				console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

  			}

  			return this.applyQuaternion( quaternion.setFromEuler( euler ) );

  		};

  	}(),

  	applyAxisAngle: function () {

  		var quaternion = new Quaternion$1();

  		return function applyAxisAngle( axis, angle ) {

  			return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

  		};

  	}(),

  	applyMatrix3: function ( m ) {

  		var x = this.x, y = this.y, z = this.z;
  		var e = m.elements;

  		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
  		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
  		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

  		return this;

  	},

  	applyMatrix4: function ( m ) {

  		var x = this.x, y = this.y, z = this.z;
  		var e = m.elements;

  		var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

  		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
  		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
  		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

  		return this;

  	},

  	applyQuaternion: function ( q ) {

  		var x = this.x, y = this.y, z = this.z;
  		var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

  		// calculate quat * vector

  		var ix = qw * x + qy * z - qz * y;
  		var iy = qw * y + qz * x - qx * z;
  		var iz = qw * z + qx * y - qy * x;
  		var iw = - qx * x - qy * y - qz * z;

  		// calculate result * inverse quat

  		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
  		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
  		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

  		return this;

  	},

  	project: function () {

  		var matrix = new Matrix4$1();

  		return function project( camera ) {

  			matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
  			return this.applyMatrix4( matrix );

  		};

  	}(),

  	unproject: function () {

  		var matrix = new Matrix4$1();

  		return function unproject( camera ) {

  			matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
  			return this.applyMatrix4( matrix );

  		};

  	}(),

  	transformDirection: function ( m ) {

  		// input: THREE.Matrix4 affine matrix
  		// vector interpreted as a direction

  		var x = this.x, y = this.y, z = this.z;
  		var e = m.elements;

  		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
  		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
  		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

  		return this.normalize();

  	},

  	divide: function ( v ) {

  		this.x /= v.x;
  		this.y /= v.y;
  		this.z /= v.z;

  		return this;

  	},

  	divideScalar: function ( scalar ) {

  		return this.multiplyScalar( 1 / scalar );

  	},

  	min: function ( v ) {

  		this.x = Math.min( this.x, v.x );
  		this.y = Math.min( this.y, v.y );
  		this.z = Math.min( this.z, v.z );

  		return this;

  	},

  	max: function ( v ) {

  		this.x = Math.max( this.x, v.x );
  		this.y = Math.max( this.y, v.y );
  		this.z = Math.max( this.z, v.z );

  		return this;

  	},

  	clamp: function ( min, max ) {

  		// assumes min < max, componentwise

  		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
  		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
  		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

  		return this;

  	},

  	clampScalar: function () {

  		var min = new Vector3$2();
  		var max = new Vector3$2();

  		return function clampScalar( minVal, maxVal ) {

  			min.set( minVal, minVal, minVal );
  			max.set( maxVal, maxVal, maxVal );

  			return this.clamp( min, max );

  		};

  	}(),

  	clampLength: function ( min, max ) {

  		var length = this.length();

  		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

  	},

  	floor: function () {

  		this.x = Math.floor( this.x );
  		this.y = Math.floor( this.y );
  		this.z = Math.floor( this.z );

  		return this;

  	},

  	ceil: function () {

  		this.x = Math.ceil( this.x );
  		this.y = Math.ceil( this.y );
  		this.z = Math.ceil( this.z );

  		return this;

  	},

  	round: function () {

  		this.x = Math.round( this.x );
  		this.y = Math.round( this.y );
  		this.z = Math.round( this.z );

  		return this;

  	},

  	roundToZero: function () {

  		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
  		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
  		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

  		return this;

  	},

  	negate: function () {

  		this.x = - this.x;
  		this.y = - this.y;
  		this.z = - this.z;

  		return this;

  	},

  	dot: function ( v ) {

  		return this.x * v.x + this.y * v.y + this.z * v.z;

  	},

  	// TODO lengthSquared?

  	lengthSq: function () {

  		return this.x * this.x + this.y * this.y + this.z * this.z;

  	},

  	length: function () {

  		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

  	},

  	lengthManhattan: function () {

  		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

  	},

  	normalize: function () {

  		return this.divideScalar( this.length() || 1 );

  	},

  	setLength: function ( length ) {

  		return this.normalize().multiplyScalar( length );

  	},

  	lerp: function ( v, alpha ) {

  		this.x += ( v.x - this.x ) * alpha;
  		this.y += ( v.y - this.y ) * alpha;
  		this.z += ( v.z - this.z ) * alpha;

  		return this;

  	},

  	lerpVectors: function ( v1, v2, alpha ) {

  		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

  	},

  	cross: function ( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
  			return this.crossVectors( v, w );

  		}

  		var x = this.x, y = this.y, z = this.z;

  		this.x = y * v.z - z * v.y;
  		this.y = z * v.x - x * v.z;
  		this.z = x * v.y - y * v.x;

  		return this;

  	},

  	crossVectors: function ( a, b ) {

  		var ax = a.x, ay = a.y, az = a.z;
  		var bx = b.x, by = b.y, bz = b.z;

  		this.x = ay * bz - az * by;
  		this.y = az * bx - ax * bz;
  		this.z = ax * by - ay * bx;

  		return this;

  	},

  	projectOnVector: function ( vector ) {

  		var scalar = vector.dot( this ) / vector.lengthSq();

  		return this.copy( vector ).multiplyScalar( scalar );

  	},

  	projectOnPlane: function () {

  		var v1 = new Vector3$2();

  		return function projectOnPlane( planeNormal ) {

  			v1.copy( this ).projectOnVector( planeNormal );

  			return this.sub( v1 );

  		};

  	}(),

  	reflect: function () {

  		// reflect incident vector off plane orthogonal to normal
  		// normal is assumed to have unit length

  		var v1 = new Vector3$2();

  		return function reflect( normal ) {

  			return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

  		};

  	}(),

  	angleTo: function ( v ) {

  		var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );

  		// clamp, to handle numerical problems

  		return Math.acos( _Math$1.clamp( theta, - 1, 1 ) );

  	},

  	distanceTo: function ( v ) {

  		return Math.sqrt( this.distanceToSquared( v ) );

  	},

  	distanceToSquared: function ( v ) {

  		var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

  		return dx * dx + dy * dy + dz * dz;

  	},

  	distanceToManhattan: function ( v ) {

  		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

  	},

  	setFromSpherical: function ( s ) {

  		var sinPhiRadius = Math.sin( s.phi ) * s.radius;

  		this.x = sinPhiRadius * Math.sin( s.theta );
  		this.y = Math.cos( s.phi ) * s.radius;
  		this.z = sinPhiRadius * Math.cos( s.theta );

  		return this;

  	},

  	setFromCylindrical: function ( c ) {

  		this.x = c.radius * Math.sin( c.theta );
  		this.y = c.y;
  		this.z = c.radius * Math.cos( c.theta );

  		return this;

  	},

  	setFromMatrixPosition: function ( m ) {

  		var e = m.elements;

  		this.x = e[ 12 ];
  		this.y = e[ 13 ];
  		this.z = e[ 14 ];

  		return this;

  	},

  	setFromMatrixScale: function ( m ) {

  		var sx = this.setFromMatrixColumn( m, 0 ).length();
  		var sy = this.setFromMatrixColumn( m, 1 ).length();
  		var sz = this.setFromMatrixColumn( m, 2 ).length();

  		this.x = sx;
  		this.y = sy;
  		this.z = sz;

  		return this;

  	},

  	setFromMatrixColumn: function ( m, index ) {

  		return this.fromArray( m.elements, index * 4 );

  	},

  	equals: function ( v ) {

  		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

  	},

  	fromArray: function ( array, offset ) {

  		if ( offset === undefined ) { offset = 0; }

  		this.x = array[ offset ];
  		this.y = array[ offset + 1 ];
  		this.z = array[ offset + 2 ];

  		return this;

  	},

  	toArray: function ( array, offset ) {

  		if ( array === undefined ) { array = []; }
  		if ( offset === undefined ) { offset = 0; }

  		array[ offset ] = this.x;
  		array[ offset + 1 ] = this.y;
  		array[ offset + 2 ] = this.z;

  		return array;

  	},

  	fromBufferAttribute: function ( attribute, index, offset ) {

  		if ( offset !== undefined ) {

  			console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

  		}

  		this.x = attribute.getX( index );
  		this.y = attribute.getY( index );
  		this.z = attribute.getZ( index );

  		return this;

  	}

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author WestLangley / http://github.com/WestLangley
   * @author bhouston / http://clara.io
   * @author tschw
   */

  function Matrix3$1() {

  	this.elements = [

  		1, 0, 0,
  		0, 1, 0,
  		0, 0, 1

  	];

  	if ( arguments.length > 0 ) {

  		console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

  	}

  }

  Object.assign( Matrix3$1.prototype, {

  	isMatrix3: true,

  	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

  		var te = this.elements;

  		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
  		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
  		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

  		return this;

  	},

  	identity: function () {

  		this.set(

  			1, 0, 0,
  			0, 1, 0,
  			0, 0, 1

  		);

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().fromArray( this.elements );

  	},

  	copy: function ( m ) {

  		var te = this.elements;
  		var me = m.elements;

  		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
  		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
  		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

  		return this;

  	},

  	setFromMatrix4: function ( m ) {

  		var me = m.elements;

  		this.set(

  			me[ 0 ], me[ 4 ], me[ 8 ],
  			me[ 1 ], me[ 5 ], me[ 9 ],
  			me[ 2 ], me[ 6 ], me[ 10 ]

  		);

  		return this;

  	},

  	applyToBufferAttribute: function () {

  		var v1 = new Vector3$2();

  		return function applyToBufferAttribute( attribute ) {
  			var this$1 = this;


  			for ( var i = 0, l = attribute.count; i < l; i ++ ) {

  				v1.x = attribute.getX( i );
  				v1.y = attribute.getY( i );
  				v1.z = attribute.getZ( i );

  				v1.applyMatrix3( this$1 );

  				attribute.setXYZ( i, v1.x, v1.y, v1.z );

  			}

  			return attribute;

  		};

  	}(),

  	multiply: function ( m ) {

  		return this.multiplyMatrices( this, m );

  	},

  	premultiply: function ( m ) {

  		return this.multiplyMatrices( m, this );

  	},

  	multiplyMatrices: function ( a, b ) {

  		var ae = a.elements;
  		var be = b.elements;
  		var te = this.elements;

  		var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
  		var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
  		var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

  		var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
  		var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
  		var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

  		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
  		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
  		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

  		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
  		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
  		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

  		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
  		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
  		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

  		return this;

  	},

  	multiplyScalar: function ( s ) {

  		var te = this.elements;

  		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
  		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
  		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

  		return this;

  	},

  	determinant: function () {

  		var te = this.elements;

  		var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
  			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
  			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

  		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

  	},

  	getInverse: function ( matrix, throwOnDegenerate ) {

  		if ( matrix && matrix.isMatrix4 ) {

  			console.error( "THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument." );

  		}

  		var me = matrix.elements,
  			te = this.elements,

  			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
  			n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
  			n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

  			t11 = n33 * n22 - n32 * n23,
  			t12 = n32 * n13 - n33 * n12,
  			t13 = n23 * n12 - n22 * n13,

  			det = n11 * t11 + n21 * t12 + n31 * t13;

  		if ( det === 0 ) {

  			var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";

  			if ( throwOnDegenerate === true ) {

  				throw new Error( msg );

  			} else {

  				console.warn( msg );

  			}

  			return this.identity();

  		}

  		var detInv = 1 / det;

  		te[ 0 ] = t11 * detInv;
  		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
  		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

  		te[ 3 ] = t12 * detInv;
  		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
  		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

  		te[ 6 ] = t13 * detInv;
  		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
  		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

  		return this;

  	},

  	transpose: function () {

  		var tmp, m = this.elements;

  		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
  		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
  		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

  		return this;

  	},

  	getNormalMatrix: function ( matrix4 ) {

  		return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

  	},

  	transposeIntoArray: function ( r ) {

  		var m = this.elements;

  		r[ 0 ] = m[ 0 ];
  		r[ 1 ] = m[ 3 ];
  		r[ 2 ] = m[ 6 ];
  		r[ 3 ] = m[ 1 ];
  		r[ 4 ] = m[ 4 ];
  		r[ 5 ] = m[ 7 ];
  		r[ 6 ] = m[ 2 ];
  		r[ 7 ] = m[ 5 ];
  		r[ 8 ] = m[ 8 ];

  		return this;

  	},

  	setUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {

  		var c = Math.cos( rotation );
  		var s = Math.sin( rotation );

  		this.set(
  			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
  			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
  			0, 0, 1
  		);

  	},

  	scale: function ( sx, sy ) {

  		var te = this.elements;

  		te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
  		te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

  		return this;

  	},

  	rotate: function ( theta ) {

  		var c = Math.cos( theta );
  		var s = Math.sin( theta );

  		var te = this.elements;

  		var a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
  		var a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

  		te[ 0 ] = c * a11 + s * a21;
  		te[ 3 ] = c * a12 + s * a22;
  		te[ 6 ] = c * a13 + s * a23;

  		te[ 1 ] = - s * a11 + c * a21;
  		te[ 4 ] = - s * a12 + c * a22;
  		te[ 7 ] = - s * a13 + c * a23;

  		return this;

  	},

  	translate: function ( tx, ty ) {

  		var te = this.elements;

  		te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
  		te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

  		return this;

  	},

  	equals: function ( matrix ) {

  		var te = this.elements;
  		var me = matrix.elements;

  		for ( var i = 0; i < 9; i ++ ) {

  			if ( te[ i ] !== me[ i ] ) { return false; }

  		}

  		return true;

  	},

  	fromArray: function ( array, offset ) {
  		var this$1 = this;


  		if ( offset === undefined ) { offset = 0; }

  		for ( var i = 0; i < 9; i ++ ) {

  			this$1.elements[ i ] = array[ i + offset ];

  		}

  		return this;

  	},

  	toArray: function ( array, offset ) {

  		if ( array === undefined ) { array = []; }
  		if ( offset === undefined ) { offset = 0; }

  		var te = this.elements;

  		array[ offset ] = te[ 0 ];
  		array[ offset + 1 ] = te[ 1 ];
  		array[ offset + 2 ] = te[ 2 ];

  		array[ offset + 3 ] = te[ 3 ];
  		array[ offset + 4 ] = te[ 4 ];
  		array[ offset + 5 ] = te[ 5 ];

  		array[ offset + 6 ] = te[ 6 ];
  		array[ offset + 7 ] = te[ 7 ];
  		array[ offset + 8 ] = te[ 8 ];

  		return array;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   * @author szimek / https://github.com/szimek/
   */

  var textureId$1 = 0;

  function Texture$1( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

  	Object.defineProperty( this, 'id', { value: textureId$1 ++ } );

  	this.uuid = _Math$1.generateUUID();

  	this.name = '';

  	this.image = image !== undefined ? image : Texture$1.DEFAULT_IMAGE;
  	this.mipmaps = [];

  	this.mapping = mapping !== undefined ? mapping : Texture$1.DEFAULT_MAPPING;

  	this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping$1;
  	this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping$1;

  	this.magFilter = magFilter !== undefined ? magFilter : LinearFilter$1;
  	this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter$1;

  	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

  	this.format = format !== undefined ? format : RGBAFormat$1;
  	this.type = type !== undefined ? type : UnsignedByteType$1;

  	this.offset = new Vector2$1( 0, 0 );
  	this.repeat = new Vector2$1( 1, 1 );
  	this.center = new Vector2$1( 0, 0 );
  	this.rotation = 0;

  	this.matrixAutoUpdate = true;
  	this.matrix = new Matrix3$1();

  	this.generateMipmaps = true;
  	this.premultiplyAlpha = false;
  	this.flipY = true;
  	this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

  	// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
  	//
  	// Also changing the encoding after already used by a Material will not automatically make the Material
  	// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
  	this.encoding = encoding !== undefined ? encoding : LinearEncoding$1;

  	this.version = 0;
  	this.onUpdate = null;

  }

  Texture$1.DEFAULT_IMAGE = undefined;
  Texture$1.DEFAULT_MAPPING = UVMapping$1;

  Object.defineProperty( Texture$1.prototype, "needsUpdate", {

  	set: function ( value ) {

  		if ( value === true ) { this.version ++; }

  	}

  } );

  Object.assign( Texture$1.prototype, EventDispatcher$1.prototype, {

  	constructor: Texture$1,

  	isTexture: true,

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( source ) {

  		this.name = source.name;

  		this.image = source.image;
  		this.mipmaps = source.mipmaps.slice( 0 );

  		this.mapping = source.mapping;

  		this.wrapS = source.wrapS;
  		this.wrapT = source.wrapT;

  		this.magFilter = source.magFilter;
  		this.minFilter = source.minFilter;

  		this.anisotropy = source.anisotropy;

  		this.format = source.format;
  		this.type = source.type;

  		this.offset.copy( source.offset );
  		this.repeat.copy( source.repeat );
  		this.center.copy( source.center );
  		this.rotation = source.rotation;

  		this.matrixAutoUpdate = source.matrixAutoUpdate;
  		this.matrix.copy( source.matrix );

  		this.generateMipmaps = source.generateMipmaps;
  		this.premultiplyAlpha = source.premultiplyAlpha;
  		this.flipY = source.flipY;
  		this.unpackAlignment = source.unpackAlignment;
  		this.encoding = source.encoding;

  		return this;

  	},

  	toJSON: function ( meta ) {

  		if ( meta.textures[ this.uuid ] !== undefined ) {

  			return meta.textures[ this.uuid ];

  		}

  		function getDataURL( image ) {

  			var canvas;

  			if ( image instanceof HTMLCanvasElement ) {

  				canvas = image;

  			} else {

  				canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
  				canvas.width = image.width;
  				canvas.height = image.height;

  				var context = canvas.getContext( '2d' );

  				if ( image instanceof ImageData ) {

  					context.putImageData( image, 0, 0 );

  				} else {

  					context.drawImage( image, 0, 0, image.width, image.height );

  				}

  			}

  			if ( canvas.width > 2048 || canvas.height > 2048 ) {

  				return canvas.toDataURL( 'image/jpeg', 0.6 );

  			} else {

  				return canvas.toDataURL( 'image/png' );

  			}

  		}

  		var output = {
  			metadata: {
  				version: 4.5,
  				type: 'Texture',
  				generator: 'Texture.toJSON'
  			},

  			uuid: this.uuid,
  			name: this.name,

  			mapping: this.mapping,

  			repeat: [ this.repeat.x, this.repeat.y ],
  			offset: [ this.offset.x, this.offset.y ],
  			center: [ this.center.x, this.center.y ],
  			rotation: this.rotation,

  			wrap: [ this.wrapS, this.wrapT ],

  			minFilter: this.minFilter,
  			magFilter: this.magFilter,
  			anisotropy: this.anisotropy,

  			flipY: this.flipY
  		};

  		if ( this.image !== undefined ) {

  			// TODO: Move to THREE.Image

  			var image = this.image;

  			if ( image.uuid === undefined ) {

  				image.uuid = _Math$1.generateUUID(); // UGH

  			}

  			if ( meta.images[ image.uuid ] === undefined ) {

  				meta.images[ image.uuid ] = {
  					uuid: image.uuid,
  					url: getDataURL( image )
  				};

  			}

  			output.image = image.uuid;

  		}

  		meta.textures[ this.uuid ] = output;

  		return output;

  	},

  	dispose: function () {

  		this.dispatchEvent( { type: 'dispose' } );

  	},

  	transformUv: function ( uv ) {

  		if ( this.mapping !== UVMapping$1 ) { return; }

  		uv.applyMatrix3( this.matrix );

  		if ( uv.x < 0 || uv.x > 1 ) {

  			switch ( this.wrapS ) {

  				case RepeatWrapping$1:

  					uv.x = uv.x - Math.floor( uv.x );
  					break;

  				case ClampToEdgeWrapping$1:

  					uv.x = uv.x < 0 ? 0 : 1;
  					break;

  				case MirroredRepeatWrapping$1:

  					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

  						uv.x = Math.ceil( uv.x ) - uv.x;

  					} else {

  						uv.x = uv.x - Math.floor( uv.x );

  					}
  					break;

  			}

  		}

  		if ( uv.y < 0 || uv.y > 1 ) {

  			switch ( this.wrapT ) {

  				case RepeatWrapping$1:

  					uv.y = uv.y - Math.floor( uv.y );
  					break;

  				case ClampToEdgeWrapping$1:

  					uv.y = uv.y < 0 ? 0 : 1;
  					break;

  				case MirroredRepeatWrapping$1:

  					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

  						uv.y = Math.ceil( uv.y ) - uv.y;

  					} else {

  						uv.y = uv.y - Math.floor( uv.y );

  					}
  					break;

  			}

  		}

  		if ( this.flipY ) {

  			uv.y = 1 - uv.y;

  		}

  	}

  } );

  /**
   * @author supereggbert / http://www.paulbrunt.co.uk/
   * @author philogb / http://blog.thejit.org/
   * @author mikael emtinger / http://gomo.se/
   * @author egraether / http://egraether.com/
   * @author WestLangley / http://github.com/WestLangley
   */

  function Vector4$1( x, y, z, w ) {

  	this.x = x || 0;
  	this.y = y || 0;
  	this.z = z || 0;
  	this.w = ( w !== undefined ) ? w : 1;

  }

  Object.assign( Vector4$1.prototype, {

  	isVector4: true,

  	set: function ( x, y, z, w ) {

  		this.x = x;
  		this.y = y;
  		this.z = z;
  		this.w = w;

  		return this;

  	},

  	setScalar: function ( scalar ) {

  		this.x = scalar;
  		this.y = scalar;
  		this.z = scalar;
  		this.w = scalar;

  		return this;

  	},

  	setX: function ( x ) {

  		this.x = x;

  		return this;

  	},

  	setY: function ( y ) {

  		this.y = y;

  		return this;

  	},

  	setZ: function ( z ) {

  		this.z = z;

  		return this;

  	},

  	setW: function ( w ) {

  		this.w = w;

  		return this;

  	},

  	setComponent: function ( index, value ) {

  		switch ( index ) {

  			case 0: this.x = value; break;
  			case 1: this.y = value; break;
  			case 2: this.z = value; break;
  			case 3: this.w = value; break;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  		return this;

  	},

  	getComponent: function ( index ) {

  		switch ( index ) {

  			case 0: return this.x;
  			case 1: return this.y;
  			case 2: return this.z;
  			case 3: return this.w;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  	},

  	clone: function () {

  		return new this.constructor( this.x, this.y, this.z, this.w );

  	},

  	copy: function ( v ) {

  		this.x = v.x;
  		this.y = v.y;
  		this.z = v.z;
  		this.w = ( v.w !== undefined ) ? v.w : 1;

  		return this;

  	},

  	add: function ( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
  			return this.addVectors( v, w );

  		}

  		this.x += v.x;
  		this.y += v.y;
  		this.z += v.z;
  		this.w += v.w;

  		return this;

  	},

  	addScalar: function ( s ) {

  		this.x += s;
  		this.y += s;
  		this.z += s;
  		this.w += s;

  		return this;

  	},

  	addVectors: function ( a, b ) {

  		this.x = a.x + b.x;
  		this.y = a.y + b.y;
  		this.z = a.z + b.z;
  		this.w = a.w + b.w;

  		return this;

  	},

  	addScaledVector: function ( v, s ) {

  		this.x += v.x * s;
  		this.y += v.y * s;
  		this.z += v.z * s;
  		this.w += v.w * s;

  		return this;

  	},

  	sub: function ( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
  			return this.subVectors( v, w );

  		}

  		this.x -= v.x;
  		this.y -= v.y;
  		this.z -= v.z;
  		this.w -= v.w;

  		return this;

  	},

  	subScalar: function ( s ) {

  		this.x -= s;
  		this.y -= s;
  		this.z -= s;
  		this.w -= s;

  		return this;

  	},

  	subVectors: function ( a, b ) {

  		this.x = a.x - b.x;
  		this.y = a.y - b.y;
  		this.z = a.z - b.z;
  		this.w = a.w - b.w;

  		return this;

  	},

  	multiplyScalar: function ( scalar ) {

  		this.x *= scalar;
  		this.y *= scalar;
  		this.z *= scalar;
  		this.w *= scalar;

  		return this;

  	},

  	applyMatrix4: function ( m ) {

  		var x = this.x, y = this.y, z = this.z, w = this.w;
  		var e = m.elements;

  		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
  		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
  		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
  		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

  		return this;

  	},

  	divideScalar: function ( scalar ) {

  		return this.multiplyScalar( 1 / scalar );

  	},

  	setAxisAngleFromQuaternion: function ( q ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

  		// q is assumed to be normalized

  		this.w = 2 * Math.acos( q.w );

  		var s = Math.sqrt( 1 - q.w * q.w );

  		if ( s < 0.0001 ) {

  			this.x = 1;
  			this.y = 0;
  			this.z = 0;

  		} else {

  			this.x = q.x / s;
  			this.y = q.y / s;
  			this.z = q.z / s;

  		}

  		return this;

  	},

  	setAxisAngleFromRotationMatrix: function ( m ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		var angle, x, y, z,		// variables for result
  			epsilon = 0.01,		// margin to allow for rounding errors
  			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

  			te = m.elements,

  			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
  			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
  			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

  		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
  		     ( Math.abs( m13 - m31 ) < epsilon ) &&
  		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

  			// singularity found
  			// first check for identity matrix which must have +1 for all terms
  			// in leading diagonal and zero in other terms

  			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
  			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
  			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
  			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

  				// this singularity is identity matrix so angle = 0

  				this.set( 1, 0, 0, 0 );

  				return this; // zero angle, arbitrary axis

  			}

  			// otherwise this singularity is angle = 180

  			angle = Math.PI;

  			var xx = ( m11 + 1 ) / 2;
  			var yy = ( m22 + 1 ) / 2;
  			var zz = ( m33 + 1 ) / 2;
  			var xy = ( m12 + m21 ) / 4;
  			var xz = ( m13 + m31 ) / 4;
  			var yz = ( m23 + m32 ) / 4;

  			if ( ( xx > yy ) && ( xx > zz ) ) {

  				// m11 is the largest diagonal term

  				if ( xx < epsilon ) {

  					x = 0;
  					y = 0.707106781;
  					z = 0.707106781;

  				} else {

  					x = Math.sqrt( xx );
  					y = xy / x;
  					z = xz / x;

  				}

  			} else if ( yy > zz ) {

  				// m22 is the largest diagonal term

  				if ( yy < epsilon ) {

  					x = 0.707106781;
  					y = 0;
  					z = 0.707106781;

  				} else {

  					y = Math.sqrt( yy );
  					x = xy / y;
  					z = yz / y;

  				}

  			} else {

  				// m33 is the largest diagonal term so base result on this

  				if ( zz < epsilon ) {

  					x = 0.707106781;
  					y = 0.707106781;
  					z = 0;

  				} else {

  					z = Math.sqrt( zz );
  					x = xz / z;
  					y = yz / z;

  				}

  			}

  			this.set( x, y, z, angle );

  			return this; // return 180 deg rotation

  		}

  		// as we have reached here there are no singularities so we can handle normally

  		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
  		                   ( m13 - m31 ) * ( m13 - m31 ) +
  		                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

  		if ( Math.abs( s ) < 0.001 ) { s = 1; }

  		// prevent divide by zero, should not happen if matrix is orthogonal and should be
  		// caught by singularity test above, but I've left it in just in case

  		this.x = ( m32 - m23 ) / s;
  		this.y = ( m13 - m31 ) / s;
  		this.z = ( m21 - m12 ) / s;
  		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

  		return this;

  	},

  	min: function ( v ) {

  		this.x = Math.min( this.x, v.x );
  		this.y = Math.min( this.y, v.y );
  		this.z = Math.min( this.z, v.z );
  		this.w = Math.min( this.w, v.w );

  		return this;

  	},

  	max: function ( v ) {

  		this.x = Math.max( this.x, v.x );
  		this.y = Math.max( this.y, v.y );
  		this.z = Math.max( this.z, v.z );
  		this.w = Math.max( this.w, v.w );

  		return this;

  	},

  	clamp: function ( min, max ) {

  		// assumes min < max, componentwise

  		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
  		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
  		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
  		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

  		return this;

  	},

  	clampScalar: function () {

  		var min, max;

  		return function clampScalar( minVal, maxVal ) {

  			if ( min === undefined ) {

  				min = new Vector4$1();
  				max = new Vector4$1();

  			}

  			min.set( minVal, minVal, minVal, minVal );
  			max.set( maxVal, maxVal, maxVal, maxVal );

  			return this.clamp( min, max );

  		};

  	}(),

  	clampLength: function ( min, max ) {

  		var length = this.length();

  		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

  	},

  	floor: function () {

  		this.x = Math.floor( this.x );
  		this.y = Math.floor( this.y );
  		this.z = Math.floor( this.z );
  		this.w = Math.floor( this.w );

  		return this;

  	},

  	ceil: function () {

  		this.x = Math.ceil( this.x );
  		this.y = Math.ceil( this.y );
  		this.z = Math.ceil( this.z );
  		this.w = Math.ceil( this.w );

  		return this;

  	},

  	round: function () {

  		this.x = Math.round( this.x );
  		this.y = Math.round( this.y );
  		this.z = Math.round( this.z );
  		this.w = Math.round( this.w );

  		return this;

  	},

  	roundToZero: function () {

  		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
  		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
  		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
  		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

  		return this;

  	},

  	negate: function () {

  		this.x = - this.x;
  		this.y = - this.y;
  		this.z = - this.z;
  		this.w = - this.w;

  		return this;

  	},

  	dot: function ( v ) {

  		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

  	},

  	lengthSq: function () {

  		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

  	},

  	length: function () {

  		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

  	},

  	lengthManhattan: function () {

  		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

  	},

  	normalize: function () {

  		return this.divideScalar( this.length() || 1 );

  	},

  	setLength: function ( length ) {

  		return this.normalize().multiplyScalar( length );

  	},

  	lerp: function ( v, alpha ) {

  		this.x += ( v.x - this.x ) * alpha;
  		this.y += ( v.y - this.y ) * alpha;
  		this.z += ( v.z - this.z ) * alpha;
  		this.w += ( v.w - this.w ) * alpha;

  		return this;

  	},

  	lerpVectors: function ( v1, v2, alpha ) {

  		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

  	},

  	equals: function ( v ) {

  		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

  	},

  	fromArray: function ( array, offset ) {

  		if ( offset === undefined ) { offset = 0; }

  		this.x = array[ offset ];
  		this.y = array[ offset + 1 ];
  		this.z = array[ offset + 2 ];
  		this.w = array[ offset + 3 ];

  		return this;

  	},

  	toArray: function ( array, offset ) {

  		if ( array === undefined ) { array = []; }
  		if ( offset === undefined ) { offset = 0; }

  		array[ offset ] = this.x;
  		array[ offset + 1 ] = this.y;
  		array[ offset + 2 ] = this.z;
  		array[ offset + 3 ] = this.w;

  		return array;

  	},

  	fromBufferAttribute: function ( attribute, index, offset ) {

  		if ( offset !== undefined ) {

  			console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

  		}

  		this.x = attribute.getX( index );
  		this.y = attribute.getY( index );
  		this.z = attribute.getZ( index );
  		this.w = attribute.getW( index );

  		return this;

  	}

  } );

  /**
   * @author szimek / https://github.com/szimek/
   * @author alteredq / http://alteredqualia.com/
   * @author Marius Kintel / https://github.com/kintel
   */

  /*
   In options, we can specify:
   * Texture parameters for an auto-generated target texture
   * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
  */
  function WebGLRenderTarget( width, height, options ) {

  	this.uuid = _Math$1.generateUUID();

  	this.width = width;
  	this.height = height;

  	this.scissor = new Vector4$1( 0, 0, width, height );
  	this.scissorTest = false;

  	this.viewport = new Vector4$1( 0, 0, width, height );

  	options = options || {};

  	if ( options.minFilter === undefined ) { options.minFilter = LinearFilter$1; }

  	this.texture = new Texture$1( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

  	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
  	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
  	this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

  }

  Object.assign( WebGLRenderTarget.prototype, EventDispatcher$1.prototype, {

  	isWebGLRenderTarget: true,

  	setSize: function ( width, height ) {

  		if ( this.width !== width || this.height !== height ) {

  			this.width = width;
  			this.height = height;

  			this.dispose();

  		}

  		this.viewport.set( 0, 0, width, height );
  		this.scissor.set( 0, 0, width, height );

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( source ) {

  		this.width = source.width;
  		this.height = source.height;

  		this.viewport.copy( source.viewport );

  		this.texture = source.texture.clone();

  		this.depthBuffer = source.depthBuffer;
  		this.stencilBuffer = source.stencilBuffer;
  		this.depthTexture = source.depthTexture;

  		return this;

  	},

  	dispose: function () {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  } );

  /**
   * @author alteredq / http://alteredqualia.com
   */

  function WebGLRenderTargetCube( width, height, options ) {

  	WebGLRenderTarget.call( this, width, height, options );

  	this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
  	this.activeMipMapLevel = 0;

  }

  WebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );
  WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;

  WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

  	Texture$1.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

  	this.image = { data: data, width: width, height: height };

  	this.magFilter = magFilter !== undefined ? magFilter : NearestFilter$1;
  	this.minFilter = minFilter !== undefined ? minFilter : NearestFilter$1;

  	this.generateMipmaps = false;
  	this.flipY = false;
  	this.unpackAlignment = 1;

  }

  DataTexture.prototype = Object.create( Texture$1.prototype );
  DataTexture.prototype.constructor = DataTexture;

  DataTexture.prototype.isDataTexture = true;

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

  	images = images !== undefined ? images : [];
  	mapping = mapping !== undefined ? mapping : CubeReflectionMapping$1;

  	Texture$1.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

  	this.flipY = false;

  }

  CubeTexture.prototype = Object.create( Texture$1.prototype );
  CubeTexture.prototype.constructor = CubeTexture;

  CubeTexture.prototype.isCubeTexture = true;

  Object.defineProperty( CubeTexture.prototype, 'images', {

  	get: function () {

  		return this.image;

  	},

  	set: function ( value ) {

  		this.image = value;

  	}

  } );

  /**
   * @author tschw
   *
   * Uniforms of a program.
   * Those form a tree structure with a special top-level container for the root,
   * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
   *
   *
   * Properties of inner nodes including the top-level container:
   *
   * .seq - array of nested uniforms
   * .map - nested uniforms by name
   *
   *
   * Methods of all nodes except the top-level container:
   *
   * .setValue( gl, value, [renderer] )
   *
   * 		uploads a uniform value(s)
   *  	the 'renderer' parameter is needed for sampler uniforms
   *
   *
   * Static methods of the top-level container (renderer factorizations):
   *
   * .upload( gl, seq, values, renderer )
   *
   * 		sets uniforms in 'seq' to 'values[id].value'
   *
   * .seqWithValue( seq, values ) : filteredSeq
   *
   * 		filters 'seq' entries with corresponding entry in values
   *
   *
   * Methods of the top-level container (renderer factorizations):
   *
   * .setValue( gl, name, value )
   *
   * 		sets uniform with  name 'name' to 'value'
   *
   * .set( gl, obj, prop )
   *
   * 		sets uniform from object and property with same name than uniform
   *
   * .setOptional( gl, obj, prop )
   *
   * 		like .set for an optional property of the object
   *
   */

  var emptyTexture = new Texture$1();
  var emptyCubeTexture = new CubeTexture();

  // --- Base for inner nodes (including the root) ---

  function UniformContainer() {

  	this.seq = [];
  	this.map = {};

  }

  // --- Utilities ---

  // Array Caches (provide typed arrays for temporary by size)

  var arrayCacheF32 = [];
  var arrayCacheI32 = [];

  // Float32Array caches used for uploading Matrix uniforms

  var mat4array = new Float32Array( 16 );
  var mat3array = new Float32Array( 9 );

  // Flattening for arrays of vectors and matrices

  function flatten( array, nBlocks, blockSize ) {

  	var firstElem = array[ 0 ];

  	if ( firstElem <= 0 || firstElem > 0 ) { return array; }
  	// unoptimized: ! isNaN( firstElem )
  	// see http://jacksondunstan.com/articles/983

  	var n = nBlocks * blockSize,
  		r = arrayCacheF32[ n ];

  	if ( r === undefined ) {

  		r = new Float32Array( n );
  		arrayCacheF32[ n ] = r;

  	}

  	if ( nBlocks !== 0 ) {

  		firstElem.toArray( r, 0 );

  		for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {

  			offset += blockSize;
  			array[ i ].toArray( r, offset );

  		}

  	}

  	return r;

  }

  // Texture unit allocation

  function allocTexUnits( renderer, n ) {

  	var r = arrayCacheI32[ n ];

  	if ( r === undefined ) {

  		r = new Int32Array( n );
  		arrayCacheI32[ n ] = r;

  	}

  	for ( var i = 0; i !== n; ++ i )
  		{ r[ i ] = renderer.allocTextureUnit(); }

  	return r;

  }

  // --- Setters ---

  // Note: Defining these methods externally, because they come in a bunch
  // and this way their names minify.

  // Single scalar

  function setValue1f( gl, v ) {

  	gl.uniform1f( this.addr, v );

  }

  function setValue1i( gl, v ) {

  	gl.uniform1i( this.addr, v );

  }

  // Single float vector (from flat array or THREE.VectorN)

  function setValue2fv( gl, v ) {

  	if ( v.x === undefined ) {

  		gl.uniform2fv( this.addr, v );

  	} else {

  		gl.uniform2f( this.addr, v.x, v.y );

  	}

  }

  function setValue3fv( gl, v ) {

  	if ( v.x !== undefined ) {

  		gl.uniform3f( this.addr, v.x, v.y, v.z );

  	} else if ( v.r !== undefined ) {

  		gl.uniform3f( this.addr, v.r, v.g, v.b );

  	} else {

  		gl.uniform3fv( this.addr, v );

  	}

  }

  function setValue4fv( gl, v ) {

  	if ( v.x === undefined ) {

  		gl.uniform4fv( this.addr, v );

  	} else {

  		 gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

  	}

  }

  // Single matrix (from flat array or MatrixN)

  function setValue2fm( gl, v ) {

  	gl.uniformMatrix2fv( this.addr, false, v.elements || v );

  }

  function setValue3fm( gl, v ) {

  	if ( v.elements === undefined ) {

  		gl.uniformMatrix3fv( this.addr, false, v );

  	} else {

  		mat3array.set( v.elements );
  		gl.uniformMatrix3fv( this.addr, false, mat3array );

  	}

  }

  function setValue4fm( gl, v ) {

  	if ( v.elements === undefined ) {

  		gl.uniformMatrix4fv( this.addr, false, v );

  	} else {

  		mat4array.set( v.elements );
  		gl.uniformMatrix4fv( this.addr, false, mat4array );

  	}

  }

  // Single texture (2D / Cube)

  function setValueT1( gl, v, renderer ) {

  	var unit = renderer.allocTextureUnit();
  	gl.uniform1i( this.addr, unit );
  	renderer.setTexture2D( v || emptyTexture, unit );

  }

  function setValueT6( gl, v, renderer ) {

  	var unit = renderer.allocTextureUnit();
  	gl.uniform1i( this.addr, unit );
  	renderer.setTextureCube( v || emptyCubeTexture, unit );

  }

  // Integer / Boolean vectors or arrays thereof (always flat arrays)

  function setValue2iv( gl, v ) {

  	gl.uniform2iv( this.addr, v );

  }

  function setValue3iv( gl, v ) {

  	gl.uniform3iv( this.addr, v );

  }

  function setValue4iv( gl, v ) {

  	gl.uniform4iv( this.addr, v );

  }

  // Helper to pick the right setter for the singular case

  function getSingularSetter( type ) {

  	switch ( type ) {

  		case 0x1406: return setValue1f; // FLOAT
  		case 0x8b50: return setValue2fv; // _VEC2
  		case 0x8b51: return setValue3fv; // _VEC3
  		case 0x8b52: return setValue4fv; // _VEC4

  		case 0x8b5a: return setValue2fm; // _MAT2
  		case 0x8b5b: return setValue3fm; // _MAT3
  		case 0x8b5c: return setValue4fm; // _MAT4

  		case 0x8b5e: case 0x8d66: return setValueT1; // SAMPLER_2D, SAMPLER_EXTERNAL_OES
  		case 0x8b60: return setValueT6; // SAMPLER_CUBE

  		case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL
  		case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
  		case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
  		case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

  	}

  }

  // Array of scalars

  function setValue1fv( gl, v ) {

  	gl.uniform1fv( this.addr, v );

  }
  function setValue1iv( gl, v ) {

  	gl.uniform1iv( this.addr, v );

  }

  // Array of vectors (flat or from THREE classes)

  function setValueV2a( gl, v ) {

  	gl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );

  }

  function setValueV3a( gl, v ) {

  	gl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );

  }

  function setValueV4a( gl, v ) {

  	gl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );

  }

  // Array of matrices (flat or from THREE clases)

  function setValueM2a( gl, v ) {

  	gl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );

  }

  function setValueM3a( gl, v ) {

  	gl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );

  }

  function setValueM4a( gl, v ) {

  	gl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );

  }

  // Array of textures (2D / Cube)

  function setValueT1a( gl, v, renderer ) {

  	var n = v.length,
  		units = allocTexUnits( renderer, n );

  	gl.uniform1iv( this.addr, units );

  	for ( var i = 0; i !== n; ++ i ) {

  		renderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

  	}

  }

  function setValueT6a( gl, v, renderer ) {

  	var n = v.length,
  		units = allocTexUnits( renderer, n );

  	gl.uniform1iv( this.addr, units );

  	for ( var i = 0; i !== n; ++ i ) {

  		renderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

  	}

  }

  // Helper to pick the right setter for a pure (bottom-level) array

  function getPureArraySetter( type ) {

  	switch ( type ) {

  		case 0x1406: return setValue1fv; // FLOAT
  		case 0x8b50: return setValueV2a; // _VEC2
  		case 0x8b51: return setValueV3a; // _VEC3
  		case 0x8b52: return setValueV4a; // _VEC4

  		case 0x8b5a: return setValueM2a; // _MAT2
  		case 0x8b5b: return setValueM3a; // _MAT3
  		case 0x8b5c: return setValueM4a; // _MAT4

  		case 0x8b5e: return setValueT1a; // SAMPLER_2D
  		case 0x8b60: return setValueT6a; // SAMPLER_CUBE

  		case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL
  		case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
  		case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
  		case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

  	}

  }

  // --- Uniform Classes ---

  function SingleUniform( id, activeInfo, addr ) {

  	this.id = id;
  	this.addr = addr;
  	this.setValue = getSingularSetter( activeInfo.type );

  	// this.path = activeInfo.name; // DEBUG

  }

  function PureArrayUniform( id, activeInfo, addr ) {

  	this.id = id;
  	this.addr = addr;
  	this.size = activeInfo.size;
  	this.setValue = getPureArraySetter( activeInfo.type );

  	// this.path = activeInfo.name; // DEBUG

  }

  function StructuredUniform( id ) {

  	this.id = id;

  	UniformContainer.call( this ); // mix-in

  }

  StructuredUniform.prototype.setValue = function ( gl, value ) {

  	// Note: Don't need an extra 'renderer' parameter, since samplers
  	// are not allowed in structured uniforms.

  	var seq = this.seq;

  	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

  		var u = seq[ i ];
  		u.setValue( gl, value[ u.id ] );

  	}

  };

  // --- Top-level ---

  // Parser - builds up the property tree from the path strings

  var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

  // extracts
  // 	- the identifier (member name or array index)
  //  - followed by an optional right bracket (found when array index)
  //  - followed by an optional left bracket or dot (type of subscript)
  //
  // Note: These portions can be read in a non-overlapping fashion and
  // allow straightforward parsing of the hierarchy that WebGL encodes
  // in the uniform names.

  function addUniform( container, uniformObject ) {

  	container.seq.push( uniformObject );
  	container.map[ uniformObject.id ] = uniformObject;

  }

  function parseUniform( activeInfo, addr, container ) {

  	var path = activeInfo.name,
  		pathLength = path.length;

  	// reset RegExp object, because of the early exit of a previous run
  	RePathPart.lastIndex = 0;

  	for ( ; ; ) {

  		var match = RePathPart.exec( path ),
  			matchEnd = RePathPart.lastIndex,

  			id = match[ 1 ],
  			idIsIndex = match[ 2 ] === ']',
  			subscript = match[ 3 ];

  		if ( idIsIndex ) { id = id | 0; } // convert to integer

  		if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

  			// bare name or "pure" bottom-level array "[0]" suffix

  			addUniform( container, subscript === undefined ?
  				new SingleUniform( id, activeInfo, addr ) :
  				new PureArrayUniform( id, activeInfo, addr ) );

  			break;

  		} else {

  			// step into inner node / create it in case it doesn't exist

  			var map = container.map, next = map[ id ];

  			if ( next === undefined ) {

  				next = new StructuredUniform( id );
  				addUniform( container, next );

  			}

  			container = next;

  		}

  	}

  }

  // Root Container

  function WebGLUniforms( gl, program, renderer ) {
  	var this$1 = this;


  	UniformContainer.call( this );

  	this.renderer = renderer;

  	var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

  	for ( var i = 0; i < n; ++ i ) {

  		var info = gl.getActiveUniform( program, i ),
  			path = info.name,
  			addr = gl.getUniformLocation( program, path );

  		parseUniform( info, addr, this$1 );

  	}

  }

  WebGLUniforms.prototype.setValue = function ( gl, name, value ) {

  	var u = this.map[ name ];

  	if ( u !== undefined ) { u.setValue( gl, value, this.renderer ); }

  };

  WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {

  	var v = object[ name ];

  	if ( v !== undefined ) { this.setValue( gl, name, v ); }

  };


  // Static interface

  WebGLUniforms.upload = function ( gl, seq, values, renderer ) {

  	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

  		var u = seq[ i ],
  			v = values[ u.id ];

  		if ( v.needsUpdate !== false ) {

  			// note: always updating when .needsUpdate is undefined
  			u.setValue( gl, v.value, renderer );

  		}

  	}

  };

  WebGLUniforms.seqWithValue = function ( seq, values ) {

  	var r = [];

  	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

  		var u = seq[ i ];
  		if ( u.id in values ) { r.push( u ); }

  	}

  	return r;

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  var ColorKeywords$1 = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
  	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
  	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
  	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
  	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
  	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
  	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
  	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
  	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
  	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
  	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
  	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
  	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
  	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
  	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
  	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
  	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
  	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
  	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
  	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
  	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
  	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
  	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
  	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

  function Color$1( r, g, b ) {

  	if ( g === undefined && b === undefined ) {

  		// r is THREE.Color, hex or string
  		return this.set( r );

  	}

  	return this.setRGB( r, g, b );

  }

  Object.assign( Color$1.prototype, {

  	isColor: true,

  	r: 1, g: 1, b: 1,

  	set: function ( value ) {

  		if ( value && value.isColor ) {

  			this.copy( value );

  		} else if ( typeof value === 'number' ) {

  			this.setHex( value );

  		} else if ( typeof value === 'string' ) {

  			this.setStyle( value );

  		}

  		return this;

  	},

  	setScalar: function ( scalar ) {

  		this.r = scalar;
  		this.g = scalar;
  		this.b = scalar;

  		return this;

  	},

  	setHex: function ( hex ) {

  		hex = Math.floor( hex );

  		this.r = ( hex >> 16 & 255 ) / 255;
  		this.g = ( hex >> 8 & 255 ) / 255;
  		this.b = ( hex & 255 ) / 255;

  		return this;

  	},

  	setRGB: function ( r, g, b ) {

  		this.r = r;
  		this.g = g;
  		this.b = b;

  		return this;

  	},

  	setHSL: function () {

  		function hue2rgb( p, q, t ) {

  			if ( t < 0 ) { t += 1; }
  			if ( t > 1 ) { t -= 1; }
  			if ( t < 1 / 6 ) { return p + ( q - p ) * 6 * t; }
  			if ( t < 1 / 2 ) { return q; }
  			if ( t < 2 / 3 ) { return p + ( q - p ) * 6 * ( 2 / 3 - t ); }
  			return p;

  		}

  		return function setHSL( h, s, l ) {

  			// h,s,l ranges are in 0.0 - 1.0
  			h = _Math$1.euclideanModulo( h, 1 );
  			s = _Math$1.clamp( s, 0, 1 );
  			l = _Math$1.clamp( l, 0, 1 );

  			if ( s === 0 ) {

  				this.r = this.g = this.b = l;

  			} else {

  				var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
  				var q = ( 2 * l ) - p;

  				this.r = hue2rgb( q, p, h + 1 / 3 );
  				this.g = hue2rgb( q, p, h );
  				this.b = hue2rgb( q, p, h - 1 / 3 );

  			}

  			return this;

  		};

  	}(),

  	setStyle: function ( style ) {

  		function handleAlpha( string ) {

  			if ( string === undefined ) { return; }

  			if ( parseFloat( string ) < 1 ) {

  				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

  			}

  		}


  		var m;

  		if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

  			// rgb / hsl

  			var color;
  			var name = m[ 1 ];
  			var components = m[ 2 ];

  			switch ( name ) {

  				case 'rgb':
  				case 'rgba':

  					if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

  						// rgb(255,0,0) rgba(255,0,0,0.5)
  						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
  						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
  						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

  						handleAlpha( color[ 5 ] );

  						return this;

  					}

  					if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

  						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
  						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
  						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
  						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

  						handleAlpha( color[ 5 ] );

  						return this;

  					}

  					break;

  				case 'hsl':
  				case 'hsla':

  					if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

  						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
  						var h = parseFloat( color[ 1 ] ) / 360;
  						var s = parseInt( color[ 2 ], 10 ) / 100;
  						var l = parseInt( color[ 3 ], 10 ) / 100;

  						handleAlpha( color[ 5 ] );

  						return this.setHSL( h, s, l );

  					}

  					break;

  			}

  		} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

  			// hex color

  			var hex = m[ 1 ];
  			var size = hex.length;

  			if ( size === 3 ) {

  				// #ff0
  				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
  				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
  				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

  				return this;

  			} else if ( size === 6 ) {

  				// #ff0000
  				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
  				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
  				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

  				return this;

  			}

  		}

  		if ( style && style.length > 0 ) {

  			// color keywords
  			var hex = ColorKeywords$1[ style ];

  			if ( hex !== undefined ) {

  				// red
  				this.setHex( hex );

  			} else {

  				// unknown color
  				console.warn( 'THREE.Color: Unknown color ' + style );

  			}

  		}

  		return this;

  	},

  	clone: function () {

  		return new this.constructor( this.r, this.g, this.b );

  	},

  	copy: function ( color ) {

  		this.r = color.r;
  		this.g = color.g;
  		this.b = color.b;

  		return this;

  	},

  	copyGammaToLinear: function ( color, gammaFactor ) {

  		if ( gammaFactor === undefined ) { gammaFactor = 2.0; }

  		this.r = Math.pow( color.r, gammaFactor );
  		this.g = Math.pow( color.g, gammaFactor );
  		this.b = Math.pow( color.b, gammaFactor );

  		return this;

  	},

  	copyLinearToGamma: function ( color, gammaFactor ) {

  		if ( gammaFactor === undefined ) { gammaFactor = 2.0; }

  		var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

  		this.r = Math.pow( color.r, safeInverse );
  		this.g = Math.pow( color.g, safeInverse );
  		this.b = Math.pow( color.b, safeInverse );

  		return this;

  	},

  	convertGammaToLinear: function () {

  		var r = this.r, g = this.g, b = this.b;

  		this.r = r * r;
  		this.g = g * g;
  		this.b = b * b;

  		return this;

  	},

  	convertLinearToGamma: function () {

  		this.r = Math.sqrt( this.r );
  		this.g = Math.sqrt( this.g );
  		this.b = Math.sqrt( this.b );

  		return this;

  	},

  	getHex: function () {

  		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

  	},

  	getHexString: function () {

  		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

  	},

  	getHSL: function ( optionalTarget ) {

  		// h,s,l ranges are in 0.0 - 1.0

  		var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

  		var r = this.r, g = this.g, b = this.b;

  		var max = Math.max( r, g, b );
  		var min = Math.min( r, g, b );

  		var hue, saturation;
  		var lightness = ( min + max ) / 2.0;

  		if ( min === max ) {

  			hue = 0;
  			saturation = 0;

  		} else {

  			var delta = max - min;

  			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

  			switch ( max ) {

  				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
  				case g: hue = ( b - r ) / delta + 2; break;
  				case b: hue = ( r - g ) / delta + 4; break;

  			}

  			hue /= 6;

  		}

  		hsl.h = hue;
  		hsl.s = saturation;
  		hsl.l = lightness;

  		return hsl;

  	},

  	getStyle: function () {

  		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

  	},

  	offsetHSL: function ( h, s, l ) {

  		var hsl = this.getHSL();

  		hsl.h += h; hsl.s += s; hsl.l += l;

  		this.setHSL( hsl.h, hsl.s, hsl.l );

  		return this;

  	},

  	add: function ( color ) {

  		this.r += color.r;
  		this.g += color.g;
  		this.b += color.b;

  		return this;

  	},

  	addColors: function ( color1, color2 ) {

  		this.r = color1.r + color2.r;
  		this.g = color1.g + color2.g;
  		this.b = color1.b + color2.b;

  		return this;

  	},

  	addScalar: function ( s ) {

  		this.r += s;
  		this.g += s;
  		this.b += s;

  		return this;

  	},

  	sub: function ( color ) {

  		this.r = Math.max( 0, this.r - color.r );
  		this.g = Math.max( 0, this.g - color.g );
  		this.b = Math.max( 0, this.b - color.b );

  		return this;

  	},

  	multiply: function ( color ) {

  		this.r *= color.r;
  		this.g *= color.g;
  		this.b *= color.b;

  		return this;

  	},

  	multiplyScalar: function ( s ) {

  		this.r *= s;
  		this.g *= s;
  		this.b *= s;

  		return this;

  	},

  	lerp: function ( color, alpha ) {

  		this.r += ( color.r - this.r ) * alpha;
  		this.g += ( color.g - this.g ) * alpha;
  		this.b += ( color.b - this.b ) * alpha;

  		return this;

  	},

  	equals: function ( c ) {

  		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

  	},

  	fromArray: function ( array, offset ) {

  		if ( offset === undefined ) { offset = 0; }

  		this.r = array[ offset ];
  		this.g = array[ offset + 1 ];
  		this.b = array[ offset + 2 ];

  		return this;

  	},

  	toArray: function ( array, offset ) {

  		if ( array === undefined ) { array = []; }
  		if ( offset === undefined ) { offset = 0; }

  		array[ offset ] = this.r;
  		array[ offset + 1 ] = this.g;
  		array[ offset + 2 ] = this.b;

  		return array;

  	},

  	toJSON: function () {

  		return this.getHex();

  	}

  } );

  /**
   * Uniforms library for shared webgl shaders
   */

  var UniformsLib = {

  	common: {

  		diffuse: { value: new Color$1( 0xeeeeee ) },
  		opacity: { value: 1.0 },

  		map: { value: null },
  		uvTransform: { value: new Matrix3$1() },

  		alphaMap: { value: null },

  	},

  	specularmap: {

  		specularMap: { value: null },

  	},

  	envmap: {

  		envMap: { value: null },
  		flipEnvMap: { value: - 1 },
  		reflectivity: { value: 1.0 },
  		refractionRatio: { value: 0.98 }

  	},

  	aomap: {

  		aoMap: { value: null },
  		aoMapIntensity: { value: 1 }

  	},

  	lightmap: {

  		lightMap: { value: null },
  		lightMapIntensity: { value: 1 }

  	},

  	emissivemap: {

  		emissiveMap: { value: null }

  	},

  	bumpmap: {

  		bumpMap: { value: null },
  		bumpScale: { value: 1 }

  	},

  	normalmap: {

  		normalMap: { value: null },
  		normalScale: { value: new Vector2$1( 1, 1 ) }

  	},

  	displacementmap: {

  		displacementMap: { value: null },
  		displacementScale: { value: 1 },
  		displacementBias: { value: 0 }

  	},

  	roughnessmap: {

  		roughnessMap: { value: null }

  	},

  	metalnessmap: {

  		metalnessMap: { value: null }

  	},

  	gradientmap: {

  		gradientMap: { value: null }

  	},

  	fog: {

  		fogDensity: { value: 0.00025 },
  		fogNear: { value: 1 },
  		fogFar: { value: 2000 },
  		fogColor: { value: new Color$1( 0xffffff ) }

  	},

  	lights: {

  		ambientLightColor: { value: [] },

  		directionalLights: { value: [], properties: {
  			direction: {},
  			color: {},

  			shadow: {},
  			shadowBias: {},
  			shadowRadius: {},
  			shadowMapSize: {}
  		} },

  		directionalShadowMap: { value: [] },
  		directionalShadowMatrix: { value: [] },

  		spotLights: { value: [], properties: {
  			color: {},
  			position: {},
  			direction: {},
  			distance: {},
  			coneCos: {},
  			penumbraCos: {},
  			decay: {},

  			shadow: {},
  			shadowBias: {},
  			shadowRadius: {},
  			shadowMapSize: {}
  		} },

  		spotShadowMap: { value: [] },
  		spotShadowMatrix: { value: [] },

  		pointLights: { value: [], properties: {
  			color: {},
  			position: {},
  			decay: {},
  			distance: {},

  			shadow: {},
  			shadowBias: {},
  			shadowRadius: {},
  			shadowMapSize: {},
  			shadowCameraNear: {},
  			shadowCameraFar: {}
  		} },

  		pointShadowMap: { value: [] },
  		pointShadowMatrix: { value: [] },

  		hemisphereLights: { value: [], properties: {
  			direction: {},
  			skyColor: {},
  			groundColor: {}
  		} },

  		// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
  		rectAreaLights: { value: [], properties: {
  			color: {},
  			position: {},
  			width: {},
  			height: {}
  		} }

  	},

  	points: {

  		diffuse: { value: new Color$1( 0xeeeeee ) },
  		opacity: { value: 1.0 },
  		size: { value: 1.0 },
  		scale: { value: 1.0 },
  		map: { value: null },
  		uvTransform: { value: new Matrix3$1() }

  	}

  };

  /**
   * Uniform Utilities
   */

  var UniformsUtils$1 = {

  	merge: function ( uniforms ) {
  		var this$1 = this;


  		var merged = {};

  		for ( var u = 0; u < uniforms.length; u ++ ) {

  			var tmp = this$1.clone( uniforms[ u ] );

  			for ( var p in tmp ) {

  				merged[ p ] = tmp[ p ];

  			}

  		}

  		return merged;

  	},

  	clone: function ( uniforms_src ) {

  		var uniforms_dst = {};

  		for ( var u in uniforms_src ) {

  			uniforms_dst[ u ] = {};

  			for ( var p in uniforms_src[ u ] ) {

  				var parameter_src = uniforms_src[ u ][ p ];

  				if ( parameter_src && ( parameter_src.isColor ||
  					parameter_src.isMatrix3 || parameter_src.isMatrix4 ||
  					parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||
  					parameter_src.isTexture ) ) {

  					uniforms_dst[ u ][ p ] = parameter_src.clone();

  				} else if ( Array.isArray( parameter_src ) ) {

  					uniforms_dst[ u ][ p ] = parameter_src.slice();

  				} else {

  					uniforms_dst[ u ][ p ] = parameter_src;

  				}

  			}

  		}

  		return uniforms_dst;

  	}

  };

  var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";

  var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";

  var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";

  var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";

  var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

  var begin_vertex = "\nvec3 transformed = vec3( position );\n";

  var beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";

  var bsdfs = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\n\tfloat b = 3.45068 + (4.18814 + y) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transpose( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\n\treturn result;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";

  var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";

  var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n";

  var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";

  var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";

  var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";

  var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";

  var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";

  var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

  var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";

  var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transpose( const in mat3 v ) {\n\tmat3 tmp;\n\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n";

  var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";

  var defaultnormal_vertex = "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n";

  var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";

  var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";

  var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";

  var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";

  var encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";

  var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n";

  var envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";

  var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";

  var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";

  var envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";

  var fog_vertex = "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif";

  var fog_pars_vertex = "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n";

  var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";

  var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n";

  var gradientmap_pars_fragment = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n";

  var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";

  var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

  var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";

  var lights_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";

  var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";

  var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";

  var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";

  var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";

  var lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";

  var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

  var logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";

  var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";

  var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n";

  var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";

  var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";

  var map_particle_fragment = "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";

  var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n";

  var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n";

  var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

  var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";

  var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

  var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";

  var normal_fragment = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";

  var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";

  var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";

  var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";

  var project_vertex = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n";

  var dithering_fragment = "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n";

  var dithering_pars_fragment = "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n";

  var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n";

  var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

  var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";

  var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";

  var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";

  var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";

  var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

  var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";

  var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n";

  var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";

  var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

  var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

  var tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";

  var tonemapping_pars_fragment = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";

  var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";

  var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n";

  var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

  var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

  var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";

  var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";

  var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n";

  var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";

  var cube_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";

  var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";

  var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";

  var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n";

  var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n";

  var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";

  var equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";

  var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

  var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n";

  var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

  var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n";

  var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";

  var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

  var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";

  var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

  var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";

  var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

  var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n";

  var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n";

  var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

  var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

  var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n";

  var shadow_vert = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

  var ShaderChunk = {
  	alphamap_fragment: alphamap_fragment,
  	alphamap_pars_fragment: alphamap_pars_fragment,
  	alphatest_fragment: alphatest_fragment,
  	aomap_fragment: aomap_fragment,
  	aomap_pars_fragment: aomap_pars_fragment,
  	begin_vertex: begin_vertex,
  	beginnormal_vertex: beginnormal_vertex,
  	bsdfs: bsdfs,
  	bumpmap_pars_fragment: bumpmap_pars_fragment,
  	clipping_planes_fragment: clipping_planes_fragment,
  	clipping_planes_pars_fragment: clipping_planes_pars_fragment,
  	clipping_planes_pars_vertex: clipping_planes_pars_vertex,
  	clipping_planes_vertex: clipping_planes_vertex,
  	color_fragment: color_fragment,
  	color_pars_fragment: color_pars_fragment,
  	color_pars_vertex: color_pars_vertex,
  	color_vertex: color_vertex,
  	common: common,
  	cube_uv_reflection_fragment: cube_uv_reflection_fragment,
  	defaultnormal_vertex: defaultnormal_vertex,
  	displacementmap_pars_vertex: displacementmap_pars_vertex,
  	displacementmap_vertex: displacementmap_vertex,
  	emissivemap_fragment: emissivemap_fragment,
  	emissivemap_pars_fragment: emissivemap_pars_fragment,
  	encodings_fragment: encodings_fragment,
  	encodings_pars_fragment: encodings_pars_fragment,
  	envmap_fragment: envmap_fragment,
  	envmap_pars_fragment: envmap_pars_fragment,
  	envmap_pars_vertex: envmap_pars_vertex,
  	envmap_vertex: envmap_vertex,
  	fog_vertex: fog_vertex,
  	fog_pars_vertex: fog_pars_vertex,
  	fog_fragment: fog_fragment,
  	fog_pars_fragment: fog_pars_fragment,
  	gradientmap_pars_fragment: gradientmap_pars_fragment,
  	lightmap_fragment: lightmap_fragment,
  	lightmap_pars_fragment: lightmap_pars_fragment,
  	lights_lambert_vertex: lights_lambert_vertex,
  	lights_pars: lights_pars,
  	lights_phong_fragment: lights_phong_fragment,
  	lights_phong_pars_fragment: lights_phong_pars_fragment,
  	lights_physical_fragment: lights_physical_fragment,
  	lights_physical_pars_fragment: lights_physical_pars_fragment,
  	lights_template: lights_template,
  	logdepthbuf_fragment: logdepthbuf_fragment,
  	logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
  	logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
  	logdepthbuf_vertex: logdepthbuf_vertex,
  	map_fragment: map_fragment,
  	map_pars_fragment: map_pars_fragment,
  	map_particle_fragment: map_particle_fragment,
  	map_particle_pars_fragment: map_particle_pars_fragment,
  	metalnessmap_fragment: metalnessmap_fragment,
  	metalnessmap_pars_fragment: metalnessmap_pars_fragment,
  	morphnormal_vertex: morphnormal_vertex,
  	morphtarget_pars_vertex: morphtarget_pars_vertex,
  	morphtarget_vertex: morphtarget_vertex,
  	normal_fragment: normal_fragment,
  	normalmap_pars_fragment: normalmap_pars_fragment,
  	packing: packing,
  	premultiplied_alpha_fragment: premultiplied_alpha_fragment,
  	project_vertex: project_vertex,
  	dithering_fragment: dithering_fragment,
  	dithering_pars_fragment: dithering_pars_fragment,
  	roughnessmap_fragment: roughnessmap_fragment,
  	roughnessmap_pars_fragment: roughnessmap_pars_fragment,
  	shadowmap_pars_fragment: shadowmap_pars_fragment,
  	shadowmap_pars_vertex: shadowmap_pars_vertex,
  	shadowmap_vertex: shadowmap_vertex,
  	shadowmask_pars_fragment: shadowmask_pars_fragment,
  	skinbase_vertex: skinbase_vertex,
  	skinning_pars_vertex: skinning_pars_vertex,
  	skinning_vertex: skinning_vertex,
  	skinnormal_vertex: skinnormal_vertex,
  	specularmap_fragment: specularmap_fragment,
  	specularmap_pars_fragment: specularmap_pars_fragment,
  	tonemapping_fragment: tonemapping_fragment,
  	tonemapping_pars_fragment: tonemapping_pars_fragment,
  	uv_pars_fragment: uv_pars_fragment,
  	uv_pars_vertex: uv_pars_vertex,
  	uv_vertex: uv_vertex,
  	uv2_pars_fragment: uv2_pars_fragment,
  	uv2_pars_vertex: uv2_pars_vertex,
  	uv2_vertex: uv2_vertex,
  	worldpos_vertex: worldpos_vertex,

  	cube_frag: cube_frag,
  	cube_vert: cube_vert,
  	depth_frag: depth_frag,
  	depth_vert: depth_vert,
  	distanceRGBA_frag: distanceRGBA_frag,
  	distanceRGBA_vert: distanceRGBA_vert,
  	equirect_frag: equirect_frag,
  	equirect_vert: equirect_vert,
  	linedashed_frag: linedashed_frag,
  	linedashed_vert: linedashed_vert,
  	meshbasic_frag: meshbasic_frag,
  	meshbasic_vert: meshbasic_vert,
  	meshlambert_frag: meshlambert_frag,
  	meshlambert_vert: meshlambert_vert,
  	meshphong_frag: meshphong_frag,
  	meshphong_vert: meshphong_vert,
  	meshphysical_frag: meshphysical_frag,
  	meshphysical_vert: meshphysical_vert,
  	normal_frag: normal_frag,
  	normal_vert: normal_vert,
  	points_frag: points_frag,
  	points_vert: points_vert,
  	shadow_frag: shadow_frag,
  	shadow_vert: shadow_vert
  };

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   * @author mikael emtinger / http://gomo.se/
   */

  var ShaderLib = {

  	basic: {

  		uniforms: UniformsUtils$1.merge( [
  			UniformsLib.common,
  			UniformsLib.specularmap,
  			UniformsLib.envmap,
  			UniformsLib.aomap,
  			UniformsLib.lightmap,
  			UniformsLib.fog
  		] ),

  		vertexShader: ShaderChunk.meshbasic_vert,
  		fragmentShader: ShaderChunk.meshbasic_frag

  	},

  	lambert: {

  		uniforms: UniformsUtils$1.merge( [
  			UniformsLib.common,
  			UniformsLib.specularmap,
  			UniformsLib.envmap,
  			UniformsLib.aomap,
  			UniformsLib.lightmap,
  			UniformsLib.emissivemap,
  			UniformsLib.fog,
  			UniformsLib.lights,
  			{
  				emissive: { value: new Color$1( 0x000000 ) }
  			}
  		] ),

  		vertexShader: ShaderChunk.meshlambert_vert,
  		fragmentShader: ShaderChunk.meshlambert_frag

  	},

  	phong: {

  		uniforms: UniformsUtils$1.merge( [
  			UniformsLib.common,
  			UniformsLib.specularmap,
  			UniformsLib.envmap,
  			UniformsLib.aomap,
  			UniformsLib.lightmap,
  			UniformsLib.emissivemap,
  			UniformsLib.bumpmap,
  			UniformsLib.normalmap,
  			UniformsLib.displacementmap,
  			UniformsLib.gradientmap,
  			UniformsLib.fog,
  			UniformsLib.lights,
  			{
  				emissive: { value: new Color$1( 0x000000 ) },
  				specular: { value: new Color$1( 0x111111 ) },
  				shininess: { value: 30 }
  			}
  		] ),

  		vertexShader: ShaderChunk.meshphong_vert,
  		fragmentShader: ShaderChunk.meshphong_frag

  	},

  	standard: {

  		uniforms: UniformsUtils$1.merge( [
  			UniformsLib.common,
  			UniformsLib.envmap,
  			UniformsLib.aomap,
  			UniformsLib.lightmap,
  			UniformsLib.emissivemap,
  			UniformsLib.bumpmap,
  			UniformsLib.normalmap,
  			UniformsLib.displacementmap,
  			UniformsLib.roughnessmap,
  			UniformsLib.metalnessmap,
  			UniformsLib.fog,
  			UniformsLib.lights,
  			{
  				emissive: { value: new Color$1( 0x000000 ) },
  				roughness: { value: 0.5 },
  				metalness: { value: 0.5 },
  				envMapIntensity: { value: 1 } // temporary
  			}
  		] ),

  		vertexShader: ShaderChunk.meshphysical_vert,
  		fragmentShader: ShaderChunk.meshphysical_frag

  	},

  	points: {

  		uniforms: UniformsUtils$1.merge( [
  			UniformsLib.points,
  			UniformsLib.fog
  		] ),

  		vertexShader: ShaderChunk.points_vert,
  		fragmentShader: ShaderChunk.points_frag

  	},

  	dashed: {

  		uniforms: UniformsUtils$1.merge( [
  			UniformsLib.common,
  			UniformsLib.fog,
  			{
  				scale: { value: 1 },
  				dashSize: { value: 1 },
  				totalSize: { value: 2 }
  			}
  		] ),

  		vertexShader: ShaderChunk.linedashed_vert,
  		fragmentShader: ShaderChunk.linedashed_frag

  	},

  	depth: {

  		uniforms: UniformsUtils$1.merge( [
  			UniformsLib.common,
  			UniformsLib.displacementmap
  		] ),

  		vertexShader: ShaderChunk.depth_vert,
  		fragmentShader: ShaderChunk.depth_frag

  	},

  	normal: {

  		uniforms: UniformsUtils$1.merge( [
  			UniformsLib.common,
  			UniformsLib.bumpmap,
  			UniformsLib.normalmap,
  			UniformsLib.displacementmap,
  			{
  				opacity: { value: 1.0 }
  			}
  		] ),

  		vertexShader: ShaderChunk.normal_vert,
  		fragmentShader: ShaderChunk.normal_frag

  	},

  	/* -------------------------------------------------------------------------
  	//	Cube map shader
  	 ------------------------------------------------------------------------- */

  	cube: {

  		uniforms: {
  			tCube: { value: null },
  			tFlip: { value: - 1 },
  			opacity: { value: 1.0 }
  		},

  		vertexShader: ShaderChunk.cube_vert,
  		fragmentShader: ShaderChunk.cube_frag

  	},

  	equirect: {

  		uniforms: {
  			tEquirect: { value: null },
  		},

  		vertexShader: ShaderChunk.equirect_vert,
  		fragmentShader: ShaderChunk.equirect_frag

  	},

  	distanceRGBA: {

  		uniforms: UniformsUtils$1.merge( [
  			UniformsLib.common,
  			UniformsLib.displacementmap,
  			{
  				referencePosition: { value: new Vector3$2() },
  				nearDistance: { value: 1 },
  				farDistance: { value: 1000 }
  			}
  		] ),

  		vertexShader: ShaderChunk.distanceRGBA_vert,
  		fragmentShader: ShaderChunk.distanceRGBA_frag

  	},

  	shadow: {

  		uniforms: UniformsUtils$1.merge( [
  			UniformsLib.lights,
  			UniformsLib.fog,
  			{
  				color: { value: new Color$1( 0x00000 ) },
  				opacity: { value: 1.0 }
  			} ] ),

  		vertexShader: ShaderChunk.shadow_vert,
  		fragmentShader: ShaderChunk.shadow_frag

  	}

  };

  ShaderLib.physical = {

  	uniforms: UniformsUtils$1.merge( [
  		ShaderLib.standard.uniforms,
  		{
  			clearCoat: { value: 0 },
  			clearCoatRoughness: { value: 0 }
  		}
  	] ),

  	vertexShader: ShaderChunk.meshphysical_vert,
  	fragmentShader: ShaderChunk.meshphysical_frag

  };

  /**
   * @author bhouston / http://clara.io
   */

  function Box2( min, max ) {

  	this.min = ( min !== undefined ) ? min : new Vector2$1( + Infinity, + Infinity );
  	this.max = ( max !== undefined ) ? max : new Vector2$1( - Infinity, - Infinity );

  }

  Object.assign( Box2.prototype, {

  	set: function ( min, max ) {

  		this.min.copy( min );
  		this.max.copy( max );

  		return this;

  	},

  	setFromPoints: function ( points ) {
  		var this$1 = this;


  		this.makeEmpty();

  		for ( var i = 0, il = points.length; i < il; i ++ ) {

  			this$1.expandByPoint( points[ i ] );

  		}

  		return this;

  	},

  	setFromCenterAndSize: function () {

  		var v1 = new Vector2$1();

  		return function setFromCenterAndSize( center, size ) {

  			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
  			this.min.copy( center ).sub( halfSize );
  			this.max.copy( center ).add( halfSize );

  			return this;

  		};

  	}(),

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( box ) {

  		this.min.copy( box.min );
  		this.max.copy( box.max );

  		return this;

  	},

  	makeEmpty: function () {

  		this.min.x = this.min.y = + Infinity;
  		this.max.x = this.max.y = - Infinity;

  		return this;

  	},

  	isEmpty: function () {

  		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

  		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

  	},

  	getCenter: function ( optionalTarget ) {

  		var result = optionalTarget || new Vector2$1();
  		return this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

  	},

  	getSize: function ( optionalTarget ) {

  		var result = optionalTarget || new Vector2$1();
  		return this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );

  	},

  	expandByPoint: function ( point ) {

  		this.min.min( point );
  		this.max.max( point );

  		return this;

  	},

  	expandByVector: function ( vector ) {

  		this.min.sub( vector );
  		this.max.add( vector );

  		return this;

  	},

  	expandByScalar: function ( scalar ) {

  		this.min.addScalar( - scalar );
  		this.max.addScalar( scalar );

  		return this;

  	},

  	containsPoint: function ( point ) {

  		return point.x < this.min.x || point.x > this.max.x ||
  			point.y < this.min.y || point.y > this.max.y ? false : true;

  	},

  	containsBox: function ( box ) {

  		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
  			this.min.y <= box.min.y && box.max.y <= this.max.y;

  	},

  	getParameter: function ( point, optionalTarget ) {

  		// This can potentially have a divide by zero if the box
  		// has a size dimension of 0.

  		var result = optionalTarget || new Vector2$1();

  		return result.set(
  			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
  			( point.y - this.min.y ) / ( this.max.y - this.min.y )
  		);

  	},

  	intersectsBox: function ( box ) {

  		// using 4 splitting planes to rule out intersections

  		return box.max.x < this.min.x || box.min.x > this.max.x ||
  			box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

  	},

  	clampPoint: function ( point, optionalTarget ) {

  		var result = optionalTarget || new Vector2$1();
  		return result.copy( point ).clamp( this.min, this.max );

  	},

  	distanceToPoint: function () {

  		var v1 = new Vector2$1();

  		return function distanceToPoint( point ) {

  			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
  			return clampedPoint.sub( point ).length();

  		};

  	}(),

  	intersect: function ( box ) {

  		this.min.max( box.min );
  		this.max.min( box.max );

  		return this;

  	},

  	union: function ( box ) {

  		this.min.min( box.min );
  		this.max.max( box.max );

  		return this;

  	},

  	translate: function ( offset ) {

  		this.min.add( offset );
  		this.max.add( offset );

  		return this;

  	},

  	equals: function ( box ) {

  		return box.min.equals( this.min ) && box.max.equals( this.max );

  	}

  } );

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   */

  function WebGLFlareRenderer( renderer, gl, state, textures, capabilities ) {

  	var vertexBuffer, elementBuffer;
  	var shader, program, attributes, uniforms;

  	var tempTexture, occlusionTexture;

  	function init() {

  		var vertices = new Float32Array( [
  			- 1, - 1, 0, 0,
  			  1, - 1, 1, 0,
  			  1, 1, 1, 1,
  			- 1, 1, 0, 1
  		] );

  		var faces = new Uint16Array( [
  			0, 1, 2,
  			0, 2, 3
  		] );

  		// buffers

  		vertexBuffer = gl.createBuffer();
  		elementBuffer = gl.createBuffer();

  		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
  		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

  		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
  		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

  		// textures

  		tempTexture = gl.createTexture();
  		occlusionTexture = gl.createTexture();

  		state.bindTexture( gl.TEXTURE_2D, tempTexture );
  		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
  		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
  		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
  		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
  		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

  		state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
  		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
  		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
  		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
  		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
  		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

  		shader = {

  			vertexShader: [

  				'uniform lowp int renderType;',

  				'uniform vec3 screenPosition;',
  				'uniform vec2 scale;',
  				'uniform float rotation;',

  				'uniform sampler2D occlusionMap;',

  				'attribute vec2 position;',
  				'attribute vec2 uv;',

  				'varying vec2 vUV;',
  				'varying float vVisibility;',

  				'void main() {',

  				'	vUV = uv;',

  				'	vec2 pos = position;',

  				'	if ( renderType == 2 ) {',

  				'		vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );',
  				'		visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );',
  				'		visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );',
  				'		visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );',
  				'		visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );',
  				'		visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );',
  				'		visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );',
  				'		visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );',
  				'		visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );',

  				'		vVisibility =        visibility.r / 9.0;',
  				'		vVisibility *= 1.0 - visibility.g / 9.0;',
  				'		vVisibility *=       visibility.b / 9.0;',
  				'		vVisibility *= 1.0 - visibility.a / 9.0;',

  				'		pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;',
  				'		pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;',

  				'	}',

  				'	gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );',

  				'}'

  			].join( '\n' ),

  			fragmentShader: [

  				'uniform lowp int renderType;',

  				'uniform sampler2D map;',
  				'uniform float opacity;',
  				'uniform vec3 color;',

  				'varying vec2 vUV;',
  				'varying float vVisibility;',

  				'void main() {',

  				// pink square

  				'	if ( renderType == 0 ) {',

  				'		gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );',

  				// restore

  				'	} else if ( renderType == 1 ) {',

  				'		gl_FragColor = texture2D( map, vUV );',

  				// flare

  				'	} else {',

  				'		vec4 texture = texture2D( map, vUV );',
  				'		texture.a *= opacity * vVisibility;',
  				'		gl_FragColor = texture;',
  				'		gl_FragColor.rgb *= color;',

  				'	}',

  				'}'

  			].join( '\n' )

  		};

  		program = createProgram( shader );

  		attributes = {
  			vertex: gl.getAttribLocation( program, 'position' ),
  			uv: gl.getAttribLocation( program, 'uv' )
  		};

  		uniforms = {
  			renderType: gl.getUniformLocation( program, 'renderType' ),
  			map: gl.getUniformLocation( program, 'map' ),
  			occlusionMap: gl.getUniformLocation( program, 'occlusionMap' ),
  			opacity: gl.getUniformLocation( program, 'opacity' ),
  			color: gl.getUniformLocation( program, 'color' ),
  			scale: gl.getUniformLocation( program, 'scale' ),
  			rotation: gl.getUniformLocation( program, 'rotation' ),
  			screenPosition: gl.getUniformLocation( program, 'screenPosition' )
  		};

  	}

  	/*
  	 * Render lens flares
  	 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
  	 *         reads these back and calculates occlusion.
  	 */

  	this.render = function ( flares, scene, camera, viewport ) {

  		if ( flares.length === 0 ) { return; }

  		var tempPosition = new Vector3$2();

  		var invAspect = viewport.w / viewport.z,
  			halfViewportWidth = viewport.z * 0.5,
  			halfViewportHeight = viewport.w * 0.5;

  		var size = 16 / viewport.w,
  			scale = new Vector2$1( size * invAspect, size );

  		var screenPosition = new Vector3$2( 1, 1, 0 ),
  			screenPositionPixels = new Vector2$1( 1, 1 );

  		var validArea = new Box2();

  		validArea.min.set( viewport.x, viewport.y );
  		validArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );

  		if ( program === undefined ) {

  			init();

  		}

  		state.useProgram( program );

  		state.initAttributes();
  		state.enableAttribute( attributes.vertex );
  		state.enableAttribute( attributes.uv );
  		state.disableUnusedAttributes();

  		// loop through all lens flares to update their occlusion and positions
  		// setup gl and common used attribs/uniforms

  		gl.uniform1i( uniforms.occlusionMap, 0 );
  		gl.uniform1i( uniforms.map, 1 );

  		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
  		gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
  		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

  		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

  		state.disable( gl.CULL_FACE );
  		state.buffers.depth.setMask( false );

  		for ( var i = 0, l = flares.length; i < l; i ++ ) {

  			size = 16 / viewport.w;
  			scale.set( size * invAspect, size );

  			// calc object screen position

  			var flare = flares[ i ];

  			tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );

  			tempPosition.applyMatrix4( camera.matrixWorldInverse );
  			tempPosition.applyMatrix4( camera.projectionMatrix );

  			// setup arrays for gl programs

  			screenPosition.copy( tempPosition );

  			// horizontal and vertical coordinate of the lower left corner of the pixels to copy

  			screenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;
  			screenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;

  			// screen cull

  			if ( validArea.containsPoint( screenPositionPixels ) === true ) {

  				// save current RGB to temp texture

  				state.activeTexture( gl.TEXTURE0 );
  				state.bindTexture( gl.TEXTURE_2D, null );
  				state.activeTexture( gl.TEXTURE1 );
  				state.bindTexture( gl.TEXTURE_2D, tempTexture );
  				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );


  				// render pink quad

  				gl.uniform1i( uniforms.renderType, 0 );
  				gl.uniform2f( uniforms.scale, scale.x, scale.y );
  				gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

  				state.disable( gl.BLEND );
  				state.enable( gl.DEPTH_TEST );

  				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


  				// copy result to occlusionMap

  				state.activeTexture( gl.TEXTURE0 );
  				state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
  				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );


  				// restore graphics

  				gl.uniform1i( uniforms.renderType, 1 );
  				state.disable( gl.DEPTH_TEST );

  				state.activeTexture( gl.TEXTURE1 );
  				state.bindTexture( gl.TEXTURE_2D, tempTexture );
  				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


  				// update object positions

  				flare.positionScreen.copy( screenPosition );

  				if ( flare.customUpdateCallback ) {

  					flare.customUpdateCallback( flare );

  				} else {

  					flare.updateLensFlares();

  				}

  				// render flares

  				gl.uniform1i( uniforms.renderType, 2 );
  				state.enable( gl.BLEND );

  				for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

  					var sprite = flare.lensFlares[ j ];

  					if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

  						screenPosition.x = sprite.x;
  						screenPosition.y = sprite.y;
  						screenPosition.z = sprite.z;

  						size = sprite.size * sprite.scale / viewport.w;

  						scale.x = size * invAspect;
  						scale.y = size;

  						gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
  						gl.uniform2f( uniforms.scale, scale.x, scale.y );
  						gl.uniform1f( uniforms.rotation, sprite.rotation );

  						gl.uniform1f( uniforms.opacity, sprite.opacity );
  						gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

  						state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );

  						textures.setTexture2D( sprite.texture, 1 );

  						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

  					}

  				}

  			}

  		}

  		// restore gl

  		state.enable( gl.CULL_FACE );
  		state.enable( gl.DEPTH_TEST );
  		state.buffers.depth.setMask( true );

  		state.reset();

  	};

  	function createProgram( shader ) {

  		var program = gl.createProgram();

  		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
  		var vertexShader = gl.createShader( gl.VERTEX_SHADER );

  		var prefix = 'precision ' + capabilities.precision + ' float;\n';

  		gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
  		gl.shaderSource( vertexShader, prefix + shader.vertexShader );

  		gl.compileShader( fragmentShader );
  		gl.compileShader( vertexShader );

  		gl.attachShader( program, fragmentShader );
  		gl.attachShader( program, vertexShader );

  		gl.linkProgram( program );

  		return program;

  	}

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

  	Texture$1.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  	this.needsUpdate = true;

  }

  CanvasTexture.prototype = Object.create( Texture$1.prototype );
  CanvasTexture.prototype.constructor = CanvasTexture;

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   */

  function WebGLSpriteRenderer( renderer, gl, state, textures, capabilities ) {

  	var vertexBuffer, elementBuffer;
  	var program, attributes, uniforms;

  	var texture;

  	// decompose matrixWorld

  	var spritePosition = new Vector3$2();
  	var spriteRotation = new Quaternion$1();
  	var spriteScale = new Vector3$2();

  	function init() {

  		var vertices = new Float32Array( [
  			- 0.5, - 0.5, 0, 0,
  			  0.5, - 0.5, 1, 0,
  			  0.5, 0.5, 1, 1,
  			- 0.5, 0.5, 0, 1
  		] );

  		var faces = new Uint16Array( [
  			0, 1, 2,
  			0, 2, 3
  		] );

  		vertexBuffer = gl.createBuffer();
  		elementBuffer = gl.createBuffer();

  		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
  		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

  		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
  		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

  		program = createProgram();

  		attributes = {
  			position: gl.getAttribLocation( program, 'position' ),
  			uv: gl.getAttribLocation( program, 'uv' )
  		};

  		uniforms = {
  			uvOffset: gl.getUniformLocation( program, 'uvOffset' ),
  			uvScale: gl.getUniformLocation( program, 'uvScale' ),

  			rotation: gl.getUniformLocation( program, 'rotation' ),
  			scale: gl.getUniformLocation( program, 'scale' ),

  			color: gl.getUniformLocation( program, 'color' ),
  			map: gl.getUniformLocation( program, 'map' ),
  			opacity: gl.getUniformLocation( program, 'opacity' ),

  			modelViewMatrix: gl.getUniformLocation( program, 'modelViewMatrix' ),
  			projectionMatrix: gl.getUniformLocation( program, 'projectionMatrix' ),

  			fogType: gl.getUniformLocation( program, 'fogType' ),
  			fogDensity: gl.getUniformLocation( program, 'fogDensity' ),
  			fogNear: gl.getUniformLocation( program, 'fogNear' ),
  			fogFar: gl.getUniformLocation( program, 'fogFar' ),
  			fogColor: gl.getUniformLocation( program, 'fogColor' ),
  			fogDepth: gl.getUniformLocation( program, 'fogDepth' ),

  			alphaTest: gl.getUniformLocation( program, 'alphaTest' )
  		};

  		var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
  		canvas.width = 8;
  		canvas.height = 8;

  		var context = canvas.getContext( '2d' );
  		context.fillStyle = 'white';
  		context.fillRect( 0, 0, 8, 8 );

  		texture = new CanvasTexture( canvas );

  	}

  	this.render = function ( sprites, scene, camera ) {

  		if ( sprites.length === 0 ) { return; }

  		// setup gl

  		if ( program === undefined ) {

  			init();

  		}

  		state.useProgram( program );

  		state.initAttributes();
  		state.enableAttribute( attributes.position );
  		state.enableAttribute( attributes.uv );
  		state.disableUnusedAttributes();

  		state.disable( gl.CULL_FACE );
  		state.enable( gl.BLEND );

  		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
  		gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
  		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

  		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

  		gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

  		state.activeTexture( gl.TEXTURE0 );
  		gl.uniform1i( uniforms.map, 0 );

  		var oldFogType = 0;
  		var sceneFogType = 0;
  		var fog = scene.fog;

  		if ( fog ) {

  			gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

  			if ( fog.isFog ) {

  				gl.uniform1f( uniforms.fogNear, fog.near );
  				gl.uniform1f( uniforms.fogFar, fog.far );

  				gl.uniform1i( uniforms.fogType, 1 );
  				oldFogType = 1;
  				sceneFogType = 1;

  			} else if ( fog.isFogExp2 ) {

  				gl.uniform1f( uniforms.fogDensity, fog.density );

  				gl.uniform1i( uniforms.fogType, 2 );
  				oldFogType = 2;
  				sceneFogType = 2;

  			}

  		} else {

  			gl.uniform1i( uniforms.fogType, 0 );
  			oldFogType = 0;
  			sceneFogType = 0;

  		}


  		// update positions and sort

  		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

  			var sprite = sprites[ i ];

  			sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
  			sprite.z = - sprite.modelViewMatrix.elements[ 14 ];

  		}

  		sprites.sort( painterSortStable );

  		// render all sprites

  		var scale = [];

  		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

  			var sprite = sprites[ i ];
  			var material = sprite.material;

  			if ( material.visible === false ) { continue; }

  			sprite.onBeforeRender( renderer, scene, camera, undefined, material, undefined );

  			gl.uniform1f( uniforms.alphaTest, material.alphaTest );
  			gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );

  			sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

  			scale[ 0 ] = spriteScale.x;
  			scale[ 1 ] = spriteScale.y;

  			var fogType = 0;

  			if ( scene.fog && material.fog ) {

  				fogType = sceneFogType;

  			}

  			if ( oldFogType !== fogType ) {

  				gl.uniform1i( uniforms.fogType, fogType );
  				oldFogType = fogType;

  			}

  			if ( material.map !== null ) {

  				gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
  				gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

  			} else {

  				gl.uniform2f( uniforms.uvOffset, 0, 0 );
  				gl.uniform2f( uniforms.uvScale, 1, 1 );

  			}

  			gl.uniform1f( uniforms.opacity, material.opacity );
  			gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

  			gl.uniform1f( uniforms.rotation, material.rotation );
  			gl.uniform2fv( uniforms.scale, scale );

  			state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );
  			state.buffers.depth.setTest( material.depthTest );
  			state.buffers.depth.setMask( material.depthWrite );
  			state.buffers.color.setMask( material.colorWrite );

  			textures.setTexture2D( material.map || texture, 0 );

  			gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

  			sprite.onAfterRender( renderer, scene, camera, undefined, material, undefined );

  		}

  		// restore gl

  		state.enable( gl.CULL_FACE );

  		state.reset();

  	};

  	function createProgram() {

  		var program = gl.createProgram();

  		var vertexShader = gl.createShader( gl.VERTEX_SHADER );
  		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

  		gl.shaderSource( vertexShader, [

  			'precision ' + capabilities.precision + ' float;',

  			'#define SHADER_NAME ' + 'SpriteMaterial',

  			'uniform mat4 modelViewMatrix;',
  			'uniform mat4 projectionMatrix;',
  			'uniform float rotation;',
  			'uniform vec2 scale;',
  			'uniform vec2 uvOffset;',
  			'uniform vec2 uvScale;',

  			'attribute vec2 position;',
  			'attribute vec2 uv;',

  			'varying vec2 vUV;',
  			'varying float fogDepth;',

  			'void main() {',

  			'	vUV = uvOffset + uv * uvScale;',

  			'	vec2 alignedPosition = position * scale;',

  			'	vec2 rotatedPosition;',
  			'	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
  			'	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

  			'	vec4 mvPosition;',

  			'	mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
  			'	mvPosition.xy += rotatedPosition;',

  			'	gl_Position = projectionMatrix * mvPosition;',

  			'	fogDepth = - mvPosition.z;',

  			'}'

  		].join( '\n' ) );

  		gl.shaderSource( fragmentShader, [

  			'precision ' + capabilities.precision + ' float;',

  			'#define SHADER_NAME ' + 'SpriteMaterial',

  			'uniform vec3 color;',
  			'uniform sampler2D map;',
  			'uniform float opacity;',

  			'uniform int fogType;',
  			'uniform vec3 fogColor;',
  			'uniform float fogDensity;',
  			'uniform float fogNear;',
  			'uniform float fogFar;',
  			'uniform float alphaTest;',

  			'varying vec2 vUV;',
  			'varying float fogDepth;',

  			'void main() {',

  			'	vec4 texture = texture2D( map, vUV );',

  			'	gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

  			'	if ( gl_FragColor.a < alphaTest ) discard;',

  			'	if ( fogType > 0 ) {',

  			'		float fogFactor = 0.0;',

  			'		if ( fogType == 1 ) {',

  			'			fogFactor = smoothstep( fogNear, fogFar, fogDepth );',

  			'		} else {',

  			'			const float LOG2 = 1.442695;',
  			'			fogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );',
  			'			fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

  			'		}',

  			'		gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );',

  			'	}',

  			'}'

  		].join( '\n' ) );

  		gl.compileShader( vertexShader );
  		gl.compileShader( fragmentShader );

  		gl.attachShader( program, vertexShader );
  		gl.attachShader( program, fragmentShader );

  		gl.linkProgram( program );

  		return program;

  	}

  	function painterSortStable( a, b ) {

  		if ( a.renderOrder !== b.renderOrder ) {

  			return a.renderOrder - b.renderOrder;

  		} else if ( a.z !== b.z ) {

  			return b.z - a.z;

  		} else {

  			return b.id - a.id;

  		}

  	}

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  var materialId$1 = 0;

  function Material$1() {

  	Object.defineProperty( this, 'id', { value: materialId$1 ++ } );

  	this.uuid = _Math$1.generateUUID();

  	this.name = '';
  	this.type = 'Material';

  	this.fog = true;
  	this.lights = true;

  	this.blending = NormalBlending$1;
  	this.side = FrontSide$1;
  	this.flatShading = false;
  	this.vertexColors = NoColors$1; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors

  	this.opacity = 1;
  	this.transparent = false;

  	this.blendSrc = SrcAlphaFactor$1;
  	this.blendDst = OneMinusSrcAlphaFactor$1;
  	this.blendEquation = AddEquation$1;
  	this.blendSrcAlpha = null;
  	this.blendDstAlpha = null;
  	this.blendEquationAlpha = null;

  	this.depthFunc = LessEqualDepth$1;
  	this.depthTest = true;
  	this.depthWrite = true;

  	this.clippingPlanes = null;
  	this.clipIntersection = false;
  	this.clipShadows = false;

  	this.colorWrite = true;

  	this.precision = null; // override the renderer's default precision for this material

  	this.polygonOffset = false;
  	this.polygonOffsetFactor = 0;
  	this.polygonOffsetUnits = 0;

  	this.dithering = false;

  	this.alphaTest = 0;
  	this.premultipliedAlpha = false;

  	this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

  	this.visible = true;

  	this.userData = {};

  	this.needsUpdate = true;

  }

  Object.assign( Material$1.prototype, EventDispatcher$1.prototype, {

  	isMaterial: true,

  	onBeforeCompile: function () {},

  	setValues: function ( values ) {
  		var this$1 = this;


  		if ( values === undefined ) { return; }

  		for ( var key in values ) {

  			var newValue = values[ key ];

  			if ( newValue === undefined ) {

  				console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
  				continue;

  			}

  			// for backward compatability if shading is set in the constructor
  			if ( key === 'shading' ) {

  				console.warn( 'THREE.' + this$1.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
  				this$1.flatShading = ( newValue === FlatShading$1 ) ? true : false;
  				continue;

  			}

  			var currentValue = this$1[ key ];

  			if ( currentValue === undefined ) {

  				console.warn( "THREE." + this$1.type + ": '" + key + "' is not a property of this material." );
  				continue;

  			}

  			if ( currentValue && currentValue.isColor ) {

  				currentValue.set( newValue );

  			} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

  				currentValue.copy( newValue );

  			} else if ( key === 'overdraw' ) {

  				// ensure overdraw is backwards-compatible with legacy boolean type
  				this$1[ key ] = Number( newValue );

  			} else {

  				this$1[ key ] = newValue;

  			}

  		}

  	},

  	toJSON: function ( meta ) {

  		var isRoot = meta === undefined;

  		if ( isRoot ) {

  			meta = {
  				textures: {},
  				images: {}
  			};

  		}

  		var data = {
  			metadata: {
  				version: 4.5,
  				type: 'Material',
  				generator: 'Material.toJSON'
  			}
  		};

  		// standard Material serialization
  		data.uuid = this.uuid;
  		data.type = this.type;

  		if ( this.name !== '' ) { data.name = this.name; }

  		if ( this.color && this.color.isColor ) { data.color = this.color.getHex(); }

  		if ( this.roughness !== undefined ) { data.roughness = this.roughness; }
  		if ( this.metalness !== undefined ) { data.metalness = this.metalness; }

  		if ( this.emissive && this.emissive.isColor ) { data.emissive = this.emissive.getHex(); }
  		if ( this.specular && this.specular.isColor ) { data.specular = this.specular.getHex(); }
  		if ( this.shininess !== undefined ) { data.shininess = this.shininess; }
  		if ( this.clearCoat !== undefined ) { data.clearCoat = this.clearCoat; }
  		if ( this.clearCoatRoughness !== undefined ) { data.clearCoatRoughness = this.clearCoatRoughness; }

  		if ( this.map && this.map.isTexture ) { data.map = this.map.toJSON( meta ).uuid; }
  		if ( this.alphaMap && this.alphaMap.isTexture ) { data.alphaMap = this.alphaMap.toJSON( meta ).uuid; }
  		if ( this.lightMap && this.lightMap.isTexture ) { data.lightMap = this.lightMap.toJSON( meta ).uuid; }
  		if ( this.bumpMap && this.bumpMap.isTexture ) {

  			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
  			data.bumpScale = this.bumpScale;

  		}
  		if ( this.normalMap && this.normalMap.isTexture ) {

  			data.normalMap = this.normalMap.toJSON( meta ).uuid;
  			data.normalScale = this.normalScale.toArray();

  		}
  		if ( this.displacementMap && this.displacementMap.isTexture ) {

  			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
  			data.displacementScale = this.displacementScale;
  			data.displacementBias = this.displacementBias;

  		}
  		if ( this.roughnessMap && this.roughnessMap.isTexture ) { data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid; }
  		if ( this.metalnessMap && this.metalnessMap.isTexture ) { data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid; }

  		if ( this.emissiveMap && this.emissiveMap.isTexture ) { data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid; }
  		if ( this.specularMap && this.specularMap.isTexture ) { data.specularMap = this.specularMap.toJSON( meta ).uuid; }

  		if ( this.envMap && this.envMap.isTexture ) {

  			data.envMap = this.envMap.toJSON( meta ).uuid;
  			data.reflectivity = this.reflectivity; // Scale behind envMap

  		}

  		if ( this.gradientMap && this.gradientMap.isTexture ) {

  			data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

  		}

  		if ( this.size !== undefined ) { data.size = this.size; }
  		if ( this.sizeAttenuation !== undefined ) { data.sizeAttenuation = this.sizeAttenuation; }

  		if ( this.blending !== NormalBlending$1 ) { data.blending = this.blending; }
  		if ( this.flatShading === true ) { data.flatShading = this.flatShading; }
  		if ( this.side !== FrontSide$1 ) { data.side = this.side; }
  		if ( this.vertexColors !== NoColors$1 ) { data.vertexColors = this.vertexColors; }

  		if ( this.opacity < 1 ) { data.opacity = this.opacity; }
  		if ( this.transparent === true ) { data.transparent = this.transparent; }

  		data.depthFunc = this.depthFunc;
  		data.depthTest = this.depthTest;
  		data.depthWrite = this.depthWrite;

  		if ( this.dithering === true ) { data.dithering = true; }

  		if ( this.alphaTest > 0 ) { data.alphaTest = this.alphaTest; }
  		if ( this.premultipliedAlpha === true ) { data.premultipliedAlpha = this.premultipliedAlpha; }

  		if ( this.wireframe === true ) { data.wireframe = this.wireframe; }
  		if ( this.wireframeLinewidth > 1 ) { data.wireframeLinewidth = this.wireframeLinewidth; }
  		if ( this.wireframeLinecap !== 'round' ) { data.wireframeLinecap = this.wireframeLinecap; }
  		if ( this.wireframeLinejoin !== 'round' ) { data.wireframeLinejoin = this.wireframeLinejoin; }

  		if ( this.morphTargets === true ) { data.morphTargets = true; }
  		if ( this.skinning === true ) { data.skinning = true; }

  		if ( this.visible === false ) { data.visible = false; }
  		if ( JSON.stringify( this.userData ) !== '{}' ) { data.userData = this.userData; }

  		// TODO: Copied from Object3D.toJSON

  		function extractFromCache( cache ) {

  			var values = [];

  			for ( var key in cache ) {

  				var data = cache[ key ];
  				delete data.metadata;
  				values.push( data );

  			}

  			return values;

  		}

  		if ( isRoot ) {

  			var textures = extractFromCache( meta.textures );
  			var images = extractFromCache( meta.images );

  			if ( textures.length > 0 ) { data.textures = textures; }
  			if ( images.length > 0 ) { data.images = images; }

  		}

  		return data;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( source ) {

  		this.name = source.name;

  		this.fog = source.fog;
  		this.lights = source.lights;

  		this.blending = source.blending;
  		this.side = source.side;
  		this.flatShading = source.flatShading;
  		this.vertexColors = source.vertexColors;

  		this.opacity = source.opacity;
  		this.transparent = source.transparent;

  		this.blendSrc = source.blendSrc;
  		this.blendDst = source.blendDst;
  		this.blendEquation = source.blendEquation;
  		this.blendSrcAlpha = source.blendSrcAlpha;
  		this.blendDstAlpha = source.blendDstAlpha;
  		this.blendEquationAlpha = source.blendEquationAlpha;

  		this.depthFunc = source.depthFunc;
  		this.depthTest = source.depthTest;
  		this.depthWrite = source.depthWrite;

  		this.colorWrite = source.colorWrite;

  		this.precision = source.precision;

  		this.polygonOffset = source.polygonOffset;
  		this.polygonOffsetFactor = source.polygonOffsetFactor;
  		this.polygonOffsetUnits = source.polygonOffsetUnits;

  		this.dithering = source.dithering;

  		this.alphaTest = source.alphaTest;
  		this.premultipliedAlpha = source.premultipliedAlpha;

  		this.overdraw = source.overdraw;

  		this.visible = source.visible;
  		this.userData = JSON.parse( JSON.stringify( source.userData ) );

  		this.clipShadows = source.clipShadows;
  		this.clipIntersection = source.clipIntersection;

  		var srcPlanes = source.clippingPlanes,
  			dstPlanes = null;

  		if ( srcPlanes !== null ) {

  			var n = srcPlanes.length;
  			dstPlanes = new Array( n );

  			for ( var i = 0; i !== n; ++ i )
  				{ dstPlanes[ i ] = srcPlanes[ i ].clone(); }

  		}

  		this.clippingPlanes = dstPlanes;

  		return this;

  	},

  	dispose: function () {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   * @author bhouston / https://clara.io
   * @author WestLangley / http://github.com/WestLangley
   *
   * parameters = {
   *
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>
   * }
   */

  function MeshDepthMaterial$1( parameters ) {

  	Material$1.call( this );

  	this.type = 'MeshDepthMaterial';

  	this.depthPacking = BasicDepthPacking$1;

  	this.skinning = false;
  	this.morphTargets = false;

  	this.map = null;

  	this.alphaMap = null;

  	this.displacementMap = null;
  	this.displacementScale = 1;
  	this.displacementBias = 0;

  	this.wireframe = false;
  	this.wireframeLinewidth = 1;

  	this.fog = false;
  	this.lights = false;

  	this.setValues( parameters );

  }

  MeshDepthMaterial$1.prototype = Object.create( Material$1.prototype );
  MeshDepthMaterial$1.prototype.constructor = MeshDepthMaterial$1;

  MeshDepthMaterial$1.prototype.isMeshDepthMaterial = true;

  MeshDepthMaterial$1.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.depthPacking = source.depthPacking;

  	this.skinning = source.skinning;
  	this.morphTargets = source.morphTargets;

  	this.map = source.map;

  	this.alphaMap = source.alphaMap;

  	this.displacementMap = source.displacementMap;
  	this.displacementScale = source.displacementScale;
  	this.displacementBias = source.displacementBias;

  	this.wireframe = source.wireframe;
  	this.wireframeLinewidth = source.wireframeLinewidth;

  	return this;

  };

  /**
   * @author WestLangley / http://github.com/WestLangley
   *
   * parameters = {
   *
   *  referencePosition: <float>,
   *  nearDistance: <float>,
   *  farDistance: <float>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>
   *
   * }
   */

  function MeshDistanceMaterial$1( parameters ) {

  	Material$1.call( this );

  	this.type = 'MeshDistanceMaterial';

  	this.referencePosition = new Vector3$2();
  	this.nearDistance = 1;
  	this.farDistance = 1000;

  	this.skinning = false;
  	this.morphTargets = false;

  	this.map = null;

  	this.alphaMap = null;

  	this.displacementMap = null;
  	this.displacementScale = 1;
  	this.displacementBias = 0;

  	this.fog = false;
  	this.lights = false;

  	this.setValues( parameters );

  }

  MeshDistanceMaterial$1.prototype = Object.create( Material$1.prototype );
  MeshDistanceMaterial$1.prototype.constructor = MeshDistanceMaterial$1;

  MeshDistanceMaterial$1.prototype.isMeshDistanceMaterial = true;

  MeshDistanceMaterial$1.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.referencePosition.copy( source.referencePosition );
  	this.nearDistance = source.nearDistance;
  	this.farDistance = source.farDistance;

  	this.skinning = source.skinning;
  	this.morphTargets = source.morphTargets;

  	this.map = source.map;

  	this.alphaMap = source.alphaMap;

  	this.displacementMap = source.displacementMap;
  	this.displacementScale = source.displacementScale;
  	this.displacementBias = source.displacementBias;

  	return this;

  };

  /**
   * @author bhouston / http://clara.io
   * @author WestLangley / http://github.com/WestLangley
   */

  function Box3$1( min, max ) {

  	this.min = ( min !== undefined ) ? min : new Vector3$2( + Infinity, + Infinity, + Infinity );
  	this.max = ( max !== undefined ) ? max : new Vector3$2( - Infinity, - Infinity, - Infinity );

  }

  Object.assign( Box3$1.prototype, {

  	isBox3: true,

  	set: function ( min, max ) {

  		this.min.copy( min );
  		this.max.copy( max );

  		return this;

  	},

  	setFromArray: function ( array ) {

  		var minX = + Infinity;
  		var minY = + Infinity;
  		var minZ = + Infinity;

  		var maxX = - Infinity;
  		var maxY = - Infinity;
  		var maxZ = - Infinity;

  		for ( var i = 0, l = array.length; i < l; i += 3 ) {

  			var x = array[ i ];
  			var y = array[ i + 1 ];
  			var z = array[ i + 2 ];

  			if ( x < minX ) { minX = x; }
  			if ( y < minY ) { minY = y; }
  			if ( z < minZ ) { minZ = z; }

  			if ( x > maxX ) { maxX = x; }
  			if ( y > maxY ) { maxY = y; }
  			if ( z > maxZ ) { maxZ = z; }

  		}

  		this.min.set( minX, minY, minZ );
  		this.max.set( maxX, maxY, maxZ );

  		return this;

  	},

  	setFromBufferAttribute: function ( attribute ) {

  		var minX = + Infinity;
  		var minY = + Infinity;
  		var minZ = + Infinity;

  		var maxX = - Infinity;
  		var maxY = - Infinity;
  		var maxZ = - Infinity;

  		for ( var i = 0, l = attribute.count; i < l; i ++ ) {

  			var x = attribute.getX( i );
  			var y = attribute.getY( i );
  			var z = attribute.getZ( i );

  			if ( x < minX ) { minX = x; }
  			if ( y < minY ) { minY = y; }
  			if ( z < minZ ) { minZ = z; }

  			if ( x > maxX ) { maxX = x; }
  			if ( y > maxY ) { maxY = y; }
  			if ( z > maxZ ) { maxZ = z; }

  		}

  		this.min.set( minX, minY, minZ );
  		this.max.set( maxX, maxY, maxZ );

  		return this;

  	},

  	setFromPoints: function ( points ) {
  		var this$1 = this;


  		this.makeEmpty();

  		for ( var i = 0, il = points.length; i < il; i ++ ) {

  			this$1.expandByPoint( points[ i ] );

  		}

  		return this;

  	},

  	setFromCenterAndSize: function () {

  		var v1 = new Vector3$2();

  		return function setFromCenterAndSize( center, size ) {

  			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

  			this.min.copy( center ).sub( halfSize );
  			this.max.copy( center ).add( halfSize );

  			return this;

  		};

  	}(),

  	setFromObject: function ( object ) {

  		this.makeEmpty();

  		return this.expandByObject( object );

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( box ) {

  		this.min.copy( box.min );
  		this.max.copy( box.max );

  		return this;

  	},

  	makeEmpty: function () {

  		this.min.x = this.min.y = this.min.z = + Infinity;
  		this.max.x = this.max.y = this.max.z = - Infinity;

  		return this;

  	},

  	isEmpty: function () {

  		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

  		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

  	},

  	getCenter: function ( optionalTarget ) {

  		var result = optionalTarget || new Vector3$2();
  		return this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

  	},

  	getSize: function ( optionalTarget ) {

  		var result = optionalTarget || new Vector3$2();
  		return this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );

  	},

  	expandByPoint: function ( point ) {

  		this.min.min( point );
  		this.max.max( point );

  		return this;

  	},

  	expandByVector: function ( vector ) {

  		this.min.sub( vector );
  		this.max.add( vector );

  		return this;

  	},

  	expandByScalar: function ( scalar ) {

  		this.min.addScalar( - scalar );
  		this.max.addScalar( scalar );

  		return this;

  	},

  	expandByObject: function () {

  		// Computes the world-axis-aligned bounding box of an object (including its children),
  		// accounting for both the object's, and children's, world transforms

  		var v1 = new Vector3$2();

  		return function expandByObject( object ) {

  			var scope = this;

  			object.updateMatrixWorld( true );

  			object.traverse( function ( node ) {

  				var i, l;

  				var geometry = node.geometry;

  				if ( geometry !== undefined ) {

  					if ( geometry.isGeometry ) {

  						var vertices = geometry.vertices;

  						for ( i = 0, l = vertices.length; i < l; i ++ ) {

  							v1.copy( vertices[ i ] );
  							v1.applyMatrix4( node.matrixWorld );

  							scope.expandByPoint( v1 );

  						}

  					} else if ( geometry.isBufferGeometry ) {

  						var attribute = geometry.attributes.position;

  						if ( attribute !== undefined ) {

  							for ( i = 0, l = attribute.count; i < l; i ++ ) {

  								v1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );

  								scope.expandByPoint( v1 );

  							}

  						}

  					}

  				}

  			} );

  			return this;

  		};

  	}(),

  	containsPoint: function ( point ) {

  		return point.x < this.min.x || point.x > this.max.x ||
  			point.y < this.min.y || point.y > this.max.y ||
  			point.z < this.min.z || point.z > this.max.z ? false : true;

  	},

  	containsBox: function ( box ) {

  		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
  			this.min.y <= box.min.y && box.max.y <= this.max.y &&
  			this.min.z <= box.min.z && box.max.z <= this.max.z;

  	},

  	getParameter: function ( point, optionalTarget ) {

  		// This can potentially have a divide by zero if the box
  		// has a size dimension of 0.

  		var result = optionalTarget || new Vector3$2();

  		return result.set(
  			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
  			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
  			( point.z - this.min.z ) / ( this.max.z - this.min.z )
  		);

  	},

  	intersectsBox: function ( box ) {

  		// using 6 splitting planes to rule out intersections.
  		return box.max.x < this.min.x || box.min.x > this.max.x ||
  			box.max.y < this.min.y || box.min.y > this.max.y ||
  			box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

  	},

  	intersectsSphere: ( function () {

  		var closestPoint = new Vector3$2();

  		return function intersectsSphere( sphere ) {

  			// Find the point on the AABB closest to the sphere center.
  			this.clampPoint( sphere.center, closestPoint );

  			// If that point is inside the sphere, the AABB and sphere intersect.
  			return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

  		};

  	} )(),

  	intersectsPlane: function ( plane ) {

  		// We compute the minimum and maximum dot product values. If those values
  		// are on the same side (back or front) of the plane, then there is no intersection.

  		var min, max;

  		if ( plane.normal.x > 0 ) {

  			min = plane.normal.x * this.min.x;
  			max = plane.normal.x * this.max.x;

  		} else {

  			min = plane.normal.x * this.max.x;
  			max = plane.normal.x * this.min.x;

  		}

  		if ( plane.normal.y > 0 ) {

  			min += plane.normal.y * this.min.y;
  			max += plane.normal.y * this.max.y;

  		} else {

  			min += plane.normal.y * this.max.y;
  			max += plane.normal.y * this.min.y;

  		}

  		if ( plane.normal.z > 0 ) {

  			min += plane.normal.z * this.min.z;
  			max += plane.normal.z * this.max.z;

  		} else {

  			min += plane.normal.z * this.max.z;
  			max += plane.normal.z * this.min.z;

  		}

  		return ( min <= plane.constant && max >= plane.constant );

  	},

  	clampPoint: function ( point, optionalTarget ) {

  		var result = optionalTarget || new Vector3$2();
  		return result.copy( point ).clamp( this.min, this.max );

  	},

  	distanceToPoint: function () {

  		var v1 = new Vector3$2();

  		return function distanceToPoint( point ) {

  			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
  			return clampedPoint.sub( point ).length();

  		};

  	}(),

  	getBoundingSphere: function () {

  		var v1 = new Vector3$2();

  		return function getBoundingSphere( optionalTarget ) {

  			var result = optionalTarget || new Sphere$1();

  			this.getCenter( result.center );

  			result.radius = this.getSize( v1 ).length() * 0.5;

  			return result;

  		};

  	}(),

  	intersect: function ( box ) {

  		this.min.max( box.min );
  		this.max.min( box.max );

  		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
  		if ( this.isEmpty() ) { this.makeEmpty(); }

  		return this;

  	},

  	union: function ( box ) {

  		this.min.min( box.min );
  		this.max.max( box.max );

  		return this;

  	},

  	applyMatrix4: function () {

  		var points = [
  			new Vector3$2(),
  			new Vector3$2(),
  			new Vector3$2(),
  			new Vector3$2(),
  			new Vector3$2(),
  			new Vector3$2(),
  			new Vector3$2(),
  			new Vector3$2()
  		];

  		return function applyMatrix4( matrix ) {

  			// transform of empty box is an empty box.
  			if ( this.isEmpty() ) { return this; }

  			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
  			points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
  			points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
  			points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
  			points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
  			points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
  			points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
  			points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
  			points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );	// 111

  			this.setFromPoints( points );

  			return this;

  		};

  	}(),

  	translate: function ( offset ) {

  		this.min.add( offset );
  		this.max.add( offset );

  		return this;

  	},

  	equals: function ( box ) {

  		return box.min.equals( this.min ) && box.max.equals( this.max );

  	}

  } );

  /**
   * @author bhouston / http://clara.io
   * @author mrdoob / http://mrdoob.com/
   */

  function Sphere$1( center, radius ) {

  	this.center = ( center !== undefined ) ? center : new Vector3$2();
  	this.radius = ( radius !== undefined ) ? radius : 0;

  }

  Object.assign( Sphere$1.prototype, {

  	set: function ( center, radius ) {

  		this.center.copy( center );
  		this.radius = radius;

  		return this;

  	},

  	setFromPoints: function () {

  		var box = new Box3$1();

  		return function setFromPoints( points, optionalCenter ) {

  			var center = this.center;

  			if ( optionalCenter !== undefined ) {

  				center.copy( optionalCenter );

  			} else {

  				box.setFromPoints( points ).getCenter( center );

  			}

  			var maxRadiusSq = 0;

  			for ( var i = 0, il = points.length; i < il; i ++ ) {

  				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

  			}

  			this.radius = Math.sqrt( maxRadiusSq );

  			return this;

  		};

  	}(),

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( sphere ) {

  		this.center.copy( sphere.center );
  		this.radius = sphere.radius;

  		return this;

  	},

  	empty: function () {

  		return ( this.radius <= 0 );

  	},

  	containsPoint: function ( point ) {

  		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

  	},

  	distanceToPoint: function ( point ) {

  		return ( point.distanceTo( this.center ) - this.radius );

  	},

  	intersectsSphere: function ( sphere ) {

  		var radiusSum = this.radius + sphere.radius;

  		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

  	},

  	intersectsBox: function ( box ) {

  		return box.intersectsSphere( this );

  	},

  	intersectsPlane: function ( plane ) {

  		return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

  	},

  	clampPoint: function ( point, optionalTarget ) {

  		var deltaLengthSq = this.center.distanceToSquared( point );

  		var result = optionalTarget || new Vector3$2();

  		result.copy( point );

  		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

  			result.sub( this.center ).normalize();
  			result.multiplyScalar( this.radius ).add( this.center );

  		}

  		return result;

  	},

  	getBoundingBox: function ( optionalTarget ) {

  		var box = optionalTarget || new Box3$1();

  		box.set( this.center, this.center );
  		box.expandByScalar( this.radius );

  		return box;

  	},

  	applyMatrix4: function ( matrix ) {

  		this.center.applyMatrix4( matrix );
  		this.radius = this.radius * matrix.getMaxScaleOnAxis();

  		return this;

  	},

  	translate: function ( offset ) {

  		this.center.add( offset );

  		return this;

  	},

  	equals: function ( sphere ) {

  		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

  	}

  } );

  /**
   * @author bhouston / http://clara.io
   */

  function Plane$1( normal, constant ) {

  	// normal is assumed to be normalized

  	this.normal = ( normal !== undefined ) ? normal : new Vector3$2( 1, 0, 0 );
  	this.constant = ( constant !== undefined ) ? constant : 0;

  }

  Object.assign( Plane$1.prototype, {

  	set: function ( normal, constant ) {

  		this.normal.copy( normal );
  		this.constant = constant;

  		return this;

  	},

  	setComponents: function ( x, y, z, w ) {

  		this.normal.set( x, y, z );
  		this.constant = w;

  		return this;

  	},

  	setFromNormalAndCoplanarPoint: function ( normal, point ) {

  		this.normal.copy( normal );
  		this.constant = - point.dot( this.normal );

  		return this;

  	},

  	setFromCoplanarPoints: function () {

  		var v1 = new Vector3$2();
  		var v2 = new Vector3$2();

  		return function setFromCoplanarPoints( a, b, c ) {

  			var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

  			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

  			this.setFromNormalAndCoplanarPoint( normal, a );

  			return this;

  		};

  	}(),

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( plane ) {

  		this.normal.copy( plane.normal );
  		this.constant = plane.constant;

  		return this;

  	},

  	normalize: function () {

  		// Note: will lead to a divide by zero if the plane is invalid.

  		var inverseNormalLength = 1.0 / this.normal.length();
  		this.normal.multiplyScalar( inverseNormalLength );
  		this.constant *= inverseNormalLength;

  		return this;

  	},

  	negate: function () {

  		this.constant *= - 1;
  		this.normal.negate();

  		return this;

  	},

  	distanceToPoint: function ( point ) {

  		return this.normal.dot( point ) + this.constant;

  	},

  	distanceToSphere: function ( sphere ) {

  		return this.distanceToPoint( sphere.center ) - sphere.radius;

  	},

  	projectPoint: function ( point, optionalTarget ) {

  		var result = optionalTarget || new Vector3$2();

  		return result.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

  	},

  	intersectLine: function () {

  		var v1 = new Vector3$2();

  		return function intersectLine( line, optionalTarget ) {

  			var result = optionalTarget || new Vector3$2();

  			var direction = line.delta( v1 );

  			var denominator = this.normal.dot( direction );

  			if ( denominator === 0 ) {

  				// line is coplanar, return origin
  				if ( this.distanceToPoint( line.start ) === 0 ) {

  					return result.copy( line.start );

  				}

  				// Unsure if this is the correct method to handle this case.
  				return undefined;

  			}

  			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

  			if ( t < 0 || t > 1 ) {

  				return undefined;

  			}

  			return result.copy( direction ).multiplyScalar( t ).add( line.start );

  		};

  	}(),

  	intersectsLine: function ( line ) {

  		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

  		var startSign = this.distanceToPoint( line.start );
  		var endSign = this.distanceToPoint( line.end );

  		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

  	},

  	intersectsBox: function ( box ) {

  		return box.intersectsPlane( this );

  	},

  	intersectsSphere: function ( sphere ) {

  		return sphere.intersectsPlane( this );

  	},

  	coplanarPoint: function ( optionalTarget ) {

  		var result = optionalTarget || new Vector3$2();

  		return result.copy( this.normal ).multiplyScalar( - this.constant );

  	},

  	applyMatrix4: function () {

  		var v1 = new Vector3$2();
  		var m1 = new Matrix3$1();

  		return function applyMatrix4( matrix, optionalNormalMatrix ) {

  			var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );

  			var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );

  			var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

  			this.constant = - referencePoint.dot( normal );

  			return this;

  		};

  	}(),

  	translate: function ( offset ) {

  		this.constant -= offset.dot( this.normal );

  		return this;

  	},

  	equals: function ( plane ) {

  		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   * @author bhouston / http://clara.io
   */

  function Frustum( p0, p1, p2, p3, p4, p5 ) {

  	this.planes = [

  		( p0 !== undefined ) ? p0 : new Plane$1(),
  		( p1 !== undefined ) ? p1 : new Plane$1(),
  		( p2 !== undefined ) ? p2 : new Plane$1(),
  		( p3 !== undefined ) ? p3 : new Plane$1(),
  		( p4 !== undefined ) ? p4 : new Plane$1(),
  		( p5 !== undefined ) ? p5 : new Plane$1()

  	];

  }

  Object.assign( Frustum.prototype, {

  	set: function ( p0, p1, p2, p3, p4, p5 ) {

  		var planes = this.planes;

  		planes[ 0 ].copy( p0 );
  		planes[ 1 ].copy( p1 );
  		planes[ 2 ].copy( p2 );
  		planes[ 3 ].copy( p3 );
  		planes[ 4 ].copy( p4 );
  		planes[ 5 ].copy( p5 );

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( frustum ) {

  		var planes = this.planes;

  		for ( var i = 0; i < 6; i ++ ) {

  			planes[ i ].copy( frustum.planes[ i ] );

  		}

  		return this;

  	},

  	setFromMatrix: function ( m ) {

  		var planes = this.planes;
  		var me = m.elements;
  		var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
  		var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
  		var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
  		var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

  		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
  		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
  		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
  		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
  		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
  		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

  		return this;

  	},

  	intersectsObject: function () {

  		var sphere = new Sphere$1();

  		return function intersectsObject( object ) {

  			var geometry = object.geometry;

  			if ( geometry.boundingSphere === null )
  				{ geometry.computeBoundingSphere(); }

  			sphere.copy( geometry.boundingSphere )
  				.applyMatrix4( object.matrixWorld );

  			return this.intersectsSphere( sphere );

  		};

  	}(),

  	intersectsSprite: function () {

  		var sphere = new Sphere$1();

  		return function intersectsSprite( sprite ) {

  			sphere.center.set( 0, 0, 0 );
  			sphere.radius = 0.7071067811865476;
  			sphere.applyMatrix4( sprite.matrixWorld );

  			return this.intersectsSphere( sphere );

  		};

  	}(),

  	intersectsSphere: function ( sphere ) {

  		var planes = this.planes;
  		var center = sphere.center;
  		var negRadius = - sphere.radius;

  		for ( var i = 0; i < 6; i ++ ) {

  			var distance = planes[ i ].distanceToPoint( center );

  			if ( distance < negRadius ) {

  				return false;

  			}

  		}

  		return true;

  	},

  	intersectsBox: function () {

  		var p1 = new Vector3$2(),
  			p2 = new Vector3$2();

  		return function intersectsBox( box ) {

  			var planes = this.planes;

  			for ( var i = 0; i < 6; i ++ ) {

  				var plane = planes[ i ];

  				p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
  				p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
  				p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
  				p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
  				p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
  				p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

  				var d1 = plane.distanceToPoint( p1 );
  				var d2 = plane.distanceToPoint( p2 );

  				// if both outside plane, no intersection

  				if ( d1 < 0 && d2 < 0 ) {

  					return false;

  				}

  			}

  			return true;

  		};

  	}(),

  	containsPoint: function ( point ) {

  		var planes = this.planes;

  		for ( var i = 0; i < 6; i ++ ) {

  			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

  				return false;

  			}

  		}

  		return true;

  	}

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLShadowMap( _renderer, _objects, maxTextureSize ) {

  	var _frustum = new Frustum(),
  		_projScreenMatrix = new Matrix4$1(),

  		_shadowMapSize = new Vector2$1(),
  		_maxShadowMapSize = new Vector2$1( maxTextureSize, maxTextureSize ),

  		_lookTarget = new Vector3$2(),
  		_lightPositionWorld = new Vector3$2(),

  		_MorphingFlag = 1,
  		_SkinningFlag = 2,

  		_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,

  		_depthMaterials = new Array( _NumberOfMaterialVariants ),
  		_distanceMaterials = new Array( _NumberOfMaterialVariants ),

  		_materialCache = {};

  	var cubeDirections = [
  		new Vector3$2( 1, 0, 0 ), new Vector3$2( - 1, 0, 0 ), new Vector3$2( 0, 0, 1 ),
  		new Vector3$2( 0, 0, - 1 ), new Vector3$2( 0, 1, 0 ), new Vector3$2( 0, - 1, 0 )
  	];

  	var cubeUps = [
  		new Vector3$2( 0, 1, 0 ), new Vector3$2( 0, 1, 0 ), new Vector3$2( 0, 1, 0 ),
  		new Vector3$2( 0, 1, 0 ), new Vector3$2( 0, 0, 1 ),	new Vector3$2( 0, 0, - 1 )
  	];

  	var cube2DViewPorts = [
  		new Vector4$1(), new Vector4$1(), new Vector4$1(),
  		new Vector4$1(), new Vector4$1(), new Vector4$1()
  	];

  	// init

  	for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {

  		var useMorphing = ( i & _MorphingFlag ) !== 0;
  		var useSkinning = ( i & _SkinningFlag ) !== 0;

  		var depthMaterial = new MeshDepthMaterial$1( {

  			depthPacking: RGBADepthPacking$1,

  			morphTargets: useMorphing,
  			skinning: useSkinning

  		} );

  		_depthMaterials[ i ] = depthMaterial;

  		//

  		var distanceMaterial = new MeshDistanceMaterial$1( {

  			morphTargets: useMorphing,
  			skinning: useSkinning

  		} );

  		_distanceMaterials[ i ] = distanceMaterial;

  	}

  	//

  	var scope = this;

  	this.enabled = false;

  	this.autoUpdate = true;
  	this.needsUpdate = false;

  	this.type = PCFShadowMap$1;

  	this.renderReverseSided = true;
  	this.renderSingleSided = true;

  	this.render = function ( lights, scene, camera ) {

  		if ( scope.enabled === false ) { return; }
  		if ( scope.autoUpdate === false && scope.needsUpdate === false ) { return; }

  		if ( lights.length === 0 ) { return; }

  		// TODO Clean up (needed in case of contextlost)
  		var _gl = _renderer.context;
  		var _state = _renderer.state;

  		// Set GL state for depth map.
  		_state.disable( _gl.BLEND );
  		_state.buffers.color.setClear( 1, 1, 1, 1 );
  		_state.buffers.depth.setTest( true );
  		_state.setScissorTest( false );

  		// render depth map

  		var faceCount;

  		for ( var i = 0, il = lights.length; i < il; i ++ ) {

  			var light = lights[ i ];
  			var shadow = light.shadow;
  			var isPointLight = light && light.isPointLight;

  			if ( shadow === undefined ) {

  				console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
  				continue;

  			}

  			var shadowCamera = shadow.camera;

  			_shadowMapSize.copy( shadow.mapSize );
  			_shadowMapSize.min( _maxShadowMapSize );

  			if ( isPointLight ) {

  				var vpWidth = _shadowMapSize.x;
  				var vpHeight = _shadowMapSize.y;

  				// These viewports map a cube-map onto a 2D texture with the
  				// following orientation:
  				//
  				//  xzXZ
  				//   y Y
  				//
  				// X - Positive x direction
  				// x - Negative x direction
  				// Y - Positive y direction
  				// y - Negative y direction
  				// Z - Positive z direction
  				// z - Negative z direction

  				// positive X
  				cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
  				// negative X
  				cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
  				// positive Z
  				cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
  				// negative Z
  				cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
  				// positive Y
  				cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
  				// negative Y
  				cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );

  				_shadowMapSize.x *= 4.0;
  				_shadowMapSize.y *= 2.0;

  			}

  			if ( shadow.map === null ) {

  				var pars = { minFilter: NearestFilter$1, magFilter: NearestFilter$1, format: RGBAFormat$1 };

  				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
  				shadow.map.texture.name = light.name + ".shadowMap";

  				shadowCamera.updateProjectionMatrix();

  			}

  			if ( shadow.isSpotLightShadow ) {

  				shadow.update( light );

  			}

  			var shadowMap = shadow.map;
  			var shadowMatrix = shadow.matrix;

  			_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
  			shadowCamera.position.copy( _lightPositionWorld );

  			if ( isPointLight ) {

  				faceCount = 6;

  				// for point lights we set the shadow matrix to be a translation-only matrix
  				// equal to inverse of the light's position

  				shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

  			} else {

  				faceCount = 1;

  				_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
  				shadowCamera.lookAt( _lookTarget );
  				shadowCamera.updateMatrixWorld();

  				// compute shadow matrix

  				shadowMatrix.set(
  					0.5, 0.0, 0.0, 0.5,
  					0.0, 0.5, 0.0, 0.5,
  					0.0, 0.0, 0.5, 0.5,
  					0.0, 0.0, 0.0, 1.0
  				);

  				shadowMatrix.multiply( shadowCamera.projectionMatrix );
  				shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

  			}

  			_renderer.setRenderTarget( shadowMap );
  			_renderer.clear();

  			// render shadow map for each cube face (if omni-directional) or
  			// run a single pass if not

  			for ( var face = 0; face < faceCount; face ++ ) {

  				if ( isPointLight ) {

  					_lookTarget.copy( shadowCamera.position );
  					_lookTarget.add( cubeDirections[ face ] );
  					shadowCamera.up.copy( cubeUps[ face ] );
  					shadowCamera.lookAt( _lookTarget );
  					shadowCamera.updateMatrixWorld();

  					var vpDimensions = cube2DViewPorts[ face ];
  					_state.viewport( vpDimensions );

  				}

  				// update camera matrices and frustum

  				_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
  				_frustum.setFromMatrix( _projScreenMatrix );

  				// set object matrices & frustum culling

  				renderObject( scene, camera, shadowCamera, isPointLight );

  			}

  		}

  		scope.needsUpdate = false;

  	};

  	function getDepthMaterial( object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar ) {

  		var geometry = object.geometry;

  		var result = null;

  		var materialVariants = _depthMaterials;
  		var customMaterial = object.customDepthMaterial;

  		if ( isPointLight ) {

  			materialVariants = _distanceMaterials;
  			customMaterial = object.customDistanceMaterial;

  		}

  		if ( ! customMaterial ) {

  			var useMorphing = false;

  			if ( material.morphTargets ) {

  				if ( geometry && geometry.isBufferGeometry ) {

  					useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

  				} else if ( geometry && geometry.isGeometry ) {

  					useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;

  				}

  			}

  			if ( object.isSkinnedMesh && material.skinning === false ) {

  				console.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );

  			}

  			var useSkinning = object.isSkinnedMesh && material.skinning;

  			var variantIndex = 0;

  			if ( useMorphing ) { variantIndex |= _MorphingFlag; }
  			if ( useSkinning ) { variantIndex |= _SkinningFlag; }

  			result = materialVariants[ variantIndex ];

  		} else {

  			result = customMaterial;

  		}

  		if ( _renderer.localClippingEnabled &&
  				material.clipShadows === true &&
  				material.clippingPlanes.length !== 0 ) {

  			// in this case we need a unique material instance reflecting the
  			// appropriate state

  			var keyA = result.uuid, keyB = material.uuid;

  			var materialsForVariant = _materialCache[ keyA ];

  			if ( materialsForVariant === undefined ) {

  				materialsForVariant = {};
  				_materialCache[ keyA ] = materialsForVariant;

  			}

  			var cachedMaterial = materialsForVariant[ keyB ];

  			if ( cachedMaterial === undefined ) {

  				cachedMaterial = result.clone();
  				materialsForVariant[ keyB ] = cachedMaterial;

  			}

  			result = cachedMaterial;

  		}

  		result.visible = material.visible;
  		result.wireframe = material.wireframe;

  		var side = material.side;

  		if ( scope.renderSingleSided && side == DoubleSide$1 ) {

  			side = FrontSide$1;

  		}

  		if ( scope.renderReverseSided ) {

  			if ( side === FrontSide$1 ) { side = BackSide$1; }
  			else if ( side === BackSide$1 ) { side = FrontSide$1; }

  		}

  		result.side = side;

  		result.clipShadows = material.clipShadows;
  		result.clippingPlanes = material.clippingPlanes;
  		result.clipIntersection = material.clipIntersection;

  		result.wireframeLinewidth = material.wireframeLinewidth;
  		result.linewidth = material.linewidth;

  		if ( isPointLight && result.isMeshDistanceMaterial ) {

  			result.referencePosition.copy( lightPositionWorld );
  			result.nearDistance = shadowCameraNear;
  			result.farDistance = shadowCameraFar;

  		}

  		return result;

  	}

  	function renderObject( object, camera, shadowCamera, isPointLight ) {

  		if ( object.visible === false ) { return; }

  		var visible = object.layers.test( camera.layers );

  		if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

  			if ( object.castShadow && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

  				object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

  				var geometry = _objects.update( object );
  				var material = object.material;

  				if ( Array.isArray( material ) ) {

  					var groups = geometry.groups;

  					for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

  						var group = groups[ k ];
  						var groupMaterial = material[ group.materialIndex ];

  						if ( groupMaterial && groupMaterial.visible ) {

  							var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );
  							_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

  						}

  					}

  				} else if ( material.visible ) {

  					var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );
  					_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

  				}

  			}

  		}

  		var children = object.children;

  		for ( var i = 0, l = children.length; i < l; i ++ ) {

  			renderObject( children[ i ], camera, shadowCamera, isPointLight );

  		}

  	}

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLAttributes( gl ) {

  	var buffers = {};

  	function createBuffer( attribute, bufferType ) {

  		var array = attribute.array;
  		var usage = attribute.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

  		var buffer = gl.createBuffer();

  		gl.bindBuffer( bufferType, buffer );
  		gl.bufferData( bufferType, array, usage );

  		attribute.onUploadCallback();

  		var type = gl.FLOAT;

  		if ( array instanceof Float32Array ) {

  			type = gl.FLOAT;

  		} else if ( array instanceof Float64Array ) {

  			console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );

  		} else if ( array instanceof Uint16Array ) {

  			type = gl.UNSIGNED_SHORT;

  		} else if ( array instanceof Int16Array ) {

  			type = gl.SHORT;

  		} else if ( array instanceof Uint32Array ) {

  			type = gl.UNSIGNED_INT;

  		} else if ( array instanceof Int32Array ) {

  			type = gl.INT;

  		} else if ( array instanceof Int8Array ) {

  			type = gl.BYTE;

  		} else if ( array instanceof Uint8Array ) {

  			type = gl.UNSIGNED_BYTE;

  		}

  		return {
  			buffer: buffer,
  			type: type,
  			bytesPerElement: array.BYTES_PER_ELEMENT,
  			version: attribute.version
  		};

  	}

  	function updateBuffer( buffer, attribute, bufferType ) {

  		var array = attribute.array;
  		var updateRange = attribute.updateRange;

  		gl.bindBuffer( bufferType, buffer );

  		if ( attribute.dynamic === false ) {

  			gl.bufferData( bufferType, array, gl.STATIC_DRAW );

  		} else if ( updateRange.count === - 1 ) {

  			// Not using update ranges

  			gl.bufferSubData( bufferType, 0, array );

  		} else if ( updateRange.count === 0 ) {

  			console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

  		} else {

  			gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
  				array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

  			updateRange.count = - 1; // reset range

  		}

  	}

  	//

  	function get( attribute ) {

  		if ( attribute.isInterleavedBufferAttribute ) { attribute = attribute.data; }

  		return buffers[ attribute.uuid ];

  	}

  	function remove( attribute ) {

  		if ( attribute.isInterleavedBufferAttribute ) { attribute = attribute.data; }

  		var data = buffers[ attribute.uuid ];

  		if ( data ) {

  			gl.deleteBuffer( data.buffer );

  			delete buffers[ attribute.uuid ];

  		}

  	}

  	function update( attribute, bufferType ) {

  		if ( attribute.isInterleavedBufferAttribute ) { attribute = attribute.data; }

  		var data = buffers[ attribute.uuid ];

  		if ( data === undefined ) {

  			buffers[ attribute.uuid ] = createBuffer( attribute, bufferType );

  		} else if ( data.version < attribute.version ) {

  			updateBuffer( data.buffer, attribute, bufferType );

  			data.version = attribute.version;

  		}

  	}

  	return {

  		get: get,
  		remove: remove,
  		update: update

  	};

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author WestLangley / http://github.com/WestLangley
   * @author bhouston / http://clara.io
   */

  function Euler$1( x, y, z, order ) {

  	this._x = x || 0;
  	this._y = y || 0;
  	this._z = z || 0;
  	this._order = order || Euler$1.DefaultOrder;

  }

  Euler$1.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

  Euler$1.DefaultOrder = 'XYZ';

  Object.defineProperties( Euler$1.prototype, {

  	x: {

  		get: function () {

  			return this._x;

  		},

  		set: function ( value ) {

  			this._x = value;
  			this.onChangeCallback();

  		}

  	},

  	y: {

  		get: function () {

  			return this._y;

  		},

  		set: function ( value ) {

  			this._y = value;
  			this.onChangeCallback();

  		}

  	},

  	z: {

  		get: function () {

  			return this._z;

  		},

  		set: function ( value ) {

  			this._z = value;
  			this.onChangeCallback();

  		}

  	},

  	order: {

  		get: function () {

  			return this._order;

  		},

  		set: function ( value ) {

  			this._order = value;
  			this.onChangeCallback();

  		}

  	}

  } );

  Object.assign( Euler$1.prototype, {

  	isEuler: true,

  	set: function ( x, y, z, order ) {

  		this._x = x;
  		this._y = y;
  		this._z = z;
  		this._order = order || this._order;

  		this.onChangeCallback();

  		return this;

  	},

  	clone: function () {

  		return new this.constructor( this._x, this._y, this._z, this._order );

  	},

  	copy: function ( euler ) {

  		this._x = euler._x;
  		this._y = euler._y;
  		this._z = euler._z;
  		this._order = euler._order;

  		this.onChangeCallback();

  		return this;

  	},

  	setFromRotationMatrix: function ( m, order, update ) {

  		var clamp = _Math$1.clamp;

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		var te = m.elements;
  		var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
  		var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
  		var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

  		order = order || this._order;

  		if ( order === 'XYZ' ) {

  			this._y = Math.asin( clamp( m13, - 1, 1 ) );

  			if ( Math.abs( m13 ) < 0.99999 ) {

  				this._x = Math.atan2( - m23, m33 );
  				this._z = Math.atan2( - m12, m11 );

  			} else {

  				this._x = Math.atan2( m32, m22 );
  				this._z = 0;

  			}

  		} else if ( order === 'YXZ' ) {

  			this._x = Math.asin( - clamp( m23, - 1, 1 ) );

  			if ( Math.abs( m23 ) < 0.99999 ) {

  				this._y = Math.atan2( m13, m33 );
  				this._z = Math.atan2( m21, m22 );

  			} else {

  				this._y = Math.atan2( - m31, m11 );
  				this._z = 0;

  			}

  		} else if ( order === 'ZXY' ) {

  			this._x = Math.asin( clamp( m32, - 1, 1 ) );

  			if ( Math.abs( m32 ) < 0.99999 ) {

  				this._y = Math.atan2( - m31, m33 );
  				this._z = Math.atan2( - m12, m22 );

  			} else {

  				this._y = 0;
  				this._z = Math.atan2( m21, m11 );

  			}

  		} else if ( order === 'ZYX' ) {

  			this._y = Math.asin( - clamp( m31, - 1, 1 ) );

  			if ( Math.abs( m31 ) < 0.99999 ) {

  				this._x = Math.atan2( m32, m33 );
  				this._z = Math.atan2( m21, m11 );

  			} else {

  				this._x = 0;
  				this._z = Math.atan2( - m12, m22 );

  			}

  		} else if ( order === 'YZX' ) {

  			this._z = Math.asin( clamp( m21, - 1, 1 ) );

  			if ( Math.abs( m21 ) < 0.99999 ) {

  				this._x = Math.atan2( - m23, m22 );
  				this._y = Math.atan2( - m31, m11 );

  			} else {

  				this._x = 0;
  				this._y = Math.atan2( m13, m33 );

  			}

  		} else if ( order === 'XZY' ) {

  			this._z = Math.asin( - clamp( m12, - 1, 1 ) );

  			if ( Math.abs( m12 ) < 0.99999 ) {

  				this._x = Math.atan2( m32, m22 );
  				this._y = Math.atan2( m13, m11 );

  			} else {

  				this._x = Math.atan2( - m23, m33 );
  				this._y = 0;

  			}

  		} else {

  			console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );

  		}

  		this._order = order;

  		if ( update !== false ) { this.onChangeCallback(); }

  		return this;

  	},

  	setFromQuaternion: function () {

  		var matrix = new Matrix4$1();

  		return function setFromQuaternion( q, order, update ) {

  			matrix.makeRotationFromQuaternion( q );

  			return this.setFromRotationMatrix( matrix, order, update );

  		};

  	}(),

  	setFromVector3: function ( v, order ) {

  		return this.set( v.x, v.y, v.z, order || this._order );

  	},

  	reorder: function () {

  		// WARNING: this discards revolution information -bhouston

  		var q = new Quaternion$1();

  		return function reorder( newOrder ) {

  			q.setFromEuler( this );

  			return this.setFromQuaternion( q, newOrder );

  		};

  	}(),

  	equals: function ( euler ) {

  		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

  	},

  	fromArray: function ( array ) {

  		this._x = array[ 0 ];
  		this._y = array[ 1 ];
  		this._z = array[ 2 ];
  		if ( array[ 3 ] !== undefined ) { this._order = array[ 3 ]; }

  		this.onChangeCallback();

  		return this;

  	},

  	toArray: function ( array, offset ) {

  		if ( array === undefined ) { array = []; }
  		if ( offset === undefined ) { offset = 0; }

  		array[ offset ] = this._x;
  		array[ offset + 1 ] = this._y;
  		array[ offset + 2 ] = this._z;
  		array[ offset + 3 ] = this._order;

  		return array;

  	},

  	toVector3: function ( optionalResult ) {

  		if ( optionalResult ) {

  			return optionalResult.set( this._x, this._y, this._z );

  		} else {

  			return new Vector3$2( this._x, this._y, this._z );

  		}

  	},

  	onChange: function ( callback ) {

  		this.onChangeCallback = callback;

  		return this;

  	},

  	onChangeCallback: function () {}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function Layers$1() {

  	this.mask = 1 | 0;

  }

  Object.assign( Layers$1.prototype, {

  	set: function ( channel ) {

  		this.mask = 1 << channel | 0;

  	},

  	enable: function ( channel ) {

  		this.mask |= 1 << channel | 0;

  	},

  	toggle: function ( channel ) {

  		this.mask ^= 1 << channel | 0;

  	},

  	disable: function ( channel ) {

  		this.mask &= ~ ( 1 << channel | 0 );

  	},

  	test: function ( layers ) {

  		return ( this.mask & layers.mask ) !== 0;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author WestLangley / http://github.com/WestLangley
   * @author elephantatwork / www.elephantatwork.ch
   */

  var object3DId$1 = 0;

  function Object3D$1() {

  	Object.defineProperty( this, 'id', { value: object3DId$1 ++ } );

  	this.uuid = _Math$1.generateUUID();

  	this.name = '';
  	this.type = 'Object3D';

  	this.parent = null;
  	this.children = [];

  	this.up = Object3D$1.DefaultUp.clone();

  	var position = new Vector3$2();
  	var rotation = new Euler$1();
  	var quaternion = new Quaternion$1();
  	var scale = new Vector3$2( 1, 1, 1 );

  	function onRotationChange() {

  		quaternion.setFromEuler( rotation, false );

  	}

  	function onQuaternionChange() {

  		rotation.setFromQuaternion( quaternion, undefined, false );

  	}

  	rotation.onChange( onRotationChange );
  	quaternion.onChange( onQuaternionChange );

  	Object.defineProperties( this, {
  		position: {
  			enumerable: true,
  			value: position
  		},
  		rotation: {
  			enumerable: true,
  			value: rotation
  		},
  		quaternion: {
  			enumerable: true,
  			value: quaternion
  		},
  		scale: {
  			enumerable: true,
  			value: scale
  		},
  		modelViewMatrix: {
  			value: new Matrix4$1()
  		},
  		normalMatrix: {
  			value: new Matrix3$1()
  		}
  	} );

  	this.matrix = new Matrix4$1();
  	this.matrixWorld = new Matrix4$1();

  	this.matrixAutoUpdate = Object3D$1.DefaultMatrixAutoUpdate;
  	this.matrixWorldNeedsUpdate = false;

  	this.layers = new Layers$1();
  	this.visible = true;

  	this.castShadow = false;
  	this.receiveShadow = false;

  	this.frustumCulled = true;
  	this.renderOrder = 0;

  	this.userData = {};

  }

  Object3D$1.DefaultUp = new Vector3$2( 0, 1, 0 );
  Object3D$1.DefaultMatrixAutoUpdate = true;

  Object.assign( Object3D$1.prototype, EventDispatcher$1.prototype, {

  	isObject3D: true,

  	onBeforeRender: function () {},
  	onAfterRender: function () {},

  	applyMatrix: function ( matrix ) {

  		this.matrix.multiplyMatrices( matrix, this.matrix );

  		this.matrix.decompose( this.position, this.quaternion, this.scale );

  	},

  	applyQuaternion: function ( q ) {

  		this.quaternion.premultiply( q );

  		return this;

  	},

  	setRotationFromAxisAngle: function ( axis, angle ) {

  		// assumes axis is normalized

  		this.quaternion.setFromAxisAngle( axis, angle );

  	},

  	setRotationFromEuler: function ( euler ) {

  		this.quaternion.setFromEuler( euler, true );

  	},

  	setRotationFromMatrix: function ( m ) {

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		this.quaternion.setFromRotationMatrix( m );

  	},

  	setRotationFromQuaternion: function ( q ) {

  		// assumes q is normalized

  		this.quaternion.copy( q );

  	},

  	rotateOnAxis: function () {

  		// rotate object on axis in object space
  		// axis is assumed to be normalized

  		var q1 = new Quaternion$1();

  		return function rotateOnAxis( axis, angle ) {

  			q1.setFromAxisAngle( axis, angle );

  			this.quaternion.multiply( q1 );

  			return this;

  		};

  	}(),

  	rotateX: function () {

  		var v1 = new Vector3$2( 1, 0, 0 );

  		return function rotateX( angle ) {

  			return this.rotateOnAxis( v1, angle );

  		};

  	}(),

  	rotateY: function () {

  		var v1 = new Vector3$2( 0, 1, 0 );

  		return function rotateY( angle ) {

  			return this.rotateOnAxis( v1, angle );

  		};

  	}(),

  	rotateZ: function () {

  		var v1 = new Vector3$2( 0, 0, 1 );

  		return function rotateZ( angle ) {

  			return this.rotateOnAxis( v1, angle );

  		};

  	}(),

  	translateOnAxis: function () {

  		// translate object by distance along axis in object space
  		// axis is assumed to be normalized

  		var v1 = new Vector3$2();

  		return function translateOnAxis( axis, distance ) {

  			v1.copy( axis ).applyQuaternion( this.quaternion );

  			this.position.add( v1.multiplyScalar( distance ) );

  			return this;

  		};

  	}(),

  	translateX: function () {

  		var v1 = new Vector3$2( 1, 0, 0 );

  		return function translateX( distance ) {

  			return this.translateOnAxis( v1, distance );

  		};

  	}(),

  	translateY: function () {

  		var v1 = new Vector3$2( 0, 1, 0 );

  		return function translateY( distance ) {

  			return this.translateOnAxis( v1, distance );

  		};

  	}(),

  	translateZ: function () {

  		var v1 = new Vector3$2( 0, 0, 1 );

  		return function translateZ( distance ) {

  			return this.translateOnAxis( v1, distance );

  		};

  	}(),

  	localToWorld: function ( vector ) {

  		return vector.applyMatrix4( this.matrixWorld );

  	},

  	worldToLocal: function () {

  		var m1 = new Matrix4$1();

  		return function worldToLocal( vector ) {

  			return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

  		};

  	}(),

  	lookAt: function () {

  		// This method does not support objects with rotated and/or translated parent(s)

  		var m1 = new Matrix4$1();
  		var vector = new Vector3$2();

  		return function lookAt( x, y, z ) {

  			if ( x.isVector3 ) {

  				vector.copy( x );

  			} else {

  				vector.set( x, y, z );

  			}

  			if ( this.isCamera ) {

  				m1.lookAt( this.position, vector, this.up );

  			} else {

  				m1.lookAt( vector, this.position, this.up );

  			}

  			this.quaternion.setFromRotationMatrix( m1 );

  		};

  	}(),

  	add: function ( object ) {
  		var arguments$1 = arguments;
  		var this$1 = this;


  		if ( arguments.length > 1 ) {

  			for ( var i = 0; i < arguments.length; i ++ ) {

  				this$1.add( arguments$1[ i ] );

  			}

  			return this;

  		}

  		if ( object === this ) {

  			console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
  			return this;

  		}

  		if ( ( object && object.isObject3D ) ) {

  			if ( object.parent !== null ) {

  				object.parent.remove( object );

  			}

  			object.parent = this;
  			object.dispatchEvent( { type: 'added' } );

  			this.children.push( object );

  		} else {

  			console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

  		}

  		return this;

  	},

  	remove: function ( object ) {
  		var arguments$1 = arguments;
  		var this$1 = this;


  		if ( arguments.length > 1 ) {

  			for ( var i = 0; i < arguments.length; i ++ ) {

  				this$1.remove( arguments$1[ i ] );

  			}

  			return this;

  		}

  		var index = this.children.indexOf( object );

  		if ( index !== - 1 ) {

  			object.parent = null;

  			object.dispatchEvent( { type: 'removed' } );

  			this.children.splice( index, 1 );

  		}

  		return this;

  	},

  	getObjectById: function ( id ) {

  		return this.getObjectByProperty( 'id', id );

  	},

  	getObjectByName: function ( name ) {

  		return this.getObjectByProperty( 'name', name );

  	},

  	getObjectByProperty: function ( name, value ) {
  		var this$1 = this;


  		if ( this[ name ] === value ) { return this; }

  		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

  			var child = this$1.children[ i ];
  			var object = child.getObjectByProperty( name, value );

  			if ( object !== undefined ) {

  				return object;

  			}

  		}

  		return undefined;

  	},

  	getWorldPosition: function ( optionalTarget ) {

  		var result = optionalTarget || new Vector3$2();

  		this.updateMatrixWorld( true );

  		return result.setFromMatrixPosition( this.matrixWorld );

  	},

  	getWorldQuaternion: function () {

  		var position = new Vector3$2();
  		var scale = new Vector3$2();

  		return function getWorldQuaternion( optionalTarget ) {

  			var result = optionalTarget || new Quaternion$1();

  			this.updateMatrixWorld( true );

  			this.matrixWorld.decompose( position, result, scale );

  			return result;

  		};

  	}(),

  	getWorldRotation: function () {

  		var quaternion = new Quaternion$1();

  		return function getWorldRotation( optionalTarget ) {

  			var result = optionalTarget || new Euler$1();

  			this.getWorldQuaternion( quaternion );

  			return result.setFromQuaternion( quaternion, this.rotation.order, false );

  		};

  	}(),

  	getWorldScale: function () {

  		var position = new Vector3$2();
  		var quaternion = new Quaternion$1();

  		return function getWorldScale( optionalTarget ) {

  			var result = optionalTarget || new Vector3$2();

  			this.updateMatrixWorld( true );

  			this.matrixWorld.decompose( position, quaternion, result );

  			return result;

  		};

  	}(),

  	getWorldDirection: function () {

  		var quaternion = new Quaternion$1();

  		return function getWorldDirection( optionalTarget ) {

  			var result = optionalTarget || new Vector3$2();

  			this.getWorldQuaternion( quaternion );

  			return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

  		};

  	}(),

  	raycast: function () {},

  	traverse: function ( callback ) {

  		callback( this );

  		var children = this.children;

  		for ( var i = 0, l = children.length; i < l; i ++ ) {

  			children[ i ].traverse( callback );

  		}

  	},

  	traverseVisible: function ( callback ) {

  		if ( this.visible === false ) { return; }

  		callback( this );

  		var children = this.children;

  		for ( var i = 0, l = children.length; i < l; i ++ ) {

  			children[ i ].traverseVisible( callback );

  		}

  	},

  	traverseAncestors: function ( callback ) {

  		var parent = this.parent;

  		if ( parent !== null ) {

  			callback( parent );

  			parent.traverseAncestors( callback );

  		}

  	},

  	updateMatrix: function () {

  		this.matrix.compose( this.position, this.quaternion, this.scale );

  		this.matrixWorldNeedsUpdate = true;

  	},

  	updateMatrixWorld: function ( force ) {

  		if ( this.matrixAutoUpdate ) { this.updateMatrix(); }

  		if ( this.matrixWorldNeedsUpdate || force ) {

  			if ( this.parent === null ) {

  				this.matrixWorld.copy( this.matrix );

  			} else {

  				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

  			}

  			this.matrixWorldNeedsUpdate = false;

  			force = true;

  		}

  		// update children

  		var children = this.children;

  		for ( var i = 0, l = children.length; i < l; i ++ ) {

  			children[ i ].updateMatrixWorld( force );

  		}

  	},

  	toJSON: function ( meta ) {
  		var this$1 = this;


  		// meta is '' when called from JSON.stringify
  		var isRootObject = ( meta === undefined || meta === '' );

  		var output = {};

  		// meta is a hash used to collect geometries, materials.
  		// not providing it implies that this is the root object
  		// being serialized.
  		if ( isRootObject ) {

  			// initialize meta obj
  			meta = {
  				geometries: {},
  				materials: {},
  				textures: {},
  				images: {}
  			};

  			output.metadata = {
  				version: 4.5,
  				type: 'Object',
  				generator: 'Object3D.toJSON'
  			};

  		}

  		// standard Object3D serialization

  		var object = {};

  		object.uuid = this.uuid;
  		object.type = this.type;

  		if ( this.name !== '' ) { object.name = this.name; }
  		if ( this.castShadow === true ) { object.castShadow = true; }
  		if ( this.receiveShadow === true ) { object.receiveShadow = true; }
  		if ( this.visible === false ) { object.visible = false; }
  		if ( JSON.stringify( this.userData ) !== '{}' ) { object.userData = this.userData; }

  		object.matrix = this.matrix.toArray();

  		//

  		function serialize( library, element ) {

  			if ( library[ element.uuid ] === undefined ) {

  				library[ element.uuid ] = element.toJSON( meta );

  			}

  			return element.uuid;

  		}

  		if ( this.geometry !== undefined ) {

  			object.geometry = serialize( meta.geometries, this.geometry );

  		}

  		if ( this.material !== undefined ) {

  			if ( Array.isArray( this.material ) ) {

  				var uuids = [];

  				for ( var i = 0, l = this.material.length; i < l; i ++ ) {

  					uuids.push( serialize( meta.materials, this$1.material[ i ] ) );

  				}

  				object.material = uuids;

  			} else {

  				object.material = serialize( meta.materials, this.material );

  			}

  		}

  		//

  		if ( this.children.length > 0 ) {

  			object.children = [];

  			for ( var i = 0; i < this.children.length; i ++ ) {

  				object.children.push( this$1.children[ i ].toJSON( meta ).object );

  			}

  		}

  		if ( isRootObject ) {

  			var geometries = extractFromCache( meta.geometries );
  			var materials = extractFromCache( meta.materials );
  			var textures = extractFromCache( meta.textures );
  			var images = extractFromCache( meta.images );

  			if ( geometries.length > 0 ) { output.geometries = geometries; }
  			if ( materials.length > 0 ) { output.materials = materials; }
  			if ( textures.length > 0 ) { output.textures = textures; }
  			if ( images.length > 0 ) { output.images = images; }

  		}

  		output.object = object;

  		return output;

  		// extract data from the cache hash
  		// remove metadata on each item
  		// and return as array
  		function extractFromCache( cache ) {

  			var values = [];
  			for ( var key in cache ) {

  				var data = cache[ key ];
  				delete data.metadata;
  				values.push( data );

  			}
  			return values;

  		}

  	},

  	clone: function ( recursive ) {

  		return new this.constructor().copy( this, recursive );

  	},

  	copy: function ( source, recursive ) {
  		var this$1 = this;


  		if ( recursive === undefined ) { recursive = true; }

  		this.name = source.name;

  		this.up.copy( source.up );

  		this.position.copy( source.position );
  		this.quaternion.copy( source.quaternion );
  		this.scale.copy( source.scale );

  		this.matrix.copy( source.matrix );
  		this.matrixWorld.copy( source.matrixWorld );

  		this.matrixAutoUpdate = source.matrixAutoUpdate;
  		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

  		this.layers.mask = source.layers.mask;
  		this.visible = source.visible;

  		this.castShadow = source.castShadow;
  		this.receiveShadow = source.receiveShadow;

  		this.frustumCulled = source.frustumCulled;
  		this.renderOrder = source.renderOrder;

  		this.userData = JSON.parse( JSON.stringify( source.userData ) );

  		if ( recursive === true ) {

  			for ( var i = 0; i < source.children.length; i ++ ) {

  				var child = source.children[ i ];
  				this$1.add( child.clone() );

  			}

  		}

  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author mikael emtinger / http://gomo.se/
   * @author WestLangley / http://github.com/WestLangley
  */

  function Camera$1() {

  	Object3D$1.call( this );

  	this.type = 'Camera';

  	this.matrixWorldInverse = new Matrix4$1();
  	this.projectionMatrix = new Matrix4$1();

  }

  Camera$1.prototype = Object.assign( Object.create( Object3D$1.prototype ), {

  	constructor: Camera$1,

  	isCamera: true,

  	copy: function ( source, recursive ) {

  		Object3D$1.prototype.copy.call( this, source, recursive );

  		this.matrixWorldInverse.copy( source.matrixWorldInverse );
  		this.projectionMatrix.copy( source.projectionMatrix );

  		return this;

  	},

  	getWorldDirection: function () {

  		var quaternion = new Quaternion$1();

  		return function getWorldDirection( optionalTarget ) {

  			var result = optionalTarget || new Vector3$2();

  			this.getWorldQuaternion( quaternion );

  			return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

  		};

  	}(),

  	updateMatrixWorld: function ( force ) {

  		Object3D$1.prototype.updateMatrixWorld.call( this, force );

  		this.matrixWorldInverse.getInverse( this.matrixWorld );

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	}

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author arose / http://github.com/arose
   */

  function OrthographicCamera$1( left, right, top, bottom, near, far ) {

  	Camera$1.call( this );

  	this.type = 'OrthographicCamera';

  	this.zoom = 1;
  	this.view = null;

  	this.left = left;
  	this.right = right;
  	this.top = top;
  	this.bottom = bottom;

  	this.near = ( near !== undefined ) ? near : 0.1;
  	this.far = ( far !== undefined ) ? far : 2000;

  	this.updateProjectionMatrix();

  }

  OrthographicCamera$1.prototype = Object.assign( Object.create( Camera$1.prototype ), {

  	constructor: OrthographicCamera$1,

  	isOrthographicCamera: true,

  	copy: function ( source, recursive ) {

  		Camera$1.prototype.copy.call( this, source, recursive );

  		this.left = source.left;
  		this.right = source.right;
  		this.top = source.top;
  		this.bottom = source.bottom;
  		this.near = source.near;
  		this.far = source.far;

  		this.zoom = source.zoom;
  		this.view = source.view === null ? null : Object.assign( {}, source.view );

  		return this;

  	},

  	setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

  		if ( this.view === null ) {

  			this.view = {
  				enabled: true,
  				fullWidth: 1,
  				fullHeight: 1,
  				offsetX: 0,
  				offsetY: 0,
  				width: 1,
  				height: 1
  			};

  		}

  		this.view.enabled = true;
  		this.view.fullWidth = fullWidth;
  		this.view.fullHeight = fullHeight;
  		this.view.offsetX = x;
  		this.view.offsetY = y;
  		this.view.width = width;
  		this.view.height = height;

  		this.updateProjectionMatrix();

  	},

  	clearViewOffset: function () {

  		if ( this.view !== null ) {

  			this.view.enabled = false;

  		}

  		this.updateProjectionMatrix();

  	},

  	updateProjectionMatrix: function () {

  		var dx = ( this.right - this.left ) / ( 2 * this.zoom );
  		var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
  		var cx = ( this.right + this.left ) / 2;
  		var cy = ( this.top + this.bottom ) / 2;

  		var left = cx - dx;
  		var right = cx + dx;
  		var top = cy + dy;
  		var bottom = cy - dy;

  		if ( this.view !== null && this.view.enabled ) {

  			var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );
  			var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );
  			var scaleW = ( this.right - this.left ) / this.view.width;
  			var scaleH = ( this.top - this.bottom ) / this.view.height;

  			left += scaleW * ( this.view.offsetX / zoomW );
  			right = left + scaleW * ( this.view.width / zoomW );
  			top -= scaleH * ( this.view.offsetY / zoomH );
  			bottom = top - scaleH * ( this.view.height / zoomH );

  		}

  		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

  	},

  	toJSON: function ( meta ) {

  		var data = Object3D$1.prototype.toJSON.call( this, meta );

  		data.object.zoom = this.zoom;
  		data.object.left = this.left;
  		data.object.right = this.right;
  		data.object.top = this.top;
  		data.object.bottom = this.bottom;
  		data.object.near = this.near;
  		data.object.far = this.far;

  		if ( this.view !== null ) { data.object.view = Object.assign( {}, this.view ); }

  		return data;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  function Face3$2( a, b, c, normal, color, materialIndex ) {

  	this.a = a;
  	this.b = b;
  	this.c = c;

  	this.normal = ( normal && normal.isVector3 ) ? normal : new Vector3$2();
  	this.vertexNormals = Array.isArray( normal ) ? normal : [];

  	this.color = ( color && color.isColor ) ? color : new Color$1();
  	this.vertexColors = Array.isArray( color ) ? color : [];

  	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

  }

  Object.assign( Face3$2.prototype, {

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( source ) {
  		var this$1 = this;


  		this.a = source.a;
  		this.b = source.b;
  		this.c = source.c;

  		this.normal.copy( source.normal );
  		this.color.copy( source.color );

  		this.materialIndex = source.materialIndex;

  		for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

  			this$1.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

  		}

  		for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

  			this$1.vertexColors[ i ] = source.vertexColors[ i ].clone();

  		}

  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author kile / http://kile.stravaganza.org/
   * @author alteredq / http://alteredqualia.com/
   * @author mikael emtinger / http://gomo.se/
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * @author bhouston / http://clara.io
   */

  var count$1 = 0;

  function GeometryIdCount$1() {

  	return count$1 ++;

  }

  function Geometry$1() {

  	Object.defineProperty( this, 'id', { value: GeometryIdCount$1() } );

  	this.uuid = _Math$1.generateUUID();

  	this.name = '';
  	this.type = 'Geometry';

  	this.vertices = [];
  	this.colors = [];
  	this.faces = [];
  	this.faceVertexUvs = [[]];

  	this.morphTargets = [];
  	this.morphNormals = [];

  	this.skinWeights = [];
  	this.skinIndices = [];

  	this.lineDistances = [];

  	this.boundingBox = null;
  	this.boundingSphere = null;

  	// update flags

  	this.elementsNeedUpdate = false;
  	this.verticesNeedUpdate = false;
  	this.uvsNeedUpdate = false;
  	this.normalsNeedUpdate = false;
  	this.colorsNeedUpdate = false;
  	this.lineDistancesNeedUpdate = false;
  	this.groupsNeedUpdate = false;

  }

  Object.assign( Geometry$1.prototype, EventDispatcher$1.prototype, {

  	isGeometry: true,

  	applyMatrix: function ( matrix ) {
  		var this$1 = this;


  		var normalMatrix = new Matrix3$1().getNormalMatrix( matrix );

  		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

  			var vertex = this$1.vertices[ i ];
  			vertex.applyMatrix4( matrix );

  		}

  		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

  			var face = this$1.faces[ i ];
  			face.normal.applyMatrix3( normalMatrix ).normalize();

  			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

  				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

  			}

  		}

  		if ( this.boundingBox !== null ) {

  			this.computeBoundingBox();

  		}

  		if ( this.boundingSphere !== null ) {

  			this.computeBoundingSphere();

  		}

  		this.verticesNeedUpdate = true;
  		this.normalsNeedUpdate = true;

  		return this;

  	},

  	rotateX: function () {

  		// rotate geometry around world x-axis

  		var m1 = new Matrix4$1();

  		return function rotateX( angle ) {

  			m1.makeRotationX( angle );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	rotateY: function () {

  		// rotate geometry around world y-axis

  		var m1 = new Matrix4$1();

  		return function rotateY( angle ) {

  			m1.makeRotationY( angle );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	rotateZ: function () {

  		// rotate geometry around world z-axis

  		var m1 = new Matrix4$1();

  		return function rotateZ( angle ) {

  			m1.makeRotationZ( angle );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	translate: function () {

  		// translate geometry

  		var m1 = new Matrix4$1();

  		return function translate( x, y, z ) {

  			m1.makeTranslation( x, y, z );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	scale: function () {

  		// scale geometry

  		var m1 = new Matrix4$1();

  		return function scale( x, y, z ) {

  			m1.makeScale( x, y, z );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	lookAt: function () {

  		var obj = new Object3D$1();

  		return function lookAt( vector ) {

  			obj.lookAt( vector );

  			obj.updateMatrix();

  			this.applyMatrix( obj.matrix );

  		};

  	}(),

  	fromBufferGeometry: function ( geometry ) {

  		var scope = this;

  		var indices = geometry.index !== null ? geometry.index.array : undefined;
  		var attributes = geometry.attributes;

  		var positions = attributes.position.array;
  		var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
  		var colors = attributes.color !== undefined ? attributes.color.array : undefined;
  		var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
  		var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

  		if ( uvs2 !== undefined ) { this.faceVertexUvs[ 1 ] = []; }

  		var tempNormals = [];
  		var tempUVs = [];
  		var tempUVs2 = [];

  		for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {

  			scope.vertices.push( new Vector3$2( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );

  			if ( normals !== undefined ) {

  				tempNormals.push( new Vector3$2( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

  			}

  			if ( colors !== undefined ) {

  				scope.colors.push( new Color$1( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

  			}

  			if ( uvs !== undefined ) {

  				tempUVs.push( new Vector2$1( uvs[ j ], uvs[ j + 1 ] ) );

  			}

  			if ( uvs2 !== undefined ) {

  				tempUVs2.push( new Vector2$1( uvs2[ j ], uvs2[ j + 1 ] ) );

  			}

  		}

  		function addFace( a, b, c, materialIndex ) {

  			var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
  			var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

  			var face = new Face3$2( a, b, c, vertexNormals, vertexColors, materialIndex );

  			scope.faces.push( face );

  			if ( uvs !== undefined ) {

  				scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

  			}

  			if ( uvs2 !== undefined ) {

  				scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

  			}

  		}

  		var groups = geometry.groups;

  		if ( groups.length > 0 ) {

  			for ( var i = 0; i < groups.length; i ++ ) {

  				var group = groups[ i ];

  				var start = group.start;
  				var count = group.count;

  				for ( var j = start, jl = start + count; j < jl; j += 3 ) {

  					if ( indices !== undefined ) {

  						addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );

  					} else {

  						addFace( j, j + 1, j + 2, group.materialIndex );

  					}

  				}

  			}

  		} else {

  			if ( indices !== undefined ) {

  				for ( var i = 0; i < indices.length; i += 3 ) {

  					addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

  				}

  			} else {

  				for ( var i = 0; i < positions.length / 3; i += 3 ) {

  					addFace( i, i + 1, i + 2 );

  				}

  			}

  		}

  		this.computeFaceNormals();

  		if ( geometry.boundingBox !== null ) {

  			this.boundingBox = geometry.boundingBox.clone();

  		}

  		if ( geometry.boundingSphere !== null ) {

  			this.boundingSphere = geometry.boundingSphere.clone();

  		}

  		return this;

  	},

  	center: function () {

  		this.computeBoundingBox();

  		var offset = this.boundingBox.getCenter().negate();

  		this.translate( offset.x, offset.y, offset.z );

  		return offset;

  	},

  	normalize: function () {

  		this.computeBoundingSphere();

  		var center = this.boundingSphere.center;
  		var radius = this.boundingSphere.radius;

  		var s = radius === 0 ? 1 : 1.0 / radius;

  		var matrix = new Matrix4$1();
  		matrix.set(
  			s, 0, 0, - s * center.x,
  			0, s, 0, - s * center.y,
  			0, 0, s, - s * center.z,
  			0, 0, 0, 1
  		);

  		this.applyMatrix( matrix );

  		return this;

  	},

  	computeFaceNormals: function () {
  		var this$1 = this;


  		var cb = new Vector3$2(), ab = new Vector3$2();

  		for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

  			var face = this$1.faces[ f ];

  			var vA = this$1.vertices[ face.a ];
  			var vB = this$1.vertices[ face.b ];
  			var vC = this$1.vertices[ face.c ];

  			cb.subVectors( vC, vB );
  			ab.subVectors( vA, vB );
  			cb.cross( ab );

  			cb.normalize();

  			face.normal.copy( cb );

  		}

  	},

  	computeVertexNormals: function ( areaWeighted ) {
  		var this$1 = this;


  		if ( areaWeighted === undefined ) { areaWeighted = true; }

  		var v, vl, f, fl, face, vertices;

  		vertices = new Array( this.vertices.length );

  		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

  			vertices[ v ] = new Vector3$2();

  		}

  		if ( areaWeighted ) {

  			// vertex normals weighted by triangle areas
  			// http://www.iquilezles.org/www/articles/normals/normals.htm

  			var vA, vB, vC;
  			var cb = new Vector3$2(), ab = new Vector3$2();

  			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  				face = this$1.faces[ f ];

  				vA = this$1.vertices[ face.a ];
  				vB = this$1.vertices[ face.b ];
  				vC = this$1.vertices[ face.c ];

  				cb.subVectors( vC, vB );
  				ab.subVectors( vA, vB );
  				cb.cross( ab );

  				vertices[ face.a ].add( cb );
  				vertices[ face.b ].add( cb );
  				vertices[ face.c ].add( cb );

  			}

  		} else {

  			this.computeFaceNormals();

  			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  				face = this$1.faces[ f ];

  				vertices[ face.a ].add( face.normal );
  				vertices[ face.b ].add( face.normal );
  				vertices[ face.c ].add( face.normal );

  			}

  		}

  		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

  			vertices[ v ].normalize();

  		}

  		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  			face = this$1.faces[ f ];

  			var vertexNormals = face.vertexNormals;

  			if ( vertexNormals.length === 3 ) {

  				vertexNormals[ 0 ].copy( vertices[ face.a ] );
  				vertexNormals[ 1 ].copy( vertices[ face.b ] );
  				vertexNormals[ 2 ].copy( vertices[ face.c ] );

  			} else {

  				vertexNormals[ 0 ] = vertices[ face.a ].clone();
  				vertexNormals[ 1 ] = vertices[ face.b ].clone();
  				vertexNormals[ 2 ] = vertices[ face.c ].clone();

  			}

  		}

  		if ( this.faces.length > 0 ) {

  			this.normalsNeedUpdate = true;

  		}

  	},

  	computeFlatVertexNormals: function () {
  		var this$1 = this;


  		var f, fl, face;

  		this.computeFaceNormals();

  		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  			face = this$1.faces[ f ];

  			var vertexNormals = face.vertexNormals;

  			if ( vertexNormals.length === 3 ) {

  				vertexNormals[ 0 ].copy( face.normal );
  				vertexNormals[ 1 ].copy( face.normal );
  				vertexNormals[ 2 ].copy( face.normal );

  			} else {

  				vertexNormals[ 0 ] = face.normal.clone();
  				vertexNormals[ 1 ] = face.normal.clone();
  				vertexNormals[ 2 ] = face.normal.clone();

  			}

  		}

  		if ( this.faces.length > 0 ) {

  			this.normalsNeedUpdate = true;

  		}

  	},

  	computeMorphNormals: function () {
  		var this$1 = this;


  		var i, il, f, fl, face;

  		// save original normals
  		// - create temp variables on first access
  		//   otherwise just copy (for faster repeated calls)

  		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  			face = this$1.faces[ f ];

  			if ( ! face.__originalFaceNormal ) {

  				face.__originalFaceNormal = face.normal.clone();

  			} else {

  				face.__originalFaceNormal.copy( face.normal );

  			}

  			if ( ! face.__originalVertexNormals ) { face.__originalVertexNormals = []; }

  			for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

  				if ( ! face.__originalVertexNormals[ i ] ) {

  					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

  				} else {

  					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

  				}

  			}

  		}

  		// use temp geometry to compute face and vertex normals for each morph

  		var tmpGeo = new Geometry$1();
  		tmpGeo.faces = this.faces;

  		for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

  			// create on first access

  			if ( ! this$1.morphNormals[ i ] ) {

  				this$1.morphNormals[ i ] = {};
  				this$1.morphNormals[ i ].faceNormals = [];
  				this$1.morphNormals[ i ].vertexNormals = [];

  				var dstNormalsFace = this$1.morphNormals[ i ].faceNormals;
  				var dstNormalsVertex = this$1.morphNormals[ i ].vertexNormals;

  				var faceNormal, vertexNormals;

  				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  					faceNormal = new Vector3$2();
  					vertexNormals = { a: new Vector3$2(), b: new Vector3$2(), c: new Vector3$2() };

  					dstNormalsFace.push( faceNormal );
  					dstNormalsVertex.push( vertexNormals );

  				}

  			}

  			var morphNormals = this$1.morphNormals[ i ];

  			// set vertices to morph target

  			tmpGeo.vertices = this$1.morphTargets[ i ].vertices;

  			// compute morph normals

  			tmpGeo.computeFaceNormals();
  			tmpGeo.computeVertexNormals();

  			// store morph normals

  			var faceNormal, vertexNormals;

  			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  				face = this$1.faces[ f ];

  				faceNormal = morphNormals.faceNormals[ f ];
  				vertexNormals = morphNormals.vertexNormals[ f ];

  				faceNormal.copy( face.normal );

  				vertexNormals.a.copy( face.vertexNormals[ 0 ] );
  				vertexNormals.b.copy( face.vertexNormals[ 1 ] );
  				vertexNormals.c.copy( face.vertexNormals[ 2 ] );

  			}

  		}

  		// restore original normals

  		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  			face = this$1.faces[ f ];

  			face.normal = face.__originalFaceNormal;
  			face.vertexNormals = face.__originalVertexNormals;

  		}

  	},

  	computeLineDistances: function () {
  		var this$1 = this;


  		var d = 0;
  		var vertices = this.vertices;

  		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

  			if ( i > 0 ) {

  				d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

  			}

  			this$1.lineDistances[ i ] = d;

  		}

  	},

  	computeBoundingBox: function () {

  		if ( this.boundingBox === null ) {

  			this.boundingBox = new Box3$1();

  		}

  		this.boundingBox.setFromPoints( this.vertices );

  	},

  	computeBoundingSphere: function () {

  		if ( this.boundingSphere === null ) {

  			this.boundingSphere = new Sphere$1();

  		}

  		this.boundingSphere.setFromPoints( this.vertices );

  	},

  	merge: function ( geometry, matrix, materialIndexOffset ) {

  		if ( ! ( geometry && geometry.isGeometry ) ) {

  			console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
  			return;

  		}

  		var normalMatrix,
  			vertexOffset = this.vertices.length,
  			vertices1 = this.vertices,
  			vertices2 = geometry.vertices,
  			faces1 = this.faces,
  			faces2 = geometry.faces,
  			uvs1 = this.faceVertexUvs[ 0 ],
  			uvs2 = geometry.faceVertexUvs[ 0 ],
  			colors1 = this.colors,
  			colors2 = geometry.colors;

  		if ( materialIndexOffset === undefined ) { materialIndexOffset = 0; }

  		if ( matrix !== undefined ) {

  			normalMatrix = new Matrix3$1().getNormalMatrix( matrix );

  		}

  		// vertices

  		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

  			var vertex = vertices2[ i ];

  			var vertexCopy = vertex.clone();

  			if ( matrix !== undefined ) { vertexCopy.applyMatrix4( matrix ); }

  			vertices1.push( vertexCopy );

  		}

  		// colors

  		for ( var i = 0, il = colors2.length; i < il; i ++ ) {

  			colors1.push( colors2[ i ].clone() );

  		}

  		// faces

  		for ( i = 0, il = faces2.length; i < il; i ++ ) {

  			var face = faces2[ i ], faceCopy, normal, color,
  				faceVertexNormals = face.vertexNormals,
  				faceVertexColors = face.vertexColors;

  			faceCopy = new Face3$2( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
  			faceCopy.normal.copy( face.normal );

  			if ( normalMatrix !== undefined ) {

  				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

  			}

  			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

  				normal = faceVertexNormals[ j ].clone();

  				if ( normalMatrix !== undefined ) {

  					normal.applyMatrix3( normalMatrix ).normalize();

  				}

  				faceCopy.vertexNormals.push( normal );

  			}

  			faceCopy.color.copy( face.color );

  			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

  				color = faceVertexColors[ j ];
  				faceCopy.vertexColors.push( color.clone() );

  			}

  			faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

  			faces1.push( faceCopy );

  		}

  		// uvs

  		for ( i = 0, il = uvs2.length; i < il; i ++ ) {

  			var uv = uvs2[ i ], uvCopy = [];

  			if ( uv === undefined ) {

  				continue;

  			}

  			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

  				uvCopy.push( uv[ j ].clone() );

  			}

  			uvs1.push( uvCopy );

  		}

  	},

  	mergeMesh: function ( mesh ) {

  		if ( ! ( mesh && mesh.isMesh ) ) {

  			console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
  			return;

  		}

  		mesh.matrixAutoUpdate && mesh.updateMatrix();

  		this.merge( mesh.geometry, mesh.matrix );

  	},

  	/*
  	 * Checks for duplicate vertices with hashmap.
  	 * Duplicated vertices are removed
  	 * and faces' vertices are updated.
  	 */

  	mergeVertices: function () {
  		var this$1 = this;


  		var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
  		var unique = [], changes = [];

  		var v, key;
  		var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
  		var precision = Math.pow( 10, precisionPoints );
  		var i, il, face;
  		var indices, j, jl;

  		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

  			v = this$1.vertices[ i ];
  			key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

  			if ( verticesMap[ key ] === undefined ) {

  				verticesMap[ key ] = i;
  				unique.push( this$1.vertices[ i ] );
  				changes[ i ] = unique.length - 1;

  			} else {

  				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
  				changes[ i ] = changes[ verticesMap[ key ] ];

  			}

  		}


  		// if faces are completely degenerate after merging vertices, we
  		// have to remove them from the geometry.
  		var faceIndicesToRemove = [];

  		for ( i = 0, il = this.faces.length; i < il; i ++ ) {

  			face = this$1.faces[ i ];

  			face.a = changes[ face.a ];
  			face.b = changes[ face.b ];
  			face.c = changes[ face.c ];

  			indices = [ face.a, face.b, face.c ];

  			// if any duplicate vertices are found in a Face3
  			// we have to remove the face as nothing can be saved
  			for ( var n = 0; n < 3; n ++ ) {

  				if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

  					faceIndicesToRemove.push( i );
  					break;

  				}

  			}

  		}

  		for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

  			var idx = faceIndicesToRemove[ i ];

  			this$1.faces.splice( idx, 1 );

  			for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

  				this$1.faceVertexUvs[ j ].splice( idx, 1 );

  			}

  		}

  		// Use unique set of vertices

  		var diff = this.vertices.length - unique.length;
  		this.vertices = unique;
  		return diff;

  	},

  	sortFacesByMaterialIndex: function () {

  		var faces = this.faces;
  		var length = faces.length;

  		// tag faces

  		for ( var i = 0; i < length; i ++ ) {

  			faces[ i ]._id = i;

  		}

  		// sort faces

  		function materialIndexSort( a, b ) {

  			return a.materialIndex - b.materialIndex;

  		}

  		faces.sort( materialIndexSort );

  		// sort uvs

  		var uvs1 = this.faceVertexUvs[ 0 ];
  		var uvs2 = this.faceVertexUvs[ 1 ];

  		var newUvs1, newUvs2;

  		if ( uvs1 && uvs1.length === length ) { newUvs1 = []; }
  		if ( uvs2 && uvs2.length === length ) { newUvs2 = []; }

  		for ( var i = 0; i < length; i ++ ) {

  			var id = faces[ i ]._id;

  			if ( newUvs1 ) { newUvs1.push( uvs1[ id ] ); }
  			if ( newUvs2 ) { newUvs2.push( uvs2[ id ] ); }

  		}

  		if ( newUvs1 ) { this.faceVertexUvs[ 0 ] = newUvs1; }
  		if ( newUvs2 ) { this.faceVertexUvs[ 1 ] = newUvs2; }

  	},

  	toJSON: function () {
  		var this$1 = this;


  		var data = {
  			metadata: {
  				version: 4.5,
  				type: 'Geometry',
  				generator: 'Geometry.toJSON'
  			}
  		};

  		// standard Geometry serialization

  		data.uuid = this.uuid;
  		data.type = this.type;
  		if ( this.name !== '' ) { data.name = this.name; }

  		if ( this.parameters !== undefined ) {

  			var parameters = this.parameters;

  			for ( var key in parameters ) {

  				if ( parameters[ key ] !== undefined ) { data[ key ] = parameters[ key ]; }

  			}

  			return data;

  		}

  		var vertices = [];

  		for ( var i = 0; i < this.vertices.length; i ++ ) {

  			var vertex = this$1.vertices[ i ];
  			vertices.push( vertex.x, vertex.y, vertex.z );

  		}

  		var faces = [];
  		var normals = [];
  		var normalsHash = {};
  		var colors = [];
  		var colorsHash = {};
  		var uvs = [];
  		var uvsHash = {};

  		for ( var i = 0; i < this.faces.length; i ++ ) {

  			var face = this$1.faces[ i ];

  			var hasMaterial = true;
  			var hasFaceUv = false; // deprecated
  			var hasFaceVertexUv = this$1.faceVertexUvs[ 0 ][ i ] !== undefined;
  			var hasFaceNormal = face.normal.length() > 0;
  			var hasFaceVertexNormal = face.vertexNormals.length > 0;
  			var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
  			var hasFaceVertexColor = face.vertexColors.length > 0;

  			var faceType = 0;

  			faceType = setBit( faceType, 0, 0 ); // isQuad
  			faceType = setBit( faceType, 1, hasMaterial );
  			faceType = setBit( faceType, 2, hasFaceUv );
  			faceType = setBit( faceType, 3, hasFaceVertexUv );
  			faceType = setBit( faceType, 4, hasFaceNormal );
  			faceType = setBit( faceType, 5, hasFaceVertexNormal );
  			faceType = setBit( faceType, 6, hasFaceColor );
  			faceType = setBit( faceType, 7, hasFaceVertexColor );

  			faces.push( faceType );
  			faces.push( face.a, face.b, face.c );
  			faces.push( face.materialIndex );

  			if ( hasFaceVertexUv ) {

  				var faceVertexUvs = this$1.faceVertexUvs[ 0 ][ i ];

  				faces.push(
  					getUvIndex( faceVertexUvs[ 0 ] ),
  					getUvIndex( faceVertexUvs[ 1 ] ),
  					getUvIndex( faceVertexUvs[ 2 ] )
  				);

  			}

  			if ( hasFaceNormal ) {

  				faces.push( getNormalIndex( face.normal ) );

  			}

  			if ( hasFaceVertexNormal ) {

  				var vertexNormals = face.vertexNormals;

  				faces.push(
  					getNormalIndex( vertexNormals[ 0 ] ),
  					getNormalIndex( vertexNormals[ 1 ] ),
  					getNormalIndex( vertexNormals[ 2 ] )
  				);

  			}

  			if ( hasFaceColor ) {

  				faces.push( getColorIndex( face.color ) );

  			}

  			if ( hasFaceVertexColor ) {

  				var vertexColors = face.vertexColors;

  				faces.push(
  					getColorIndex( vertexColors[ 0 ] ),
  					getColorIndex( vertexColors[ 1 ] ),
  					getColorIndex( vertexColors[ 2 ] )
  				);

  			}

  		}

  		function setBit( value, position, enabled ) {

  			return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

  		}

  		function getNormalIndex( normal ) {

  			var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

  			if ( normalsHash[ hash ] !== undefined ) {

  				return normalsHash[ hash ];

  			}

  			normalsHash[ hash ] = normals.length / 3;
  			normals.push( normal.x, normal.y, normal.z );

  			return normalsHash[ hash ];

  		}

  		function getColorIndex( color ) {

  			var hash = color.r.toString() + color.g.toString() + color.b.toString();

  			if ( colorsHash[ hash ] !== undefined ) {

  				return colorsHash[ hash ];

  			}

  			colorsHash[ hash ] = colors.length;
  			colors.push( color.getHex() );

  			return colorsHash[ hash ];

  		}

  		function getUvIndex( uv ) {

  			var hash = uv.x.toString() + uv.y.toString();

  			if ( uvsHash[ hash ] !== undefined ) {

  				return uvsHash[ hash ];

  			}

  			uvsHash[ hash ] = uvs.length / 2;
  			uvs.push( uv.x, uv.y );

  			return uvsHash[ hash ];

  		}

  		data.data = {};

  		data.data.vertices = vertices;
  		data.data.normals = normals;
  		if ( colors.length > 0 ) { data.data.colors = colors; }
  		if ( uvs.length > 0 ) { data.data.uvs = [ uvs ]; } // temporal backward compatibility
  		data.data.faces = faces;

  		return data;

  	},

  	clone: function () {

  		/*
  		 // Handle primitives

  		 var parameters = this.parameters;

  		 if ( parameters !== undefined ) {

  		 var values = [];

  		 for ( var key in parameters ) {

  		 values.push( parameters[ key ] );

  		 }

  		 var geometry = Object.create( this.constructor.prototype );
  		 this.constructor.apply( geometry, values );
  		 return geometry;

  		 }

  		 return new this.constructor().copy( this );
  		 */

  		return new Geometry$1().copy( this );

  	},

  	copy: function ( source ) {
  		var this$1 = this;


  		var i, il, j, jl, k, kl;

  		// reset

  		this.vertices = [];
  		this.colors = [];
  		this.faces = [];
  		this.faceVertexUvs = [[]];
  		this.morphTargets = [];
  		this.morphNormals = [];
  		this.skinWeights = [];
  		this.skinIndices = [];
  		this.lineDistances = [];
  		this.boundingBox = null;
  		this.boundingSphere = null;

  		// name

  		this.name = source.name;

  		// vertices

  		var vertices = source.vertices;

  		for ( i = 0, il = vertices.length; i < il; i ++ ) {

  			this$1.vertices.push( vertices[ i ].clone() );

  		}

  		// colors

  		var colors = source.colors;

  		for ( i = 0, il = colors.length; i < il; i ++ ) {

  			this$1.colors.push( colors[ i ].clone() );

  		}

  		// faces

  		var faces = source.faces;

  		for ( i = 0, il = faces.length; i < il; i ++ ) {

  			this$1.faces.push( faces[ i ].clone() );

  		}

  		// face vertex uvs

  		for ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

  			var faceVertexUvs = source.faceVertexUvs[ i ];

  			if ( this$1.faceVertexUvs[ i ] === undefined ) {

  				this$1.faceVertexUvs[ i ] = [];

  			}

  			for ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

  				var uvs = faceVertexUvs[ j ], uvsCopy = [];

  				for ( k = 0, kl = uvs.length; k < kl; k ++ ) {

  					var uv = uvs[ k ];

  					uvsCopy.push( uv.clone() );

  				}

  				this$1.faceVertexUvs[ i ].push( uvsCopy );

  			}

  		}

  		// morph targets

  		var morphTargets = source.morphTargets;

  		for ( i = 0, il = morphTargets.length; i < il; i ++ ) {

  			var morphTarget = {};
  			morphTarget.name = morphTargets[ i ].name;

  			// vertices

  			if ( morphTargets[ i ].vertices !== undefined ) {

  				morphTarget.vertices = [];

  				for ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {

  					morphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );

  				}

  			}

  			// normals

  			if ( morphTargets[ i ].normals !== undefined ) {

  				morphTarget.normals = [];

  				for ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {

  					morphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );

  				}

  			}

  			this$1.morphTargets.push( morphTarget );

  		}

  		// morph normals

  		var morphNormals = source.morphNormals;

  		for ( i = 0, il = morphNormals.length; i < il; i ++ ) {

  			var morphNormal = {};

  			// vertex normals

  			if ( morphNormals[ i ].vertexNormals !== undefined ) {

  				morphNormal.vertexNormals = [];

  				for ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {

  					var srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];
  					var destVertexNormal = {};

  					destVertexNormal.a = srcVertexNormal.a.clone();
  					destVertexNormal.b = srcVertexNormal.b.clone();
  					destVertexNormal.c = srcVertexNormal.c.clone();

  					morphNormal.vertexNormals.push( destVertexNormal );

  				}

  			}

  			// face normals

  			if ( morphNormals[ i ].faceNormals !== undefined ) {

  				morphNormal.faceNormals = [];

  				for ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {

  					morphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );

  				}

  			}

  			this$1.morphNormals.push( morphNormal );

  		}

  		// skin weights

  		var skinWeights = source.skinWeights;

  		for ( i = 0, il = skinWeights.length; i < il; i ++ ) {

  			this$1.skinWeights.push( skinWeights[ i ].clone() );

  		}

  		// skin indices

  		var skinIndices = source.skinIndices;

  		for ( i = 0, il = skinIndices.length; i < il; i ++ ) {

  			this$1.skinIndices.push( skinIndices[ i ].clone() );

  		}

  		// line distances

  		var lineDistances = source.lineDistances;

  		for ( i = 0, il = lineDistances.length; i < il; i ++ ) {

  			this$1.lineDistances.push( lineDistances[ i ] );

  		}

  		// bounding box

  		var boundingBox = source.boundingBox;

  		if ( boundingBox !== null ) {

  			this.boundingBox = boundingBox.clone();

  		}

  		// bounding sphere

  		var boundingSphere = source.boundingSphere;

  		if ( boundingSphere !== null ) {

  			this.boundingSphere = boundingSphere.clone();

  		}

  		// update flags

  		this.elementsNeedUpdate = source.elementsNeedUpdate;
  		this.verticesNeedUpdate = source.verticesNeedUpdate;
  		this.uvsNeedUpdate = source.uvsNeedUpdate;
  		this.normalsNeedUpdate = source.normalsNeedUpdate;
  		this.colorsNeedUpdate = source.colorsNeedUpdate;
  		this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
  		this.groupsNeedUpdate = source.groupsNeedUpdate;

  		return this;

  	},

  	dispose: function () {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function BufferAttribute$1( array, itemSize, normalized ) {

  	if ( Array.isArray( array ) ) {

  		throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

  	}

  	this.uuid = _Math$1.generateUUID();
  	this.name = '';

  	this.array = array;
  	this.itemSize = itemSize;
  	this.count = array !== undefined ? array.length / itemSize : 0;
  	this.normalized = normalized === true;

  	this.dynamic = false;
  	this.updateRange = { offset: 0, count: - 1 };

  	this.onUploadCallback = function () {};

  	this.version = 0;

  }

  Object.defineProperty( BufferAttribute$1.prototype, 'needsUpdate', {

  	set: function ( value ) {

  		if ( value === true ) { this.version ++; }

  	}

  } );

  Object.assign( BufferAttribute$1.prototype, {

  	isBufferAttribute: true,

  	setArray: function ( array ) {

  		if ( Array.isArray( array ) ) {

  			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

  		}

  		this.count = array !== undefined ? array.length / this.itemSize : 0;
  		this.array = array;

  	},

  	setDynamic: function ( value ) {

  		this.dynamic = value;

  		return this;

  	},

  	copy: function ( source ) {

  		this.array = new source.array.constructor( source.array );
  		this.itemSize = source.itemSize;
  		this.count = source.count;
  		this.normalized = source.normalized;

  		this.dynamic = source.dynamic;

  		return this;

  	},

  	copyAt: function ( index1, attribute, index2 ) {
  		var this$1 = this;


  		index1 *= this.itemSize;
  		index2 *= attribute.itemSize;

  		for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

  			this$1.array[ index1 + i ] = attribute.array[ index2 + i ];

  		}

  		return this;

  	},

  	copyArray: function ( array ) {

  		this.array.set( array );

  		return this;

  	},

  	copyColorsArray: function ( colors ) {

  		var array = this.array, offset = 0;

  		for ( var i = 0, l = colors.length; i < l; i ++ ) {

  			var color = colors[ i ];

  			if ( color === undefined ) {

  				console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
  				color = new Color$1();

  			}

  			array[ offset ++ ] = color.r;
  			array[ offset ++ ] = color.g;
  			array[ offset ++ ] = color.b;

  		}

  		return this;

  	},

  	copyIndicesArray: function ( indices ) {

  		var array = this.array, offset = 0;

  		for ( var i = 0, l = indices.length; i < l; i ++ ) {

  			var index = indices[ i ];

  			array[ offset ++ ] = index.a;
  			array[ offset ++ ] = index.b;
  			array[ offset ++ ] = index.c;

  		}

  		return this;

  	},

  	copyVector2sArray: function ( vectors ) {

  		var array = this.array, offset = 0;

  		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

  			var vector = vectors[ i ];

  			if ( vector === undefined ) {

  				console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
  				vector = new Vector2$1();

  			}

  			array[ offset ++ ] = vector.x;
  			array[ offset ++ ] = vector.y;

  		}

  		return this;

  	},

  	copyVector3sArray: function ( vectors ) {

  		var array = this.array, offset = 0;

  		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

  			var vector = vectors[ i ];

  			if ( vector === undefined ) {

  				console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
  				vector = new Vector3$2();

  			}

  			array[ offset ++ ] = vector.x;
  			array[ offset ++ ] = vector.y;
  			array[ offset ++ ] = vector.z;

  		}

  		return this;

  	},

  	copyVector4sArray: function ( vectors ) {

  		var array = this.array, offset = 0;

  		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

  			var vector = vectors[ i ];

  			if ( vector === undefined ) {

  				console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
  				vector = new Vector4$1();

  			}

  			array[ offset ++ ] = vector.x;
  			array[ offset ++ ] = vector.y;
  			array[ offset ++ ] = vector.z;
  			array[ offset ++ ] = vector.w;

  		}

  		return this;

  	},

  	set: function ( value, offset ) {

  		if ( offset === undefined ) { offset = 0; }

  		this.array.set( value, offset );

  		return this;

  	},

  	getX: function ( index ) {

  		return this.array[ index * this.itemSize ];

  	},

  	setX: function ( index, x ) {

  		this.array[ index * this.itemSize ] = x;

  		return this;

  	},

  	getY: function ( index ) {

  		return this.array[ index * this.itemSize + 1 ];

  	},

  	setY: function ( index, y ) {

  		this.array[ index * this.itemSize + 1 ] = y;

  		return this;

  	},

  	getZ: function ( index ) {

  		return this.array[ index * this.itemSize + 2 ];

  	},

  	setZ: function ( index, z ) {

  		this.array[ index * this.itemSize + 2 ] = z;

  		return this;

  	},

  	getW: function ( index ) {

  		return this.array[ index * this.itemSize + 3 ];

  	},

  	setW: function ( index, w ) {

  		this.array[ index * this.itemSize + 3 ] = w;

  		return this;

  	},

  	setXY: function ( index, x, y ) {

  		index *= this.itemSize;

  		this.array[ index + 0 ] = x;
  		this.array[ index + 1 ] = y;

  		return this;

  	},

  	setXYZ: function ( index, x, y, z ) {

  		index *= this.itemSize;

  		this.array[ index + 0 ] = x;
  		this.array[ index + 1 ] = y;
  		this.array[ index + 2 ] = z;

  		return this;

  	},

  	setXYZW: function ( index, x, y, z, w ) {

  		index *= this.itemSize;

  		this.array[ index + 0 ] = x;
  		this.array[ index + 1 ] = y;
  		this.array[ index + 2 ] = z;
  		this.array[ index + 3 ] = w;

  		return this;

  	},

  	onUpload: function ( callback ) {

  		this.onUploadCallback = callback;

  		return this;

  	},

  	clone: function () {

  		return new this.constructor( this.array, this.itemSize ).copy( this );

  	}

  } );

  //

  function Int8BufferAttribute$1( array, itemSize ) {

  	BufferAttribute$1.call( this, new Int8Array( array ), itemSize );

  }

  Int8BufferAttribute$1.prototype = Object.create( BufferAttribute$1.prototype );
  Int8BufferAttribute$1.prototype.constructor = Int8BufferAttribute$1;


  function Uint8BufferAttribute$1( array, itemSize ) {

  	BufferAttribute$1.call( this, new Uint8Array( array ), itemSize );

  }

  Uint8BufferAttribute$1.prototype = Object.create( BufferAttribute$1.prototype );
  Uint8BufferAttribute$1.prototype.constructor = Uint8BufferAttribute$1;


  function Uint8ClampedBufferAttribute$1( array, itemSize ) {

  	BufferAttribute$1.call( this, new Uint8ClampedArray( array ), itemSize );

  }

  Uint8ClampedBufferAttribute$1.prototype = Object.create( BufferAttribute$1.prototype );
  Uint8ClampedBufferAttribute$1.prototype.constructor = Uint8ClampedBufferAttribute$1;


  function Int16BufferAttribute$1( array, itemSize ) {

  	BufferAttribute$1.call( this, new Int16Array( array ), itemSize );

  }

  Int16BufferAttribute$1.prototype = Object.create( BufferAttribute$1.prototype );
  Int16BufferAttribute$1.prototype.constructor = Int16BufferAttribute$1;


  function Uint16BufferAttribute$1( array, itemSize ) {

  	BufferAttribute$1.call( this, new Uint16Array( array ), itemSize );

  }

  Uint16BufferAttribute$1.prototype = Object.create( BufferAttribute$1.prototype );
  Uint16BufferAttribute$1.prototype.constructor = Uint16BufferAttribute$1;


  function Int32BufferAttribute$1( array, itemSize ) {

  	BufferAttribute$1.call( this, new Int32Array( array ), itemSize );

  }

  Int32BufferAttribute$1.prototype = Object.create( BufferAttribute$1.prototype );
  Int32BufferAttribute$1.prototype.constructor = Int32BufferAttribute$1;


  function Uint32BufferAttribute$1( array, itemSize ) {

  	BufferAttribute$1.call( this, new Uint32Array( array ), itemSize );

  }

  Uint32BufferAttribute$1.prototype = Object.create( BufferAttribute$1.prototype );
  Uint32BufferAttribute$1.prototype.constructor = Uint32BufferAttribute$1;


  function Float32BufferAttribute$1( array, itemSize ) {

  	BufferAttribute$1.call( this, new Float32Array( array ), itemSize );

  }

  Float32BufferAttribute$1.prototype = Object.create( BufferAttribute$1.prototype );
  Float32BufferAttribute$1.prototype.constructor = Float32BufferAttribute$1;


  function Float64BufferAttribute$1( array, itemSize ) {

  	BufferAttribute$1.call( this, new Float64Array( array ), itemSize );

  }

  Float64BufferAttribute$1.prototype = Object.create( BufferAttribute$1.prototype );
  Float64BufferAttribute$1.prototype.constructor = Float64BufferAttribute$1;

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function DirectGeometry$1() {

  	this.indices = [];
  	this.vertices = [];
  	this.normals = [];
  	this.colors = [];
  	this.uvs = [];
  	this.uvs2 = [];

  	this.groups = [];

  	this.morphTargets = {};

  	this.skinWeights = [];
  	this.skinIndices = [];

  	// this.lineDistances = [];

  	this.boundingBox = null;
  	this.boundingSphere = null;

  	// update flags

  	this.verticesNeedUpdate = false;
  	this.normalsNeedUpdate = false;
  	this.colorsNeedUpdate = false;
  	this.uvsNeedUpdate = false;
  	this.groupsNeedUpdate = false;

  }

  Object.assign( DirectGeometry$1.prototype, {

  	computeGroups: function ( geometry ) {

  		var group;
  		var groups = [];
  		var materialIndex = undefined;

  		var faces = geometry.faces;

  		for ( var i = 0; i < faces.length; i ++ ) {

  			var face = faces[ i ];

  			// materials

  			if ( face.materialIndex !== materialIndex ) {

  				materialIndex = face.materialIndex;

  				if ( group !== undefined ) {

  					group.count = ( i * 3 ) - group.start;
  					groups.push( group );

  				}

  				group = {
  					start: i * 3,
  					materialIndex: materialIndex
  				};

  			}

  		}

  		if ( group !== undefined ) {

  			group.count = ( i * 3 ) - group.start;
  			groups.push( group );

  		}

  		this.groups = groups;

  	},

  	fromGeometry: function ( geometry ) {
  		var this$1 = this;


  		var faces = geometry.faces;
  		var vertices = geometry.vertices;
  		var faceVertexUvs = geometry.faceVertexUvs;

  		var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
  		var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

  		// morphs

  		var morphTargets = geometry.morphTargets;
  		var morphTargetsLength = morphTargets.length;

  		var morphTargetsPosition;

  		if ( morphTargetsLength > 0 ) {

  			morphTargetsPosition = [];

  			for ( var i = 0; i < morphTargetsLength; i ++ ) {

  				morphTargetsPosition[ i ] = [];

  			}

  			this.morphTargets.position = morphTargetsPosition;

  		}

  		var morphNormals = geometry.morphNormals;
  		var morphNormalsLength = morphNormals.length;

  		var morphTargetsNormal;

  		if ( morphNormalsLength > 0 ) {

  			morphTargetsNormal = [];

  			for ( var i = 0; i < morphNormalsLength; i ++ ) {

  				morphTargetsNormal[ i ] = [];

  			}

  			this.morphTargets.normal = morphTargetsNormal;

  		}

  		// skins

  		var skinIndices = geometry.skinIndices;
  		var skinWeights = geometry.skinWeights;

  		var hasSkinIndices = skinIndices.length === vertices.length;
  		var hasSkinWeights = skinWeights.length === vertices.length;

  		//

  		for ( var i = 0; i < faces.length; i ++ ) {

  			var face = faces[ i ];

  			this$1.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

  			var vertexNormals = face.vertexNormals;

  			if ( vertexNormals.length === 3 ) {

  				this$1.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

  			} else {

  				var normal = face.normal;

  				this$1.normals.push( normal, normal, normal );

  			}

  			var vertexColors = face.vertexColors;

  			if ( vertexColors.length === 3 ) {

  				this$1.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

  			} else {

  				var color = face.color;

  				this$1.colors.push( color, color, color );

  			}

  			if ( hasFaceVertexUv === true ) {

  				var vertexUvs = faceVertexUvs[ 0 ][ i ];

  				if ( vertexUvs !== undefined ) {

  					this$1.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

  				} else {

  					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

  					this$1.uvs.push( new Vector2$1(), new Vector2$1(), new Vector2$1() );

  				}

  			}

  			if ( hasFaceVertexUv2 === true ) {

  				var vertexUvs = faceVertexUvs[ 1 ][ i ];

  				if ( vertexUvs !== undefined ) {

  					this$1.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

  				} else {

  					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

  					this$1.uvs2.push( new Vector2$1(), new Vector2$1(), new Vector2$1() );

  				}

  			}

  			// morphs

  			for ( var j = 0; j < morphTargetsLength; j ++ ) {

  				var morphTarget = morphTargets[ j ].vertices;

  				morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

  			}

  			for ( var j = 0; j < morphNormalsLength; j ++ ) {

  				var morphNormal = morphNormals[ j ].vertexNormals[ i ];

  				morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

  			}

  			// skins

  			if ( hasSkinIndices ) {

  				this$1.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

  			}

  			if ( hasSkinWeights ) {

  				this$1.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

  			}

  		}

  		this.computeGroups( geometry );

  		this.verticesNeedUpdate = geometry.verticesNeedUpdate;
  		this.normalsNeedUpdate = geometry.normalsNeedUpdate;
  		this.colorsNeedUpdate = geometry.colorsNeedUpdate;
  		this.uvsNeedUpdate = geometry.uvsNeedUpdate;
  		this.groupsNeedUpdate = geometry.groupsNeedUpdate;

  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function arrayMax$1( array ) {

  	if ( array.length === 0 ) { return - Infinity; }

  	var max = array[ 0 ];

  	for ( var i = 1, l = array.length; i < l; ++ i ) {

  		if ( array[ i ] > max ) { max = array[ i ]; }

  	}

  	return max;

  }

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   */

  function BufferGeometry$1() {

  	Object.defineProperty( this, 'id', { value: GeometryIdCount$1() } );

  	this.uuid = _Math$1.generateUUID();

  	this.name = '';
  	this.type = 'BufferGeometry';

  	this.index = null;
  	this.attributes = {};

  	this.morphAttributes = {};

  	this.groups = [];

  	this.boundingBox = null;
  	this.boundingSphere = null;

  	this.drawRange = { start: 0, count: Infinity };

  }

  BufferGeometry$1.MaxIndex = 65535;

  Object.assign( BufferGeometry$1.prototype, EventDispatcher$1.prototype, {

  	isBufferGeometry: true,

  	getIndex: function () {

  		return this.index;

  	},

  	setIndex: function ( index ) {

  		if ( Array.isArray( index ) ) {

  			this.index = new ( arrayMax$1( index ) > 65535 ? Uint32BufferAttribute$1 : Uint16BufferAttribute$1 )( index, 1 );

  		} else {

  			this.index = index;

  		}

  	},

  	addAttribute: function ( name, attribute ) {

  		if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {

  			console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

  			this.addAttribute( name, new BufferAttribute$1( arguments[ 1 ], arguments[ 2 ] ) );

  			return;

  		}

  		if ( name === 'index' ) {

  			console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
  			this.setIndex( attribute );

  			return;

  		}

  		this.attributes[ name ] = attribute;

  		return this;

  	},

  	getAttribute: function ( name ) {

  		return this.attributes[ name ];

  	},

  	removeAttribute: function ( name ) {

  		delete this.attributes[ name ];

  		return this;

  	},

  	addGroup: function ( start, count, materialIndex ) {

  		this.groups.push( {

  			start: start,
  			count: count,
  			materialIndex: materialIndex !== undefined ? materialIndex : 0

  		} );

  	},

  	clearGroups: function () {

  		this.groups = [];

  	},

  	setDrawRange: function ( start, count ) {

  		this.drawRange.start = start;
  		this.drawRange.count = count;

  	},

  	applyMatrix: function ( matrix ) {

  		var position = this.attributes.position;

  		if ( position !== undefined ) {

  			matrix.applyToBufferAttribute( position );
  			position.needsUpdate = true;

  		}

  		var normal = this.attributes.normal;

  		if ( normal !== undefined ) {

  			var normalMatrix = new Matrix3$1().getNormalMatrix( matrix );

  			normalMatrix.applyToBufferAttribute( normal );
  			normal.needsUpdate = true;

  		}

  		if ( this.boundingBox !== null ) {

  			this.computeBoundingBox();

  		}

  		if ( this.boundingSphere !== null ) {

  			this.computeBoundingSphere();

  		}

  		return this;

  	},

  	rotateX: function () {

  		// rotate geometry around world x-axis

  		var m1 = new Matrix4$1();

  		return function rotateX( angle ) {

  			m1.makeRotationX( angle );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	rotateY: function () {

  		// rotate geometry around world y-axis

  		var m1 = new Matrix4$1();

  		return function rotateY( angle ) {

  			m1.makeRotationY( angle );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	rotateZ: function () {

  		// rotate geometry around world z-axis

  		var m1 = new Matrix4$1();

  		return function rotateZ( angle ) {

  			m1.makeRotationZ( angle );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	translate: function () {

  		// translate geometry

  		var m1 = new Matrix4$1();

  		return function translate( x, y, z ) {

  			m1.makeTranslation( x, y, z );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	scale: function () {

  		// scale geometry

  		var m1 = new Matrix4$1();

  		return function scale( x, y, z ) {

  			m1.makeScale( x, y, z );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	lookAt: function () {

  		var obj = new Object3D$1();

  		return function lookAt( vector ) {

  			obj.lookAt( vector );

  			obj.updateMatrix();

  			this.applyMatrix( obj.matrix );

  		};

  	}(),

  	center: function () {

  		this.computeBoundingBox();

  		var offset = this.boundingBox.getCenter().negate();

  		this.translate( offset.x, offset.y, offset.z );

  		return offset;

  	},

  	setFromObject: function ( object ) {

  		// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

  		var geometry = object.geometry;

  		if ( object.isPoints || object.isLine ) {

  			var positions = new Float32BufferAttribute$1( geometry.vertices.length * 3, 3 );
  			var colors = new Float32BufferAttribute$1( geometry.colors.length * 3, 3 );

  			this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
  			this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

  			if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

  				var lineDistances = new Float32BufferAttribute$1( geometry.lineDistances.length, 1 );

  				this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

  			}

  			if ( geometry.boundingSphere !== null ) {

  				this.boundingSphere = geometry.boundingSphere.clone();

  			}

  			if ( geometry.boundingBox !== null ) {

  				this.boundingBox = geometry.boundingBox.clone();

  			}

  		} else if ( object.isMesh ) {

  			if ( geometry && geometry.isGeometry ) {

  				this.fromGeometry( geometry );

  			}

  		}

  		return this;

  	},

  	updateFromObject: function ( object ) {

  		var geometry = object.geometry;

  		if ( object.isMesh ) {

  			var direct = geometry.__directGeometry;

  			if ( geometry.elementsNeedUpdate === true ) {

  				direct = undefined;
  				geometry.elementsNeedUpdate = false;

  			}

  			if ( direct === undefined ) {

  				return this.fromGeometry( geometry );

  			}

  			direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
  			direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
  			direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
  			direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
  			direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

  			geometry.verticesNeedUpdate = false;
  			geometry.normalsNeedUpdate = false;
  			geometry.colorsNeedUpdate = false;
  			geometry.uvsNeedUpdate = false;
  			geometry.groupsNeedUpdate = false;

  			geometry = direct;

  		}

  		var attribute;

  		if ( geometry.verticesNeedUpdate === true ) {

  			attribute = this.attributes.position;

  			if ( attribute !== undefined ) {

  				attribute.copyVector3sArray( geometry.vertices );
  				attribute.needsUpdate = true;

  			}

  			geometry.verticesNeedUpdate = false;

  		}

  		if ( geometry.normalsNeedUpdate === true ) {

  			attribute = this.attributes.normal;

  			if ( attribute !== undefined ) {

  				attribute.copyVector3sArray( geometry.normals );
  				attribute.needsUpdate = true;

  			}

  			geometry.normalsNeedUpdate = false;

  		}

  		if ( geometry.colorsNeedUpdate === true ) {

  			attribute = this.attributes.color;

  			if ( attribute !== undefined ) {

  				attribute.copyColorsArray( geometry.colors );
  				attribute.needsUpdate = true;

  			}

  			geometry.colorsNeedUpdate = false;

  		}

  		if ( geometry.uvsNeedUpdate ) {

  			attribute = this.attributes.uv;

  			if ( attribute !== undefined ) {

  				attribute.copyVector2sArray( geometry.uvs );
  				attribute.needsUpdate = true;

  			}

  			geometry.uvsNeedUpdate = false;

  		}

  		if ( geometry.lineDistancesNeedUpdate ) {

  			attribute = this.attributes.lineDistance;

  			if ( attribute !== undefined ) {

  				attribute.copyArray( geometry.lineDistances );
  				attribute.needsUpdate = true;

  			}

  			geometry.lineDistancesNeedUpdate = false;

  		}

  		if ( geometry.groupsNeedUpdate ) {

  			geometry.computeGroups( object.geometry );
  			this.groups = geometry.groups;

  			geometry.groupsNeedUpdate = false;

  		}

  		return this;

  	},

  	fromGeometry: function ( geometry ) {

  		geometry.__directGeometry = new DirectGeometry$1().fromGeometry( geometry );

  		return this.fromDirectGeometry( geometry.__directGeometry );

  	},

  	fromDirectGeometry: function ( geometry ) {
  		var this$1 = this;


  		var positions = new Float32Array( geometry.vertices.length * 3 );
  		this.addAttribute( 'position', new BufferAttribute$1( positions, 3 ).copyVector3sArray( geometry.vertices ) );

  		if ( geometry.normals.length > 0 ) {

  			var normals = new Float32Array( geometry.normals.length * 3 );
  			this.addAttribute( 'normal', new BufferAttribute$1( normals, 3 ).copyVector3sArray( geometry.normals ) );

  		}

  		if ( geometry.colors.length > 0 ) {

  			var colors = new Float32Array( geometry.colors.length * 3 );
  			this.addAttribute( 'color', new BufferAttribute$1( colors, 3 ).copyColorsArray( geometry.colors ) );

  		}

  		if ( geometry.uvs.length > 0 ) {

  			var uvs = new Float32Array( geometry.uvs.length * 2 );
  			this.addAttribute( 'uv', new BufferAttribute$1( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

  		}

  		if ( geometry.uvs2.length > 0 ) {

  			var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
  			this.addAttribute( 'uv2', new BufferAttribute$1( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

  		}

  		if ( geometry.indices.length > 0 ) {

  			var TypeArray = arrayMax$1( geometry.indices ) > 65535 ? Uint32Array : Uint16Array;
  			var indices = new TypeArray( geometry.indices.length * 3 );
  			this.setIndex( new BufferAttribute$1( indices, 1 ).copyIndicesArray( geometry.indices ) );

  		}

  		// groups

  		this.groups = geometry.groups;

  		// morphs

  		for ( var name in geometry.morphTargets ) {

  			var array = [];
  			var morphTargets = geometry.morphTargets[ name ];

  			for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

  				var morphTarget = morphTargets[ i ];

  				var attribute = new Float32BufferAttribute$1( morphTarget.length * 3, 3 );

  				array.push( attribute.copyVector3sArray( morphTarget ) );

  			}

  			this$1.morphAttributes[ name ] = array;

  		}

  		// skinning

  		if ( geometry.skinIndices.length > 0 ) {

  			var skinIndices = new Float32BufferAttribute$1( geometry.skinIndices.length * 4, 4 );
  			this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

  		}

  		if ( geometry.skinWeights.length > 0 ) {

  			var skinWeights = new Float32BufferAttribute$1( geometry.skinWeights.length * 4, 4 );
  			this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

  		}

  		//

  		if ( geometry.boundingSphere !== null ) {

  			this.boundingSphere = geometry.boundingSphere.clone();

  		}

  		if ( geometry.boundingBox !== null ) {

  			this.boundingBox = geometry.boundingBox.clone();

  		}

  		return this;

  	},

  	computeBoundingBox: function () {

  		if ( this.boundingBox === null ) {

  			this.boundingBox = new Box3$1();

  		}

  		var position = this.attributes.position;

  		if ( position !== undefined ) {

  			this.boundingBox.setFromBufferAttribute( position );

  		} else {

  			this.boundingBox.makeEmpty();

  		}

  		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

  			console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

  		}

  	},

  	computeBoundingSphere: function () {

  		var box = new Box3$1();
  		var vector = new Vector3$2();

  		return function computeBoundingSphere() {

  			if ( this.boundingSphere === null ) {

  				this.boundingSphere = new Sphere$1();

  			}

  			var position = this.attributes.position;

  			if ( position ) {

  				var center = this.boundingSphere.center;

  				box.setFromBufferAttribute( position );
  				box.getCenter( center );

  				// hoping to find a boundingSphere with a radius smaller than the
  				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

  				var maxRadiusSq = 0;

  				for ( var i = 0, il = position.count; i < il; i ++ ) {

  					vector.x = position.getX( i );
  					vector.y = position.getY( i );
  					vector.z = position.getZ( i );
  					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

  				}

  				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

  				if ( isNaN( this.boundingSphere.radius ) ) {

  					console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

  				}

  			}

  		};

  	}(),

  	computeFaceNormals: function () {

  		// backwards compatibility

  	},

  	computeVertexNormals: function () {

  		var index = this.index;
  		var attributes = this.attributes;
  		var groups = this.groups;

  		if ( attributes.position ) {

  			var positions = attributes.position.array;

  			if ( attributes.normal === undefined ) {

  				this.addAttribute( 'normal', new BufferAttribute$1( new Float32Array( positions.length ), 3 ) );

  			} else {

  				// reset existing normals to zero

  				var array = attributes.normal.array;

  				for ( var i = 0, il = array.length; i < il; i ++ ) {

  					array[ i ] = 0;

  				}

  			}

  			var normals = attributes.normal.array;

  			var vA, vB, vC;
  			var pA = new Vector3$2(), pB = new Vector3$2(), pC = new Vector3$2();
  			var cb = new Vector3$2(), ab = new Vector3$2();

  			// indexed elements

  			if ( index ) {

  				var indices = index.array;

  				if ( groups.length === 0 ) {

  					this.addGroup( 0, indices.length );

  				}

  				for ( var j = 0, jl = groups.length; j < jl; ++ j ) {

  					var group = groups[ j ];

  					var start = group.start;
  					var count = group.count;

  					for ( var i = start, il = start + count; i < il; i += 3 ) {

  						vA = indices[ i + 0 ] * 3;
  						vB = indices[ i + 1 ] * 3;
  						vC = indices[ i + 2 ] * 3;

  						pA.fromArray( positions, vA );
  						pB.fromArray( positions, vB );
  						pC.fromArray( positions, vC );

  						cb.subVectors( pC, pB );
  						ab.subVectors( pA, pB );
  						cb.cross( ab );

  						normals[ vA ] += cb.x;
  						normals[ vA + 1 ] += cb.y;
  						normals[ vA + 2 ] += cb.z;

  						normals[ vB ] += cb.x;
  						normals[ vB + 1 ] += cb.y;
  						normals[ vB + 2 ] += cb.z;

  						normals[ vC ] += cb.x;
  						normals[ vC + 1 ] += cb.y;
  						normals[ vC + 2 ] += cb.z;

  					}

  				}

  			} else {

  				// non-indexed elements (unconnected triangle soup)

  				for ( var i = 0, il = positions.length; i < il; i += 9 ) {

  					pA.fromArray( positions, i );
  					pB.fromArray( positions, i + 3 );
  					pC.fromArray( positions, i + 6 );

  					cb.subVectors( pC, pB );
  					ab.subVectors( pA, pB );
  					cb.cross( ab );

  					normals[ i ] = cb.x;
  					normals[ i + 1 ] = cb.y;
  					normals[ i + 2 ] = cb.z;

  					normals[ i + 3 ] = cb.x;
  					normals[ i + 4 ] = cb.y;
  					normals[ i + 5 ] = cb.z;

  					normals[ i + 6 ] = cb.x;
  					normals[ i + 7 ] = cb.y;
  					normals[ i + 8 ] = cb.z;

  				}

  			}

  			this.normalizeNormals();

  			attributes.normal.needsUpdate = true;

  		}

  	},

  	merge: function ( geometry, offset ) {

  		if ( ! ( geometry && geometry.isBufferGeometry ) ) {

  			console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
  			return;

  		}

  		if ( offset === undefined ) { offset = 0; }

  		var attributes = this.attributes;

  		for ( var key in attributes ) {

  			if ( geometry.attributes[ key ] === undefined ) { continue; }

  			var attribute1 = attributes[ key ];
  			var attributeArray1 = attribute1.array;

  			var attribute2 = geometry.attributes[ key ];
  			var attributeArray2 = attribute2.array;

  			var attributeSize = attribute2.itemSize;

  			for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

  				attributeArray1[ j ] = attributeArray2[ i ];

  			}

  		}

  		return this;

  	},

  	normalizeNormals: function () {

  		var vector = new Vector3$2();

  		return function normalizeNormals() {

  			var normals = this.attributes.normal;

  			for ( var i = 0, il = normals.count; i < il; i ++ ) {

  				vector.x = normals.getX( i );
  				vector.y = normals.getY( i );
  				vector.z = normals.getZ( i );

  				vector.normalize();

  				normals.setXYZ( i, vector.x, vector.y, vector.z );

  			}

  		};

  	}(),

  	toNonIndexed: function () {

  		if ( this.index === null ) {

  			console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
  			return this;

  		}

  		var geometry2 = new BufferGeometry$1();

  		var indices = this.index.array;
  		var attributes = this.attributes;

  		for ( var name in attributes ) {

  			var attribute = attributes[ name ];

  			var array = attribute.array;
  			var itemSize = attribute.itemSize;

  			var array2 = new array.constructor( indices.length * itemSize );

  			var index = 0, index2 = 0;

  			for ( var i = 0, l = indices.length; i < l; i ++ ) {

  				index = indices[ i ] * itemSize;

  				for ( var j = 0; j < itemSize; j ++ ) {

  					array2[ index2 ++ ] = array[ index ++ ];

  				}

  			}

  			geometry2.addAttribute( name, new BufferAttribute$1( array2, itemSize ) );

  		}

  		return geometry2;

  	},

  	toJSON: function () {

  		var data = {
  			metadata: {
  				version: 4.5,
  				type: 'BufferGeometry',
  				generator: 'BufferGeometry.toJSON'
  			}
  		};

  		// standard BufferGeometry serialization

  		data.uuid = this.uuid;
  		data.type = this.type;
  		if ( this.name !== '' ) { data.name = this.name; }

  		if ( this.parameters !== undefined ) {

  			var parameters = this.parameters;

  			for ( var key in parameters ) {

  				if ( parameters[ key ] !== undefined ) { data[ key ] = parameters[ key ]; }

  			}

  			return data;

  		}

  		data.data = { attributes: {} };

  		var index = this.index;

  		if ( index !== null ) {

  			var array = Array.prototype.slice.call( index.array );

  			data.data.index = {
  				type: index.array.constructor.name,
  				array: array
  			};

  		}

  		var attributes = this.attributes;

  		for ( var key in attributes ) {

  			var attribute = attributes[ key ];

  			var array = Array.prototype.slice.call( attribute.array );

  			data.data.attributes[ key ] = {
  				itemSize: attribute.itemSize,
  				type: attribute.array.constructor.name,
  				array: array,
  				normalized: attribute.normalized
  			};

  		}

  		var groups = this.groups;

  		if ( groups.length > 0 ) {

  			data.data.groups = JSON.parse( JSON.stringify( groups ) );

  		}

  		var boundingSphere = this.boundingSphere;

  		if ( boundingSphere !== null ) {

  			data.data.boundingSphere = {
  				center: boundingSphere.center.toArray(),
  				radius: boundingSphere.radius
  			};

  		}

  		return data;

  	},

  	clone: function () {

  		/*
  		 // Handle primitives

  		 var parameters = this.parameters;

  		 if ( parameters !== undefined ) {

  		 var values = [];

  		 for ( var key in parameters ) {

  		 values.push( parameters[ key ] );

  		 }

  		 var geometry = Object.create( this.constructor.prototype );
  		 this.constructor.apply( geometry, values );
  		 return geometry;

  		 }

  		 return new this.constructor().copy( this );
  		 */

  		return new BufferGeometry$1().copy( this );

  	},

  	copy: function ( source ) {
  		var this$1 = this;


  		var name, i, l;

  		// reset

  		this.index = null;
  		this.attributes = {};
  		this.morphAttributes = {};
  		this.groups = [];
  		this.boundingBox = null;
  		this.boundingSphere = null;

  		// name

  		this.name = source.name;

  		// index

  		var index = source.index;

  		if ( index !== null ) {

  			this.setIndex( index.clone() );

  		}

  		// attributes

  		var attributes = source.attributes;

  		for ( name in attributes ) {

  			var attribute = attributes[ name ];
  			this$1.addAttribute( name, attribute.clone() );

  		}

  		// morph attributes

  		var morphAttributes = source.morphAttributes;

  		for ( name in morphAttributes ) {

  			var array = [];
  			var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

  			for ( i = 0, l = morphAttribute.length; i < l; i ++ ) {

  				array.push( morphAttribute[ i ].clone() );

  			}

  			this$1.morphAttributes[ name ] = array;

  		}

  		// groups

  		var groups = source.groups;

  		for ( i = 0, l = groups.length; i < l; i ++ ) {

  			var group = groups[ i ];
  			this$1.addGroup( group.start, group.count, group.materialIndex );

  		}

  		// bounding box

  		var boundingBox = source.boundingBox;

  		if ( boundingBox !== null ) {

  			this.boundingBox = boundingBox.clone();

  		}

  		// bounding sphere

  		var boundingSphere = source.boundingSphere;

  		if ( boundingSphere !== null ) {

  			this.boundingSphere = boundingSphere.clone();

  		}

  		// draw range

  		this.drawRange.start = source.drawRange.start;
  		this.drawRange.count = source.drawRange.count;

  		return this;

  	},

  	dispose: function () {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */

  // BoxGeometry

  function BoxGeometry$1( width, height, depth, widthSegments, heightSegments, depthSegments ) {

  	Geometry$1.call( this );

  	this.type = 'BoxGeometry';

  	this.parameters = {
  		width: width,
  		height: height,
  		depth: depth,
  		widthSegments: widthSegments,
  		heightSegments: heightSegments,
  		depthSegments: depthSegments
  	};

  	this.fromBufferGeometry( new BoxBufferGeometry$1( width, height, depth, widthSegments, heightSegments, depthSegments ) );
  	this.mergeVertices();

  }

  BoxGeometry$1.prototype = Object.create( Geometry$1.prototype );
  BoxGeometry$1.prototype.constructor = BoxGeometry$1;

  // BoxBufferGeometry

  function BoxBufferGeometry$1( width, height, depth, widthSegments, heightSegments, depthSegments ) {

  	BufferGeometry$1.call( this );

  	this.type = 'BoxBufferGeometry';

  	this.parameters = {
  		width: width,
  		height: height,
  		depth: depth,
  		widthSegments: widthSegments,
  		heightSegments: heightSegments,
  		depthSegments: depthSegments
  	};

  	var scope = this;

  	// segments

  	widthSegments = Math.floor( widthSegments ) || 1;
  	heightSegments = Math.floor( heightSegments ) || 1;
  	depthSegments = Math.floor( depthSegments ) || 1;

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// helper variables

  	var numberOfVertices = 0;
  	var groupStart = 0;

  	// build each side of the box geometry

  	buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
  	buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
  	buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
  	buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
  	buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
  	buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute$1( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute$1( uvs, 2 ) );

  	function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

  		var segmentWidth = width / gridX;
  		var segmentHeight = height / gridY;

  		var widthHalf = width / 2;
  		var heightHalf = height / 2;
  		var depthHalf = depth / 2;

  		var gridX1 = gridX + 1;
  		var gridY1 = gridY + 1;

  		var vertexCounter = 0;
  		var groupCount = 0;

  		var ix, iy;

  		var vector = new Vector3$2();

  		// generate vertices, normals and uvs

  		for ( iy = 0; iy < gridY1; iy ++ ) {

  			var y = iy * segmentHeight - heightHalf;

  			for ( ix = 0; ix < gridX1; ix ++ ) {

  				var x = ix * segmentWidth - widthHalf;

  				// set values to correct vector component

  				vector[ u ] = x * udir;
  				vector[ v ] = y * vdir;
  				vector[ w ] = depthHalf;

  				// now apply vector to vertex buffer

  				vertices.push( vector.x, vector.y, vector.z );

  				// set values to correct vector component

  				vector[ u ] = 0;
  				vector[ v ] = 0;
  				vector[ w ] = depth > 0 ? 1 : - 1;

  				// now apply vector to normal buffer

  				normals.push( vector.x, vector.y, vector.z );

  				// uvs

  				uvs.push( ix / gridX );
  				uvs.push( 1 - ( iy / gridY ) );

  				// counters

  				vertexCounter += 1;

  			}

  		}

  		// indices

  		// 1. you need three indices to draw a single face
  		// 2. a single segment consists of two faces
  		// 3. so we need to generate six (2*3) indices per segment

  		for ( iy = 0; iy < gridY; iy ++ ) {

  			for ( ix = 0; ix < gridX; ix ++ ) {

  				var a = numberOfVertices + ix + gridX1 * iy;
  				var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
  				var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
  				var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

  				// faces

  				indices.push( a, b, d );
  				indices.push( b, c, d );

  				// increase counter

  				groupCount += 6;

  			}

  		}

  		// add a group to the geometry. this will ensure multi material support

  		scope.addGroup( groupStart, groupCount, materialIndex );

  		// calculate new start value for groups

  		groupStart += groupCount;

  		// update total number of vertices

  		numberOfVertices += vertexCounter;

  	}

  }

  BoxBufferGeometry$1.prototype = Object.create( BufferGeometry$1.prototype );
  BoxBufferGeometry$1.prototype.constructor = BoxBufferGeometry$1;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */

  // PlaneGeometry

  function PlaneGeometry$1( width, height, widthSegments, heightSegments ) {

  	Geometry$1.call( this );

  	this.type = 'PlaneGeometry';

  	this.parameters = {
  		width: width,
  		height: height,
  		widthSegments: widthSegments,
  		heightSegments: heightSegments
  	};

  	this.fromBufferGeometry( new PlaneBufferGeometry$1( width, height, widthSegments, heightSegments ) );
  	this.mergeVertices();

  }

  PlaneGeometry$1.prototype = Object.create( Geometry$1.prototype );
  PlaneGeometry$1.prototype.constructor = PlaneGeometry$1;

  // PlaneBufferGeometry

  function PlaneBufferGeometry$1( width, height, widthSegments, heightSegments ) {

  	BufferGeometry$1.call( this );

  	this.type = 'PlaneBufferGeometry';

  	this.parameters = {
  		width: width,
  		height: height,
  		widthSegments: widthSegments,
  		heightSegments: heightSegments
  	};

  	var width_half = width / 2;
  	var height_half = height / 2;

  	var gridX = Math.floor( widthSegments ) || 1;
  	var gridY = Math.floor( heightSegments ) || 1;

  	var gridX1 = gridX + 1;
  	var gridY1 = gridY + 1;

  	var segment_width = width / gridX;
  	var segment_height = height / gridY;

  	var ix, iy;

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// generate vertices, normals and uvs

  	for ( iy = 0; iy < gridY1; iy ++ ) {

  		var y = iy * segment_height - height_half;

  		for ( ix = 0; ix < gridX1; ix ++ ) {

  			var x = ix * segment_width - width_half;

  			vertices.push( x, - y, 0 );

  			normals.push( 0, 0, 1 );

  			uvs.push( ix / gridX );
  			uvs.push( 1 - ( iy / gridY ) );

  		}

  	}

  	// indices

  	for ( iy = 0; iy < gridY; iy ++ ) {

  		for ( ix = 0; ix < gridX; ix ++ ) {

  			var a = ix + gridX1 * iy;
  			var b = ix + gridX1 * ( iy + 1 );
  			var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
  			var d = ( ix + 1 ) + gridX1 * iy;

  			// faces

  			indices.push( a, b, d );
  			indices.push( b, c, d );

  		}

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute$1( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute$1( uvs, 2 ) );

  }

  PlaneBufferGeometry$1.prototype = Object.create( BufferGeometry$1.prototype );
  PlaneBufferGeometry$1.prototype.constructor = PlaneBufferGeometry$1;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  specularMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
   *  combine: THREE.Multiply,
   *  reflectivity: <float>,
   *  refractionRatio: <float>,
   *
   *  depthTest: <bool>,
   *  depthWrite: <bool>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>
   * }
   */

  function MeshBasicMaterial$1( parameters ) {

  	Material$1.call( this );

  	this.type = 'MeshBasicMaterial';

  	this.color = new Color$1( 0xffffff ); // emissive

  	this.map = null;

  	this.lightMap = null;
  	this.lightMapIntensity = 1.0;

  	this.aoMap = null;
  	this.aoMapIntensity = 1.0;

  	this.specularMap = null;

  	this.alphaMap = null;

  	this.envMap = null;
  	this.combine = MultiplyOperation$1;
  	this.reflectivity = 1;
  	this.refractionRatio = 0.98;

  	this.wireframe = false;
  	this.wireframeLinewidth = 1;
  	this.wireframeLinecap = 'round';
  	this.wireframeLinejoin = 'round';

  	this.skinning = false;
  	this.morphTargets = false;

  	this.lights = false;

  	this.setValues( parameters );

  }

  MeshBasicMaterial$1.prototype = Object.create( Material$1.prototype );
  MeshBasicMaterial$1.prototype.constructor = MeshBasicMaterial$1;

  MeshBasicMaterial$1.prototype.isMeshBasicMaterial = true;

  MeshBasicMaterial$1.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.color.copy( source.color );

  	this.map = source.map;

  	this.lightMap = source.lightMap;
  	this.lightMapIntensity = source.lightMapIntensity;

  	this.aoMap = source.aoMap;
  	this.aoMapIntensity = source.aoMapIntensity;

  	this.specularMap = source.specularMap;

  	this.alphaMap = source.alphaMap;

  	this.envMap = source.envMap;
  	this.combine = source.combine;
  	this.reflectivity = source.reflectivity;
  	this.refractionRatio = source.refractionRatio;

  	this.wireframe = source.wireframe;
  	this.wireframeLinewidth = source.wireframeLinewidth;
  	this.wireframeLinecap = source.wireframeLinecap;
  	this.wireframeLinejoin = source.wireframeLinejoin;

  	this.skinning = source.skinning;
  	this.morphTargets = source.morphTargets;

  	return this;

  };

  /**
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  defines: { "label" : "value" },
   *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
   *
   *  fragmentShader: <string>,
   *  vertexShader: <string>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  lights: <bool>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */

  function ShaderMaterial$1( parameters ) {

  	Material$1.call( this );

  	this.type = 'ShaderMaterial';

  	this.defines = {};
  	this.uniforms = {};

  	this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
  	this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

  	this.linewidth = 1;

  	this.wireframe = false;
  	this.wireframeLinewidth = 1;

  	this.fog = false; // set to use scene fog
  	this.lights = false; // set to use scene lights
  	this.clipping = false; // set to use user-defined clipping planes

  	this.skinning = false; // set to use skinning attribute streams
  	this.morphTargets = false; // set to use morph targets
  	this.morphNormals = false; // set to use morph normals

  	this.extensions = {
  		derivatives: false, // set to use derivatives
  		fragDepth: false, // set to use fragment depth values
  		drawBuffers: false, // set to use draw buffers
  		shaderTextureLOD: false // set to use shader texture LOD
  	};

  	// When rendered geometry doesn't include these attributes but the material does,
  	// use these default values in WebGL. This avoids errors when buffer data is missing.
  	this.defaultAttributeValues = {
  		'color': [ 1, 1, 1 ],
  		'uv': [ 0, 0 ],
  		'uv2': [ 0, 0 ]
  	};

  	this.index0AttributeName = undefined;

  	if ( parameters !== undefined ) {

  		if ( parameters.attributes !== undefined ) {

  			console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

  		}

  		this.setValues( parameters );

  	}

  }

  ShaderMaterial$1.prototype = Object.create( Material$1.prototype );
  ShaderMaterial$1.prototype.constructor = ShaderMaterial$1;

  ShaderMaterial$1.prototype.isShaderMaterial = true;

  ShaderMaterial$1.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.fragmentShader = source.fragmentShader;
  	this.vertexShader = source.vertexShader;

  	this.uniforms = UniformsUtils$1.clone( source.uniforms );

  	this.defines = source.defines;

  	this.wireframe = source.wireframe;
  	this.wireframeLinewidth = source.wireframeLinewidth;

  	this.lights = source.lights;
  	this.clipping = source.clipping;

  	this.skinning = source.skinning;

  	this.morphTargets = source.morphTargets;
  	this.morphNormals = source.morphNormals;

  	this.extensions = source.extensions;

  	return this;

  };

  ShaderMaterial$1.prototype.toJSON = function ( meta ) {

  	var data = Material$1.prototype.toJSON.call( this, meta );

  	data.uniforms = this.uniforms;
  	data.vertexShader = this.vertexShader;
  	data.fragmentShader = this.fragmentShader;

  	return data;

  };

  /**
   * @author bhouston / http://clara.io
   */

  function Ray$1( origin, direction ) {

  	this.origin = ( origin !== undefined ) ? origin : new Vector3$2();
  	this.direction = ( direction !== undefined ) ? direction : new Vector3$2();

  }

  Object.assign( Ray$1.prototype, {

  	set: function ( origin, direction ) {

  		this.origin.copy( origin );
  		this.direction.copy( direction );

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( ray ) {

  		this.origin.copy( ray.origin );
  		this.direction.copy( ray.direction );

  		return this;

  	},

  	at: function ( t, optionalTarget ) {

  		var result = optionalTarget || new Vector3$2();

  		return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

  	},

  	lookAt: function ( v ) {

  		this.direction.copy( v ).sub( this.origin ).normalize();

  		return this;

  	},

  	recast: function () {

  		var v1 = new Vector3$2();

  		return function recast( t ) {

  			this.origin.copy( this.at( t, v1 ) );

  			return this;

  		};

  	}(),

  	closestPointToPoint: function ( point, optionalTarget ) {

  		var result = optionalTarget || new Vector3$2();
  		result.subVectors( point, this.origin );
  		var directionDistance = result.dot( this.direction );

  		if ( directionDistance < 0 ) {

  			return result.copy( this.origin );

  		}

  		return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

  	},

  	distanceToPoint: function ( point ) {

  		return Math.sqrt( this.distanceSqToPoint( point ) );

  	},

  	distanceSqToPoint: function () {

  		var v1 = new Vector3$2();

  		return function distanceSqToPoint( point ) {

  			var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

  			// point behind the ray

  			if ( directionDistance < 0 ) {

  				return this.origin.distanceToSquared( point );

  			}

  			v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

  			return v1.distanceToSquared( point );

  		};

  	}(),

  	distanceSqToSegment: function () {

  		var segCenter = new Vector3$2();
  		var segDir = new Vector3$2();
  		var diff = new Vector3$2();

  		return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

  			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
  			// It returns the min distance between the ray and the segment
  			// defined by v0 and v1
  			// It can also set two optional targets :
  			// - The closest point on the ray
  			// - The closest point on the segment

  			segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
  			segDir.copy( v1 ).sub( v0 ).normalize();
  			diff.copy( this.origin ).sub( segCenter );

  			var segExtent = v0.distanceTo( v1 ) * 0.5;
  			var a01 = - this.direction.dot( segDir );
  			var b0 = diff.dot( this.direction );
  			var b1 = - diff.dot( segDir );
  			var c = diff.lengthSq();
  			var det = Math.abs( 1 - a01 * a01 );
  			var s0, s1, sqrDist, extDet;

  			if ( det > 0 ) {

  				// The ray and segment are not parallel.

  				s0 = a01 * b1 - b0;
  				s1 = a01 * b0 - b1;
  				extDet = segExtent * det;

  				if ( s0 >= 0 ) {

  					if ( s1 >= - extDet ) {

  						if ( s1 <= extDet ) {

  							// region 0
  							// Minimum at interior points of ray and segment.

  							var invDet = 1 / det;
  							s0 *= invDet;
  							s1 *= invDet;
  							sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

  						} else {

  							// region 1

  							s1 = segExtent;
  							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
  							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  						}

  					} else {

  						// region 5

  						s1 = - segExtent;
  						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
  						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  					}

  				} else {

  					if ( s1 <= - extDet ) {

  						// region 4

  						s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
  						s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
  						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  					} else if ( s1 <= extDet ) {

  						// region 3

  						s0 = 0;
  						s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
  						sqrDist = s1 * ( s1 + 2 * b1 ) + c;

  					} else {

  						// region 2

  						s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
  						s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
  						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  					}

  				}

  			} else {

  				// Ray and segment are parallel.

  				s1 = ( a01 > 0 ) ? - segExtent : segExtent;
  				s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
  				sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  			}

  			if ( optionalPointOnRay ) {

  				optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

  			}

  			if ( optionalPointOnSegment ) {

  				optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

  			}

  			return sqrDist;

  		};

  	}(),

  	intersectSphere: function () {

  		var v1 = new Vector3$2();

  		return function intersectSphere( sphere, optionalTarget ) {

  			v1.subVectors( sphere.center, this.origin );
  			var tca = v1.dot( this.direction );
  			var d2 = v1.dot( v1 ) - tca * tca;
  			var radius2 = sphere.radius * sphere.radius;

  			if ( d2 > radius2 ) { return null; }

  			var thc = Math.sqrt( radius2 - d2 );

  			// t0 = first intersect point - entrance on front of sphere
  			var t0 = tca - thc;

  			// t1 = second intersect point - exit point on back of sphere
  			var t1 = tca + thc;

  			// test to see if both t0 and t1 are behind the ray - if so, return null
  			if ( t0 < 0 && t1 < 0 ) { return null; }

  			// test to see if t0 is behind the ray:
  			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
  			// in order to always return an intersect point that is in front of the ray.
  			if ( t0 < 0 ) { return this.at( t1, optionalTarget ); }

  			// else t0 is in front of the ray, so return the first collision point scaled by t0
  			return this.at( t0, optionalTarget );

  		};

  	}(),

  	intersectsSphere: function ( sphere ) {

  		return this.distanceToPoint( sphere.center ) <= sphere.radius;

  	},

  	distanceToPlane: function ( plane ) {

  		var denominator = plane.normal.dot( this.direction );

  		if ( denominator === 0 ) {

  			// line is coplanar, return origin
  			if ( plane.distanceToPoint( this.origin ) === 0 ) {

  				return 0;

  			}

  			// Null is preferable to undefined since undefined means.... it is undefined

  			return null;

  		}

  		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

  		// Return if the ray never intersects the plane

  		return t >= 0 ? t : null;

  	},

  	intersectPlane: function ( plane, optionalTarget ) {

  		var t = this.distanceToPlane( plane );

  		if ( t === null ) {

  			return null;

  		}

  		return this.at( t, optionalTarget );

  	},

  	intersectsPlane: function ( plane ) {

  		// check if the ray lies on the plane first

  		var distToPoint = plane.distanceToPoint( this.origin );

  		if ( distToPoint === 0 ) {

  			return true;

  		}

  		var denominator = plane.normal.dot( this.direction );

  		if ( denominator * distToPoint < 0 ) {

  			return true;

  		}

  		// ray origin is behind the plane (and is pointing behind it)

  		return false;

  	},

  	intersectBox: function ( box, optionalTarget ) {

  		var tmin, tmax, tymin, tymax, tzmin, tzmax;

  		var invdirx = 1 / this.direction.x,
  			invdiry = 1 / this.direction.y,
  			invdirz = 1 / this.direction.z;

  		var origin = this.origin;

  		if ( invdirx >= 0 ) {

  			tmin = ( box.min.x - origin.x ) * invdirx;
  			tmax = ( box.max.x - origin.x ) * invdirx;

  		} else {

  			tmin = ( box.max.x - origin.x ) * invdirx;
  			tmax = ( box.min.x - origin.x ) * invdirx;

  		}

  		if ( invdiry >= 0 ) {

  			tymin = ( box.min.y - origin.y ) * invdiry;
  			tymax = ( box.max.y - origin.y ) * invdiry;

  		} else {

  			tymin = ( box.max.y - origin.y ) * invdiry;
  			tymax = ( box.min.y - origin.y ) * invdiry;

  		}

  		if ( ( tmin > tymax ) || ( tymin > tmax ) ) { return null; }

  		// These lines also handle the case where tmin or tmax is NaN
  		// (result of 0 * Infinity). x !== x returns true if x is NaN

  		if ( tymin > tmin || tmin !== tmin ) { tmin = tymin; }

  		if ( tymax < tmax || tmax !== tmax ) { tmax = tymax; }

  		if ( invdirz >= 0 ) {

  			tzmin = ( box.min.z - origin.z ) * invdirz;
  			tzmax = ( box.max.z - origin.z ) * invdirz;

  		} else {

  			tzmin = ( box.max.z - origin.z ) * invdirz;
  			tzmax = ( box.min.z - origin.z ) * invdirz;

  		}

  		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) { return null; }

  		if ( tzmin > tmin || tmin !== tmin ) { tmin = tzmin; }

  		if ( tzmax < tmax || tmax !== tmax ) { tmax = tzmax; }

  		//return point closest to the ray (positive side)

  		if ( tmax < 0 ) { return null; }

  		return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

  	},

  	intersectsBox: ( function () {

  		var v = new Vector3$2();

  		return function intersectsBox( box ) {

  			return this.intersectBox( box, v ) !== null;

  		};

  	} )(),

  	intersectTriangle: function () {

  		// Compute the offset origin, edges, and normal.
  		var diff = new Vector3$2();
  		var edge1 = new Vector3$2();
  		var edge2 = new Vector3$2();
  		var normal = new Vector3$2();

  		return function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {

  			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

  			edge1.subVectors( b, a );
  			edge2.subVectors( c, a );
  			normal.crossVectors( edge1, edge2 );

  			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
  			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
  			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
  			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
  			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
  			var DdN = this.direction.dot( normal );
  			var sign;

  			if ( DdN > 0 ) {

  				if ( backfaceCulling ) { return null; }
  				sign = 1;

  			} else if ( DdN < 0 ) {

  				sign = - 1;
  				DdN = - DdN;

  			} else {

  				return null;

  			}

  			diff.subVectors( this.origin, a );
  			var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

  			// b1 < 0, no intersection
  			if ( DdQxE2 < 0 ) {

  				return null;

  			}

  			var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

  			// b2 < 0, no intersection
  			if ( DdE1xQ < 0 ) {

  				return null;

  			}

  			// b1+b2 > 1, no intersection
  			if ( DdQxE2 + DdE1xQ > DdN ) {

  				return null;

  			}

  			// Line intersects triangle, check if ray does.
  			var QdN = - sign * diff.dot( normal );

  			// t < 0, no intersection
  			if ( QdN < 0 ) {

  				return null;

  			}

  			// Ray intersects triangle.
  			return this.at( QdN / DdN, optionalTarget );

  		};

  	}(),

  	applyMatrix4: function ( matrix4 ) {

  		this.origin.applyMatrix4( matrix4 );
  		this.direction.transformDirection( matrix4 );

  		return this;

  	},

  	equals: function ( ray ) {

  		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

  	}

  } );

  /**
   * @author bhouston / http://clara.io
   */

  function Line3$1( start, end ) {

  	this.start = ( start !== undefined ) ? start : new Vector3$2();
  	this.end = ( end !== undefined ) ? end : new Vector3$2();

  }

  Object.assign( Line3$1.prototype, {

  	set: function ( start, end ) {

  		this.start.copy( start );
  		this.end.copy( end );

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( line ) {

  		this.start.copy( line.start );
  		this.end.copy( line.end );

  		return this;

  	},

  	getCenter: function ( optionalTarget ) {

  		var result = optionalTarget || new Vector3$2();
  		return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

  	},

  	delta: function ( optionalTarget ) {

  		var result = optionalTarget || new Vector3$2();
  		return result.subVectors( this.end, this.start );

  	},

  	distanceSq: function () {

  		return this.start.distanceToSquared( this.end );

  	},

  	distance: function () {

  		return this.start.distanceTo( this.end );

  	},

  	at: function ( t, optionalTarget ) {

  		var result = optionalTarget || new Vector3$2();

  		return this.delta( result ).multiplyScalar( t ).add( this.start );

  	},

  	closestPointToPointParameter: function () {

  		var startP = new Vector3$2();
  		var startEnd = new Vector3$2();

  		return function closestPointToPointParameter( point, clampToLine ) {

  			startP.subVectors( point, this.start );
  			startEnd.subVectors( this.end, this.start );

  			var startEnd2 = startEnd.dot( startEnd );
  			var startEnd_startP = startEnd.dot( startP );

  			var t = startEnd_startP / startEnd2;

  			if ( clampToLine ) {

  				t = _Math$1.clamp( t, 0, 1 );

  			}

  			return t;

  		};

  	}(),

  	closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

  		var t = this.closestPointToPointParameter( point, clampToLine );

  		var result = optionalTarget || new Vector3$2();

  		return this.delta( result ).multiplyScalar( t ).add( this.start );

  	},

  	applyMatrix4: function ( matrix ) {

  		this.start.applyMatrix4( matrix );
  		this.end.applyMatrix4( matrix );

  		return this;

  	},

  	equals: function ( line ) {

  		return line.start.equals( this.start ) && line.end.equals( this.end );

  	}

  } );

  /**
   * @author bhouston / http://clara.io
   * @author mrdoob / http://mrdoob.com/
   */

  function Triangle$1( a, b, c ) {

  	this.a = ( a !== undefined ) ? a : new Vector3$2();
  	this.b = ( b !== undefined ) ? b : new Vector3$2();
  	this.c = ( c !== undefined ) ? c : new Vector3$2();

  }

  Object.assign( Triangle$1, {

  	normal: function () {

  		var v0 = new Vector3$2();

  		return function normal( a, b, c, optionalTarget ) {

  			var result = optionalTarget || new Vector3$2();

  			result.subVectors( c, b );
  			v0.subVectors( a, b );
  			result.cross( v0 );

  			var resultLengthSq = result.lengthSq();
  			if ( resultLengthSq > 0 ) {

  				return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

  			}

  			return result.set( 0, 0, 0 );

  		};

  	}(),

  	// static/instance method to calculate barycentric coordinates
  	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  	barycoordFromPoint: function () {

  		var v0 = new Vector3$2();
  		var v1 = new Vector3$2();
  		var v2 = new Vector3$2();

  		return function barycoordFromPoint( point, a, b, c, optionalTarget ) {

  			v0.subVectors( c, a );
  			v1.subVectors( b, a );
  			v2.subVectors( point, a );

  			var dot00 = v0.dot( v0 );
  			var dot01 = v0.dot( v1 );
  			var dot02 = v0.dot( v2 );
  			var dot11 = v1.dot( v1 );
  			var dot12 = v1.dot( v2 );

  			var denom = ( dot00 * dot11 - dot01 * dot01 );

  			var result = optionalTarget || new Vector3$2();

  			// collinear or singular triangle
  			if ( denom === 0 ) {

  				// arbitrary location outside of triangle?
  				// not sure if this is the best idea, maybe should be returning undefined
  				return result.set( - 2, - 1, - 1 );

  			}

  			var invDenom = 1 / denom;
  			var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
  			var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

  			// barycentric coordinates must always sum to 1
  			return result.set( 1 - u - v, v, u );

  		};

  	}(),

  	containsPoint: function () {

  		var v1 = new Vector3$2();

  		return function containsPoint( point, a, b, c ) {

  			var result = Triangle$1.barycoordFromPoint( point, a, b, c, v1 );

  			return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

  		};

  	}()

  } );

  Object.assign( Triangle$1.prototype, {

  	set: function ( a, b, c ) {

  		this.a.copy( a );
  		this.b.copy( b );
  		this.c.copy( c );

  		return this;

  	},

  	setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

  		this.a.copy( points[ i0 ] );
  		this.b.copy( points[ i1 ] );
  		this.c.copy( points[ i2 ] );

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( triangle ) {

  		this.a.copy( triangle.a );
  		this.b.copy( triangle.b );
  		this.c.copy( triangle.c );

  		return this;

  	},

  	area: function () {

  		var v0 = new Vector3$2();
  		var v1 = new Vector3$2();

  		return function area() {

  			v0.subVectors( this.c, this.b );
  			v1.subVectors( this.a, this.b );

  			return v0.cross( v1 ).length() * 0.5;

  		};

  	}(),

  	midpoint: function ( optionalTarget ) {

  		var result = optionalTarget || new Vector3$2();
  		return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

  	},

  	normal: function ( optionalTarget ) {

  		return Triangle$1.normal( this.a, this.b, this.c, optionalTarget );

  	},

  	plane: function ( optionalTarget ) {

  		var result = optionalTarget || new Plane$1();

  		return result.setFromCoplanarPoints( this.a, this.b, this.c );

  	},

  	barycoordFromPoint: function ( point, optionalTarget ) {

  		return Triangle$1.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

  	},

  	containsPoint: function ( point ) {

  		return Triangle$1.containsPoint( point, this.a, this.b, this.c );

  	},

  	closestPointToPoint: function () {

  		var plane = new Plane$1();
  		var edgeList = [ new Line3$1(), new Line3$1(), new Line3$1() ];
  		var projectedPoint = new Vector3$2();
  		var closestPoint = new Vector3$2();

  		return function closestPointToPoint( point, optionalTarget ) {

  			var result = optionalTarget || new Vector3$2();
  			var minDistance = Infinity;

  			// project the point onto the plane of the triangle

  			plane.setFromCoplanarPoints( this.a, this.b, this.c );
  			plane.projectPoint( point, projectedPoint );

  			// check if the projection lies within the triangle

  			if ( this.containsPoint( projectedPoint ) === true ) {

  				// if so, this is the closest point

  				result.copy( projectedPoint );

  			} else {

  				// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices

  				edgeList[ 0 ].set( this.a, this.b );
  				edgeList[ 1 ].set( this.b, this.c );
  				edgeList[ 2 ].set( this.c, this.a );

  				for ( var i = 0; i < edgeList.length; i ++ ) {

  					edgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );

  					var distance = projectedPoint.distanceToSquared( closestPoint );

  					if ( distance < minDistance ) {

  						minDistance = distance;

  						result.copy( closestPoint );

  					}

  				}

  			}

  			return result;

  		};

  	}(),

  	equals: function ( triangle ) {

  		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   * @author mikael emtinger / http://gomo.se/
   * @author jonobr1 / http://jonobr1.com/
   */

  function Mesh$1( geometry, material ) {

  	Object3D$1.call( this );

  	this.type = 'Mesh';

  	this.geometry = geometry !== undefined ? geometry : new BufferGeometry$1();
  	this.material = material !== undefined ? material : new MeshBasicMaterial$1( { color: Math.random() * 0xffffff } );

  	this.drawMode = TrianglesDrawMode$1;

  	this.updateMorphTargets();

  }

  Mesh$1.prototype = Object.assign( Object.create( Object3D$1.prototype ), {

  	constructor: Mesh$1,

  	isMesh: true,

  	setDrawMode: function ( value ) {

  		this.drawMode = value;

  	},

  	copy: function ( source ) {

  		Object3D$1.prototype.copy.call( this, source );

  		this.drawMode = source.drawMode;

  		return this;

  	},

  	updateMorphTargets: function () {
  		var this$1 = this;


  		var geometry = this.geometry;
  		var m, ml, name;

  		if ( geometry.isBufferGeometry ) {

  			var morphAttributes = geometry.morphAttributes;
  			var keys = Object.keys( morphAttributes );

  			if ( keys.length > 0 ) {

  				var morphAttribute = morphAttributes[ keys[ 0 ] ];

  				if ( morphAttribute !== undefined ) {

  					this.morphTargetInfluences = [];
  					this.morphTargetDictionary = {};

  					for ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

  						name = morphAttribute[ m ].name || String( m );

  						this$1.morphTargetInfluences.push( 0 );
  						this$1.morphTargetDictionary[ name ] = m;

  					}

  				}

  			}

  		} else {

  			var morphTargets = geometry.morphTargets;

  			if ( morphTargets !== undefined && morphTargets.length > 0 ) {

  				this.morphTargetInfluences = [];
  				this.morphTargetDictionary = {};

  				for ( m = 0, ml = morphTargets.length; m < ml; m ++ ) {

  					name = morphTargets[ m ].name || String( m );

  					this$1.morphTargetInfluences.push( 0 );
  					this$1.morphTargetDictionary[ name ] = m;

  				}

  			}

  		}

  	},

  	raycast: ( function () {

  		var inverseMatrix = new Matrix4$1();
  		var ray = new Ray$1();
  		var sphere = new Sphere$1();

  		var vA = new Vector3$2();
  		var vB = new Vector3$2();
  		var vC = new Vector3$2();

  		var tempA = new Vector3$2();
  		var tempB = new Vector3$2();
  		var tempC = new Vector3$2();

  		var uvA = new Vector2$1();
  		var uvB = new Vector2$1();
  		var uvC = new Vector2$1();

  		var barycoord = new Vector3$2();

  		var intersectionPoint = new Vector3$2();
  		var intersectionPointWorld = new Vector3$2();

  		function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

  			Triangle$1.barycoordFromPoint( point, p1, p2, p3, barycoord );

  			uv1.multiplyScalar( barycoord.x );
  			uv2.multiplyScalar( barycoord.y );
  			uv3.multiplyScalar( barycoord.z );

  			uv1.add( uv2 ).add( uv3 );

  			return uv1.clone();

  		}

  		function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

  			var intersect;

  			if ( material.side === BackSide$1 ) {

  				intersect = ray.intersectTriangle( pC, pB, pA, true, point );

  			} else {

  				intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide$1, point );

  			}

  			if ( intersect === null ) { return null; }

  			intersectionPointWorld.copy( point );
  			intersectionPointWorld.applyMatrix4( object.matrixWorld );

  			var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

  			if ( distance < raycaster.near || distance > raycaster.far ) { return null; }

  			return {
  				distance: distance,
  				point: intersectionPointWorld.clone(),
  				object: object
  			};

  		}

  		function checkBufferGeometryIntersection( object, raycaster, ray, position, uv, a, b, c ) {

  			vA.fromBufferAttribute( position, a );
  			vB.fromBufferAttribute( position, b );
  			vC.fromBufferAttribute( position, c );

  			var intersection = checkIntersection( object, object.material, raycaster, ray, vA, vB, vC, intersectionPoint );

  			if ( intersection ) {

  				if ( uv ) {

  					uvA.fromBufferAttribute( uv, a );
  					uvB.fromBufferAttribute( uv, b );
  					uvC.fromBufferAttribute( uv, c );

  					intersection.uv = uvIntersection( intersectionPoint, vA, vB, vC, uvA, uvB, uvC );

  				}

  				intersection.face = new Face3$2( a, b, c, Triangle$1.normal( vA, vB, vC ) );
  				intersection.faceIndex = a;

  			}

  			return intersection;

  		}

  		return function raycast( raycaster, intersects ) {
  			var this$1 = this;


  			var geometry = this.geometry;
  			var material = this.material;
  			var matrixWorld = this.matrixWorld;

  			if ( material === undefined ) { return; }

  			// Checking boundingSphere distance to ray

  			if ( geometry.boundingSphere === null ) { geometry.computeBoundingSphere(); }

  			sphere.copy( geometry.boundingSphere );
  			sphere.applyMatrix4( matrixWorld );

  			if ( raycaster.ray.intersectsSphere( sphere ) === false ) { return; }

  			//

  			inverseMatrix.getInverse( matrixWorld );
  			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

  			// Check boundingBox before continuing

  			if ( geometry.boundingBox !== null ) {

  				if ( ray.intersectsBox( geometry.boundingBox ) === false ) { return; }

  			}

  			var intersection;

  			if ( geometry.isBufferGeometry ) {

  				var a, b, c;
  				var index = geometry.index;
  				var position = geometry.attributes.position;
  				var uv = geometry.attributes.uv;
  				var i, l;

  				if ( index !== null ) {

  					// indexed buffer geometry

  					for ( i = 0, l = index.count; i < l; i += 3 ) {

  						a = index.getX( i );
  						b = index.getX( i + 1 );
  						c = index.getX( i + 2 );

  						intersection = checkBufferGeometryIntersection( this$1, raycaster, ray, position, uv, a, b, c );

  						if ( intersection ) {

  							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
  							intersects.push( intersection );

  						}

  					}

  				} else if ( position !== undefined ) {

  					// non-indexed buffer geometry

  					for ( i = 0, l = position.count; i < l; i += 3 ) {

  						a = i;
  						b = i + 1;
  						c = i + 2;

  						intersection = checkBufferGeometryIntersection( this$1, raycaster, ray, position, uv, a, b, c );

  						if ( intersection ) {

  							intersection.index = a; // triangle number in positions buffer semantics
  							intersects.push( intersection );

  						}

  					}

  				}

  			} else if ( geometry.isGeometry ) {

  				var fvA, fvB, fvC;
  				var isMultiMaterial = Array.isArray( material );

  				var vertices = geometry.vertices;
  				var faces = geometry.faces;
  				var uvs;

  				var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
  				if ( faceVertexUvs.length > 0 ) { uvs = faceVertexUvs; }

  				for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

  					var face = faces[ f ];
  					var faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;

  					if ( faceMaterial === undefined ) { continue; }

  					fvA = vertices[ face.a ];
  					fvB = vertices[ face.b ];
  					fvC = vertices[ face.c ];

  					if ( faceMaterial.morphTargets === true ) {

  						var morphTargets = geometry.morphTargets;
  						var morphInfluences = this$1.morphTargetInfluences;

  						vA.set( 0, 0, 0 );
  						vB.set( 0, 0, 0 );
  						vC.set( 0, 0, 0 );

  						for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

  							var influence = morphInfluences[ t ];

  							if ( influence === 0 ) { continue; }

  							var targets = morphTargets[ t ].vertices;

  							vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
  							vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
  							vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );

  						}

  						vA.add( fvA );
  						vB.add( fvB );
  						vC.add( fvC );

  						fvA = vA;
  						fvB = vB;
  						fvC = vC;

  					}

  					intersection = checkIntersection( this$1, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint );

  					if ( intersection ) {

  						if ( uvs && uvs[ f ] ) {

  							var uvs_f = uvs[ f ];
  							uvA.copy( uvs_f[ 0 ] );
  							uvB.copy( uvs_f[ 1 ] );
  							uvC.copy( uvs_f[ 2 ] );

  							intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );

  						}

  						intersection.face = face;
  						intersection.faceIndex = f;
  						intersects.push( intersection );

  					}

  				}

  			}

  		};

  	}() ),

  	clone: function () {

  		return new this.constructor( this.geometry, this.material ).copy( this );

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLBackground( renderer, state, geometries, premultipliedAlpha ) {

  	var clearColor = new Color$1( 0x000000 );
  	var clearAlpha = 0;

  	var planeCamera, planeMesh;
  	var boxMesh;

  	function render( renderList, scene, camera, forceClear ) {

  		var background = scene.background;

  		if ( background === null ) {

  			setClear( clearColor, clearAlpha );

  		} else if ( background && background.isColor ) {

  			setClear( background, 1 );
  			forceClear = true;

  		}

  		if ( renderer.autoClear || forceClear ) {

  			renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

  		}

  		if ( background && background.isCubeTexture ) {

  			if ( boxMesh === undefined ) {

  				boxMesh = new Mesh$1(
  					new BoxBufferGeometry$1( 1, 1, 1 ),
  					new ShaderMaterial$1( {
  						uniforms: ShaderLib.cube.uniforms,
  						vertexShader: ShaderLib.cube.vertexShader,
  						fragmentShader: ShaderLib.cube.fragmentShader,
  						side: BackSide$1,
  						depthTest: true,
  						depthWrite: false,
  						polygonOffset: true,
  						fog: false
  					} )
  				);

  				boxMesh.geometry.removeAttribute( 'normal' );
  				boxMesh.geometry.removeAttribute( 'uv' );

  				boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

  					var scale = camera.far;

  					this.matrixWorld.makeScale( scale, scale, scale );
  					this.matrixWorld.copyPosition( camera.matrixWorld );

  					this.material.polygonOffsetUnits = scale * 10;

  				};

  				geometries.update( boxMesh.geometry );

  			}

  			boxMesh.material.uniforms.tCube.value = background;

  			renderList.push( boxMesh, boxMesh.geometry, boxMesh.material, 0, null );

  		} else if ( background && background.isTexture ) {

  			if ( planeCamera === undefined ) {

  				planeCamera = new OrthographicCamera$1( - 1, 1, 1, - 1, 0, 1 );

  				planeMesh = new Mesh$1(
  					new PlaneBufferGeometry$1( 2, 2 ),
  					new MeshBasicMaterial$1( { depthTest: false, depthWrite: false, fog: false } )
  				);

  				geometries.update( planeMesh.geometry );

  			}

  			planeMesh.material.map = background;

  			// TODO Push this to renderList

  			renderer.renderBufferDirect( planeCamera, null, planeMesh.geometry, planeMesh.material, planeMesh, null );

  		}

  	}

  	function setClear( color, alpha ) {

  		state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );

  	}

  	return {

  		getClearColor: function () {

  			return clearColor;

  		},
  		setClearColor: function ( color, alpha ) {

  			clearColor.set( color );
  			clearAlpha = alpha !== undefined ? alpha : 1;
  			setClear( clearColor, clearAlpha );

  		},
  		getClearAlpha: function () {

  			return clearAlpha;

  		},
  		setClearAlpha: function ( alpha ) {

  			clearAlpha = alpha;
  			setClear( clearColor, clearAlpha );

  		},
  		render: render

  	};

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function painterSortStable( a, b ) {

  	if ( a.renderOrder !== b.renderOrder ) {

  		return a.renderOrder - b.renderOrder;

  	} else if ( a.program && b.program && a.program !== b.program ) {

  		return a.program.id - b.program.id;

  	} else if ( a.material.id !== b.material.id ) {

  		return a.material.id - b.material.id;

  	} else if ( a.z !== b.z ) {

  		return a.z - b.z;

  	} else {

  		return a.id - b.id;

  	}

  }

  function reversePainterSortStable( a, b ) {

  	if ( a.renderOrder !== b.renderOrder ) {

  		return a.renderOrder - b.renderOrder;

  	} if ( a.z !== b.z ) {

  		return b.z - a.z;

  	} else {

  		return a.id - b.id;

  	}

  }

  function WebGLRenderList() {

  	var renderItems = [];
  	var renderItemsIndex = 0;

  	var opaque = [];
  	var transparent = [];

  	function init() {

  		renderItemsIndex = 0;

  		opaque.length = 0;
  		transparent.length = 0;

  	}

  	function push( object, geometry, material, z, group ) {

  		var renderItem = renderItems[ renderItemsIndex ];

  		if ( renderItem === undefined ) {

  			renderItem = {
  				id: object.id,
  				object: object,
  				geometry: geometry,
  				material: material,
  				program: material.program,
  				renderOrder: object.renderOrder,
  				z: z,
  				group: group
  			};

  			renderItems[ renderItemsIndex ] = renderItem;

  		} else {

  			renderItem.id = object.id;
  			renderItem.object = object;
  			renderItem.geometry = geometry;
  			renderItem.material = material;
  			renderItem.program = material.program;
  			renderItem.renderOrder = object.renderOrder;
  			renderItem.z = z;
  			renderItem.group = group;

  		}

  		( material.transparent === true ? transparent : opaque ).push( renderItem );

  		renderItemsIndex ++;

  	}

  	function sort() {

  		if ( opaque.length > 1 ) { opaque.sort( painterSortStable ); }
  		if ( transparent.length > 1 ) { transparent.sort( reversePainterSortStable ); }

  	}

  	return {
  		opaque: opaque,
  		transparent: transparent,

  		init: init,
  		push: push,

  		sort: sort
  	};

  }

  function WebGLRenderLists() {

  	var lists = {};

  	function get( scene, camera ) {

  		var hash = scene.id + ',' + camera.id;
  		var list = lists[ hash ];

  		if ( list === undefined ) {

  			// console.log( 'THREE.WebGLRenderLists:', hash );

  			list = new WebGLRenderList();
  			lists[ hash ] = list;

  		}

  		return list;

  	}

  	function dispose() {

  		lists = {};

  	}

  	return {
  		get: get,
  		dispose: dispose
  	};

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function absNumericalSort( a, b ) {

  	return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

  }

  function WebGLMorphtargets( gl ) {

  	var influencesList = {};
  	var morphInfluences = new Float32Array( 8 );

  	function update( object, geometry, material, program ) {

  		var objectInfluences = object.morphTargetInfluences;

  		var length = objectInfluences.length;

  		var influences = influencesList[ geometry.id ];

  		if ( influences === undefined ) {

  			// initialise list

  			influences = [];

  			for ( var i = 0; i < length; i ++ ) {

  				influences[ i ] = [ i, 0 ];

  			}

  			influencesList[ geometry.id ] = influences;

  		}

  		var morphTargets = material.morphTargets && geometry.morphAttributes.position;
  		var morphNormals = material.morphNormals && geometry.morphAttributes.normal;

  		// Remove current morphAttributes

  		for ( var i = 0; i < length; i ++ ) {

  			var influence = influences[ i ];

  			if ( influence[ 1 ] !== 0 ) {

  				if ( morphTargets ) { geometry.removeAttribute( 'morphTarget' + i ); }
  				if ( morphNormals ) { geometry.removeAttribute( 'morphNormal' + i ); }

  			}

  		}

  		// Collect influences

  		for ( var i = 0; i < length; i ++ ) {

  			var influence = influences[ i ];

  			influence[ 0 ] = i;
  			influence[ 1 ] = objectInfluences[ i ];

  		}

  		influences.sort( absNumericalSort );

  		// Add morphAttributes

  		for ( var i = 0; i < 8; i ++ ) {

  			var influence = influences[ i ];

  			if ( influence ) {

  				var index = influence[ 0 ];
  				var value = influence[ 1 ];

  				if ( value ) {

  					if ( morphTargets ) { geometry.addAttribute( 'morphTarget' + i, morphTargets[ index ] ); }
  					if ( morphNormals ) { geometry.addAttribute( 'morphNormal' + i, morphNormals[ index ] ); }

  					morphInfluences[ i ] = value;
  					continue;

  				}

  			}

  			morphInfluences[ i ] = 0;

  		}

  		program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

  	}

  	return {

  		update: update

  	};

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {

  	var mode;

  	function setMode( value ) {

  		mode = value;

  	}

  	var type, bytesPerElement;

  	function setIndex( value ) {

  		type = value.type;
  		bytesPerElement = value.bytesPerElement;

  	}

  	function render( start, count ) {

  		gl.drawElements( mode, count, type, start * bytesPerElement );

  		infoRender.calls ++;
  		infoRender.vertices += count;

  		if ( mode === gl.TRIANGLES ) { infoRender.faces += count / 3; }
  		else if ( mode === gl.POINTS ) { infoRender.points += count; }

  	}

  	function renderInstances( geometry, start, count ) {

  		var extension = extensions.get( 'ANGLE_instanced_arrays' );

  		if ( extension === null ) {

  			console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
  			return;

  		}

  		extension.drawElementsInstancedANGLE( mode, count, type, start * bytesPerElement, geometry.maxInstancedCount );

  		infoRender.calls ++;
  		infoRender.vertices += count * geometry.maxInstancedCount;

  		if ( mode === gl.TRIANGLES ) { infoRender.faces += geometry.maxInstancedCount * count / 3; }
  		else if ( mode === gl.POINTS ) { infoRender.points += geometry.maxInstancedCount * count; }

  	}

  	//

  	this.setMode = setMode;
  	this.setIndex = setIndex;
  	this.render = render;
  	this.renderInstances = renderInstances;

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLBufferRenderer( gl, extensions, infoRender ) {

  	var mode;

  	function setMode( value ) {

  		mode = value;

  	}

  	function render( start, count ) {

  		gl.drawArrays( mode, start, count );

  		infoRender.calls ++;
  		infoRender.vertices += count;

  		if ( mode === gl.TRIANGLES ) { infoRender.faces += count / 3; }
  		else if ( mode === gl.POINTS ) { infoRender.points += count; }

  	}

  	function renderInstances( geometry, start, count ) {

  		var extension = extensions.get( 'ANGLE_instanced_arrays' );

  		if ( extension === null ) {

  			console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
  			return;

  		}

  		var position = geometry.attributes.position;

  		if ( position.isInterleavedBufferAttribute ) {

  			count = position.data.count;

  			extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );

  		} else {

  			extension.drawArraysInstancedANGLE( mode, start, count, geometry.maxInstancedCount );

  		}

  		infoRender.calls ++;
  		infoRender.vertices += count * geometry.maxInstancedCount;

  		if ( mode === gl.TRIANGLES ) { infoRender.faces += geometry.maxInstancedCount * count / 3; }
  		else if ( mode === gl.POINTS ) { infoRender.points += geometry.maxInstancedCount * count; }

  	}

  	//

  	this.setMode = setMode;
  	this.render = render;
  	this.renderInstances = renderInstances;

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLGeometries( gl, attributes, infoMemory ) {

  	var geometries = {};
  	var wireframeAttributes = {};

  	function onGeometryDispose( event ) {

  		var geometry = event.target;
  		var buffergeometry = geometries[ geometry.id ];

  		if ( buffergeometry.index !== null ) {

  			attributes.remove( buffergeometry.index );

  		}

  		for ( var name in buffergeometry.attributes ) {

  			attributes.remove( buffergeometry.attributes[ name ] );

  		}

  		geometry.removeEventListener( 'dispose', onGeometryDispose );

  		delete geometries[ geometry.id ];

  		// TODO Remove duplicate code

  		var attribute = wireframeAttributes[ geometry.id ];

  		if ( attribute ) {

  			attributes.remove( attribute );
  			delete wireframeAttributes[ geometry.id ];

  		}

  		attribute = wireframeAttributes[ buffergeometry.id ];

  		if ( attribute ) {

  			attributes.remove( attribute );
  			delete wireframeAttributes[ buffergeometry.id ];

  		}

  		//

  		infoMemory.geometries --;

  	}

  	function get( object, geometry ) {

  		var buffergeometry = geometries[ geometry.id ];

  		if ( buffergeometry ) { return buffergeometry; }

  		geometry.addEventListener( 'dispose', onGeometryDispose );

  		if ( geometry.isBufferGeometry ) {

  			buffergeometry = geometry;

  		} else if ( geometry.isGeometry ) {

  			if ( geometry._bufferGeometry === undefined ) {

  				geometry._bufferGeometry = new BufferGeometry$1().setFromObject( object );

  			}

  			buffergeometry = geometry._bufferGeometry;

  		}

  		geometries[ geometry.id ] = buffergeometry;

  		infoMemory.geometries ++;

  		return buffergeometry;

  	}

  	function update( geometry ) {

  		var index = geometry.index;
  		var geometryAttributes = geometry.attributes;

  		if ( index !== null ) {

  			attributes.update( index, gl.ELEMENT_ARRAY_BUFFER );

  		}

  		for ( var name in geometryAttributes ) {

  			attributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );

  		}

  		// morph targets

  		var morphAttributes = geometry.morphAttributes;

  		for ( var name in morphAttributes ) {

  			var array = morphAttributes[ name ];

  			for ( var i = 0, l = array.length; i < l; i ++ ) {

  				attributes.update( array[ i ], gl.ARRAY_BUFFER );

  			}

  		}

  	}

  	function getWireframeAttribute( geometry ) {

  		var attribute = wireframeAttributes[ geometry.id ];

  		if ( attribute ) { return attribute; }

  		var indices = [];

  		var geometryIndex = geometry.index;
  		var geometryAttributes = geometry.attributes;

  		// console.time( 'wireframe' );

  		if ( geometryIndex !== null ) {

  			var array = geometryIndex.array;

  			for ( var i = 0, l = array.length; i < l; i += 3 ) {

  				var a = array[ i + 0 ];
  				var b = array[ i + 1 ];
  				var c = array[ i + 2 ];

  				indices.push( a, b, b, c, c, a );

  			}

  		} else {

  			var array = geometryAttributes.position.array;

  			for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

  				var a = i + 0;
  				var b = i + 1;
  				var c = i + 2;

  				indices.push( a, b, b, c, c, a );

  			}

  		}

  		// console.timeEnd( 'wireframe' );

  		attribute = new ( arrayMax$1( indices ) > 65535 ? Uint32BufferAttribute$1 : Uint16BufferAttribute$1 )( indices, 1 );

  		attributes.update( attribute, gl.ELEMENT_ARRAY_BUFFER );

  		wireframeAttributes[ geometry.id ] = attribute;

  		return attribute;

  	}

  	return {

  		get: get,
  		update: update,

  		getWireframeAttribute: getWireframeAttribute

  	};

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function UniformsCache() {

  	var lights = {};

  	return {

  		get: function ( light ) {

  			if ( lights[ light.id ] !== undefined ) {

  				return lights[ light.id ];

  			}

  			var uniforms;

  			switch ( light.type ) {

  				case 'DirectionalLight':
  					uniforms = {
  						direction: new Vector3$2(),
  						color: new Color$1(),

  						shadow: false,
  						shadowBias: 0,
  						shadowRadius: 1,
  						shadowMapSize: new Vector2$1()
  					};
  					break;

  				case 'SpotLight':
  					uniforms = {
  						position: new Vector3$2(),
  						direction: new Vector3$2(),
  						color: new Color$1(),
  						distance: 0,
  						coneCos: 0,
  						penumbraCos: 0,
  						decay: 0,

  						shadow: false,
  						shadowBias: 0,
  						shadowRadius: 1,
  						shadowMapSize: new Vector2$1()
  					};
  					break;

  				case 'PointLight':
  					uniforms = {
  						position: new Vector3$2(),
  						color: new Color$1(),
  						distance: 0,
  						decay: 0,

  						shadow: false,
  						shadowBias: 0,
  						shadowRadius: 1,
  						shadowMapSize: new Vector2$1(),
  						shadowCameraNear: 1,
  						shadowCameraFar: 1000
  					};
  					break;

  				case 'HemisphereLight':
  					uniforms = {
  						direction: new Vector3$2(),
  						skyColor: new Color$1(),
  						groundColor: new Color$1()
  					};
  					break;

  				case 'RectAreaLight':
  					uniforms = {
  						color: new Color$1(),
  						position: new Vector3$2(),
  						halfWidth: new Vector3$2(),
  						halfHeight: new Vector3$2()
  						// TODO (abelnation): set RectAreaLight shadow uniforms
  					};
  					break;

  			}

  			lights[ light.id ] = uniforms;

  			return uniforms;

  		}

  	};

  }

  function WebGLLights() {

  	var cache = new UniformsCache();

  	var state = {

  		hash: '',

  		ambient: [ 0, 0, 0 ],
  		directional: [],
  		directionalShadowMap: [],
  		directionalShadowMatrix: [],
  		spot: [],
  		spotShadowMap: [],
  		spotShadowMatrix: [],
  		rectArea: [],
  		point: [],
  		pointShadowMap: [],
  		pointShadowMatrix: [],
  		hemi: []

  	};

  	var vector3 = new Vector3$2();
  	var matrix4 = new Matrix4$1();
  	var matrix42 = new Matrix4$1();

  	function setup( lights, shadows, camera ) {

  		var r = 0, g = 0, b = 0;

  		var directionalLength = 0;
  		var pointLength = 0;
  		var spotLength = 0;
  		var rectAreaLength = 0;
  		var hemiLength = 0;

  		var viewMatrix = camera.matrixWorldInverse;

  		for ( var i = 0, l = lights.length; i < l; i ++ ) {

  			var light = lights[ i ];

  			var color = light.color;
  			var intensity = light.intensity;
  			var distance = light.distance;

  			var shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

  			if ( light.isAmbientLight ) {

  				r += color.r * intensity;
  				g += color.g * intensity;
  				b += color.b * intensity;

  			} else if ( light.isDirectionalLight ) {

  				var uniforms = cache.get( light );

  				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
  				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
  				vector3.setFromMatrixPosition( light.target.matrixWorld );
  				uniforms.direction.sub( vector3 );
  				uniforms.direction.transformDirection( viewMatrix );

  				uniforms.shadow = light.castShadow;

  				if ( light.castShadow ) {

  					var shadow = light.shadow;

  					uniforms.shadowBias = shadow.bias;
  					uniforms.shadowRadius = shadow.radius;
  					uniforms.shadowMapSize = shadow.mapSize;

  				}

  				state.directionalShadowMap[ directionalLength ] = shadowMap;
  				state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
  				state.directional[ directionalLength ] = uniforms;

  				directionalLength ++;

  			} else if ( light.isSpotLight ) {

  				var uniforms = cache.get( light );

  				uniforms.position.setFromMatrixPosition( light.matrixWorld );
  				uniforms.position.applyMatrix4( viewMatrix );

  				uniforms.color.copy( color ).multiplyScalar( intensity );
  				uniforms.distance = distance;

  				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
  				vector3.setFromMatrixPosition( light.target.matrixWorld );
  				uniforms.direction.sub( vector3 );
  				uniforms.direction.transformDirection( viewMatrix );

  				uniforms.coneCos = Math.cos( light.angle );
  				uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
  				uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

  				uniforms.shadow = light.castShadow;

  				if ( light.castShadow ) {

  					var shadow = light.shadow;

  					uniforms.shadowBias = shadow.bias;
  					uniforms.shadowRadius = shadow.radius;
  					uniforms.shadowMapSize = shadow.mapSize;

  				}

  				state.spotShadowMap[ spotLength ] = shadowMap;
  				state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
  				state.spot[ spotLength ] = uniforms;

  				spotLength ++;

  			} else if ( light.isRectAreaLight ) {

  				var uniforms = cache.get( light );

  				// (a) intensity controls irradiance of entire light
  				uniforms.color
  					.copy( color )
  					.multiplyScalar( intensity / ( light.width * light.height ) );

  				// (b) intensity controls the radiance per light area
  				// uniforms.color.copy( color ).multiplyScalar( intensity );

  				uniforms.position.setFromMatrixPosition( light.matrixWorld );
  				uniforms.position.applyMatrix4( viewMatrix );

  				// extract local rotation of light to derive width/height half vectors
  				matrix42.identity();
  				matrix4.copy( light.matrixWorld );
  				matrix4.premultiply( viewMatrix );
  				matrix42.extractRotation( matrix4 );

  				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
  				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

  				uniforms.halfWidth.applyMatrix4( matrix42 );
  				uniforms.halfHeight.applyMatrix4( matrix42 );

  				// TODO (abelnation): RectAreaLight distance?
  				// uniforms.distance = distance;

  				state.rectArea[ rectAreaLength ] = uniforms;

  				rectAreaLength ++;

  			} else if ( light.isPointLight ) {

  				var uniforms = cache.get( light );

  				uniforms.position.setFromMatrixPosition( light.matrixWorld );
  				uniforms.position.applyMatrix4( viewMatrix );

  				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
  				uniforms.distance = light.distance;
  				uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

  				uniforms.shadow = light.castShadow;

  				if ( light.castShadow ) {

  					var shadow = light.shadow;

  					uniforms.shadowBias = shadow.bias;
  					uniforms.shadowRadius = shadow.radius;
  					uniforms.shadowMapSize = shadow.mapSize;
  					uniforms.shadowCameraNear = shadow.camera.near;
  					uniforms.shadowCameraFar = shadow.camera.far;

  				}

  				state.pointShadowMap[ pointLength ] = shadowMap;
  				state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;
  				state.point[ pointLength ] = uniforms;

  				pointLength ++;

  			} else if ( light.isHemisphereLight ) {

  				var uniforms = cache.get( light );

  				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
  				uniforms.direction.transformDirection( viewMatrix );
  				uniforms.direction.normalize();

  				uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
  				uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

  				state.hemi[ hemiLength ] = uniforms;

  				hemiLength ++;

  			}

  		}

  		state.ambient[ 0 ] = r;
  		state.ambient[ 1 ] = g;
  		state.ambient[ 2 ] = b;

  		state.directional.length = directionalLength;
  		state.spot.length = spotLength;
  		state.rectArea.length = rectAreaLength;
  		state.point.length = pointLength;
  		state.hemi.length = hemiLength;

  		// TODO (sam-g-steel) why aren't we using join
  		state.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + rectAreaLength + ',' + hemiLength + ',' + shadows.length;

  	}

  	return {
  		setup: setup,
  		state: state
  	};

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLObjects( geometries, infoRender ) {

  	var updateList = {};

  	function update( object ) {

  		var frame = infoRender.frame;

  		var geometry = object.geometry;
  		var buffergeometry = geometries.get( object, geometry );

  		// Update once per frame

  		if ( updateList[ buffergeometry.id ] !== frame ) {

  			if ( geometry.isGeometry ) {

  				buffergeometry.updateFromObject( object );

  			}

  			geometries.update( buffergeometry );

  			updateList[ buffergeometry.id ] = frame;

  		}

  		return buffergeometry;

  	}

  	function clear() {

  		updateList = {};

  	}

  	return {

  		update: update,
  		clear: clear

  	};

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function addLineNumbers( string ) {

  	var lines = string.split( '\n' );

  	for ( var i = 0; i < lines.length; i ++ ) {

  		lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

  	}

  	return lines.join( '\n' );

  }

  function WebGLShader( gl, type, string ) {

  	var shader = gl.createShader( type );

  	gl.shaderSource( shader, string );
  	gl.compileShader( shader );

  	if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

  		console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

  	}

  	if ( gl.getShaderInfoLog( shader ) !== '' ) {

  		console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

  	}

  	// --enable-privileged-webgl-extension
  	// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

  	return shader;

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  var programIdCount = 0;

  function getEncodingComponents( encoding ) {

  	switch ( encoding ) {

  		case LinearEncoding$1:
  			return [ 'Linear', '( value )' ];
  		case sRGBEncoding$1:
  			return [ 'sRGB', '( value )' ];
  		case RGBEEncoding$1:
  			return [ 'RGBE', '( value )' ];
  		case RGBM7Encoding$1:
  			return [ 'RGBM', '( value, 7.0 )' ];
  		case RGBM16Encoding$1:
  			return [ 'RGBM', '( value, 16.0 )' ];
  		case RGBDEncoding$1:
  			return [ 'RGBD', '( value, 256.0 )' ];
  		case GammaEncoding$1:
  			return [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];
  		default:
  			throw new Error( 'unsupported encoding: ' + encoding );

  	}

  }

  function getTexelDecodingFunction( functionName, encoding ) {

  	var components = getEncodingComponents( encoding );
  	return "vec4 " + functionName + "( vec4 value ) { return " + components[ 0 ] + "ToLinear" + components[ 1 ] + "; }";

  }

  function getTexelEncodingFunction( functionName, encoding ) {

  	var components = getEncodingComponents( encoding );
  	return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[ 0 ] + components[ 1 ] + "; }";

  }

  function getToneMappingFunction( functionName, toneMapping ) {

  	var toneMappingName;

  	switch ( toneMapping ) {

  		case LinearToneMapping$1:
  			toneMappingName = "Linear";
  			break;

  		case ReinhardToneMapping$1:
  			toneMappingName = "Reinhard";
  			break;

  		case Uncharted2ToneMapping$1:
  			toneMappingName = "Uncharted2";
  			break;

  		case CineonToneMapping$1:
  			toneMappingName = "OptimizedCineon";
  			break;

  		default:
  			throw new Error( 'unsupported toneMapping: ' + toneMapping );

  	}

  	return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";

  }

  function generateExtensions( extensions, parameters, rendererExtensions ) {

  	extensions = extensions || {};

  	var chunks = [
  		( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
  		( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
  		( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
  		( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : ''
  	];

  	return chunks.filter( filterEmptyLine ).join( '\n' );

  }

  function generateDefines( defines ) {

  	var chunks = [];

  	for ( var name in defines ) {

  		var value = defines[ name ];

  		if ( value === false ) { continue; }

  		chunks.push( '#define ' + name + ' ' + value );

  	}

  	return chunks.join( '\n' );

  }

  function fetchAttributeLocations( gl, program ) {

  	var attributes = {};

  	var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

  	for ( var i = 0; i < n; i ++ ) {

  		var info = gl.getActiveAttrib( program, i );
  		var name = info.name;

  		// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

  		attributes[ name ] = gl.getAttribLocation( program, name );

  	}

  	return attributes;

  }

  function filterEmptyLine( string ) {

  	return string !== '';

  }

  function replaceLightNums( string, parameters ) {

  	return string
  		.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
  		.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
  		.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
  		.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
  		.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );

  }

  function parseIncludes( string ) {

  	var pattern = /^[ \t]*#include +<([\w\d.]+)>/gm;

  	function replace( match, include ) {

  		var replace = ShaderChunk[ include ];

  		if ( replace === undefined ) {

  			throw new Error( 'Can not resolve #include <' + include + '>' );

  		}

  		return parseIncludes( replace );

  	}

  	return string.replace( pattern, replace );

  }

  function unrollLoops( string ) {

  	var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

  	function replace( match, start, end, snippet ) {

  		var unroll = '';

  		for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {

  			unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );

  		}

  		return unroll;

  	}

  	return string.replace( pattern, replace );

  }

  function WebGLProgram( renderer, extensions, code, material, shader, parameters ) {

  	var gl = renderer.context;

  	var defines = material.defines;

  	var vertexShader = shader.vertexShader;
  	var fragmentShader = shader.fragmentShader;

  	var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

  	if ( parameters.shadowMapType === PCFShadowMap$1 ) {

  		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

  	} else if ( parameters.shadowMapType === PCFSoftShadowMap$1 ) {

  		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

  	}

  	var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
  	var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
  	var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

  	if ( parameters.envMap ) {

  		switch ( material.envMap.mapping ) {

  			case CubeReflectionMapping$1:
  			case CubeRefractionMapping$1:
  				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
  				break;

  			case CubeUVReflectionMapping$1:
  			case CubeUVRefractionMapping$1:
  				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
  				break;

  			case EquirectangularReflectionMapping$1:
  			case EquirectangularRefractionMapping$1:
  				envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
  				break;

  			case SphericalReflectionMapping$1:
  				envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
  				break;

  		}

  		switch ( material.envMap.mapping ) {

  			case CubeRefractionMapping$1:
  			case EquirectangularRefractionMapping$1:
  				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
  				break;

  		}

  		switch ( material.combine ) {

  			case MultiplyOperation$1:
  				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
  				break;

  			case MixOperation$1:
  				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
  				break;

  			case AddOperation$1:
  				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
  				break;

  		}

  	}

  	var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

  	// console.log( 'building new program ' );

  	//

  	var customExtensions = generateExtensions( material.extensions, parameters, extensions );

  	var customDefines = generateDefines( defines );

  	//

  	var program = gl.createProgram();

  	var prefixVertex, prefixFragment;

  	if ( material.isRawShaderMaterial ) {

  		prefixVertex = [

  			customDefines,

  			'\n'

  		].filter( filterEmptyLine ).join( '\n' );

  		prefixFragment = [

  			customExtensions,
  			customDefines,

  			'\n'

  		].filter( filterEmptyLine ).join( '\n' );

  	} else {

  		prefixVertex = [

  			'precision ' + parameters.precision + ' float;',
  			'precision ' + parameters.precision + ' int;',

  			'#define SHADER_NAME ' + shader.name,

  			customDefines,

  			parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

  			'#define GAMMA_FACTOR ' + gammaFactorDefine,

  			'#define MAX_BONES ' + parameters.maxBones,
  			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
  			( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

  			parameters.map ? '#define USE_MAP' : '',
  			parameters.envMap ? '#define USE_ENVMAP' : '',
  			parameters.envMap ? '#define ' + envMapModeDefine : '',
  			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
  			parameters.aoMap ? '#define USE_AOMAP' : '',
  			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
  			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
  			parameters.normalMap ? '#define USE_NORMALMAP' : '',
  			parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
  			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
  			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
  			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
  			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
  			parameters.vertexColors ? '#define USE_COLOR' : '',

  			parameters.flatShading ? '#define FLAT_SHADED' : '',

  			parameters.skinning ? '#define USE_SKINNING' : '',
  			parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

  			parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
  			parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
  			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
  			parameters.flipSided ? '#define FLIP_SIDED' : '',

  			'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,

  			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
  			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

  			parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

  			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
  			parameters.logarithmicDepthBuffer && extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

  			'uniform mat4 modelMatrix;',
  			'uniform mat4 modelViewMatrix;',
  			'uniform mat4 projectionMatrix;',
  			'uniform mat4 viewMatrix;',
  			'uniform mat3 normalMatrix;',
  			'uniform vec3 cameraPosition;',

  			'attribute vec3 position;',
  			'attribute vec3 normal;',
  			'attribute vec2 uv;',

  			'#ifdef USE_COLOR',

  			'	attribute vec3 color;',

  			'#endif',

  			'#ifdef USE_MORPHTARGETS',

  			'	attribute vec3 morphTarget0;',
  			'	attribute vec3 morphTarget1;',
  			'	attribute vec3 morphTarget2;',
  			'	attribute vec3 morphTarget3;',

  			'	#ifdef USE_MORPHNORMALS',

  			'		attribute vec3 morphNormal0;',
  			'		attribute vec3 morphNormal1;',
  			'		attribute vec3 morphNormal2;',
  			'		attribute vec3 morphNormal3;',

  			'	#else',

  			'		attribute vec3 morphTarget4;',
  			'		attribute vec3 morphTarget5;',
  			'		attribute vec3 morphTarget6;',
  			'		attribute vec3 morphTarget7;',

  			'	#endif',

  			'#endif',

  			'#ifdef USE_SKINNING',

  			'	attribute vec4 skinIndex;',
  			'	attribute vec4 skinWeight;',

  			'#endif',

  			'\n'

  		].filter( filterEmptyLine ).join( '\n' );

  		prefixFragment = [

  			customExtensions,

  			'precision ' + parameters.precision + ' float;',
  			'precision ' + parameters.precision + ' int;',

  			'#define SHADER_NAME ' + shader.name,

  			customDefines,

  			parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

  			'#define GAMMA_FACTOR ' + gammaFactorDefine,

  			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
  			( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

  			parameters.map ? '#define USE_MAP' : '',
  			parameters.envMap ? '#define USE_ENVMAP' : '',
  			parameters.envMap ? '#define ' + envMapTypeDefine : '',
  			parameters.envMap ? '#define ' + envMapModeDefine : '',
  			parameters.envMap ? '#define ' + envMapBlendingDefine : '',
  			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
  			parameters.aoMap ? '#define USE_AOMAP' : '',
  			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
  			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
  			parameters.normalMap ? '#define USE_NORMALMAP' : '',
  			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
  			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
  			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
  			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
  			parameters.vertexColors ? '#define USE_COLOR' : '',

  			parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

  			parameters.flatShading ? '#define FLAT_SHADED' : '',

  			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
  			parameters.flipSided ? '#define FLIP_SIDED' : '',

  			'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
  			'#define UNION_CLIPPING_PLANES ' + ( parameters.numClippingPlanes - parameters.numClipIntersection ),

  			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
  			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

  			parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : '',

  			parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : '',

  			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
  			parameters.logarithmicDepthBuffer && extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

  			parameters.envMap && extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',

  			'uniform mat4 viewMatrix;',
  			'uniform vec3 cameraPosition;',

  			( parameters.toneMapping !== NoToneMapping$1 ) ? "#define TONE_MAPPING" : '',
  			( parameters.toneMapping !== NoToneMapping$1 ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
  			( parameters.toneMapping !== NoToneMapping$1 ) ? getToneMappingFunction( "toneMapping", parameters.toneMapping ) : '',

  			parameters.dithering ? '#define DITHERING' : '',

  			( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
  			parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
  			parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
  			parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
  			parameters.outputEncoding ? getTexelEncodingFunction( "linearToOutputTexel", parameters.outputEncoding ) : '',

  			parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : '',

  			'\n'

  		].filter( filterEmptyLine ).join( '\n' );

  	}

  	vertexShader = parseIncludes( vertexShader );
  	vertexShader = replaceLightNums( vertexShader, parameters );

  	fragmentShader = parseIncludes( fragmentShader );
  	fragmentShader = replaceLightNums( fragmentShader, parameters );

  	if ( ! material.isShaderMaterial ) {

  		vertexShader = unrollLoops( vertexShader );
  		fragmentShader = unrollLoops( fragmentShader );

  	}

  	var vertexGlsl = prefixVertex + vertexShader;
  	var fragmentGlsl = prefixFragment + fragmentShader;

  	// console.log( '*VERTEX*', vertexGlsl );
  	// console.log( '*FRAGMENT*', fragmentGlsl );

  	var glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
  	var glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

  	gl.attachShader( program, glVertexShader );
  	gl.attachShader( program, glFragmentShader );

  	// Force a particular attribute to index 0.

  	if ( material.index0AttributeName !== undefined ) {

  		gl.bindAttribLocation( program, 0, material.index0AttributeName );

  	} else if ( parameters.morphTargets === true ) {

  		// programs with morphTargets displace position out of attribute 0
  		gl.bindAttribLocation( program, 0, 'position' );

  	}

  	gl.linkProgram( program );

  	var programLog = gl.getProgramInfoLog( program );
  	var vertexLog = gl.getShaderInfoLog( glVertexShader );
  	var fragmentLog = gl.getShaderInfoLog( glFragmentShader );

  	var runnable = true;
  	var haveDiagnostics = true;

  	// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
  	// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

  	if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

  		runnable = false;

  		console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

  	} else if ( programLog !== '' ) {

  		console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

  	} else if ( vertexLog === '' || fragmentLog === '' ) {

  		haveDiagnostics = false;

  	}

  	if ( haveDiagnostics ) {

  		this.diagnostics = {

  			runnable: runnable,
  			material: material,

  			programLog: programLog,

  			vertexShader: {

  				log: vertexLog,
  				prefix: prefixVertex

  			},

  			fragmentShader: {

  				log: fragmentLog,
  				prefix: prefixFragment

  			}

  		};

  	}

  	// clean up

  	gl.deleteShader( glVertexShader );
  	gl.deleteShader( glFragmentShader );

  	// set up caching for uniform locations

  	var cachedUniforms;

  	this.getUniforms = function () {

  		if ( cachedUniforms === undefined ) {

  			cachedUniforms = new WebGLUniforms( gl, program, renderer );

  		}

  		return cachedUniforms;

  	};

  	// set up caching for attribute locations

  	var cachedAttributes;

  	this.getAttributes = function () {

  		if ( cachedAttributes === undefined ) {

  			cachedAttributes = fetchAttributeLocations( gl, program );

  		}

  		return cachedAttributes;

  	};

  	// free resource

  	this.destroy = function () {

  		gl.deleteProgram( program );
  		this.program = undefined;

  	};

  	// DEPRECATED

  	Object.defineProperties( this, {

  		uniforms: {
  			get: function () {

  				console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
  				return this.getUniforms();

  			}
  		},

  		attributes: {
  			get: function () {

  				console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
  				return this.getAttributes();

  			}
  		}

  	} );


  	//

  	this.id = programIdCount ++;
  	this.code = code;
  	this.usedTimes = 1;
  	this.program = program;
  	this.vertexShader = glVertexShader;
  	this.fragmentShader = glFragmentShader;

  	return this;

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLPrograms( renderer, extensions, capabilities ) {

  	var programs = [];

  	var shaderIDs = {
  		MeshDepthMaterial: 'depth',
  		MeshDistanceMaterial: 'distanceRGBA',
  		MeshNormalMaterial: 'normal',
  		MeshBasicMaterial: 'basic',
  		MeshLambertMaterial: 'lambert',
  		MeshPhongMaterial: 'phong',
  		MeshToonMaterial: 'phong',
  		MeshStandardMaterial: 'physical',
  		MeshPhysicalMaterial: 'physical',
  		LineBasicMaterial: 'basic',
  		LineDashedMaterial: 'dashed',
  		PointsMaterial: 'points',
  		ShadowMaterial: 'shadow'
  	};

  	var parameterNames = [
  		"precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding",
  		"lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap",
  		"roughnessMap", "metalnessMap", "gradientMap",
  		"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
  		"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
  		"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
  		"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
  		"numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights",
  		"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
  		"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"
  	];


  	function allocateBones( object ) {

  		var skeleton = object.skeleton;
  		var bones = skeleton.bones;

  		if ( capabilities.floatVertexTextures ) {

  			return 1024;

  		} else {

  			// default for when object is not specified
  			// ( for example when prebuilding shader to be used with multiple objects )
  			//
  			//  - leave some extra space for other uniforms
  			//  - limit here is ANGLE's 254 max uniform vectors
  			//    (up to 54 should be safe)

  			var nVertexUniforms = capabilities.maxVertexUniforms;
  			var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

  			var maxBones = Math.min( nVertexMatrices, bones.length );

  			if ( maxBones < bones.length ) {

  				console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
  				return 0;

  			}

  			return maxBones;

  		}

  	}

  	function getTextureEncodingFromMap( map, gammaOverrideLinear ) {

  		var encoding;

  		if ( ! map ) {

  			encoding = LinearEncoding$1;

  		} else if ( map.isTexture ) {

  			encoding = map.encoding;

  		} else if ( map.isWebGLRenderTarget ) {

  			console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
  			encoding = map.texture.encoding;

  		}

  		// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
  		if ( encoding === LinearEncoding$1 && gammaOverrideLinear ) {

  			encoding = GammaEncoding$1;

  		}

  		return encoding;

  	}

  	this.getParameters = function ( material, lights, shadows, fog, nClipPlanes, nClipIntersection, object ) {

  		var shaderID = shaderIDs[ material.type ];

  		// heuristics to create shader parameters according to lights in the scene
  		// (not to blow over maxLights budget)

  		var maxBones = object.isSkinnedMesh ? allocateBones( object ) : 0;
  		var precision = capabilities.precision;

  		if ( material.precision !== null ) {

  			precision = capabilities.getMaxPrecision( material.precision );

  			if ( precision !== material.precision ) {

  				console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

  			}

  		}

  		var currentRenderTarget = renderer.getRenderTarget();

  		var parameters = {

  			shaderID: shaderID,

  			precision: precision,
  			supportsVertexTextures: capabilities.vertexTextures,
  			outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),
  			map: !! material.map,
  			mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),
  			envMap: !! material.envMap,
  			envMapMode: material.envMap && material.envMap.mapping,
  			envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),
  			envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping$1 ) || ( material.envMap.mapping === CubeUVRefractionMapping$1 ) ),
  			lightMap: !! material.lightMap,
  			aoMap: !! material.aoMap,
  			emissiveMap: !! material.emissiveMap,
  			emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),
  			bumpMap: !! material.bumpMap,
  			normalMap: !! material.normalMap,
  			displacementMap: !! material.displacementMap,
  			roughnessMap: !! material.roughnessMap,
  			metalnessMap: !! material.metalnessMap,
  			specularMap: !! material.specularMap,
  			alphaMap: !! material.alphaMap,

  			gradientMap: !! material.gradientMap,

  			combine: material.combine,

  			vertexColors: material.vertexColors,

  			fog: !! fog,
  			useFog: material.fog,
  			fogExp: ( fog && fog.isFogExp2 ),

  			flatShading: material.flatShading,

  			sizeAttenuation: material.sizeAttenuation,
  			logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

  			skinning: material.skinning && maxBones > 0,
  			maxBones: maxBones,
  			useVertexTexture: capabilities.floatVertexTextures,

  			morphTargets: material.morphTargets,
  			morphNormals: material.morphNormals,
  			maxMorphTargets: renderer.maxMorphTargets,
  			maxMorphNormals: renderer.maxMorphNormals,

  			numDirLights: lights.directional.length,
  			numPointLights: lights.point.length,
  			numSpotLights: lights.spot.length,
  			numRectAreaLights: lights.rectArea.length,
  			numHemiLights: lights.hemi.length,

  			numClippingPlanes: nClipPlanes,
  			numClipIntersection: nClipIntersection,

  			dithering: material.dithering,

  			shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,
  			shadowMapType: renderer.shadowMap.type,

  			toneMapping: renderer.toneMapping,
  			physicallyCorrectLights: renderer.physicallyCorrectLights,

  			premultipliedAlpha: material.premultipliedAlpha,

  			alphaTest: material.alphaTest,
  			doubleSided: material.side === DoubleSide$1,
  			flipSided: material.side === BackSide$1,

  			depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false

  		};

  		return parameters;

  	};

  	this.getProgramCode = function ( material, parameters ) {

  		var array = [];

  		if ( parameters.shaderID ) {

  			array.push( parameters.shaderID );

  		} else {

  			array.push( material.fragmentShader );
  			array.push( material.vertexShader );

  		}

  		if ( material.defines !== undefined ) {

  			for ( var name in material.defines ) {

  				array.push( name );
  				array.push( material.defines[ name ] );

  			}

  		}

  		for ( var i = 0; i < parameterNames.length; i ++ ) {

  			array.push( parameters[ parameterNames[ i ] ] );

  		}

  		array.push( material.onBeforeCompile.toString() );

  		array.push( renderer.gammaOutput );

  		return array.join();

  	};

  	this.acquireProgram = function ( material, shader, parameters, code ) {

  		var program;

  		// Check if code has been already compiled
  		for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

  			var programInfo = programs[ p ];

  			if ( programInfo.code === code ) {

  				program = programInfo;
  				++ program.usedTimes;

  				break;

  			}

  		}

  		if ( program === undefined ) {

  			program = new WebGLProgram( renderer, extensions, code, material, shader, parameters );
  			programs.push( program );

  		}

  		return program;

  	};

  	this.releaseProgram = function ( program ) {

  		if ( -- program.usedTimes === 0 ) {

  			// Remove from unordered set
  			var i = programs.indexOf( program );
  			programs[ i ] = programs[ programs.length - 1 ];
  			programs.pop();

  			// Free WebGL resources
  			program.destroy();

  		}

  	};

  	// Exposed for resource monitoring & error feedback via renderer.info:
  	this.programs = programs;

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, infoMemory ) {

  	var _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof window.WebGL2RenderingContext );

  	//

  	function clampToMaxSize( image, maxSize ) {

  		if ( image.width > maxSize || image.height > maxSize ) {

  			// Warning: Scaling through the canvas will only work with images that use
  			// premultiplied alpha.

  			var scale = maxSize / Math.max( image.width, image.height );

  			var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
  			canvas.width = Math.floor( image.width * scale );
  			canvas.height = Math.floor( image.height * scale );

  			var context = canvas.getContext( '2d' );
  			context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

  			console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

  			return canvas;

  		}

  		return image;

  	}

  	function isPowerOfTwo( image ) {

  		return _Math$1.isPowerOfTwo( image.width ) && _Math$1.isPowerOfTwo( image.height );

  	}

  	function makePowerOfTwo( image ) {

  		if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {

  			var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
  			canvas.width = _Math$1.floorPowerOfTwo( image.width );
  			canvas.height = _Math$1.floorPowerOfTwo( image.height );

  			var context = canvas.getContext( '2d' );
  			context.drawImage( image, 0, 0, canvas.width, canvas.height );

  			console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

  			return canvas;

  		}

  		return image;

  	}

  	function textureNeedsPowerOfTwo( texture ) {

  		return ( texture.wrapS !== ClampToEdgeWrapping$1 || texture.wrapT !== ClampToEdgeWrapping$1 ) ||
  			( texture.minFilter !== NearestFilter$1 && texture.minFilter !== LinearFilter$1 );

  	}

  	function textureNeedsGenerateMipmaps( texture, isPowerOfTwo ) {

  		return texture.generateMipmaps && isPowerOfTwo &&
  			texture.minFilter !== NearestFilter$1 && texture.minFilter !== LinearFilter$1;

  	}

  	// Fallback filters for non-power-of-2 textures

  	function filterFallback( f ) {

  		if ( f === NearestFilter$1 || f === NearestMipMapNearestFilter$1 || f === NearestMipMapLinearFilter$1 ) {

  			return _gl.NEAREST;

  		}

  		return _gl.LINEAR;

  	}

  	//

  	function onTextureDispose( event ) {

  		var texture = event.target;

  		texture.removeEventListener( 'dispose', onTextureDispose );

  		deallocateTexture( texture );

  		infoMemory.textures --;


  	}

  	function onRenderTargetDispose( event ) {

  		var renderTarget = event.target;

  		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

  		deallocateRenderTarget( renderTarget );

  		infoMemory.textures --;

  	}

  	//

  	function deallocateTexture( texture ) {

  		var textureProperties = properties.get( texture );

  		if ( texture.image && textureProperties.__image__webglTextureCube ) {

  			// cube texture

  			_gl.deleteTexture( textureProperties.__image__webglTextureCube );

  		} else {

  			// 2D texture

  			if ( textureProperties.__webglInit === undefined ) { return; }

  			_gl.deleteTexture( textureProperties.__webglTexture );

  		}

  		// remove all webgl properties
  		properties.remove( texture );

  	}

  	function deallocateRenderTarget( renderTarget ) {

  		var renderTargetProperties = properties.get( renderTarget );
  		var textureProperties = properties.get( renderTarget.texture );

  		if ( ! renderTarget ) { return; }

  		if ( textureProperties.__webglTexture !== undefined ) {

  			_gl.deleteTexture( textureProperties.__webglTexture );

  		}

  		if ( renderTarget.depthTexture ) {

  			renderTarget.depthTexture.dispose();

  		}

  		if ( renderTarget.isWebGLRenderTargetCube ) {

  			for ( var i = 0; i < 6; i ++ ) {

  				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
  				if ( renderTargetProperties.__webglDepthbuffer ) { _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] ); }

  			}

  		} else {

  			_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
  			if ( renderTargetProperties.__webglDepthbuffer ) { _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer ); }

  		}

  		properties.remove( renderTarget.texture );
  		properties.remove( renderTarget );

  	}

  	//



  	function setTexture2D( texture, slot ) {

  		var textureProperties = properties.get( texture );

  		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

  			var image = texture.image;

  			if ( image === undefined ) {

  				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );

  			} else if ( image.complete === false ) {

  				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );

  			} else {

  				uploadTexture( textureProperties, texture, slot );
  				return;

  			}

  		}

  		state.activeTexture( _gl.TEXTURE0 + slot );
  		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

  	}

  	function setTextureCube( texture, slot ) {

  		var textureProperties = properties.get( texture );

  		if ( texture.image.length === 6 ) {

  			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

  				if ( ! textureProperties.__image__webglTextureCube ) {

  					texture.addEventListener( 'dispose', onTextureDispose );

  					textureProperties.__image__webglTextureCube = _gl.createTexture();

  					infoMemory.textures ++;

  				}

  				state.activeTexture( _gl.TEXTURE0 + slot );
  				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

  				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

  				var isCompressed = ( texture && texture.isCompressedTexture );
  				var isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

  				var cubeImage = [];

  				for ( var i = 0; i < 6; i ++ ) {

  					if ( ! isCompressed && ! isDataTexture ) {

  						cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );

  					} else {

  						cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

  					}

  				}

  				var image = cubeImage[ 0 ],
  					isPowerOfTwoImage = isPowerOfTwo( image ),
  					glFormat = utils.convert( texture.format ),
  					glType = utils.convert( texture.type );

  				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );

  				for ( var i = 0; i < 6; i ++ ) {

  					if ( ! isCompressed ) {

  						if ( isDataTexture ) {

  							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

  						} else {

  							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

  						}

  					} else {

  						var mipmap, mipmaps = cubeImage[ i ].mipmaps;

  						for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

  							mipmap = mipmaps[ j ];

  							if ( texture.format !== RGBAFormat$1 && texture.format !== RGBFormat$1 ) {

  								if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

  									state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

  								} else {

  									console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

  								}

  							} else {

  								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

  							}

  						}

  					}

  				}

  				if ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) {

  					_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

  				}

  				textureProperties.__version = texture.version;

  				if ( texture.onUpdate ) { texture.onUpdate( texture ); }

  			} else {

  				state.activeTexture( _gl.TEXTURE0 + slot );
  				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

  			}

  		}

  	}

  	function setTextureCubeDynamic( texture, slot ) {

  		state.activeTexture( _gl.TEXTURE0 + slot );
  		state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

  	}

  	function setTextureParameters( textureType, texture, isPowerOfTwoImage ) {

  		var extension;

  		if ( isPowerOfTwoImage ) {

  			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, utils.convert( texture.wrapS ) );
  			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, utils.convert( texture.wrapT ) );

  			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, utils.convert( texture.magFilter ) );
  			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, utils.convert( texture.minFilter ) );

  		} else {

  			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
  			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

  			if ( texture.wrapS !== ClampToEdgeWrapping$1 || texture.wrapT !== ClampToEdgeWrapping$1 ) {

  				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );

  			}

  			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
  			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

  			if ( texture.minFilter !== NearestFilter$1 && texture.minFilter !== LinearFilter$1 ) {

  				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );

  			}

  		}

  		extension = extensions.get( 'EXT_texture_filter_anisotropic' );

  		if ( extension ) {

  			if ( texture.type === FloatType$1 && extensions.get( 'OES_texture_float_linear' ) === null ) { return; }
  			if ( texture.type === HalfFloatType$1 && extensions.get( 'OES_texture_half_float_linear' ) === null ) { return; }

  			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

  				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
  				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

  			}

  		}

  	}

  	function uploadTexture( textureProperties, texture, slot ) {

  		if ( textureProperties.__webglInit === undefined ) {

  			textureProperties.__webglInit = true;

  			texture.addEventListener( 'dispose', onTextureDispose );

  			textureProperties.__webglTexture = _gl.createTexture();

  			infoMemory.textures ++;

  		}

  		state.activeTexture( _gl.TEXTURE0 + slot );
  		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

  		_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
  		_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
  		_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

  		var image = clampToMaxSize( texture.image, capabilities.maxTextureSize );

  		if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {

  			image = makePowerOfTwo( image );

  		}

  		var isPowerOfTwoImage = isPowerOfTwo( image ),
  			glFormat = utils.convert( texture.format ),
  			glType = utils.convert( texture.type );

  		setTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );

  		var mipmap, mipmaps = texture.mipmaps;

  		if ( texture.isDepthTexture ) {

  			// populate depth texture with dummy data

  			var internalFormat = _gl.DEPTH_COMPONENT;

  			if ( texture.type === FloatType$1 ) {

  				if ( ! _isWebGL2 ) { throw new Error( 'Float Depth Texture only supported in WebGL2.0' ); }
  				internalFormat = _gl.DEPTH_COMPONENT32F;

  			} else if ( _isWebGL2 ) {

  				// WebGL 2.0 requires signed internalformat for glTexImage2D
  				internalFormat = _gl.DEPTH_COMPONENT16;

  			}

  			if ( texture.format === DepthFormat$1 && internalFormat === _gl.DEPTH_COMPONENT ) {

  				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
  				// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
  				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
  				if ( texture.type !== UnsignedShortType$1 && texture.type !== UnsignedIntType$1 ) {

  					console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

  					texture.type = UnsignedShortType$1;
  					glType = utils.convert( texture.type );

  				}

  			}

  			// Depth stencil textures need the DEPTH_STENCIL internal format
  			// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
  			if ( texture.format === DepthStencilFormat$1 ) {

  				internalFormat = _gl.DEPTH_STENCIL;

  				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
  				// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
  				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
  				if ( texture.type !== UnsignedInt248Type$1 ) {

  					console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

  					texture.type = UnsignedInt248Type$1;
  					glType = utils.convert( texture.type );

  				}

  			}

  			state.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );

  		} else if ( texture.isDataTexture ) {

  			// use manually created mipmaps if available
  			// if there are no manual mipmaps
  			// set 0 level mipmap and then use GL to generate other mipmap levels

  			if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

  				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

  					mipmap = mipmaps[ i ];
  					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

  				}

  				texture.generateMipmaps = false;

  			} else {

  				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

  			}

  		} else if ( texture.isCompressedTexture ) {

  			for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

  				mipmap = mipmaps[ i ];

  				if ( texture.format !== RGBAFormat$1 && texture.format !== RGBFormat$1 ) {

  					if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

  						state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

  					} else {

  						console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

  					}

  				} else {

  					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

  				}

  			}

  		} else {

  			// regular Texture (image, video, canvas)

  			// use manually created mipmaps if available
  			// if there are no manual mipmaps
  			// set 0 level mipmap and then use GL to generate other mipmap levels

  			if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

  				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

  					mipmap = mipmaps[ i ];
  					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

  				}

  				texture.generateMipmaps = false;

  			} else {

  				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );

  			}

  		}

  		if ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) { _gl.generateMipmap( _gl.TEXTURE_2D ); }

  		textureProperties.__version = texture.version;

  		if ( texture.onUpdate ) { texture.onUpdate( texture ); }

  	}

  	// Render targets

  	// Setup storage for target texture and bind it to correct framebuffer
  	function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

  		var glFormat = utils.convert( renderTarget.texture.format );
  		var glType = utils.convert( renderTarget.texture.type );
  		state.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
  		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
  		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
  		_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

  	}

  	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
  	function setupRenderBufferStorage( renderbuffer, renderTarget ) {

  		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

  		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

  			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
  			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

  		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

  			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
  			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

  		} else {

  			// FIXME: We don't support !depth !stencil
  			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

  		}

  		_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

  	}

  	// Setup resources for a Depth Texture for a FBO (needs an extension)
  	function setupDepthTexture( framebuffer, renderTarget ) {

  		var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
  		if ( isCube ) { throw new Error( 'Depth Texture with cube render targets is not supported' ); }

  		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

  		if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

  			throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

  		}

  		// upload an empty depth texture with framebuffer size
  		if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
  				renderTarget.depthTexture.image.width !== renderTarget.width ||
  				renderTarget.depthTexture.image.height !== renderTarget.height ) {

  			renderTarget.depthTexture.image.width = renderTarget.width;
  			renderTarget.depthTexture.image.height = renderTarget.height;
  			renderTarget.depthTexture.needsUpdate = true;

  		}

  		setTexture2D( renderTarget.depthTexture, 0 );

  		var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

  		if ( renderTarget.depthTexture.format === DepthFormat$1 ) {

  			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

  		} else if ( renderTarget.depthTexture.format === DepthStencilFormat$1 ) {

  			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

  		} else {

  			throw new Error( 'Unknown depthTexture format' );

  		}

  	}

  	// Setup GL resources for a non-texture depth buffer
  	function setupDepthRenderbuffer( renderTarget ) {

  		var renderTargetProperties = properties.get( renderTarget );

  		var isCube = ( renderTarget.isWebGLRenderTargetCube === true );

  		if ( renderTarget.depthTexture ) {

  			if ( isCube ) { throw new Error( 'target.depthTexture not supported in Cube render targets' ); }

  			setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

  		} else {

  			if ( isCube ) {

  				renderTargetProperties.__webglDepthbuffer = [];

  				for ( var i = 0; i < 6; i ++ ) {

  					_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
  					renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
  					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );

  				}

  			} else {

  				_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
  				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
  				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );

  			}

  		}

  		_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

  	}

  	// Set up GL resources for the render target
  	function setupRenderTarget( renderTarget ) {

  		var renderTargetProperties = properties.get( renderTarget );
  		var textureProperties = properties.get( renderTarget.texture );

  		renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

  		textureProperties.__webglTexture = _gl.createTexture();

  		infoMemory.textures ++;

  		var isCube = ( renderTarget.isWebGLRenderTargetCube === true );
  		var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );

  		// Setup framebuffer

  		if ( isCube ) {

  			renderTargetProperties.__webglFramebuffer = [];

  			for ( var i = 0; i < 6; i ++ ) {

  				renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

  			}

  		} else {

  			renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

  		}

  		// Setup color buffer

  		if ( isCube ) {

  			state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
  			setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );

  			for ( var i = 0; i < 6; i ++ ) {

  				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );

  			}

  			if ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) { _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP ); }
  			state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

  		} else {

  			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
  			setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );
  			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );

  			if ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) { _gl.generateMipmap( _gl.TEXTURE_2D ); }
  			state.bindTexture( _gl.TEXTURE_2D, null );

  		}

  		// Setup depth and stencil buffers

  		if ( renderTarget.depthBuffer ) {

  			setupDepthRenderbuffer( renderTarget );

  		}

  	}

  	function updateRenderTargetMipmap( renderTarget ) {

  		var texture = renderTarget.texture;
  		var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );

  		if ( textureNeedsGenerateMipmaps( texture, isTargetPowerOfTwo ) ) {

  			var target = renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
  			var webglTexture = properties.get( texture ).__webglTexture;

  			state.bindTexture( target, webglTexture );
  			_gl.generateMipmap( target );
  			state.bindTexture( target, null );

  		}

  	}

  	this.setTexture2D = setTexture2D;
  	this.setTextureCube = setTextureCube;
  	this.setTextureCubeDynamic = setTextureCubeDynamic;
  	this.setupRenderTarget = setupRenderTarget;
  	this.updateRenderTargetMipmap = updateRenderTargetMipmap;

  }

  /**
   * @author fordacious / fordacious.github.io
   */

  function WebGLProperties() {

  	var properties = {};

  	function get( object ) {

  		var uuid = object.uuid;
  		var map = properties[ uuid ];

  		if ( map === undefined ) {

  			map = {};
  			properties[ uuid ] = map;

  		}

  		return map;

  	}

  	function remove( object ) {

  		delete properties[ object.uuid ];

  	}

  	function clear() {

  		properties = {};

  	}

  	return {
  		get: get,
  		remove: remove,
  		clear: clear
  	};

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLState( gl, extensions, utils ) {

  	function ColorBuffer() {

  		var locked = false;

  		var color = new Vector4$1();
  		var currentColorMask = null;
  		var currentColorClear = new Vector4$1( 0, 0, 0, 0 );

  		return {

  			setMask: function ( colorMask ) {

  				if ( currentColorMask !== colorMask && ! locked ) {

  					gl.colorMask( colorMask, colorMask, colorMask, colorMask );
  					currentColorMask = colorMask;

  				}

  			},

  			setLocked: function ( lock ) {

  				locked = lock;

  			},

  			setClear: function ( r, g, b, a, premultipliedAlpha ) {

  				if ( premultipliedAlpha === true ) {

  					r *= a; g *= a; b *= a;

  				}

  				color.set( r, g, b, a );

  				if ( currentColorClear.equals( color ) === false ) {

  					gl.clearColor( r, g, b, a );
  					currentColorClear.copy( color );

  				}

  			},

  			reset: function () {

  				locked = false;

  				currentColorMask = null;
  				currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

  			}

  		};

  	}

  	function DepthBuffer() {

  		var locked = false;

  		var currentDepthMask = null;
  		var currentDepthFunc = null;
  		var currentDepthClear = null;

  		return {

  			setTest: function ( depthTest ) {

  				if ( depthTest ) {

  					enable( gl.DEPTH_TEST );

  				} else {

  					disable( gl.DEPTH_TEST );

  				}

  			},

  			setMask: function ( depthMask ) {

  				if ( currentDepthMask !== depthMask && ! locked ) {

  					gl.depthMask( depthMask );
  					currentDepthMask = depthMask;

  				}

  			},

  			setFunc: function ( depthFunc ) {

  				if ( currentDepthFunc !== depthFunc ) {

  					if ( depthFunc ) {

  						switch ( depthFunc ) {

  							case NeverDepth$1:

  								gl.depthFunc( gl.NEVER );
  								break;

  							case AlwaysDepth$1:

  								gl.depthFunc( gl.ALWAYS );
  								break;

  							case LessDepth$1:

  								gl.depthFunc( gl.LESS );
  								break;

  							case LessEqualDepth$1:

  								gl.depthFunc( gl.LEQUAL );
  								break;

  							case EqualDepth$1:

  								gl.depthFunc( gl.EQUAL );
  								break;

  							case GreaterEqualDepth$1:

  								gl.depthFunc( gl.GEQUAL );
  								break;

  							case GreaterDepth$1:

  								gl.depthFunc( gl.GREATER );
  								break;

  							case NotEqualDepth$1:

  								gl.depthFunc( gl.NOTEQUAL );
  								break;

  							default:

  								gl.depthFunc( gl.LEQUAL );

  						}

  					} else {

  						gl.depthFunc( gl.LEQUAL );

  					}

  					currentDepthFunc = depthFunc;

  				}

  			},

  			setLocked: function ( lock ) {

  				locked = lock;

  			},

  			setClear: function ( depth ) {

  				if ( currentDepthClear !== depth ) {

  					gl.clearDepth( depth );
  					currentDepthClear = depth;

  				}

  			},

  			reset: function () {

  				locked = false;

  				currentDepthMask = null;
  				currentDepthFunc = null;
  				currentDepthClear = null;

  			}

  		};

  	}

  	function StencilBuffer() {

  		var locked = false;

  		var currentStencilMask = null;
  		var currentStencilFunc = null;
  		var currentStencilRef = null;
  		var currentStencilFuncMask = null;
  		var currentStencilFail = null;
  		var currentStencilZFail = null;
  		var currentStencilZPass = null;
  		var currentStencilClear = null;

  		return {

  			setTest: function ( stencilTest ) {

  				if ( stencilTest ) {

  					enable( gl.STENCIL_TEST );

  				} else {

  					disable( gl.STENCIL_TEST );

  				}

  			},

  			setMask: function ( stencilMask ) {

  				if ( currentStencilMask !== stencilMask && ! locked ) {

  					gl.stencilMask( stencilMask );
  					currentStencilMask = stencilMask;

  				}

  			},

  			setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

  				if ( currentStencilFunc !== stencilFunc ||
  				     currentStencilRef 	!== stencilRef 	||
  				     currentStencilFuncMask !== stencilMask ) {

  					gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

  					currentStencilFunc = stencilFunc;
  					currentStencilRef = stencilRef;
  					currentStencilFuncMask = stencilMask;

  				}

  			},

  			setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

  				if ( currentStencilFail	 !== stencilFail 	||
  				     currentStencilZFail !== stencilZFail ||
  				     currentStencilZPass !== stencilZPass ) {

  					gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

  					currentStencilFail = stencilFail;
  					currentStencilZFail = stencilZFail;
  					currentStencilZPass = stencilZPass;

  				}

  			},

  			setLocked: function ( lock ) {

  				locked = lock;

  			},

  			setClear: function ( stencil ) {

  				if ( currentStencilClear !== stencil ) {

  					gl.clearStencil( stencil );
  					currentStencilClear = stencil;

  				}

  			},

  			reset: function () {

  				locked = false;

  				currentStencilMask = null;
  				currentStencilFunc = null;
  				currentStencilRef = null;
  				currentStencilFuncMask = null;
  				currentStencilFail = null;
  				currentStencilZFail = null;
  				currentStencilZPass = null;
  				currentStencilClear = null;

  			}

  		};

  	}

  	//

  	var colorBuffer = new ColorBuffer();
  	var depthBuffer = new DepthBuffer();
  	var stencilBuffer = new StencilBuffer();

  	var maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
  	var newAttributes = new Uint8Array( maxVertexAttributes );
  	var enabledAttributes = new Uint8Array( maxVertexAttributes );
  	var attributeDivisors = new Uint8Array( maxVertexAttributes );

  	var capabilities = {};

  	var compressedTextureFormats = null;

  	var currentProgram = null;

  	var currentBlending = null;
  	var currentBlendEquation = null;
  	var currentBlendSrc = null;
  	var currentBlendDst = null;
  	var currentBlendEquationAlpha = null;
  	var currentBlendSrcAlpha = null;
  	var currentBlendDstAlpha = null;
  	var currentPremultipledAlpha = false;

  	var currentFlipSided = null;
  	var currentCullFace = null;

  	var currentLineWidth = null;

  	var currentPolygonOffsetFactor = null;
  	var currentPolygonOffsetUnits = null;

  	var maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );

  	var version = parseFloat( /^WebGL\ ([0-9])/.exec( gl.getParameter( gl.VERSION ) )[ 1 ] );
  	var lineWidthAvailable = parseFloat( version ) >= 1.0;

  	var currentTextureSlot = null;
  	var currentBoundTextures = {};

  	var currentScissor = new Vector4$1();
  	var currentViewport = new Vector4$1();

  	function createTexture( type, target, count ) {

  		var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
  		var texture = gl.createTexture();

  		gl.bindTexture( type, texture );
  		gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
  		gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

  		for ( var i = 0; i < count; i ++ ) {

  			gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

  		}

  		return texture;

  	}

  	var emptyTextures = {};
  	emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
  	emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );

  	// init

  	colorBuffer.setClear( 0, 0, 0, 1 );
  	depthBuffer.setClear( 1 );
  	stencilBuffer.setClear( 0 );

  	enable( gl.DEPTH_TEST );
  	depthBuffer.setFunc( LessEqualDepth$1 );

  	setFlipSided( false );
  	setCullFace( CullFaceBack$1 );
  	enable( gl.CULL_FACE );

  	enable( gl.BLEND );
  	setBlending( NormalBlending$1 );

  	//

  	function initAttributes() {

  		for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

  			newAttributes[ i ] = 0;

  		}

  	}

  	function enableAttribute( attribute ) {

  		newAttributes[ attribute ] = 1;

  		if ( enabledAttributes[ attribute ] === 0 ) {

  			gl.enableVertexAttribArray( attribute );
  			enabledAttributes[ attribute ] = 1;

  		}

  		if ( attributeDivisors[ attribute ] !== 0 ) {

  			var extension = extensions.get( 'ANGLE_instanced_arrays' );

  			extension.vertexAttribDivisorANGLE( attribute, 0 );
  			attributeDivisors[ attribute ] = 0;

  		}

  	}

  	function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

  		newAttributes[ attribute ] = 1;

  		if ( enabledAttributes[ attribute ] === 0 ) {

  			gl.enableVertexAttribArray( attribute );
  			enabledAttributes[ attribute ] = 1;

  		}

  		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

  			var extension = extensions.get( 'ANGLE_instanced_arrays' );

  			extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
  			attributeDivisors[ attribute ] = meshPerAttribute;

  		}

  	}

  	function disableUnusedAttributes() {

  		for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {

  			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

  				gl.disableVertexAttribArray( i );
  				enabledAttributes[ i ] = 0;

  			}

  		}

  	}

  	function enable( id ) {

  		if ( capabilities[ id ] !== true ) {

  			gl.enable( id );
  			capabilities[ id ] = true;

  		}

  	}

  	function disable( id ) {

  		if ( capabilities[ id ] !== false ) {

  			gl.disable( id );
  			capabilities[ id ] = false;

  		}

  	}

  	function getCompressedTextureFormats() {

  		if ( compressedTextureFormats === null ) {

  			compressedTextureFormats = [];

  			if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
  			     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
  			     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {

  				var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

  				for ( var i = 0; i < formats.length; i ++ ) {

  					compressedTextureFormats.push( formats[ i ] );

  				}

  			}

  		}

  		return compressedTextureFormats;

  	}

  	function useProgram( program ) {

  		if ( currentProgram !== program ) {

  			gl.useProgram( program );

  			currentProgram = program;

  			return true;

  		}

  		return false;

  	}

  	function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

  		if ( blending !== NoBlending$1 ) {

  			enable( gl.BLEND );

  		} else {

  			disable( gl.BLEND );

  		}

  		if ( blending !== CustomBlending$1 ) {

  			if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

  				switch ( blending ) {

  					case AdditiveBlending$1:

  						if ( premultipliedAlpha ) {

  							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
  							gl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );

  						} else {

  							gl.blendEquation( gl.FUNC_ADD );
  							gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

  						}
  						break;

  					case SubtractiveBlending$1:

  						if ( premultipliedAlpha ) {

  							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
  							gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );

  						} else {

  							gl.blendEquation( gl.FUNC_ADD );
  							gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

  						}
  						break;

  					case MultiplyBlending$1:

  						if ( premultipliedAlpha ) {

  							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
  							gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );

  						} else {

  							gl.blendEquation( gl.FUNC_ADD );
  							gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

  						}
  						break;

  					default:

  						if ( premultipliedAlpha ) {

  							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
  							gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

  						} else {

  							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
  							gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

  						}

  				}

  			}

  			currentBlendEquation = null;
  			currentBlendSrc = null;
  			currentBlendDst = null;
  			currentBlendEquationAlpha = null;
  			currentBlendSrcAlpha = null;
  			currentBlendDstAlpha = null;

  		} else {

  			blendEquationAlpha = blendEquationAlpha || blendEquation;
  			blendSrcAlpha = blendSrcAlpha || blendSrc;
  			blendDstAlpha = blendDstAlpha || blendDst;

  			if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

  				gl.blendEquationSeparate( utils.convert( blendEquation ), utils.convert( blendEquationAlpha ) );

  				currentBlendEquation = blendEquation;
  				currentBlendEquationAlpha = blendEquationAlpha;

  			}

  			if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

  				gl.blendFuncSeparate( utils.convert( blendSrc ), utils.convert( blendDst ), utils.convert( blendSrcAlpha ), utils.convert( blendDstAlpha ) );

  				currentBlendSrc = blendSrc;
  				currentBlendDst = blendDst;
  				currentBlendSrcAlpha = blendSrcAlpha;
  				currentBlendDstAlpha = blendDstAlpha;

  			}

  		}

  		currentBlending = blending;
  		currentPremultipledAlpha = premultipliedAlpha;

  	}

  	function setMaterial( material ) {

  		material.side === DoubleSide$1
  			? disable( gl.CULL_FACE )
  			: enable( gl.CULL_FACE );

  		setFlipSided( material.side === BackSide$1 );

  		material.transparent === true
  			? setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )
  			: setBlending( NoBlending$1 );

  		depthBuffer.setFunc( material.depthFunc );
  		depthBuffer.setTest( material.depthTest );
  		depthBuffer.setMask( material.depthWrite );
  		colorBuffer.setMask( material.colorWrite );

  		setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

  	}

  	//

  	function setFlipSided( flipSided ) {

  		if ( currentFlipSided !== flipSided ) {

  			if ( flipSided ) {

  				gl.frontFace( gl.CW );

  			} else {

  				gl.frontFace( gl.CCW );

  			}

  			currentFlipSided = flipSided;

  		}

  	}

  	function setCullFace( cullFace ) {

  		if ( cullFace !== CullFaceNone$1 ) {

  			enable( gl.CULL_FACE );

  			if ( cullFace !== currentCullFace ) {

  				if ( cullFace === CullFaceBack$1 ) {

  					gl.cullFace( gl.BACK );

  				} else if ( cullFace === CullFaceFront$1 ) {

  					gl.cullFace( gl.FRONT );

  				} else {

  					gl.cullFace( gl.FRONT_AND_BACK );

  				}

  			}

  		} else {

  			disable( gl.CULL_FACE );

  		}

  		currentCullFace = cullFace;

  	}

  	function setLineWidth( width ) {

  		if ( width !== currentLineWidth ) {

  			if ( lineWidthAvailable ) { gl.lineWidth( width ); }

  			currentLineWidth = width;

  		}

  	}

  	function setPolygonOffset( polygonOffset, factor, units ) {

  		if ( polygonOffset ) {

  			enable( gl.POLYGON_OFFSET_FILL );

  			if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

  				gl.polygonOffset( factor, units );

  				currentPolygonOffsetFactor = factor;
  				currentPolygonOffsetUnits = units;

  			}

  		} else {

  			disable( gl.POLYGON_OFFSET_FILL );

  		}

  	}

  	function setScissorTest( scissorTest ) {

  		if ( scissorTest ) {

  			enable( gl.SCISSOR_TEST );

  		} else {

  			disable( gl.SCISSOR_TEST );

  		}

  	}

  	// texture

  	function activeTexture( webglSlot ) {

  		if ( webglSlot === undefined ) { webglSlot = gl.TEXTURE0 + maxTextures - 1; }

  		if ( currentTextureSlot !== webglSlot ) {

  			gl.activeTexture( webglSlot );
  			currentTextureSlot = webglSlot;

  		}

  	}

  	function bindTexture( webglType, webglTexture ) {

  		if ( currentTextureSlot === null ) {

  			activeTexture();

  		}

  		var boundTexture = currentBoundTextures[ currentTextureSlot ];

  		if ( boundTexture === undefined ) {

  			boundTexture = { type: undefined, texture: undefined };
  			currentBoundTextures[ currentTextureSlot ] = boundTexture;

  		}

  		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

  			gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

  			boundTexture.type = webglType;
  			boundTexture.texture = webglTexture;

  		}

  	}

  	function compressedTexImage2D() {

  		try {

  			gl.compressedTexImage2D.apply( gl, arguments );

  		} catch ( error ) {

  			console.error( 'THREE.WebGLState:', error );

  		}

  	}

  	function texImage2D() {

  		try {

  			gl.texImage2D.apply( gl, arguments );

  		} catch ( error ) {

  			console.error( 'THREE.WebGLState:', error );

  		}

  	}

  	//

  	function scissor( scissor ) {

  		if ( currentScissor.equals( scissor ) === false ) {

  			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
  			currentScissor.copy( scissor );

  		}

  	}

  	function viewport( viewport ) {

  		if ( currentViewport.equals( viewport ) === false ) {

  			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
  			currentViewport.copy( viewport );

  		}

  	}

  	//

  	function reset() {

  		for ( var i = 0; i < enabledAttributes.length; i ++ ) {

  			if ( enabledAttributes[ i ] === 1 ) {

  				gl.disableVertexAttribArray( i );
  				enabledAttributes[ i ] = 0;

  			}

  		}

  		capabilities = {};

  		compressedTextureFormats = null;

  		currentTextureSlot = null;
  		currentBoundTextures = {};

  		currentProgram = null;

  		currentBlending = null;

  		currentFlipSided = null;
  		currentCullFace = null;

  		colorBuffer.reset();
  		depthBuffer.reset();
  		stencilBuffer.reset();

  	}

  	return {

  		buffers: {
  			color: colorBuffer,
  			depth: depthBuffer,
  			stencil: stencilBuffer
  		},

  		initAttributes: initAttributes,
  		enableAttribute: enableAttribute,
  		enableAttributeAndDivisor: enableAttributeAndDivisor,
  		disableUnusedAttributes: disableUnusedAttributes,
  		enable: enable,
  		disable: disable,
  		getCompressedTextureFormats: getCompressedTextureFormats,

  		useProgram: useProgram,

  		setBlending: setBlending,
  		setMaterial: setMaterial,

  		setFlipSided: setFlipSided,
  		setCullFace: setCullFace,

  		setLineWidth: setLineWidth,
  		setPolygonOffset: setPolygonOffset,

  		setScissorTest: setScissorTest,

  		activeTexture: activeTexture,
  		bindTexture: bindTexture,
  		compressedTexImage2D: compressedTexImage2D,
  		texImage2D: texImage2D,

  		scissor: scissor,
  		viewport: viewport,

  		reset: reset

  	};

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLCapabilities( gl, extensions, parameters ) {

  	var maxAnisotropy;

  	function getMaxAnisotropy() {

  		if ( maxAnisotropy !== undefined ) { return maxAnisotropy; }

  		var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

  		if ( extension !== null ) {

  			maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

  		} else {

  			maxAnisotropy = 0;

  		}

  		return maxAnisotropy;

  	}

  	function getMaxPrecision( precision ) {

  		if ( precision === 'highp' ) {

  			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
  			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

  				return 'highp';

  			}

  			precision = 'mediump';

  		}

  		if ( precision === 'mediump' ) {

  			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
  			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

  				return 'mediump';

  			}

  		}

  		return 'lowp';

  	}

  	var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
  	var maxPrecision = getMaxPrecision( precision );

  	if ( maxPrecision !== precision ) {

  		console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
  		precision = maxPrecision;

  	}

  	var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

  	var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
  	var maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
  	var maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
  	var maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

  	var maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
  	var maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
  	var maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
  	var maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

  	var vertexTextures = maxVertexTextures > 0;
  	var floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
  	var floatVertexTextures = vertexTextures && floatFragmentTextures;

  	return {

  		getMaxAnisotropy: getMaxAnisotropy,
  		getMaxPrecision: getMaxPrecision,

  		precision: precision,
  		logarithmicDepthBuffer: logarithmicDepthBuffer,

  		maxTextures: maxTextures,
  		maxVertexTextures: maxVertexTextures,
  		maxTextureSize: maxTextureSize,
  		maxCubemapSize: maxCubemapSize,

  		maxAttributes: maxAttributes,
  		maxVertexUniforms: maxVertexUniforms,
  		maxVaryings: maxVaryings,
  		maxFragmentUniforms: maxFragmentUniforms,

  		vertexTextures: vertexTextures,
  		floatFragmentTextures: floatFragmentTextures,
  		floatVertexTextures: floatVertexTextures

  	};

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author greggman / http://games.greggman.com/
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * @author tschw
   */

  function PerspectiveCamera$1( fov, aspect, near, far ) {

  	Camera$1.call( this );

  	this.type = 'PerspectiveCamera';

  	this.fov = fov !== undefined ? fov : 50;
  	this.zoom = 1;

  	this.near = near !== undefined ? near : 0.1;
  	this.far = far !== undefined ? far : 2000;
  	this.focus = 10;

  	this.aspect = aspect !== undefined ? aspect : 1;
  	this.view = null;

  	this.filmGauge = 35;	// width of the film (default in millimeters)
  	this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

  	this.updateProjectionMatrix();

  }

  PerspectiveCamera$1.prototype = Object.assign( Object.create( Camera$1.prototype ), {

  	constructor: PerspectiveCamera$1,

  	isPerspectiveCamera: true,

  	copy: function ( source, recursive ) {

  		Camera$1.prototype.copy.call( this, source, recursive );

  		this.fov = source.fov;
  		this.zoom = source.zoom;

  		this.near = source.near;
  		this.far = source.far;
  		this.focus = source.focus;

  		this.aspect = source.aspect;
  		this.view = source.view === null ? null : Object.assign( {}, source.view );

  		this.filmGauge = source.filmGauge;
  		this.filmOffset = source.filmOffset;

  		return this;

  	},

  	/**
  	 * Sets the FOV by focal length in respect to the current .filmGauge.
  	 *
  	 * The default film gauge is 35, so that the focal length can be specified for
  	 * a 35mm (full frame) camera.
  	 *
  	 * Values for focal length and film gauge must have the same unit.
  	 */
  	setFocalLength: function ( focalLength ) {

  		// see http://www.bobatkins.com/photography/technical/field_of_view.html
  		var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

  		this.fov = _Math$1.RAD2DEG * 2 * Math.atan( vExtentSlope );
  		this.updateProjectionMatrix();

  	},

  	/**
  	 * Calculates the focal length from the current .fov and .filmGauge.
  	 */
  	getFocalLength: function () {

  		var vExtentSlope = Math.tan( _Math$1.DEG2RAD * 0.5 * this.fov );

  		return 0.5 * this.getFilmHeight() / vExtentSlope;

  	},

  	getEffectiveFOV: function () {

  		return _Math$1.RAD2DEG * 2 * Math.atan(
  			Math.tan( _Math$1.DEG2RAD * 0.5 * this.fov ) / this.zoom );

  	},

  	getFilmWidth: function () {

  		// film not completely covered in portrait format (aspect < 1)
  		return this.filmGauge * Math.min( this.aspect, 1 );

  	},

  	getFilmHeight: function () {

  		// film not completely covered in landscape format (aspect > 1)
  		return this.filmGauge / Math.max( this.aspect, 1 );

  	},

  	/**
  	 * Sets an offset in a larger frustum. This is useful for multi-window or
  	 * multi-monitor/multi-machine setups.
  	 *
  	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
  	 * the monitors are in grid like this
  	 *
  	 *   +---+---+---+
  	 *   | A | B | C |
  	 *   +---+---+---+
  	 *   | D | E | F |
  	 *   +---+---+---+
  	 *
  	 * then for each monitor you would call it like this
  	 *
  	 *   var w = 1920;
  	 *   var h = 1080;
  	 *   var fullWidth = w * 3;
  	 *   var fullHeight = h * 2;
  	 *
  	 *   --A--
  	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
  	 *   --B--
  	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
  	 *   --C--
  	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
  	 *   --D--
  	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
  	 *   --E--
  	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
  	 *   --F--
  	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
  	 *
  	 *   Note there is no reason monitors have to be the same size or in a grid.
  	 */
  	setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

  		this.aspect = fullWidth / fullHeight;

  		if ( this.view === null ) {

  			this.view = {
  				enabled: true,
  				fullWidth: 1,
  				fullHeight: 1,
  				offsetX: 0,
  				offsetY: 0,
  				width: 1,
  				height: 1
  			};

  		}

  		this.view.enabled = true;
  		this.view.fullWidth = fullWidth;
  		this.view.fullHeight = fullHeight;
  		this.view.offsetX = x;
  		this.view.offsetY = y;
  		this.view.width = width;
  		this.view.height = height;

  		this.updateProjectionMatrix();

  	},

  	clearViewOffset: function () {

  		if ( this.view !== null ) {

  			this.view.enabled = false;

  		}

  		this.updateProjectionMatrix();

  	},

  	updateProjectionMatrix: function () {

  		var near = this.near,
  			top = near * Math.tan(
  				_Math$1.DEG2RAD * 0.5 * this.fov ) / this.zoom,
  			height = 2 * top,
  			width = this.aspect * height,
  			left = - 0.5 * width,
  			view = this.view;

  		if ( this.view !== null && this.view.enabled ) {

  			var fullWidth = view.fullWidth,
  				fullHeight = view.fullHeight;

  			left += view.offsetX * width / fullWidth;
  			top -= view.offsetY * height / fullHeight;
  			width *= view.width / fullWidth;
  			height *= view.height / fullHeight;

  		}

  		var skew = this.filmOffset;
  		if ( skew !== 0 ) { left += near * skew / this.getFilmWidth(); }

  		this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

  	},

  	toJSON: function ( meta ) {

  		var data = Object3D$1.prototype.toJSON.call( this, meta );

  		data.object.fov = this.fov;
  		data.object.zoom = this.zoom;

  		data.object.near = this.near;
  		data.object.far = this.far;
  		data.object.focus = this.focus;

  		data.object.aspect = this.aspect;

  		if ( this.view !== null ) { data.object.view = Object.assign( {}, this.view ); }

  		data.object.filmGauge = this.filmGauge;
  		data.object.filmOffset = this.filmOffset;

  		return data;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function ArrayCamera( array ) {

  	PerspectiveCamera$1.call( this );

  	this.cameras = array || [];

  }

  ArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera$1.prototype ), {

  	constructor: ArrayCamera,

  	isArrayCamera: true

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebVRManager( renderer ) {

  	var scope = this;

  	var device = null;
  	var frameData = null;

  	if ( 'VRFrameData' in window ) {

  		frameData = new window.VRFrameData();

  	}

  	var matrixWorldInverse = new Matrix4$1();

  	var standingMatrix = new Matrix4$1();
  	var standingMatrixInverse = new Matrix4$1();

  	var cameraL = new PerspectiveCamera$1();
  	cameraL.bounds = new Vector4$1( 0.0, 0.0, 0.5, 1.0 );
  	cameraL.layers.enable( 1 );

  	var cameraR = new PerspectiveCamera$1();
  	cameraR.bounds = new Vector4$1( 0.5, 0.0, 0.5, 1.0 );
  	cameraR.layers.enable( 2 );

  	var cameraVR = new ArrayCamera( [ cameraL, cameraR ] );
  	cameraVR.layers.enable( 1 );
  	cameraVR.layers.enable( 2 );

  	//

  	var currentSize, currentPixelRatio;

  	function onVRDisplayPresentChange() {

  		if ( device !== null && device.isPresenting ) {

  			var eyeParameters = device.getEyeParameters( 'left' );
  			var renderWidth = eyeParameters.renderWidth;
  			var renderHeight = eyeParameters.renderHeight;

  			currentPixelRatio = renderer.getPixelRatio();
  			currentSize = renderer.getSize();

  			renderer.setDrawingBufferSize( renderWidth * 2, renderHeight, 1 );

  		} else if ( scope.enabled ) {

  			renderer.setDrawingBufferSize( currentSize.width, currentSize.height, currentPixelRatio );

  		}

  	}

  	window.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false );

  	//

  	this.enabled = false;
  	this.standing = false;

  	this.getDevice = function () {

  		return device;

  	};

  	this.setDevice = function ( value ) {

  		if ( value !== undefined ) { device = value; }

  	};

  	this.getCamera = function ( camera ) {

  		if ( device === null ) { return camera; }

  		device.depthNear = camera.near;
  		device.depthFar = camera.far;

  		device.getFrameData( frameData );

  		//

  		var pose = frameData.pose;

  		if ( pose.position !== null ) {

  			camera.position.fromArray( pose.position );

  		} else {

  			camera.position.set( 0, 0, 0 );

  		}

  		if ( pose.orientation !== null ) {

  			camera.quaternion.fromArray( pose.orientation );

  		}

  		camera.updateMatrixWorld();

  		var stageParameters = device.stageParameters;

  		if ( this.standing && stageParameters ) {

  			standingMatrix.fromArray( stageParameters.sittingToStandingTransform );
  			standingMatrixInverse.getInverse( standingMatrix );

  			camera.matrixWorld.multiply( standingMatrix );
  			camera.matrixWorldInverse.multiply( standingMatrixInverse );

  		}

  		if ( device.isPresenting === false ) { return camera; }

  		//

  		cameraL.near = camera.near;
  		cameraR.near = camera.near;

  		cameraL.far = camera.far;
  		cameraR.far = camera.far;

  		cameraVR.matrixWorld.copy( camera.matrixWorld );
  		cameraVR.matrixWorldInverse.copy( camera.matrixWorldInverse );

  		cameraL.matrixWorldInverse.fromArray( frameData.leftViewMatrix );
  		cameraR.matrixWorldInverse.fromArray( frameData.rightViewMatrix );

  		if ( this.standing && stageParameters ) {

  			cameraL.matrixWorldInverse.multiply( standingMatrixInverse );
  			cameraR.matrixWorldInverse.multiply( standingMatrixInverse );

  		}

  		var parent = camera.parent;

  		if ( parent !== null ) {

  			matrixWorldInverse.getInverse( parent.matrixWorld );

  			cameraL.matrixWorldInverse.multiply( matrixWorldInverse );
  			cameraR.matrixWorldInverse.multiply( matrixWorldInverse );

  		}

  		// envMap and Mirror needs camera.matrixWorld

  		cameraL.matrixWorld.getInverse( cameraL.matrixWorldInverse );
  		cameraR.matrixWorld.getInverse( cameraR.matrixWorldInverse );

  		cameraL.projectionMatrix.fromArray( frameData.leftProjectionMatrix );
  		cameraR.projectionMatrix.fromArray( frameData.rightProjectionMatrix );

  		// HACK @mrdoob
  		// https://github.com/w3c/webvr/issues/203

  		cameraVR.projectionMatrix.copy( cameraL.projectionMatrix );

  		//

  		var layers = device.getLayers();

  		if ( layers.length ) {

  			var layer = layers[ 0 ];

  			if ( layer.leftBounds !== null && layer.leftBounds.length === 4 ) {

  				cameraL.bounds.fromArray( layer.leftBounds );

  			}

  			if ( layer.rightBounds !== null && layer.rightBounds.length === 4 ) {

  				cameraR.bounds.fromArray( layer.rightBounds );

  			}

  		}

  		return cameraVR;

  	};

  	this.getStandingMatrix = function () {

  		return standingMatrix;

  	};

  	this.submitFrame = function () {

  		if ( device && device.isPresenting ) { device.submitFrame(); }

  	};

  	this.dispose = function () {

  		window.removeEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange );

  	};

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLExtensions( gl ) {

  	var extensions = {};

  	return {

  		get: function ( name ) {

  			if ( extensions[ name ] !== undefined ) {

  				return extensions[ name ];

  			}

  			var extension;

  			switch ( name ) {

  				case 'WEBGL_depth_texture':
  					extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
  					break;

  				case 'EXT_texture_filter_anisotropic':
  					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
  					break;

  				case 'WEBGL_compressed_texture_s3tc':
  					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
  					break;

  				case 'WEBGL_compressed_texture_pvrtc':
  					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
  					break;

  				case 'WEBGL_compressed_texture_etc1':
  					extension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );
  					break;

  				default:
  					extension = gl.getExtension( name );

  			}

  			if ( extension === null ) {

  				console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

  			}

  			extensions[ name ] = extension;

  			return extension;

  		}

  	};

  }

  /**
   * @author tschw
   */

  function WebGLClipping() {

  	var scope = this,

  		globalState = null,
  		numGlobalPlanes = 0,
  		localClippingEnabled = false,
  		renderingShadows = false,

  		plane = new Plane$1(),
  		viewNormalMatrix = new Matrix3$1(),

  		uniform = { value: null, needsUpdate: false };

  	this.uniform = uniform;
  	this.numPlanes = 0;
  	this.numIntersection = 0;

  	this.init = function ( planes, enableLocalClipping, camera ) {

  		var enabled =
  			planes.length !== 0 ||
  			enableLocalClipping ||
  			// enable state of previous frame - the clipping code has to
  			// run another frame in order to reset the state:
  			numGlobalPlanes !== 0 ||
  			localClippingEnabled;

  		localClippingEnabled = enableLocalClipping;

  		globalState = projectPlanes( planes, camera, 0 );
  		numGlobalPlanes = planes.length;

  		return enabled;

  	};

  	this.beginShadows = function () {

  		renderingShadows = true;
  		projectPlanes( null );

  	};

  	this.endShadows = function () {

  		renderingShadows = false;
  		resetGlobalState();

  	};

  	this.setState = function ( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {

  		if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

  			// there's no local clipping

  			if ( renderingShadows ) {

  				// there's no global clipping

  				projectPlanes( null );

  			} else {

  				resetGlobalState();

  			}

  		} else {

  			var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
  				lGlobal = nGlobal * 4,

  				dstArray = cache.clippingState || null;

  			uniform.value = dstArray; // ensure unique state

  			dstArray = projectPlanes( planes, camera, lGlobal, fromCache );

  			for ( var i = 0; i !== lGlobal; ++ i ) {

  				dstArray[ i ] = globalState[ i ];

  			}

  			cache.clippingState = dstArray;
  			this.numIntersection = clipIntersection ? this.numPlanes : 0;
  			this.numPlanes += nGlobal;

  		}


  	};

  	function resetGlobalState() {

  		if ( uniform.value !== globalState ) {

  			uniform.value = globalState;
  			uniform.needsUpdate = numGlobalPlanes > 0;

  		}

  		scope.numPlanes = numGlobalPlanes;
  		scope.numIntersection = 0;

  	}

  	function projectPlanes( planes, camera, dstOffset, skipTransform ) {

  		var nPlanes = planes !== null ? planes.length : 0,
  			dstArray = null;

  		if ( nPlanes !== 0 ) {

  			dstArray = uniform.value;

  			if ( skipTransform !== true || dstArray === null ) {

  				var flatSize = dstOffset + nPlanes * 4,
  					viewMatrix = camera.matrixWorldInverse;

  				viewNormalMatrix.getNormalMatrix( viewMatrix );

  				if ( dstArray === null || dstArray.length < flatSize ) {

  					dstArray = new Float32Array( flatSize );

  				}

  				for ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

  					plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

  					plane.normal.toArray( dstArray, i4 );
  					dstArray[ i4 + 3 ] = plane.constant;

  				}

  			}

  			uniform.value = dstArray;
  			uniform.needsUpdate = true;

  		}

  		scope.numPlanes = nPlanes;

  		return dstArray;

  	}

  }

  /**
   * @author thespite / http://www.twitter.com/thespite
   */

  function WebGLUtils( gl, extensions ) {

  	function convert( p ) {

  		var extension;

  		if ( p === RepeatWrapping$1 ) { return gl.REPEAT; }
  		if ( p === ClampToEdgeWrapping$1 ) { return gl.CLAMP_TO_EDGE; }
  		if ( p === MirroredRepeatWrapping$1 ) { return gl.MIRRORED_REPEAT; }

  		if ( p === NearestFilter$1 ) { return gl.NEAREST; }
  		if ( p === NearestMipMapNearestFilter$1 ) { return gl.NEAREST_MIPMAP_NEAREST; }
  		if ( p === NearestMipMapLinearFilter$1 ) { return gl.NEAREST_MIPMAP_LINEAR; }

  		if ( p === LinearFilter$1 ) { return gl.LINEAR; }
  		if ( p === LinearMipMapNearestFilter$1 ) { return gl.LINEAR_MIPMAP_NEAREST; }
  		if ( p === LinearMipMapLinearFilter$1 ) { return gl.LINEAR_MIPMAP_LINEAR; }

  		if ( p === UnsignedByteType$1 ) { return gl.UNSIGNED_BYTE; }
  		if ( p === UnsignedShort4444Type$1 ) { return gl.UNSIGNED_SHORT_4_4_4_4; }
  		if ( p === UnsignedShort5551Type$1 ) { return gl.UNSIGNED_SHORT_5_5_5_1; }
  		if ( p === UnsignedShort565Type$1 ) { return gl.UNSIGNED_SHORT_5_6_5; }

  		if ( p === ByteType$1 ) { return gl.BYTE; }
  		if ( p === ShortType$1 ) { return gl.SHORT; }
  		if ( p === UnsignedShortType$1 ) { return gl.UNSIGNED_SHORT; }
  		if ( p === IntType$1 ) { return gl.INT; }
  		if ( p === UnsignedIntType$1 ) { return gl.UNSIGNED_INT; }
  		if ( p === FloatType$1 ) { return gl.FLOAT; }

  		if ( p === HalfFloatType$1 ) {

  			extension = extensions.get( 'OES_texture_half_float' );

  			if ( extension !== null ) { return extension.HALF_FLOAT_OES; }

  		}

  		if ( p === AlphaFormat$1 ) { return gl.ALPHA; }
  		if ( p === RGBFormat$1 ) { return gl.RGB; }
  		if ( p === RGBAFormat$1 ) { return gl.RGBA; }
  		if ( p === LuminanceFormat$1 ) { return gl.LUMINANCE; }
  		if ( p === LuminanceAlphaFormat$1 ) { return gl.LUMINANCE_ALPHA; }
  		if ( p === DepthFormat$1 ) { return gl.DEPTH_COMPONENT; }
  		if ( p === DepthStencilFormat$1 ) { return gl.DEPTH_STENCIL; }

  		if ( p === AddEquation$1 ) { return gl.FUNC_ADD; }
  		if ( p === SubtractEquation$1 ) { return gl.FUNC_SUBTRACT; }
  		if ( p === ReverseSubtractEquation$1 ) { return gl.FUNC_REVERSE_SUBTRACT; }

  		if ( p === ZeroFactor$1 ) { return gl.ZERO; }
  		if ( p === OneFactor$1 ) { return gl.ONE; }
  		if ( p === SrcColorFactor$1 ) { return gl.SRC_COLOR; }
  		if ( p === OneMinusSrcColorFactor$1 ) { return gl.ONE_MINUS_SRC_COLOR; }
  		if ( p === SrcAlphaFactor$1 ) { return gl.SRC_ALPHA; }
  		if ( p === OneMinusSrcAlphaFactor$1 ) { return gl.ONE_MINUS_SRC_ALPHA; }
  		if ( p === DstAlphaFactor$1 ) { return gl.DST_ALPHA; }
  		if ( p === OneMinusDstAlphaFactor$1 ) { return gl.ONE_MINUS_DST_ALPHA; }

  		if ( p === DstColorFactor$1 ) { return gl.DST_COLOR; }
  		if ( p === OneMinusDstColorFactor$1 ) { return gl.ONE_MINUS_DST_COLOR; }
  		if ( p === SrcAlphaSaturateFactor$1 ) { return gl.SRC_ALPHA_SATURATE; }

  		if ( p === RGB_S3TC_DXT1_Format$1 || p === RGBA_S3TC_DXT1_Format$1 ||
  			p === RGBA_S3TC_DXT3_Format$1 || p === RGBA_S3TC_DXT5_Format$1 ) {

  			extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

  			if ( extension !== null ) {

  				if ( p === RGB_S3TC_DXT1_Format$1 ) { return extension.COMPRESSED_RGB_S3TC_DXT1_EXT; }
  				if ( p === RGBA_S3TC_DXT1_Format$1 ) { return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT; }
  				if ( p === RGBA_S3TC_DXT3_Format$1 ) { return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT; }
  				if ( p === RGBA_S3TC_DXT5_Format$1 ) { return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT; }

  			}

  		}

  		if ( p === RGB_PVRTC_4BPPV1_Format$1 || p === RGB_PVRTC_2BPPV1_Format$1 ||
  			p === RGBA_PVRTC_4BPPV1_Format$1 || p === RGBA_PVRTC_2BPPV1_Format$1 ) {

  			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

  			if ( extension !== null ) {

  				if ( p === RGB_PVRTC_4BPPV1_Format$1 ) { return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; }
  				if ( p === RGB_PVRTC_2BPPV1_Format$1 ) { return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; }
  				if ( p === RGBA_PVRTC_4BPPV1_Format$1 ) { return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; }
  				if ( p === RGBA_PVRTC_2BPPV1_Format$1 ) { return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG; }

  			}

  		}

  		if ( p === RGB_ETC1_Format$1 ) {

  			extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

  			if ( extension !== null ) { return extension.COMPRESSED_RGB_ETC1_WEBGL; }

  		}

  		if ( p === MinEquation$1 || p === MaxEquation$1 ) {

  			extension = extensions.get( 'EXT_blend_minmax' );

  			if ( extension !== null ) {

  				if ( p === MinEquation$1 ) { return extension.MIN_EXT; }
  				if ( p === MaxEquation$1 ) { return extension.MAX_EXT; }

  			}

  		}

  		if ( p === UnsignedInt248Type$1 ) {

  			extension = extensions.get( 'WEBGL_depth_texture' );

  			if ( extension !== null ) { return extension.UNSIGNED_INT_24_8_WEBGL; }

  		}

  		return 0;

  	}

  	return { convert: convert };

  }

  /**
   * @author supereggbert / http://www.paulbrunt.co.uk/
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   * @author szimek / https://github.com/szimek/
   * @author tschw
   */

  function WebGLRenderer( parameters ) {

  	console.log( 'THREE.WebGLRenderer', REVISION$1 );

  	parameters = parameters || {};

  	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
  		_context = parameters.context !== undefined ? parameters.context : null,

  		_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
  		_depth = parameters.depth !== undefined ? parameters.depth : true,
  		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
  		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
  		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
  		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;

  	var lightsArray = [];
  	var shadowsArray = [];

  	var currentRenderList = null;

  	var spritesArray = [];
  	var flaresArray = [];

  	// public properties

  	this.domElement = _canvas;
  	this.context = null;

  	// clearing

  	this.autoClear = true;
  	this.autoClearColor = true;
  	this.autoClearDepth = true;
  	this.autoClearStencil = true;

  	// scene graph

  	this.sortObjects = true;

  	// user-defined clipping

  	this.clippingPlanes = [];
  	this.localClippingEnabled = false;

  	// physically based shading

  	this.gammaFactor = 2.0;	// for backwards compatibility
  	this.gammaInput = false;
  	this.gammaOutput = false;

  	// physical lights

  	this.physicallyCorrectLights = false;

  	// tone mapping

  	this.toneMapping = LinearToneMapping$1;
  	this.toneMappingExposure = 1.0;
  	this.toneMappingWhitePoint = 1.0;

  	// morphs

  	this.maxMorphTargets = 8;
  	this.maxMorphNormals = 4;

  	// internal properties

  	var _this = this,

  		_isContextLost = false,

  		// internal state cache

  		_currentRenderTarget = null,
  		_currentFramebuffer = null,
  		_currentMaterialId = - 1,
  		_currentGeometryProgram = '',

  		_currentCamera = null,
  		_currentArrayCamera = null,

  		_currentViewport = new Vector4$1(),
  		_currentScissor = new Vector4$1(),
  		_currentScissorTest = null,

  		//

  		_usedTextureUnits = 0,

  		//

  		_width = _canvas.width,
  		_height = _canvas.height,

  		_pixelRatio = 1,

  		_viewport = new Vector4$1( 0, 0, _width, _height ),
  		_scissor = new Vector4$1( 0, 0, _width, _height ),
  		_scissorTest = false,

  		// frustum

  		_frustum = new Frustum(),

  		// clipping

  		_clipping = new WebGLClipping(),
  		_clippingEnabled = false,
  		_localClippingEnabled = false,

  		// camera matrices cache

  		_projScreenMatrix = new Matrix4$1(),

  		_vector3 = new Vector3$2(),

  		// info

  		_infoMemory = {
  			geometries: 0,
  			textures: 0
  		},

  		_infoRender = {

  			frame: 0,
  			calls: 0,
  			vertices: 0,
  			faces: 0,
  			points: 0

  		};

  	this.info = {

  		render: _infoRender,
  		memory: _infoMemory,
  		programs: null

  	};

  	function getTargetPixelRatio() {

  		return _currentRenderTarget === null ? _pixelRatio : 1;

  	}

  	// initialize

  	var _gl;

  	try {

  		var contextAttributes = {
  			alpha: _alpha,
  			depth: _depth,
  			stencil: _stencil,
  			antialias: _antialias,
  			premultipliedAlpha: _premultipliedAlpha,
  			preserveDrawingBuffer: _preserveDrawingBuffer
  		};

  		_gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );

  		if ( _gl === null ) {

  			if ( _canvas.getContext( 'webgl' ) !== null ) {

  				throw 'Error creating WebGL context with your selected attributes.';

  			} else {

  				throw 'Error creating WebGL context.';

  			}

  		}

  		// Some experimental-webgl implementations do not have getShaderPrecisionFormat

  		if ( _gl.getShaderPrecisionFormat === undefined ) {

  			_gl.getShaderPrecisionFormat = function () {

  				return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

  			};

  		}

  		_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
  		_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );

  	} catch ( error ) {

  		console.error( 'THREE.WebGLRenderer: ' + error );

  	}

  	var extensions, capabilities, state;
  	var properties, textures, attributes, geometries, objects, lights;
  	var programCache, renderLists;

  	var background, morphtargets, bufferRenderer, indexedBufferRenderer;
  	var flareRenderer, spriteRenderer;

  	var utils;

  	function initGLContext() {

  		extensions = new WebGLExtensions( _gl );
  		extensions.get( 'WEBGL_depth_texture' );
  		extensions.get( 'OES_texture_float' );
  		extensions.get( 'OES_texture_float_linear' );
  		extensions.get( 'OES_texture_half_float' );
  		extensions.get( 'OES_texture_half_float_linear' );
  		extensions.get( 'OES_standard_derivatives' );
  		extensions.get( 'ANGLE_instanced_arrays' );

  		if ( extensions.get( 'OES_element_index_uint' ) ) {

  			BufferGeometry$1.MaxIndex = 4294967296;

  		}

  		utils = new WebGLUtils( _gl, extensions );

  		capabilities = new WebGLCapabilities( _gl, extensions, parameters );

  		state = new WebGLState( _gl, extensions, utils );
  		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
  		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

  		properties = new WebGLProperties();
  		textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, _infoMemory );
  		attributes = new WebGLAttributes( _gl );
  		geometries = new WebGLGeometries( _gl, attributes, _infoMemory );
  		objects = new WebGLObjects( geometries, _infoRender );
  		morphtargets = new WebGLMorphtargets( _gl );
  		programCache = new WebGLPrograms( _this, extensions, capabilities );
  		lights = new WebGLLights();
  		renderLists = new WebGLRenderLists();

  		background = new WebGLBackground( _this, state, geometries, _premultipliedAlpha );

  		bufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );
  		indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );

  		flareRenderer = new WebGLFlareRenderer( _this, _gl, state, textures, capabilities );
  		spriteRenderer = new WebGLSpriteRenderer( _this, _gl, state, textures, capabilities );

  		_this.info.programs = programCache.programs;

  		_this.context = _gl;
  		_this.capabilities = capabilities;
  		_this.extensions = extensions;
  		_this.properties = properties;
  		_this.renderLists = renderLists;
  		_this.state = state;

  	}

  	initGLContext();

  	// vr

  	var vr = new WebVRManager( _this );

  	this.vr = vr;

  	// shadow map

  	var shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );

  	this.shadowMap = shadowMap;

  	// API

  	this.getContext = function () {

  		return _gl;

  	};

  	this.getContextAttributes = function () {

  		return _gl.getContextAttributes();

  	};

  	this.forceContextLoss = function () {

  		var extension = extensions.get( 'WEBGL_lose_context' );
  		if ( extension ) { extension.loseContext(); }

  	};

  	this.forceContextRestore = function () {

  		var extension = extensions.get( 'WEBGL_lose_context' );
  		if ( extension ) { extension.restoreContext(); }

  	};

  	this.getPixelRatio = function () {

  		return _pixelRatio;

  	};

  	this.setPixelRatio = function ( value ) {

  		if ( value === undefined ) { return; }

  		_pixelRatio = value;

  		this.setSize( _width, _height, false );

  	};

  	this.getSize = function () {

  		return {
  			width: _width,
  			height: _height
  		};

  	};

  	this.setSize = function ( width, height, updateStyle ) {

  		var device = vr.getDevice();

  		if ( device && device.isPresenting ) {

  			console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
  			return;

  		}

  		_width = width;
  		_height = height;

  		_canvas.width = width * _pixelRatio;
  		_canvas.height = height * _pixelRatio;

  		if ( updateStyle !== false ) {

  			_canvas.style.width = width + 'px';
  			_canvas.style.height = height + 'px';

  		}

  		this.setViewport( 0, 0, width, height );

  	};

  	this.getDrawingBufferSize = function () {

  		return {
  			width: _width * _pixelRatio,
  			height: _height * _pixelRatio
  		};

  	};

  	this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

  		_width = width;
  		_height = height;

  		_pixelRatio = pixelRatio;

  		_canvas.width = width * pixelRatio;
  		_canvas.height = height * pixelRatio;

  		this.setViewport( 0, 0, width, height );

  	};

  	this.setViewport = function ( x, y, width, height ) {

  		_viewport.set( x, _height - y - height, width, height );
  		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

  	};

  	this.setScissor = function ( x, y, width, height ) {

  		_scissor.set( x, _height - y - height, width, height );
  		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );

  	};

  	this.setScissorTest = function ( boolean ) {

  		state.setScissorTest( _scissorTest = boolean );

  	};

  	// Clearing

  	this.getClearColor = background.getClearColor;
  	this.setClearColor = background.setClearColor;
  	this.getClearAlpha = background.getClearAlpha;
  	this.setClearAlpha = background.setClearAlpha;

  	this.clear = function ( color, depth, stencil ) {

  		var bits = 0;

  		if ( color === undefined || color ) { bits |= _gl.COLOR_BUFFER_BIT; }
  		if ( depth === undefined || depth ) { bits |= _gl.DEPTH_BUFFER_BIT; }
  		if ( stencil === undefined || stencil ) { bits |= _gl.STENCIL_BUFFER_BIT; }

  		_gl.clear( bits );

  	};

  	this.clearColor = function () {

  		this.clear( true, false, false );

  	};

  	this.clearDepth = function () {

  		this.clear( false, true, false );

  	};

  	this.clearStencil = function () {

  		this.clear( false, false, true );

  	};

  	this.clearTarget = function ( renderTarget, color, depth, stencil ) {

  		this.setRenderTarget( renderTarget );
  		this.clear( color, depth, stencil );

  	};

  	//

  	this.dispose = function () {

  		_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
  		_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );

  		renderLists.dispose();

  		vr.dispose();

  	};

  	// Events

  	function onContextLost( event ) {

  		event.preventDefault();

  		console.log( 'THREE.WebGLRenderer: Context Lost.' );

  		_isContextLost = true;

  	}

  	function onContextRestore( /* event */ ) {

  		console.log( 'THREE.WebGLRenderer: Context Restored.' );

  		_isContextLost = false;

  		initGLContext();

  	}

  	function onMaterialDispose( event ) {

  		var material = event.target;

  		material.removeEventListener( 'dispose', onMaterialDispose );

  		deallocateMaterial( material );

  	}

  	// Buffer deallocation

  	function deallocateMaterial( material ) {

  		releaseMaterialProgramReference( material );

  		properties.remove( material );

  	}


  	function releaseMaterialProgramReference( material ) {

  		var programInfo = properties.get( material ).program;

  		material.program = undefined;

  		if ( programInfo !== undefined ) {

  			programCache.releaseProgram( programInfo );

  		}

  	}

  	// Buffer rendering

  	function renderObjectImmediate( object, program, material ) {

  		object.render( function ( object ) {

  			_this.renderBufferImmediate( object, program, material );

  		} );

  	}

  	this.renderBufferImmediate = function ( object, program, material ) {

  		state.initAttributes();

  		var buffers = properties.get( object );

  		if ( object.hasPositions && ! buffers.position ) { buffers.position = _gl.createBuffer(); }
  		if ( object.hasNormals && ! buffers.normal ) { buffers.normal = _gl.createBuffer(); }
  		if ( object.hasUvs && ! buffers.uv ) { buffers.uv = _gl.createBuffer(); }
  		if ( object.hasColors && ! buffers.color ) { buffers.color = _gl.createBuffer(); }

  		var programAttributes = program.getAttributes();

  		if ( object.hasPositions ) {

  			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
  			_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

  			state.enableAttribute( programAttributes.position );
  			_gl.vertexAttribPointer( programAttributes.position, 3, _gl.FLOAT, false, 0, 0 );

  		}

  		if ( object.hasNormals ) {

  			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );

  			if ( ! material.isMeshPhongMaterial &&
  				! material.isMeshStandardMaterial &&
  				! material.isMeshNormalMaterial &&
  				material.flatShading === true ) {

  				for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {

  					var array = object.normalArray;

  					var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
  					var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
  					var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;

  					array[ i + 0 ] = nx;
  					array[ i + 1 ] = ny;
  					array[ i + 2 ] = nz;

  					array[ i + 3 ] = nx;
  					array[ i + 4 ] = ny;
  					array[ i + 5 ] = nz;

  					array[ i + 6 ] = nx;
  					array[ i + 7 ] = ny;
  					array[ i + 8 ] = nz;

  				}

  			}

  			_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

  			state.enableAttribute( programAttributes.normal );

  			_gl.vertexAttribPointer( programAttributes.normal, 3, _gl.FLOAT, false, 0, 0 );

  		}

  		if ( object.hasUvs && material.map ) {

  			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
  			_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

  			state.enableAttribute( programAttributes.uv );

  			_gl.vertexAttribPointer( programAttributes.uv, 2, _gl.FLOAT, false, 0, 0 );

  		}

  		if ( object.hasColors && material.vertexColors !== NoColors$1 ) {

  			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
  			_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

  			state.enableAttribute( programAttributes.color );

  			_gl.vertexAttribPointer( programAttributes.color, 3, _gl.FLOAT, false, 0, 0 );

  		}

  		state.disableUnusedAttributes();

  		_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

  		object.count = 0;

  	};

  	this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {

  		state.setMaterial( material );

  		var program = setProgram( camera, fog, material, object );
  		var geometryProgram = geometry.id + '_' + program.id + '_' + ( material.wireframe === true );

  		var updateBuffers = false;

  		if ( geometryProgram !== _currentGeometryProgram ) {

  			_currentGeometryProgram = geometryProgram;
  			updateBuffers = true;

  		}

  		if ( object.morphTargetInfluences ) {

  			morphtargets.update( object, geometry, material, program );

  			updateBuffers = true;

  		}

  		//

  		var index = geometry.index;
  		var position = geometry.attributes.position;
  		var rangeFactor = 1;

  		if ( material.wireframe === true ) {

  			index = geometries.getWireframeAttribute( geometry );
  			rangeFactor = 2;

  		}

  		var attribute;
  		var renderer = bufferRenderer;

  		if ( index !== null ) {

  			attribute = attributes.get( index );

  			renderer = indexedBufferRenderer;
  			renderer.setIndex( attribute );

  		}

  		if ( updateBuffers ) {

  			setupVertexAttributes( material, program, geometry );

  			if ( index !== null ) {

  				_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, attribute.buffer );

  			}

  		}

  		//

  		var dataCount = 0;

  		if ( index !== null ) {

  			dataCount = index.count;

  		} else if ( position !== undefined ) {

  			dataCount = position.count;

  		}

  		var rangeStart = geometry.drawRange.start * rangeFactor;
  		var rangeCount = geometry.drawRange.count * rangeFactor;

  		var groupStart = group !== null ? group.start * rangeFactor : 0;
  		var groupCount = group !== null ? group.count * rangeFactor : Infinity;

  		var drawStart = Math.max( rangeStart, groupStart );
  		var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

  		var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

  		if ( drawCount === 0 ) { return; }

  		//

  		if ( object.isMesh ) {

  			if ( material.wireframe === true ) {

  				state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
  				renderer.setMode( _gl.LINES );

  			} else {

  				switch ( object.drawMode ) {

  					case TrianglesDrawMode$1:
  						renderer.setMode( _gl.TRIANGLES );
  						break;

  					case TriangleStripDrawMode$1:
  						renderer.setMode( _gl.TRIANGLE_STRIP );
  						break;

  					case TriangleFanDrawMode$1:
  						renderer.setMode( _gl.TRIANGLE_FAN );
  						break;

  				}

  			}


  		} else if ( object.isLine ) {

  			var lineWidth = material.linewidth;

  			if ( lineWidth === undefined ) { lineWidth = 1; } // Not using Line*Material

  			state.setLineWidth( lineWidth * getTargetPixelRatio() );

  			if ( object.isLineSegments ) {

  				renderer.setMode( _gl.LINES );

  			} else if ( object.isLineLoop ) {

  				renderer.setMode( _gl.LINE_LOOP );

  			} else {

  				renderer.setMode( _gl.LINE_STRIP );

  			}

  		} else if ( object.isPoints ) {

  			renderer.setMode( _gl.POINTS );

  		}

  		if ( geometry && geometry.isInstancedBufferGeometry ) {

  			if ( geometry.maxInstancedCount > 0 ) {

  				renderer.renderInstances( geometry, drawStart, drawCount );

  			}

  		} else {

  			renderer.render( drawStart, drawCount );

  		}

  	};

  	function setupVertexAttributes( material, program, geometry, startIndex ) {

  		if ( geometry && geometry.isInstancedBufferGeometry ) {

  			if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) {

  				console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
  				return;

  			}

  		}

  		if ( startIndex === undefined ) { startIndex = 0; }

  		state.initAttributes();

  		var geometryAttributes = geometry.attributes;

  		var programAttributes = program.getAttributes();

  		var materialDefaultAttributeValues = material.defaultAttributeValues;

  		for ( var name in programAttributes ) {

  			var programAttribute = programAttributes[ name ];

  			if ( programAttribute >= 0 ) {

  				var geometryAttribute = geometryAttributes[ name ];

  				if ( geometryAttribute !== undefined ) {

  					var normalized = geometryAttribute.normalized;
  					var size = geometryAttribute.itemSize;

  					var attribute = attributes.get( geometryAttribute );

  					// TODO Attribute may not be available on context restore

  					if ( attribute === undefined ) { continue; }

  					var buffer = attribute.buffer;
  					var type = attribute.type;
  					var bytesPerElement = attribute.bytesPerElement;

  					if ( geometryAttribute.isInterleavedBufferAttribute ) {

  						var data = geometryAttribute.data;
  						var stride = data.stride;
  						var offset = geometryAttribute.offset;

  						if ( data && data.isInstancedInterleavedBuffer ) {

  							state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );

  							if ( geometry.maxInstancedCount === undefined ) {

  								geometry.maxInstancedCount = data.meshPerAttribute * data.count;

  							}

  						} else {

  							state.enableAttribute( programAttribute );

  						}

  						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
  						_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, ( startIndex * stride + offset ) * bytesPerElement );

  					} else {

  						if ( geometryAttribute.isInstancedBufferAttribute ) {

  							state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );

  							if ( geometry.maxInstancedCount === undefined ) {

  								geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

  							}

  						} else {

  							state.enableAttribute( programAttribute );

  						}

  						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
  						_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * bytesPerElement );

  					}

  				} else if ( materialDefaultAttributeValues !== undefined ) {

  					var value = materialDefaultAttributeValues[ name ];

  					if ( value !== undefined ) {

  						switch ( value.length ) {

  							case 2:
  								_gl.vertexAttrib2fv( programAttribute, value );
  								break;

  							case 3:
  								_gl.vertexAttrib3fv( programAttribute, value );
  								break;

  							case 4:
  								_gl.vertexAttrib4fv( programAttribute, value );
  								break;

  							default:
  								_gl.vertexAttrib1fv( programAttribute, value );

  						}

  					}

  				}

  			}

  		}

  		state.disableUnusedAttributes();

  	}

  	// Compile

  	this.compile = function ( scene, camera ) {

  		lightsArray.length = 0;
  		shadowsArray.length = 0;

  		scene.traverse( function ( object ) {

  			if ( object.isLight ) {

  				lightsArray.push( object );

  				if ( object.castShadow ) {

  					shadowsArray.push( object );

  				}

  			}

  		} );

  		lights.setup( lightsArray, shadowsArray, camera );

  		scene.traverse( function ( object ) {

  			if ( object.material ) {

  				if ( Array.isArray( object.material ) ) {

  					for ( var i = 0; i < object.material.length; i ++ ) {

  						initMaterial( object.material[ i ], scene.fog, object );

  					}

  				} else {

  					initMaterial( object.material, scene.fog, object );

  				}

  			}

  		} );

  	};

  	// Animation Loop

  	var isAnimating = false;
  	var onAnimationFrame = null;

  	function start() {

  		if ( isAnimating ) { return; }
  		( vr.getDevice() || window ).requestAnimationFrame( loop );
  		isAnimating = true;

  	}

  	function loop( time ) {

  		if ( onAnimationFrame !== null ) { onAnimationFrame( time ); }
  		( vr.getDevice() || window ).requestAnimationFrame( loop );

  	}

  	this.animate = function ( callback ) {

  		onAnimationFrame = callback;
  		start();

  	};

  	// Rendering

  	this.render = function ( scene, camera, renderTarget, forceClear ) {

  		if ( ! ( camera && camera.isCamera ) ) {

  			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
  			return;

  		}

  		if ( _isContextLost ) { return; }

  		// reset caching for this frame

  		_currentGeometryProgram = '';
  		_currentMaterialId = - 1;
  		_currentCamera = null;

  		// update scene graph

  		if ( scene.autoUpdate === true ) { scene.updateMatrixWorld(); }

  		// update camera matrices and frustum

  		if ( camera.parent === null ) { camera.updateMatrixWorld(); }

  		if ( vr.enabled ) {

  			camera = vr.getCamera( camera );

  		}

  		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
  		_frustum.setFromMatrix( _projScreenMatrix );

  		lightsArray.length = 0;
  		shadowsArray.length = 0;

  		spritesArray.length = 0;
  		flaresArray.length = 0;

  		_localClippingEnabled = this.localClippingEnabled;
  		_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

  		currentRenderList = renderLists.get( scene, camera );
  		currentRenderList.init();

  		projectObject( scene, camera, _this.sortObjects );

  		if ( _this.sortObjects === true ) {

  			currentRenderList.sort();

  		}

  		//

  		if ( _clippingEnabled ) { _clipping.beginShadows(); }

  		shadowMap.render( shadowsArray, scene, camera );

  		lights.setup( lightsArray, shadowsArray, camera );

  		if ( _clippingEnabled ) { _clipping.endShadows(); }

  		//

  		_infoRender.frame ++;
  		_infoRender.calls = 0;
  		_infoRender.vertices = 0;
  		_infoRender.faces = 0;
  		_infoRender.points = 0;

  		if ( renderTarget === undefined ) {

  			renderTarget = null;

  		}

  		this.setRenderTarget( renderTarget );

  		//

  		background.render( currentRenderList, scene, camera, forceClear );

  		// render scene

  		var opaqueObjects = currentRenderList.opaque;
  		var transparentObjects = currentRenderList.transparent;

  		if ( scene.overrideMaterial ) {

  			var overrideMaterial = scene.overrideMaterial;

  			if ( opaqueObjects.length ) { renderObjects( opaqueObjects, scene, camera, overrideMaterial ); }
  			if ( transparentObjects.length ) { renderObjects( transparentObjects, scene, camera, overrideMaterial ); }

  		} else {

  			// opaque pass (front-to-back order)

  			if ( opaqueObjects.length ) { renderObjects( opaqueObjects, scene, camera ); }

  			// transparent pass (back-to-front order)

  			if ( transparentObjects.length ) { renderObjects( transparentObjects, scene, camera ); }

  		}

  		// custom renderers

  		spriteRenderer.render( spritesArray, scene, camera );
  		flareRenderer.render( flaresArray, scene, camera, _currentViewport );

  		// Generate mipmap if we're using any kind of mipmap filtering

  		if ( renderTarget ) {

  			textures.updateRenderTargetMipmap( renderTarget );

  		}

  		// Ensure depth buffer writing is enabled so it can be cleared on next render

  		state.buffers.depth.setTest( true );
  		state.buffers.depth.setMask( true );
  		state.buffers.color.setMask( true );

  		state.setPolygonOffset( false );

  		if ( vr.enabled ) {

  			vr.submitFrame();

  		}

  		// _gl.finish();

  	};

  	/*
  	// TODO Duplicated code (Frustum)

  	var _sphere = new Sphere();

  	function isObjectViewable( object ) {

  		var geometry = object.geometry;

  		if ( geometry.boundingSphere === null )
  			geometry.computeBoundingSphere();

  		_sphere.copy( geometry.boundingSphere ).
  		applyMatrix4( object.matrixWorld );

  		return isSphereViewable( _sphere );

  	}

  	function isSpriteViewable( sprite ) {

  		_sphere.center.set( 0, 0, 0 );
  		_sphere.radius = 0.7071067811865476;
  		_sphere.applyMatrix4( sprite.matrixWorld );

  		return isSphereViewable( _sphere );

  	}

  	function isSphereViewable( sphere ) {

  		if ( ! _frustum.intersectsSphere( sphere ) ) return false;

  		var numPlanes = _clipping.numPlanes;

  		if ( numPlanes === 0 ) return true;

  		var planes = _this.clippingPlanes,

  			center = sphere.center,
  			negRad = - sphere.radius,
  			i = 0;

  		do {

  			// out when deeper than radius in the negative halfspace
  			if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;

  		} while ( ++ i !== numPlanes );

  		return true;

  	}
  	*/

  	function projectObject( object, camera, sortObjects ) {

  		if ( object.visible === false ) { return; }

  		var visible = object.layers.test( camera.layers );

  		if ( visible ) {

  			if ( object.isLight ) {

  				lightsArray.push( object );

  				if ( object.castShadow ) {

  					shadowsArray.push( object );

  				}

  			} else if ( object.isSprite ) {

  				if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

  					spritesArray.push( object );

  				}

  			} else if ( object.isLensFlare ) {

  				flaresArray.push( object );

  			} else if ( object.isImmediateRenderObject ) {

  				if ( sortObjects ) {

  					_vector3.setFromMatrixPosition( object.matrixWorld )
  						.applyMatrix4( _projScreenMatrix );

  				}

  				currentRenderList.push( object, null, object.material, _vector3.z, null );

  			} else if ( object.isMesh || object.isLine || object.isPoints ) {

  				if ( object.isSkinnedMesh ) {

  					object.skeleton.update();

  				}

  				if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

  					if ( sortObjects ) {

  						_vector3.setFromMatrixPosition( object.matrixWorld )
  							.applyMatrix4( _projScreenMatrix );

  					}

  					var geometry = objects.update( object );
  					var material = object.material;

  					if ( Array.isArray( material ) ) {

  						var groups = geometry.groups;

  						for ( var i = 0, l = groups.length; i < l; i ++ ) {

  							var group = groups[ i ];
  							var groupMaterial = material[ group.materialIndex ];

  							if ( groupMaterial && groupMaterial.visible ) {

  								currentRenderList.push( object, geometry, groupMaterial, _vector3.z, group );

  							}

  						}

  					} else if ( material.visible ) {

  						currentRenderList.push( object, geometry, material, _vector3.z, null );

  					}

  				}

  			}

  		}

  		var children = object.children;

  		for ( var i = 0, l = children.length; i < l; i ++ ) {

  			projectObject( children[ i ], camera, sortObjects );

  		}

  	}

  	function renderObjects( renderList, scene, camera, overrideMaterial ) {

  		for ( var i = 0, l = renderList.length; i < l; i ++ ) {

  			var renderItem = renderList[ i ];

  			var object = renderItem.object;
  			var geometry = renderItem.geometry;
  			var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
  			var group = renderItem.group;

  			if ( camera.isArrayCamera ) {

  				_currentArrayCamera = camera;

  				var cameras = camera.cameras;

  				for ( var j = 0, jl = cameras.length; j < jl; j ++ ) {

  					var camera2 = cameras[ j ];

  					if ( object.layers.test( camera2.layers ) ) {

  						var bounds = camera2.bounds;

  						var x = bounds.x * _width;
  						var y = bounds.y * _height;
  						var width = bounds.z * _width;
  						var height = bounds.w * _height;

  						state.viewport( _currentViewport.set( x, y, width, height ).multiplyScalar( _pixelRatio ) );

  						renderObject( object, scene, camera2, geometry, material, group );

  					}

  				}

  			} else {

  				_currentArrayCamera = null;

  				renderObject( object, scene, camera, geometry, material, group );

  			}

  		}

  	}

  	function renderObject( object, scene, camera, geometry, material, group ) {

  		object.onBeforeRender( _this, scene, camera, geometry, material, group );

  		object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
  		object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

  		if ( object.isImmediateRenderObject ) {

  			state.setMaterial( material );

  			var program = setProgram( camera, scene.fog, material, object );

  			_currentGeometryProgram = '';

  			renderObjectImmediate( object, program, material );

  		} else {

  			_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );

  		}

  		object.onAfterRender( _this, scene, camera, geometry, material, group );

  	}

  	function initMaterial( material, fog, object ) {

  		var materialProperties = properties.get( material );

  		var parameters = programCache.getParameters(
  			material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object );

  		var code = programCache.getProgramCode( material, parameters );

  		var program = materialProperties.program;
  		var programChange = true;

  		if ( program === undefined ) {

  			// new material
  			material.addEventListener( 'dispose', onMaterialDispose );

  		} else if ( program.code !== code ) {

  			// changed glsl or parameters
  			releaseMaterialProgramReference( material );

  		} else if ( parameters.shaderID !== undefined ) {

  			// same glsl and uniform list
  			return;

  		} else {

  			// only rebuild uniform list
  			programChange = false;

  		}

  		if ( programChange ) {

  			if ( parameters.shaderID ) {

  				var shader = ShaderLib[ parameters.shaderID ];

  				materialProperties.shader = {
  					name: material.type,
  					uniforms: UniformsUtils$1.clone( shader.uniforms ),
  					vertexShader: shader.vertexShader,
  					fragmentShader: shader.fragmentShader
  				};

  			} else {

  				materialProperties.shader = {
  					name: material.type,
  					uniforms: material.uniforms,
  					vertexShader: material.vertexShader,
  					fragmentShader: material.fragmentShader
  				};

  			}

  			material.onBeforeCompile( materialProperties.shader );

  			program = programCache.acquireProgram( material, materialProperties.shader, parameters, code );

  			materialProperties.program = program;
  			material.program = program;

  		}

  		var programAttributes = program.getAttributes();

  		if ( material.morphTargets ) {

  			material.numSupportedMorphTargets = 0;

  			for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

  				if ( programAttributes[ 'morphTarget' + i ] >= 0 ) {

  					material.numSupportedMorphTargets ++;

  				}

  			}

  		}

  		if ( material.morphNormals ) {

  			material.numSupportedMorphNormals = 0;

  			for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {

  				if ( programAttributes[ 'morphNormal' + i ] >= 0 ) {

  					material.numSupportedMorphNormals ++;

  				}

  			}

  		}

  		var uniforms = materialProperties.shader.uniforms;

  		if ( ! material.isShaderMaterial &&
  			! material.isRawShaderMaterial ||
  			material.clipping === true ) {

  			materialProperties.numClippingPlanes = _clipping.numPlanes;
  			materialProperties.numIntersection = _clipping.numIntersection;
  			uniforms.clippingPlanes = _clipping.uniform;

  		}

  		materialProperties.fog = fog;

  		// store the light setup it was created for

  		materialProperties.lightsHash = lights.state.hash;

  		if ( material.lights ) {

  			// wire up the material to this renderer's lighting state

  			uniforms.ambientLightColor.value = lights.state.ambient;
  			uniforms.directionalLights.value = lights.state.directional;
  			uniforms.spotLights.value = lights.state.spot;
  			uniforms.rectAreaLights.value = lights.state.rectArea;
  			uniforms.pointLights.value = lights.state.point;
  			uniforms.hemisphereLights.value = lights.state.hemi;

  			uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
  			uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
  			uniforms.spotShadowMap.value = lights.state.spotShadowMap;
  			uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
  			uniforms.pointShadowMap.value = lights.state.pointShadowMap;
  			uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
  			// TODO (abelnation): add area lights shadow info to uniforms

  		}

  		var progUniforms = materialProperties.program.getUniforms(),
  			uniformsList =
  				WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

  		materialProperties.uniformsList = uniformsList;

  	}

  	function setProgram( camera, fog, material, object ) {

  		_usedTextureUnits = 0;

  		var materialProperties = properties.get( material );

  		if ( _clippingEnabled ) {

  			if ( _localClippingEnabled || camera !== _currentCamera ) {

  				var useCache =
  					camera === _currentCamera &&
  					material.id === _currentMaterialId;

  				// we might want to call this function with some ClippingGroup
  				// object instead of the material, once it becomes feasible
  				// (#8465, #8379)
  				_clipping.setState(
  					material.clippingPlanes, material.clipIntersection, material.clipShadows,
  					camera, materialProperties, useCache );

  			}

  		}

  		if ( material.needsUpdate === false ) {

  			if ( materialProperties.program === undefined ) {

  				material.needsUpdate = true;

  			} else if ( material.fog && materialProperties.fog !== fog ) {

  				material.needsUpdate = true;

  			} else if ( material.lights && materialProperties.lightsHash !== lights.state.hash ) {

  				material.needsUpdate = true;

  			} else if ( materialProperties.numClippingPlanes !== undefined &&
  				( materialProperties.numClippingPlanes !== _clipping.numPlanes ||
  				materialProperties.numIntersection !== _clipping.numIntersection ) ) {

  				material.needsUpdate = true;

  			}

  		}

  		if ( material.needsUpdate ) {

  			initMaterial( material, fog, object );
  			material.needsUpdate = false;

  		}

  		var refreshProgram = false;
  		var refreshMaterial = false;
  		var refreshLights = false;

  		var program = materialProperties.program,
  			p_uniforms = program.getUniforms(),
  			m_uniforms = materialProperties.shader.uniforms;

  		if ( state.useProgram( program.program ) ) {

  			refreshProgram = true;
  			refreshMaterial = true;
  			refreshLights = true;

  		}

  		if ( material.id !== _currentMaterialId ) {

  			_currentMaterialId = material.id;

  			refreshMaterial = true;

  		}

  		if ( refreshProgram || camera !== _currentCamera ) {

  			p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

  			if ( capabilities.logarithmicDepthBuffer ) {

  				p_uniforms.setValue( _gl, 'logDepthBufFC',
  					2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

  			}

  			// Avoid unneeded uniform updates per ArrayCamera's sub-camera

  			if ( _currentCamera !== ( _currentArrayCamera || camera ) ) {

  				_currentCamera = ( _currentArrayCamera || camera );

  				// lighting uniforms depend on the camera so enforce an update
  				// now, in case this material supports lights - or later, when
  				// the next material that does gets activated:

  				refreshMaterial = true;		// set to true on material change
  				refreshLights = true;		// remains set until update done

  			}

  			// load material specific uniforms
  			// (shader material also gets them for the sake of genericity)

  			if ( material.isShaderMaterial ||
  				material.isMeshPhongMaterial ||
  				material.isMeshStandardMaterial ||
  				material.envMap ) {

  				var uCamPos = p_uniforms.map.cameraPosition;

  				if ( uCamPos !== undefined ) {

  					uCamPos.setValue( _gl,
  						_vector3.setFromMatrixPosition( camera.matrixWorld ) );

  				}

  			}

  			if ( material.isMeshPhongMaterial ||
  				material.isMeshLambertMaterial ||
  				material.isMeshBasicMaterial ||
  				material.isMeshStandardMaterial ||
  				material.isShaderMaterial ||
  				material.skinning ) {

  				p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

  			}

  		}

  		// skinning uniforms must be set even if material didn't change
  		// auto-setting of texture unit for bone texture must go before other textures
  		// not sure why, but otherwise weird things happen

  		if ( material.skinning ) {

  			p_uniforms.setOptional( _gl, object, 'bindMatrix' );
  			p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

  			var skeleton = object.skeleton;

  			if ( skeleton ) {

  				var bones = skeleton.bones;

  				if ( capabilities.floatVertexTextures ) {

  					if ( skeleton.boneTexture === undefined ) {

  						// layout (1 matrix = 4 pixels)
  						//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
  						//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
  						//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
  						//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
  						//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


  						var size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix
  						size = _Math$1.ceilPowerOfTwo( size );
  						size = Math.max( size, 4 );

  						var boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
  						boneMatrices.set( skeleton.boneMatrices ); // copy current values

  						var boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat$1, FloatType$1 );

  						skeleton.boneMatrices = boneMatrices;
  						skeleton.boneTexture = boneTexture;
  						skeleton.boneTextureSize = size;

  					}

  					p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture );
  					p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

  				} else {

  					p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

  				}

  			}

  		}

  		if ( refreshMaterial ) {

  			p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );
  			p_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint );

  			if ( material.lights ) {

  				// the current material requires lighting info

  				// note: all lighting uniforms are always set correctly
  				// they simply reference the renderer's state for their
  				// values
  				//
  				// use the current material's .needsUpdate flags to set
  				// the GL state when required

  				markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

  			}

  			// refresh uniforms common to several materials

  			if ( fog && material.fog ) {

  				refreshUniformsFog( m_uniforms, fog );

  			}

  			if ( material.isMeshBasicMaterial ) {

  				refreshUniformsCommon( m_uniforms, material );

  			} else if ( material.isMeshLambertMaterial ) {

  				refreshUniformsCommon( m_uniforms, material );
  				refreshUniformsLambert( m_uniforms, material );

  			} else if ( material.isMeshPhongMaterial ) {

  				refreshUniformsCommon( m_uniforms, material );

  				if ( material.isMeshToonMaterial ) {

  					refreshUniformsToon( m_uniforms, material );

  				} else {

  					refreshUniformsPhong( m_uniforms, material );

  				}

  			} else if ( material.isMeshStandardMaterial ) {

  				refreshUniformsCommon( m_uniforms, material );

  				if ( material.isMeshPhysicalMaterial ) {

  					refreshUniformsPhysical( m_uniforms, material );

  				} else {

  					refreshUniformsStandard( m_uniforms, material );

  				}

  			} else if ( material.isMeshDepthMaterial ) {

  				refreshUniformsCommon( m_uniforms, material );
  				refreshUniformsDepth( m_uniforms, material );

  			} else if ( material.isMeshDistanceMaterial ) {

  				refreshUniformsCommon( m_uniforms, material );
  				refreshUniformsDistance( m_uniforms, material );

  			} else if ( material.isMeshNormalMaterial ) {

  				refreshUniformsCommon( m_uniforms, material );
  				refreshUniformsNormal( m_uniforms, material );

  			} else if ( material.isLineBasicMaterial ) {

  				refreshUniformsLine( m_uniforms, material );

  				if ( material.isLineDashedMaterial ) {

  					refreshUniformsDash( m_uniforms, material );

  				}

  			} else if ( material.isPointsMaterial ) {

  				refreshUniformsPoints( m_uniforms, material );

  			} else if ( material.isShadowMaterial ) {

  				m_uniforms.color.value = material.color;
  				m_uniforms.opacity.value = material.opacity;

  			}

  			// RectAreaLight Texture
  			// TODO (mrdoob): Find a nicer implementation

  			if ( m_uniforms.ltcMat !== undefined ) { m_uniforms.ltcMat.value = UniformsLib.LTC_MAT_TEXTURE; }
  			if ( m_uniforms.ltcMag !== undefined ) { m_uniforms.ltcMag.value = UniformsLib.LTC_MAG_TEXTURE; }

  			WebGLUniforms.upload(
  				_gl, materialProperties.uniformsList, m_uniforms, _this );

  		}


  		// common matrices

  		p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
  		p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
  		p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

  		return program;

  	}

  	// Uniforms (refresh uniforms objects)

  	function refreshUniformsCommon( uniforms, material ) {

  		uniforms.opacity.value = material.opacity;

  		if ( material.color ) {

  			uniforms.diffuse.value = material.color;

  		}

  		if ( material.emissive ) {

  			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

  		}

  		if ( material.map ) {

  			uniforms.map.value = material.map;

  		}

  		if ( material.alphaMap ) {

  			uniforms.alphaMap.value = material.alphaMap;

  		}

  		if ( material.specularMap ) {

  			uniforms.specularMap.value = material.specularMap;

  		}

  		if ( material.envMap ) {

  			uniforms.envMap.value = material.envMap;

  			// don't flip CubeTexture envMaps, flip everything else:
  			//  WebGLRenderTargetCube will be flipped for backwards compatibility
  			//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
  			// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
  			uniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;

  			uniforms.reflectivity.value = material.reflectivity;
  			uniforms.refractionRatio.value = material.refractionRatio;

  		}

  		if ( material.lightMap ) {

  			uniforms.lightMap.value = material.lightMap;
  			uniforms.lightMapIntensity.value = material.lightMapIntensity;

  		}

  		if ( material.aoMap ) {

  			uniforms.aoMap.value = material.aoMap;
  			uniforms.aoMapIntensity.value = material.aoMapIntensity;

  		}

  		// uv repeat and offset setting priorities
  		// 1. color map
  		// 2. specular map
  		// 3. normal map
  		// 4. bump map
  		// 5. alpha map
  		// 6. emissive map

  		var uvScaleMap;

  		if ( material.map ) {

  			uvScaleMap = material.map;

  		} else if ( material.specularMap ) {

  			uvScaleMap = material.specularMap;

  		} else if ( material.displacementMap ) {

  			uvScaleMap = material.displacementMap;

  		} else if ( material.normalMap ) {

  			uvScaleMap = material.normalMap;

  		} else if ( material.bumpMap ) {

  			uvScaleMap = material.bumpMap;

  		} else if ( material.roughnessMap ) {

  			uvScaleMap = material.roughnessMap;

  		} else if ( material.metalnessMap ) {

  			uvScaleMap = material.metalnessMap;

  		} else if ( material.alphaMap ) {

  			uvScaleMap = material.alphaMap;

  		} else if ( material.emissiveMap ) {

  			uvScaleMap = material.emissiveMap;

  		}

  		if ( uvScaleMap !== undefined ) {

  			// backwards compatibility
  			if ( uvScaleMap.isWebGLRenderTarget ) {

  				uvScaleMap = uvScaleMap.texture;

  			}

  			if ( uvScaleMap.matrixAutoUpdate === true ) {

  				var offset = uvScaleMap.offset;
  				var repeat = uvScaleMap.repeat;
  				var rotation = uvScaleMap.rotation;
  				var center = uvScaleMap.center;

  				uvScaleMap.matrix.setUvTransform( offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y );

  			}

  			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

  		}

  	}

  	function refreshUniformsLine( uniforms, material ) {

  		uniforms.diffuse.value = material.color;
  		uniforms.opacity.value = material.opacity;

  	}

  	function refreshUniformsDash( uniforms, material ) {

  		uniforms.dashSize.value = material.dashSize;
  		uniforms.totalSize.value = material.dashSize + material.gapSize;
  		uniforms.scale.value = material.scale;

  	}

  	function refreshUniformsPoints( uniforms, material ) {

  		uniforms.diffuse.value = material.color;
  		uniforms.opacity.value = material.opacity;
  		uniforms.size.value = material.size * _pixelRatio;
  		uniforms.scale.value = _height * 0.5;

  		uniforms.map.value = material.map;

  		if ( material.map !== null ) {

  			if ( material.map.matrixAutoUpdate === true ) {

  				var offset = material.map.offset;
  				var repeat = material.map.repeat;
  				var rotation = material.map.rotation;
  				var center = material.map.center;

  				material.map.matrix.setUvTransform( offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y );

  			}

  			uniforms.uvTransform.value.copy( material.map.matrix );

  		}

  	}

  	function refreshUniformsFog( uniforms, fog ) {

  		uniforms.fogColor.value = fog.color;

  		if ( fog.isFog ) {

  			uniforms.fogNear.value = fog.near;
  			uniforms.fogFar.value = fog.far;

  		} else if ( fog.isFogExp2 ) {

  			uniforms.fogDensity.value = fog.density;

  		}

  	}

  	function refreshUniformsLambert( uniforms, material ) {

  		if ( material.emissiveMap ) {

  			uniforms.emissiveMap.value = material.emissiveMap;

  		}

  	}

  	function refreshUniformsPhong( uniforms, material ) {

  		uniforms.specular.value = material.specular;
  		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

  		if ( material.emissiveMap ) {

  			uniforms.emissiveMap.value = material.emissiveMap;

  		}

  		if ( material.bumpMap ) {

  			uniforms.bumpMap.value = material.bumpMap;
  			uniforms.bumpScale.value = material.bumpScale;

  		}

  		if ( material.normalMap ) {

  			uniforms.normalMap.value = material.normalMap;
  			uniforms.normalScale.value.copy( material.normalScale );

  		}

  		if ( material.displacementMap ) {

  			uniforms.displacementMap.value = material.displacementMap;
  			uniforms.displacementScale.value = material.displacementScale;
  			uniforms.displacementBias.value = material.displacementBias;

  		}

  	}

  	function refreshUniformsToon( uniforms, material ) {

  		refreshUniformsPhong( uniforms, material );

  		if ( material.gradientMap ) {

  			uniforms.gradientMap.value = material.gradientMap;

  		}

  	}

  	function refreshUniformsStandard( uniforms, material ) {

  		uniforms.roughness.value = material.roughness;
  		uniforms.metalness.value = material.metalness;

  		if ( material.roughnessMap ) {

  			uniforms.roughnessMap.value = material.roughnessMap;

  		}

  		if ( material.metalnessMap ) {

  			uniforms.metalnessMap.value = material.metalnessMap;

  		}

  		if ( material.emissiveMap ) {

  			uniforms.emissiveMap.value = material.emissiveMap;

  		}

  		if ( material.bumpMap ) {

  			uniforms.bumpMap.value = material.bumpMap;
  			uniforms.bumpScale.value = material.bumpScale;

  		}

  		if ( material.normalMap ) {

  			uniforms.normalMap.value = material.normalMap;
  			uniforms.normalScale.value.copy( material.normalScale );

  		}

  		if ( material.displacementMap ) {

  			uniforms.displacementMap.value = material.displacementMap;
  			uniforms.displacementScale.value = material.displacementScale;
  			uniforms.displacementBias.value = material.displacementBias;

  		}

  		if ( material.envMap ) {

  			//uniforms.envMap.value = material.envMap; // part of uniforms common
  			uniforms.envMapIntensity.value = material.envMapIntensity;

  		}

  	}

  	function refreshUniformsPhysical( uniforms, material ) {

  		uniforms.clearCoat.value = material.clearCoat;
  		uniforms.clearCoatRoughness.value = material.clearCoatRoughness;

  		refreshUniformsStandard( uniforms, material );

  	}

  	function refreshUniformsDepth( uniforms, material ) {

  		if ( material.displacementMap ) {

  			uniforms.displacementMap.value = material.displacementMap;
  			uniforms.displacementScale.value = material.displacementScale;
  			uniforms.displacementBias.value = material.displacementBias;

  		}

  	}

  	function refreshUniformsDistance( uniforms, material ) {

  		if ( material.displacementMap ) {

  			uniforms.displacementMap.value = material.displacementMap;
  			uniforms.displacementScale.value = material.displacementScale;
  			uniforms.displacementBias.value = material.displacementBias;

  		}

  		uniforms.referencePosition.value.copy( material.referencePosition );
  		uniforms.nearDistance.value = material.nearDistance;
  		uniforms.farDistance.value = material.farDistance;

  	}

  	function refreshUniformsNormal( uniforms, material ) {

  		if ( material.bumpMap ) {

  			uniforms.bumpMap.value = material.bumpMap;
  			uniforms.bumpScale.value = material.bumpScale;

  		}

  		if ( material.normalMap ) {

  			uniforms.normalMap.value = material.normalMap;
  			uniforms.normalScale.value.copy( material.normalScale );

  		}

  		if ( material.displacementMap ) {

  			uniforms.displacementMap.value = material.displacementMap;
  			uniforms.displacementScale.value = material.displacementScale;
  			uniforms.displacementBias.value = material.displacementBias;

  		}

  	}

  	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

  	function markUniformsLightsNeedsUpdate( uniforms, value ) {

  		uniforms.ambientLightColor.needsUpdate = value;

  		uniforms.directionalLights.needsUpdate = value;
  		uniforms.pointLights.needsUpdate = value;
  		uniforms.spotLights.needsUpdate = value;
  		uniforms.rectAreaLights.needsUpdate = value;
  		uniforms.hemisphereLights.needsUpdate = value;

  	}

  	// GL state setting

  	this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

  		state.setCullFace( cullFace );
  		state.setFlipSided( frontFaceDirection === FrontFaceDirectionCW$1 );

  	};

  	// Textures

  	function allocTextureUnit() {

  		var textureUnit = _usedTextureUnits;

  		if ( textureUnit >= capabilities.maxTextures ) {

  			console.warn( 'THREE.WebGLRenderer: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

  		}

  		_usedTextureUnits += 1;

  		return textureUnit;

  	}

  	this.allocTextureUnit = allocTextureUnit;

  	// this.setTexture2D = setTexture2D;
  	this.setTexture2D = ( function () {

  		var warned = false;

  		// backwards compatibility: peel texture.texture
  		return function setTexture2D( texture, slot ) {

  			if ( texture && texture.isWebGLRenderTarget ) {

  				if ( ! warned ) {

  					console.warn( "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead." );
  					warned = true;

  				}

  				texture = texture.texture;

  			}

  			textures.setTexture2D( texture, slot );

  		};

  	}() );

  	this.setTexture = ( function () {

  		var warned = false;

  		return function setTexture( texture, slot ) {

  			if ( ! warned ) {

  				console.warn( "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead." );
  				warned = true;

  			}

  			textures.setTexture2D( texture, slot );

  		};

  	}() );

  	this.setTextureCube = ( function () {

  		var warned = false;

  		return function setTextureCube( texture, slot ) {

  			// backwards compatibility: peel texture.texture
  			if ( texture && texture.isWebGLRenderTargetCube ) {

  				if ( ! warned ) {

  					console.warn( "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
  					warned = true;

  				}

  				texture = texture.texture;

  			}

  			// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
  			// TODO: unify these code paths
  			if ( ( texture && texture.isCubeTexture ) ||
  				( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

  				// CompressedTexture can have Array in image :/

  				// this function alone should take care of cube textures
  				textures.setTextureCube( texture, slot );

  			} else {

  				// assumed: texture property of THREE.WebGLRenderTargetCube

  				textures.setTextureCubeDynamic( texture, slot );

  			}

  		};

  	}() );

  	this.getRenderTarget = function () {

  		return _currentRenderTarget;

  	};

  	this.setRenderTarget = function ( renderTarget ) {

  		_currentRenderTarget = renderTarget;

  		if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

  			textures.setupRenderTarget( renderTarget );

  		}

  		var framebuffer = null;
  		var isCube = false;

  		if ( renderTarget ) {

  			var __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

  			if ( renderTarget.isWebGLRenderTargetCube ) {

  				framebuffer = __webglFramebuffer[ renderTarget.activeCubeFace ];
  				isCube = true;

  			} else {

  				framebuffer = __webglFramebuffer;

  			}

  			_currentViewport.copy( renderTarget.viewport );
  			_currentScissor.copy( renderTarget.scissor );
  			_currentScissorTest = renderTarget.scissorTest;

  		} else {

  			_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );
  			_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
  			_currentScissorTest = _scissorTest;

  		}

  		if ( _currentFramebuffer !== framebuffer ) {

  			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
  			_currentFramebuffer = framebuffer;

  		}

  		state.viewport( _currentViewport );
  		state.scissor( _currentScissor );
  		state.setScissorTest( _currentScissorTest );

  		if ( isCube ) {

  			var textureProperties = properties.get( renderTarget.texture );
  			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );

  		}

  	};

  	this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {

  		if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

  			console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
  			return;

  		}

  		var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

  		if ( framebuffer ) {

  			var restore = false;

  			if ( framebuffer !== _currentFramebuffer ) {

  				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

  				restore = true;

  			}

  			try {

  				var texture = renderTarget.texture;
  				var textureFormat = texture.format;
  				var textureType = texture.type;

  				if ( textureFormat !== RGBAFormat$1 && utils.convert( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

  					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
  					return;

  				}

  				if ( textureType !== UnsignedByteType$1 && utils.convert( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)
  					! ( textureType === FloatType$1 && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
  					! ( textureType === HalfFloatType$1 && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {

  					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
  					return;

  				}

  				if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

  					// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

  					if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

  						_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

  					}

  				} else {

  					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

  				}

  			} finally {

  				if ( restore ) {

  					_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

  				}

  			}

  		}

  	};

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  function FogExp2$1( color, density ) {

  	this.name = '';

  	this.color = new Color$1( color );
  	this.density = ( density !== undefined ) ? density : 0.00025;

  }

  FogExp2$1.prototype.isFogExp2 = true;

  FogExp2$1.prototype.clone = function () {

  	return new FogExp2$1( this.color.getHex(), this.density );

  };

  FogExp2$1.prototype.toJSON = function ( /* meta */ ) {

  	return {
  		type: 'FogExp2',
  		color: this.color.getHex(),
  		density: this.density
  	};

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  function Fog$1( color, near, far ) {

  	this.name = '';

  	this.color = new Color$1( color );

  	this.near = ( near !== undefined ) ? near : 1;
  	this.far = ( far !== undefined ) ? far : 1000;

  }

  Fog$1.prototype.isFog = true;

  Fog$1.prototype.clone = function () {

  	return new Fog$1( this.color.getHex(), this.near, this.far );

  };

  Fog$1.prototype.toJSON = function ( /* meta */ ) {

  	return {
  		type: 'Fog',
  		color: this.color.getHex(),
  		near: this.near,
  		far: this.far
  	};

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function Scene$1() {

  	Object3D$1.call( this );

  	this.type = 'Scene';

  	this.background = null;
  	this.fog = null;
  	this.overrideMaterial = null;

  	this.autoUpdate = true; // checked by the renderer

  }

  Scene$1.prototype = Object.assign( Object.create( Object3D$1.prototype ), {

  	constructor: Scene$1,

  	copy: function ( source, recursive ) {

  		Object3D$1.prototype.copy.call( this, source, recursive );

  		if ( source.background !== null ) { this.background = source.background.clone(); }
  		if ( source.fog !== null ) { this.fog = source.fog.clone(); }
  		if ( source.overrideMaterial !== null ) { this.overrideMaterial = source.overrideMaterial.clone(); }

  		this.autoUpdate = source.autoUpdate;
  		this.matrixAutoUpdate = source.matrixAutoUpdate;

  		return this;

  	},

  	toJSON: function ( meta ) {

  		var data = Object3D$1.prototype.toJSON.call( this, meta );

  		if ( this.background !== null ) { data.object.background = this.background.toJSON( meta ); }
  		if ( this.fog !== null ) { data.object.fog = this.fog.toJSON(); }

  		return data;

  	}

  } );

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   */

  function LensFlare( texture, size, distance, blending, color ) {

  	Object3D$1.call( this );

  	this.lensFlares = [];

  	this.positionScreen = new Vector3$2();
  	this.customUpdateCallback = undefined;

  	if ( texture !== undefined ) {

  		this.add( texture, size, distance, blending, color );

  	}

  }

  LensFlare.prototype = Object.assign( Object.create( Object3D$1.prototype ), {

  	constructor: LensFlare,

  	isLensFlare: true,

  	copy: function ( source ) {
  		var this$1 = this;


  		Object3D$1.prototype.copy.call( this, source );

  		this.positionScreen.copy( source.positionScreen );
  		this.customUpdateCallback = source.customUpdateCallback;

  		for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {

  			this$1.lensFlares.push( source.lensFlares[ i ] );

  		}

  		return this;

  	},

  	add: function ( texture, size, distance, blending, color, opacity ) {

  		if ( size === undefined ) { size = - 1; }
  		if ( distance === undefined ) { distance = 0; }
  		if ( opacity === undefined ) { opacity = 1; }
  		if ( color === undefined ) { color = new Color$1( 0xffffff ); }
  		if ( blending === undefined ) { blending = NormalBlending$1; }

  		distance = Math.min( distance, Math.max( 0, distance ) );

  		this.lensFlares.push( {
  			texture: texture,	// THREE.Texture
  			size: size, 		// size in pixels (-1 = use texture.width)
  			distance: distance, 	// distance (0-1) from light source (0=at light source)
  			x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
  			scale: 1, 		// scale
  			rotation: 0, 		// rotation
  			opacity: opacity,	// opacity
  			color: color,		// color
  			blending: blending	// blending
  		} );

  	},

  	/*
  	 * Update lens flares update positions on all flares based on the screen position
  	 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
  	 */

  	updateLensFlares: function () {
  		var this$1 = this;


  		var f, fl = this.lensFlares.length;
  		var flare;
  		var vecX = - this.positionScreen.x * 2;
  		var vecY = - this.positionScreen.y * 2;

  		for ( f = 0; f < fl; f ++ ) {

  			flare = this$1.lensFlares[ f ];

  			flare.x = this$1.positionScreen.x + vecX * flare.distance;
  			flare.y = this$1.positionScreen.y + vecY * flare.distance;

  			flare.wantedRotation = flare.x * Math.PI * 0.25;
  			flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

  		}

  	}

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *  map: new THREE.Texture( <Image> ),
   *
   *	uvOffset: new THREE.Vector2(),
   *	uvScale: new THREE.Vector2()
   * }
   */

  function SpriteMaterial$1( parameters ) {

  	Material$1.call( this );

  	this.type = 'SpriteMaterial';

  	this.color = new Color$1( 0xffffff );
  	this.map = null;

  	this.rotation = 0;

  	this.fog = false;
  	this.lights = false;

  	this.setValues( parameters );

  }

  SpriteMaterial$1.prototype = Object.create( Material$1.prototype );
  SpriteMaterial$1.prototype.constructor = SpriteMaterial$1;
  SpriteMaterial$1.prototype.isSpriteMaterial = true;

  SpriteMaterial$1.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.color.copy( source.color );
  	this.map = source.map;

  	this.rotation = source.rotation;

  	return this;

  };

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   */

  function Sprite$1( material ) {

  	Object3D$1.call( this );

  	this.type = 'Sprite';

  	this.material = ( material !== undefined ) ? material : new SpriteMaterial$1();

  }

  Sprite$1.prototype = Object.assign( Object.create( Object3D$1.prototype ), {

  	constructor: Sprite$1,

  	isSprite: true,

  	raycast: ( function () {

  		var intersectPoint = new Vector3$2();
  		var worldPosition = new Vector3$2();
  		var worldScale = new Vector3$2();

  		return function raycast( raycaster, intersects ) {

  			worldPosition.setFromMatrixPosition( this.matrixWorld );
  			raycaster.ray.closestPointToPoint( worldPosition, intersectPoint );

  			worldScale.setFromMatrixScale( this.matrixWorld );
  			var guessSizeSq = worldScale.x * worldScale.y / 4;

  			if ( worldPosition.distanceToSquared( intersectPoint ) > guessSizeSq ) { return; }

  			var distance = raycaster.ray.origin.distanceTo( intersectPoint );

  			if ( distance < raycaster.near || distance > raycaster.far ) { return; }

  			intersects.push( {

  				distance: distance,
  				point: intersectPoint.clone(),
  				face: null,
  				object: this

  			} );

  		};

  	}() ),

  	clone: function () {

  		return new this.constructor( this.material ).copy( this );

  	}

  } );

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   */

  function LOD$1() {

  	Object3D$1.call( this );

  	this.type = 'LOD';

  	Object.defineProperties( this, {
  		levels: {
  			enumerable: true,
  			value: []
  		}
  	} );

  }

  LOD$1.prototype = Object.assign( Object.create( Object3D$1.prototype ), {

  	constructor: LOD$1,

  	copy: function ( source ) {
  		var this$1 = this;


  		Object3D$1.prototype.copy.call( this, source, false );

  		var levels = source.levels;

  		for ( var i = 0, l = levels.length; i < l; i ++ ) {

  			var level = levels[ i ];

  			this$1.addLevel( level.object.clone(), level.distance );

  		}

  		return this;

  	},

  	addLevel: function ( object, distance ) {

  		if ( distance === undefined ) { distance = 0; }

  		distance = Math.abs( distance );

  		var levels = this.levels;

  		for ( var l = 0; l < levels.length; l ++ ) {

  			if ( distance < levels[ l ].distance ) {

  				break;

  			}

  		}

  		levels.splice( l, 0, { distance: distance, object: object } );

  		this.add( object );

  	},

  	getObjectForDistance: function ( distance ) {

  		var levels = this.levels;

  		for ( var i = 1, l = levels.length; i < l; i ++ ) {

  			if ( distance < levels[ i ].distance ) {

  				break;

  			}

  		}

  		return levels[ i - 1 ].object;

  	},

  	raycast: ( function () {

  		var matrixPosition = new Vector3$2();

  		return function raycast( raycaster, intersects ) {

  			matrixPosition.setFromMatrixPosition( this.matrixWorld );

  			var distance = raycaster.ray.origin.distanceTo( matrixPosition );

  			this.getObjectForDistance( distance ).raycast( raycaster, intersects );

  		};

  	}() ),

  	update: function () {

  		var v1 = new Vector3$2();
  		var v2 = new Vector3$2();

  		return function update( camera ) {

  			var levels = this.levels;

  			if ( levels.length > 1 ) {

  				v1.setFromMatrixPosition( camera.matrixWorld );
  				v2.setFromMatrixPosition( this.matrixWorld );

  				var distance = v1.distanceTo( v2 );

  				levels[ 0 ].object.visible = true;

  				for ( var i = 1, l = levels.length; i < l; i ++ ) {

  					if ( distance >= levels[ i ].distance ) {

  						levels[ i - 1 ].object.visible = false;
  						levels[ i ].object.visible = true;

  					} else {

  						break;

  					}

  				}

  				for ( ; i < l; i ++ ) {

  					levels[ i ].object.visible = false;

  				}

  			}

  		};

  	}(),

  	toJSON: function ( meta ) {

  		var data = Object3D$1.prototype.toJSON.call( this, meta );

  		data.object.levels = [];

  		var levels = this.levels;

  		for ( var i = 0, l = levels.length; i < l; i ++ ) {

  			var level = levels[ i ];

  			data.object.levels.push( {
  				object: level.object.uuid,
  				distance: level.distance
  			} );

  		}

  		return data;

  	}

  } );

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author michael guerrero / http://realitymeltdown.com
   * @author ikerr / http://verold.com
   */

  function Skeleton$1( bones, boneInverses ) {
  	var this$1 = this;


  	// copy the bone array

  	bones = bones || [];

  	this.bones = bones.slice( 0 );
  	this.boneMatrices = new Float32Array( this.bones.length * 16 );

  	// use the supplied bone inverses or calculate the inverses

  	if ( boneInverses === undefined ) {

  		this.calculateInverses();

  	} else {

  		if ( this.bones.length === boneInverses.length ) {

  			this.boneInverses = boneInverses.slice( 0 );

  		} else {

  			console.warn( 'THREE.Skeleton boneInverses is the wrong length.' );

  			this.boneInverses = [];

  			for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

  				this$1.boneInverses.push( new Matrix4$1() );

  			}

  		}

  	}

  }

  Object.assign( Skeleton$1.prototype, {

  	calculateInverses: function () {
  		var this$1 = this;


  		this.boneInverses = [];

  		for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

  			var inverse = new Matrix4$1();

  			if ( this$1.bones[ i ] ) {

  				inverse.getInverse( this$1.bones[ i ].matrixWorld );

  			}

  			this$1.boneInverses.push( inverse );

  		}

  	},

  	pose: function () {
  		var this$1 = this;


  		var bone, i, il;

  		// recover the bind-time world matrices

  		for ( i = 0, il = this.bones.length; i < il; i ++ ) {

  			bone = this$1.bones[ i ];

  			if ( bone ) {

  				bone.matrixWorld.getInverse( this$1.boneInverses[ i ] );

  			}

  		}

  		// compute the local matrices, positions, rotations and scales

  		for ( i = 0, il = this.bones.length; i < il; i ++ ) {

  			bone = this$1.bones[ i ];

  			if ( bone ) {

  				if ( bone.parent && bone.parent.isBone ) {

  					bone.matrix.getInverse( bone.parent.matrixWorld );
  					bone.matrix.multiply( bone.matrixWorld );

  				} else {

  					bone.matrix.copy( bone.matrixWorld );

  				}

  				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

  			}

  		}

  	},

  	update: ( function () {

  		var offsetMatrix = new Matrix4$1();
  		var identityMatrix = new Matrix4$1();

  		return function update() {

  			var bones = this.bones;
  			var boneInverses = this.boneInverses;
  			var boneMatrices = this.boneMatrices;
  			var boneTexture = this.boneTexture;

  			// flatten bone matrices to array

  			for ( var i = 0, il = bones.length; i < il; i ++ ) {

  				// compute the offset between the current and the original transform

  				var matrix = bones[ i ] ? bones[ i ].matrixWorld : identityMatrix;

  				offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
  				offsetMatrix.toArray( boneMatrices, i * 16 );

  			}

  			if ( boneTexture !== undefined ) {

  				boneTexture.needsUpdate = true;

  			}

  		};

  	} )(),

  	clone: function () {

  		return new Skeleton$1( this.bones, this.boneInverses );

  	}

  } );

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author ikerr / http://verold.com
   */

  function Bone$1() {

  	Object3D$1.call( this );

  	this.type = 'Bone';

  }

  Bone$1.prototype = Object.assign( Object.create( Object3D$1.prototype ), {

  	constructor: Bone$1,

  	isBone: true

  } );

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author ikerr / http://verold.com
   */

  function SkinnedMesh$1( geometry, material ) {

  	Mesh$1.call( this, geometry, material );

  	this.type = 'SkinnedMesh';

  	this.bindMode = 'attached';
  	this.bindMatrix = new Matrix4$1();
  	this.bindMatrixInverse = new Matrix4$1();

  	var bones = this.initBones();
  	var skeleton = new Skeleton$1( bones );

  	this.bind( skeleton, this.matrixWorld );

  	this.normalizeSkinWeights();

  }

  SkinnedMesh$1.prototype = Object.assign( Object.create( Mesh$1.prototype ), {

  	constructor: SkinnedMesh$1,

  	isSkinnedMesh: true,

  	initBones: function () {
  		var this$1 = this;


  		var bones = [], bone, gbone;
  		var i, il;

  		if ( this.geometry && this.geometry.bones !== undefined ) {

  			// first, create array of 'Bone' objects from geometry data

  			for ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {

  				gbone = this$1.geometry.bones[ i ];

  				// create new 'Bone' object

  				bone = new Bone$1();
  				bones.push( bone );

  				// apply values

  				bone.name = gbone.name;
  				bone.position.fromArray( gbone.pos );
  				bone.quaternion.fromArray( gbone.rotq );
  				if ( gbone.scl !== undefined ) { bone.scale.fromArray( gbone.scl ); }

  			}

  			// second, create bone hierarchy

  			for ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {

  				gbone = this$1.geometry.bones[ i ];

  				if ( ( gbone.parent !== - 1 ) && ( gbone.parent !== null ) && ( bones[ gbone.parent ] !== undefined ) ) {

  					// subsequent bones in the hierarchy

  					bones[ gbone.parent ].add( bones[ i ] );

  				} else {

  					// topmost bone, immediate child of the skinned mesh

  					this$1.add( bones[ i ] );

  				}

  			}

  		}

  		// now the bones are part of the scene graph and children of the skinned mesh.
  		// let's update the corresponding matrices

  		this.updateMatrixWorld( true );

  		return bones;

  	},

  	bind: function ( skeleton, bindMatrix ) {

  		this.skeleton = skeleton;

  		if ( bindMatrix === undefined ) {

  			this.updateMatrixWorld( true );

  			this.skeleton.calculateInverses();

  			bindMatrix = this.matrixWorld;

  		}

  		this.bindMatrix.copy( bindMatrix );
  		this.bindMatrixInverse.getInverse( bindMatrix );

  	},

  	pose: function () {

  		this.skeleton.pose();

  	},

  	normalizeSkinWeights: function () {
  		var this$1 = this;


  		var scale, i;

  		if ( this.geometry && this.geometry.isGeometry ) {

  			for ( i = 0; i < this.geometry.skinWeights.length; i ++ ) {

  				var sw = this$1.geometry.skinWeights[ i ];

  				scale = 1.0 / sw.lengthManhattan();

  				if ( scale !== Infinity ) {

  					sw.multiplyScalar( scale );

  				} else {

  					sw.set( 1, 0, 0, 0 ); // do something reasonable

  				}

  			}

  		} else if ( this.geometry && this.geometry.isBufferGeometry ) {

  			var vec = new Vector4$1();

  			var skinWeight = this.geometry.attributes.skinWeight;

  			for ( i = 0; i < skinWeight.count; i ++ ) {

  				vec.x = skinWeight.getX( i );
  				vec.y = skinWeight.getY( i );
  				vec.z = skinWeight.getZ( i );
  				vec.w = skinWeight.getW( i );

  				scale = 1.0 / vec.lengthManhattan();

  				if ( scale !== Infinity ) {

  					vec.multiplyScalar( scale );

  				} else {

  					vec.set( 1, 0, 0, 0 ); // do something reasonable

  				}

  				skinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );

  			}

  		}

  	},

  	updateMatrixWorld: function ( force ) {

  		Mesh$1.prototype.updateMatrixWorld.call( this, force );

  		if ( this.bindMode === 'attached' ) {

  			this.bindMatrixInverse.getInverse( this.matrixWorld );

  		} else if ( this.bindMode === 'detached' ) {

  			this.bindMatrixInverse.getInverse( this.bindMatrix );

  		} else {

  			console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

  		}

  	},

  	clone: function () {

  		return new this.constructor( this.geometry, this.material ).copy( this );

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *
   *  linewidth: <float>,
   *  linecap: "round",
   *  linejoin: "round"
   * }
   */

  function LineBasicMaterial$1( parameters ) {

  	Material$1.call( this );

  	this.type = 'LineBasicMaterial';

  	this.color = new Color$1( 0xffffff );

  	this.linewidth = 1;
  	this.linecap = 'round';
  	this.linejoin = 'round';

  	this.lights = false;

  	this.setValues( parameters );

  }

  LineBasicMaterial$1.prototype = Object.create( Material$1.prototype );
  LineBasicMaterial$1.prototype.constructor = LineBasicMaterial$1;

  LineBasicMaterial$1.prototype.isLineBasicMaterial = true;

  LineBasicMaterial$1.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.color.copy( source.color );

  	this.linewidth = source.linewidth;
  	this.linecap = source.linecap;
  	this.linejoin = source.linejoin;

  	return this;

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function Line$1( geometry, material, mode ) {

  	if ( mode === 1 ) {

  		console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
  		return new LineSegments$1( geometry, material );

  	}

  	Object3D$1.call( this );

  	this.type = 'Line';

  	this.geometry = geometry !== undefined ? geometry : new BufferGeometry$1();
  	this.material = material !== undefined ? material : new LineBasicMaterial$1( { color: Math.random() * 0xffffff } );

  }

  Line$1.prototype = Object.assign( Object.create( Object3D$1.prototype ), {

  	constructor: Line$1,

  	isLine: true,

  	raycast: ( function () {

  		var inverseMatrix = new Matrix4$1();
  		var ray = new Ray$1();
  		var sphere = new Sphere$1();

  		return function raycast( raycaster, intersects ) {
  			var this$1 = this;


  			var precision = raycaster.linePrecision;
  			var precisionSq = precision * precision;

  			var geometry = this.geometry;
  			var matrixWorld = this.matrixWorld;

  			// Checking boundingSphere distance to ray

  			if ( geometry.boundingSphere === null ) { geometry.computeBoundingSphere(); }

  			sphere.copy( geometry.boundingSphere );
  			sphere.applyMatrix4( matrixWorld );

  			if ( raycaster.ray.intersectsSphere( sphere ) === false ) { return; }

  			//

  			inverseMatrix.getInverse( matrixWorld );
  			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

  			var vStart = new Vector3$2();
  			var vEnd = new Vector3$2();
  			var interSegment = new Vector3$2();
  			var interRay = new Vector3$2();
  			var step = ( this && this.isLineSegments ) ? 2 : 1;

  			if ( geometry.isBufferGeometry ) {

  				var index = geometry.index;
  				var attributes = geometry.attributes;
  				var positions = attributes.position.array;

  				if ( index !== null ) {

  					var indices = index.array;

  					for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

  						var a = indices[ i ];
  						var b = indices[ i + 1 ];

  						vStart.fromArray( positions, a * 3 );
  						vEnd.fromArray( positions, b * 3 );

  						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

  						if ( distSq > precisionSq ) { continue; }

  						interRay.applyMatrix4( this$1.matrixWorld ); //Move back to world space for distance calculation

  						var distance = raycaster.ray.origin.distanceTo( interRay );

  						if ( distance < raycaster.near || distance > raycaster.far ) { continue; }

  						intersects.push( {

  							distance: distance,
  							// What do we want? intersection point on the ray or on the segment??
  							// point: raycaster.ray.at( distance ),
  							point: interSegment.clone().applyMatrix4( this$1.matrixWorld ),
  							index: i,
  							face: null,
  							faceIndex: null,
  							object: this$1

  						} );

  					}

  				} else {

  					for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

  						vStart.fromArray( positions, 3 * i );
  						vEnd.fromArray( positions, 3 * i + 3 );

  						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

  						if ( distSq > precisionSq ) { continue; }

  						interRay.applyMatrix4( this$1.matrixWorld ); //Move back to world space for distance calculation

  						var distance = raycaster.ray.origin.distanceTo( interRay );

  						if ( distance < raycaster.near || distance > raycaster.far ) { continue; }

  						intersects.push( {

  							distance: distance,
  							// What do we want? intersection point on the ray or on the segment??
  							// point: raycaster.ray.at( distance ),
  							point: interSegment.clone().applyMatrix4( this$1.matrixWorld ),
  							index: i,
  							face: null,
  							faceIndex: null,
  							object: this$1

  						} );

  					}

  				}

  			} else if ( geometry.isGeometry ) {

  				var vertices = geometry.vertices;
  				var nbVertices = vertices.length;

  				for ( var i = 0; i < nbVertices - 1; i += step ) {

  					var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

  					if ( distSq > precisionSq ) { continue; }

  					interRay.applyMatrix4( this$1.matrixWorld ); //Move back to world space for distance calculation

  					var distance = raycaster.ray.origin.distanceTo( interRay );

  					if ( distance < raycaster.near || distance > raycaster.far ) { continue; }

  					intersects.push( {

  						distance: distance,
  						// What do we want? intersection point on the ray or on the segment??
  						// point: raycaster.ray.at( distance ),
  						point: interSegment.clone().applyMatrix4( this$1.matrixWorld ),
  						index: i,
  						face: null,
  						faceIndex: null,
  						object: this$1

  					} );

  				}

  			}

  		};

  	}() ),

  	clone: function () {

  		return new this.constructor( this.geometry, this.material ).copy( this );

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function LineSegments$1( geometry, material ) {

  	Line$1.call( this, geometry, material );

  	this.type = 'LineSegments';

  }

  LineSegments$1.prototype = Object.assign( Object.create( Line$1.prototype ), {

  	constructor: LineSegments$1,

  	isLineSegments: true

  } );

  /**
   * @author mgreter / http://github.com/mgreter
   */

  function LineLoop$1( geometry, material ) {

  	Line$1.call( this, geometry, material );

  	this.type = 'LineLoop';

  }

  LineLoop$1.prototype = Object.assign( Object.create( Line$1.prototype ), {

  	constructor: LineLoop$1,

  	isLineLoop: true,

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *  map: new THREE.Texture( <Image> ),
   *
   *  size: <float>,
   *  sizeAttenuation: <bool>
   * }
   */

  function PointsMaterial$1( parameters ) {

  	Material$1.call( this );

  	this.type = 'PointsMaterial';

  	this.color = new Color$1( 0xffffff );

  	this.map = null;

  	this.size = 1;
  	this.sizeAttenuation = true;

  	this.lights = false;

  	this.setValues( parameters );

  }

  PointsMaterial$1.prototype = Object.create( Material$1.prototype );
  PointsMaterial$1.prototype.constructor = PointsMaterial$1;

  PointsMaterial$1.prototype.isPointsMaterial = true;

  PointsMaterial$1.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.color.copy( source.color );

  	this.map = source.map;

  	this.size = source.size;
  	this.sizeAttenuation = source.sizeAttenuation;

  	return this;

  };

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function Points$1( geometry, material ) {

  	Object3D$1.call( this );

  	this.type = 'Points';

  	this.geometry = geometry !== undefined ? geometry : new BufferGeometry$1();
  	this.material = material !== undefined ? material : new PointsMaterial$1( { color: Math.random() * 0xffffff } );

  }

  Points$1.prototype = Object.assign( Object.create( Object3D$1.prototype ), {

  	constructor: Points$1,

  	isPoints: true,

  	raycast: ( function () {

  		var inverseMatrix = new Matrix4$1();
  		var ray = new Ray$1();
  		var sphere = new Sphere$1();

  		return function raycast( raycaster, intersects ) {

  			var object = this;
  			var geometry = this.geometry;
  			var matrixWorld = this.matrixWorld;
  			var threshold = raycaster.params.Points.threshold;

  			// Checking boundingSphere distance to ray

  			if ( geometry.boundingSphere === null ) { geometry.computeBoundingSphere(); }

  			sphere.copy( geometry.boundingSphere );
  			sphere.applyMatrix4( matrixWorld );
  			sphere.radius += threshold;

  			if ( raycaster.ray.intersectsSphere( sphere ) === false ) { return; }

  			//

  			inverseMatrix.getInverse( matrixWorld );
  			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

  			var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
  			var localThresholdSq = localThreshold * localThreshold;
  			var position = new Vector3$2();

  			function testPoint( point, index ) {

  				var rayPointDistanceSq = ray.distanceSqToPoint( point );

  				if ( rayPointDistanceSq < localThresholdSq ) {

  					var intersectPoint = ray.closestPointToPoint( point );
  					intersectPoint.applyMatrix4( matrixWorld );

  					var distance = raycaster.ray.origin.distanceTo( intersectPoint );

  					if ( distance < raycaster.near || distance > raycaster.far ) { return; }

  					intersects.push( {

  						distance: distance,
  						distanceToRay: Math.sqrt( rayPointDistanceSq ),
  						point: intersectPoint.clone(),
  						index: index,
  						face: null,
  						object: object

  					} );

  				}

  			}

  			if ( geometry.isBufferGeometry ) {

  				var index = geometry.index;
  				var attributes = geometry.attributes;
  				var positions = attributes.position.array;

  				if ( index !== null ) {

  					var indices = index.array;

  					for ( var i = 0, il = indices.length; i < il; i ++ ) {

  						var a = indices[ i ];

  						position.fromArray( positions, a * 3 );

  						testPoint( position, a );

  					}

  				} else {

  					for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

  						position.fromArray( positions, i * 3 );

  						testPoint( position, i );

  					}

  				}

  			} else {

  				var vertices = geometry.vertices;

  				for ( var i = 0, l = vertices.length; i < l; i ++ ) {

  					testPoint( vertices[ i ], i );

  				}

  			}

  		};

  	}() ),

  	clone: function () {

  		return new this.constructor( this.geometry, this.material ).copy( this );

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function Group$1() {

  	Object3D$1.call( this );

  	this.type = 'Group';

  }

  Group$1.prototype = Object.assign( Object.create( Object3D$1.prototype ), {

  	constructor: Group$1

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

  	Texture$1.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  	this.generateMipmaps = false;

  	var scope = this;

  	function update() {

  		if ( video.readyState >= video.HAVE_CURRENT_DATA ) {

  			scope.needsUpdate = true;

  		}

  		requestAnimationFrame( update );

  	}

  	requestAnimationFrame( update );

  }

  VideoTexture.prototype = Object.create( Texture$1.prototype );
  VideoTexture.prototype.constructor = VideoTexture;

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

  	Texture$1.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

  	this.image = { width: width, height: height };
  	this.mipmaps = mipmaps;

  	// no flipping for cube textures
  	// (also flipping doesn't work for compressed textures )

  	this.flipY = false;

  	// can't generate mipmaps for compressed textures
  	// mips must be embedded in DDS files

  	this.generateMipmaps = false;

  }

  CompressedTexture.prototype = Object.create( Texture$1.prototype );
  CompressedTexture.prototype.constructor = CompressedTexture;

  CompressedTexture.prototype.isCompressedTexture = true;

  /**
   * @author Matt DesLauriers / @mattdesl
   * @author atix / arthursilber.de
   */

  function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

  	format = format !== undefined ? format : DepthFormat$1;

  	if ( format !== DepthFormat$1 && format !== DepthStencilFormat$1 ) {

  		throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

  	}

  	if ( type === undefined && format === DepthFormat$1 ) { type = UnsignedShortType$1; }
  	if ( type === undefined && format === DepthStencilFormat$1 ) { type = UnsignedInt248Type$1; }

  	Texture$1.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  	this.image = { width: width, height: height };

  	this.magFilter = magFilter !== undefined ? magFilter : NearestFilter$1;
  	this.minFilter = minFilter !== undefined ? minFilter : NearestFilter$1;

  	this.flipY = false;
  	this.generateMipmaps	= false;

  }

  DepthTexture.prototype = Object.create( Texture$1.prototype );
  DepthTexture.prototype.constructor = DepthTexture;
  DepthTexture.prototype.isDepthTexture = true;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */

  function WireframeGeometry$1( geometry ) {

  	BufferGeometry$1.call( this );

  	this.type = 'WireframeGeometry';

  	// buffer

  	var vertices = [];

  	// helper variables

  	var i, j, l, o, ol;
  	var edge = [ 0, 0 ], edges = {}, e, edge1, edge2;
  	var key, keys = [ 'a', 'b', 'c' ];
  	var vertex;

  	// different logic for Geometry and BufferGeometry

  	if ( geometry && geometry.isGeometry ) {

  		// create a data structure that contains all edges without duplicates

  		var faces = geometry.faces;

  		for ( i = 0, l = faces.length; i < l; i ++ ) {

  			var face = faces[ i ];

  			for ( j = 0; j < 3; j ++ ) {

  				edge1 = face[ keys[ j ] ];
  				edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
  				edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
  				edge[ 1 ] = Math.max( edge1, edge2 );

  				key = edge[ 0 ] + ',' + edge[ 1 ];

  				if ( edges[ key ] === undefined ) {

  					edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

  				}

  			}

  		}

  		// generate vertices

  		for ( key in edges ) {

  			e = edges[ key ];

  			vertex = geometry.vertices[ e.index1 ];
  			vertices.push( vertex.x, vertex.y, vertex.z );

  			vertex = geometry.vertices[ e.index2 ];
  			vertices.push( vertex.x, vertex.y, vertex.z );

  		}

  	} else if ( geometry && geometry.isBufferGeometry ) {

  		var position, indices, groups;
  		var group, start, count;
  		var index1, index2;

  		vertex = new Vector3$2();

  		if ( geometry.index !== null ) {

  			// indexed BufferGeometry

  			position = geometry.attributes.position;
  			indices = geometry.index;
  			groups = geometry.groups;

  			if ( groups.length === 0 ) {

  				groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];

  			}

  			// create a data structure that contains all eges without duplicates

  			for ( o = 0, ol = groups.length; o < ol; ++ o ) {

  				group = groups[ o ];

  				start = group.start;
  				count = group.count;

  				for ( i = start, l = ( start + count ); i < l; i += 3 ) {

  					for ( j = 0; j < 3; j ++ ) {

  						edge1 = indices.getX( i + j );
  						edge2 = indices.getX( i + ( j + 1 ) % 3 );
  						edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
  						edge[ 1 ] = Math.max( edge1, edge2 );

  						key = edge[ 0 ] + ',' + edge[ 1 ];

  						if ( edges[ key ] === undefined ) {

  							edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

  						}

  					}

  				}

  			}

  			// generate vertices

  			for ( key in edges ) {

  				e = edges[ key ];

  				vertex.fromBufferAttribute( position, e.index1 );
  				vertices.push( vertex.x, vertex.y, vertex.z );

  				vertex.fromBufferAttribute( position, e.index2 );
  				vertices.push( vertex.x, vertex.y, vertex.z );

  			}

  		} else {

  			// non-indexed BufferGeometry

  			position = geometry.attributes.position;

  			for ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {

  				for ( j = 0; j < 3; j ++ ) {

  					// three edges per triangle, an edge is represented as (index1, index2)
  					// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

  					index1 = 3 * i + j;
  					vertex.fromBufferAttribute( position, index1 );
  					vertices.push( vertex.x, vertex.y, vertex.z );

  					index2 = 3 * i + ( ( j + 1 ) % 3 );
  					vertex.fromBufferAttribute( position, index2 );
  					vertices.push( vertex.x, vertex.y, vertex.z );

  				}

  			}

  		}

  	}

  	// build geometry

  	this.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );

  }

  WireframeGeometry$1.prototype = Object.create( BufferGeometry$1.prototype );
  WireframeGeometry$1.prototype.constructor = WireframeGeometry$1;

  /**
   * @author zz85 / https://github.com/zz85
   * @author Mugen87 / https://github.com/Mugen87
   *
   * Parametric Surfaces Geometry
   * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
   */

  // ParametricGeometry

  function ParametricGeometry$1( func, slices, stacks ) {

  	Geometry$1.call( this );

  	this.type = 'ParametricGeometry';

  	this.parameters = {
  		func: func,
  		slices: slices,
  		stacks: stacks
  	};

  	this.fromBufferGeometry( new ParametricBufferGeometry$1( func, slices, stacks ) );
  	this.mergeVertices();

  }

  ParametricGeometry$1.prototype = Object.create( Geometry$1.prototype );
  ParametricGeometry$1.prototype.constructor = ParametricGeometry$1;

  // ParametricBufferGeometry

  function ParametricBufferGeometry$1( func, slices, stacks ) {

  	BufferGeometry$1.call( this );

  	this.type = 'ParametricBufferGeometry';

  	this.parameters = {
  		func: func,
  		slices: slices,
  		stacks: stacks
  	};

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	var EPS = 0.00001;

  	var normal = new Vector3$2();

  	var p0 = new Vector3$2(), p1 = new Vector3$2();
  	var pu = new Vector3$2(), pv = new Vector3$2();

  	var i, j;

  	// generate vertices, normals and uvs

  	var sliceCount = slices + 1;

  	for ( i = 0; i <= stacks; i ++ ) {

  		var v = i / stacks;

  		for ( j = 0; j <= slices; j ++ ) {

  			var u = j / slices;

  			// vertex

  			p0 = func( u, v, p0 );
  			vertices.push( p0.x, p0.y, p0.z );

  			// normal

  			// approximate tangent vectors via finite differences

  			if ( u - EPS >= 0 ) {

  				p1 = func( u - EPS, v, p1 );
  				pu.subVectors( p0, p1 );

  			} else {

  				p1 = func( u + EPS, v, p1 );
  				pu.subVectors( p1, p0 );

  			}

  			if ( v - EPS >= 0 ) {

  				p1 = func( u, v - EPS, p1 );
  				pv.subVectors( p0, p1 );

  			} else {

  				p1 = func( u, v + EPS, p1 );
  				pv.subVectors( p1, p0 );

  			}

  			// cross product of tangent vectors returns surface normal

  			normal.crossVectors( pu, pv ).normalize();
  			normals.push( normal.x, normal.y, normal.z );

  			// uv

  			uvs.push( u, v );

  		}

  	}

  	// generate indices

  	for ( i = 0; i < stacks; i ++ ) {

  		for ( j = 0; j < slices; j ++ ) {

  			var a = i * sliceCount + j;
  			var b = i * sliceCount + j + 1;
  			var c = ( i + 1 ) * sliceCount + j + 1;
  			var d = ( i + 1 ) * sliceCount + j;

  			// faces one and two

  			indices.push( a, b, d );
  			indices.push( b, c, d );

  		}

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute$1( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute$1( uvs, 2 ) );

  }

  ParametricBufferGeometry$1.prototype = Object.create( BufferGeometry$1.prototype );
  ParametricBufferGeometry$1.prototype.constructor = ParametricBufferGeometry$1;

  /**
   * @author clockworkgeek / https://github.com/clockworkgeek
   * @author timothypratley / https://github.com/timothypratley
   * @author WestLangley / http://github.com/WestLangley
   * @author Mugen87 / https://github.com/Mugen87
   */

  // PolyhedronGeometry

  function PolyhedronGeometry$1( vertices, indices, radius, detail ) {

  	Geometry$1.call( this );

  	this.type = 'PolyhedronGeometry';

  	this.parameters = {
  		vertices: vertices,
  		indices: indices,
  		radius: radius,
  		detail: detail
  	};

  	this.fromBufferGeometry( new PolyhedronBufferGeometry$1( vertices, indices, radius, detail ) );
  	this.mergeVertices();

  }

  PolyhedronGeometry$1.prototype = Object.create( Geometry$1.prototype );
  PolyhedronGeometry$1.prototype.constructor = PolyhedronGeometry$1;

  // PolyhedronBufferGeometry

  function PolyhedronBufferGeometry$1( vertices, indices, radius, detail ) {

  	BufferGeometry$1.call( this );

  	this.type = 'PolyhedronBufferGeometry';

  	this.parameters = {
  		vertices: vertices,
  		indices: indices,
  		radius: radius,
  		detail: detail
  	};

  	radius = radius || 1;
  	detail = detail || 0;

  	// default buffer data

  	var vertexBuffer = [];
  	var uvBuffer = [];

  	// the subdivision creates the vertex buffer data

  	subdivide( detail );

  	// all vertices should lie on a conceptual sphere with a given radius

  	appplyRadius( radius );

  	// finally, create the uv data

  	generateUVs();

  	// build non-indexed geometry

  	this.addAttribute( 'position', new Float32BufferAttribute$1( vertexBuffer, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute$1( vertexBuffer.slice(), 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute$1( uvBuffer, 2 ) );

  	if ( detail === 0 ) {

  		this.computeVertexNormals(); // flat normals

  	} else {

  		this.normalizeNormals(); // smooth normals

  	}

  	// helper functions

  	function subdivide( detail ) {

  		var a = new Vector3$2();
  		var b = new Vector3$2();
  		var c = new Vector3$2();

  		// iterate over all faces and apply a subdivison with the given detail value

  		for ( var i = 0; i < indices.length; i += 3 ) {

  			// get the vertices of the face

  			getVertexByIndex( indices[ i + 0 ], a );
  			getVertexByIndex( indices[ i + 1 ], b );
  			getVertexByIndex( indices[ i + 2 ], c );

  			// perform subdivision

  			subdivideFace( a, b, c, detail );

  		}

  	}

  	function subdivideFace( a, b, c, detail ) {

  		var cols = Math.pow( 2, detail );

  		// we use this multidimensional array as a data structure for creating the subdivision

  		var v = [];

  		var i, j;

  		// construct all of the vertices for this subdivision

  		for ( i = 0; i <= cols; i ++ ) {

  			v[ i ] = [];

  			var aj = a.clone().lerp( c, i / cols );
  			var bj = b.clone().lerp( c, i / cols );

  			var rows = cols - i;

  			for ( j = 0; j <= rows; j ++ ) {

  				if ( j === 0 && i === cols ) {

  					v[ i ][ j ] = aj;

  				} else {

  					v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

  				}

  			}

  		}

  		// construct all of the faces

  		for ( i = 0; i < cols; i ++ ) {

  			for ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

  				var k = Math.floor( j / 2 );

  				if ( j % 2 === 0 ) {

  					pushVertex( v[ i ][ k + 1 ] );
  					pushVertex( v[ i + 1 ][ k ] );
  					pushVertex( v[ i ][ k ] );

  				} else {

  					pushVertex( v[ i ][ k + 1 ] );
  					pushVertex( v[ i + 1 ][ k + 1 ] );
  					pushVertex( v[ i + 1 ][ k ] );

  				}

  			}

  		}

  	}

  	function appplyRadius( radius ) {

  		var vertex = new Vector3$2();

  		// iterate over the entire buffer and apply the radius to each vertex

  		for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

  			vertex.x = vertexBuffer[ i + 0 ];
  			vertex.y = vertexBuffer[ i + 1 ];
  			vertex.z = vertexBuffer[ i + 2 ];

  			vertex.normalize().multiplyScalar( radius );

  			vertexBuffer[ i + 0 ] = vertex.x;
  			vertexBuffer[ i + 1 ] = vertex.y;
  			vertexBuffer[ i + 2 ] = vertex.z;

  		}

  	}

  	function generateUVs() {

  		var vertex = new Vector3$2();

  		for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

  			vertex.x = vertexBuffer[ i + 0 ];
  			vertex.y = vertexBuffer[ i + 1 ];
  			vertex.z = vertexBuffer[ i + 2 ];

  			var u = azimuth( vertex ) / 2 / Math.PI + 0.5;
  			var v = inclination( vertex ) / Math.PI + 0.5;
  			uvBuffer.push( u, 1 - v );

  		}

  		correctUVs();

  		correctSeam();

  	}

  	function correctSeam() {

  		// handle case when face straddles the seam, see #3269

  		for ( var i = 0; i < uvBuffer.length; i += 6 ) {

  			// uv data of a single face

  			var x0 = uvBuffer[ i + 0 ];
  			var x1 = uvBuffer[ i + 2 ];
  			var x2 = uvBuffer[ i + 4 ];

  			var max = Math.max( x0, x1, x2 );
  			var min = Math.min( x0, x1, x2 );

  			// 0.9 is somewhat arbitrary

  			if ( max > 0.9 && min < 0.1 ) {

  				if ( x0 < 0.2 ) { uvBuffer[ i + 0 ] += 1; }
  				if ( x1 < 0.2 ) { uvBuffer[ i + 2 ] += 1; }
  				if ( x2 < 0.2 ) { uvBuffer[ i + 4 ] += 1; }

  			}

  		}

  	}

  	function pushVertex( vertex ) {

  		vertexBuffer.push( vertex.x, vertex.y, vertex.z );

  	}

  	function getVertexByIndex( index, vertex ) {

  		var stride = index * 3;

  		vertex.x = vertices[ stride + 0 ];
  		vertex.y = vertices[ stride + 1 ];
  		vertex.z = vertices[ stride + 2 ];

  	}

  	function correctUVs() {

  		var a = new Vector3$2();
  		var b = new Vector3$2();
  		var c = new Vector3$2();

  		var centroid = new Vector3$2();

  		var uvA = new Vector2$1();
  		var uvB = new Vector2$1();
  		var uvC = new Vector2$1();

  		for ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

  			a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
  			b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
  			c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

  			uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
  			uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
  			uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

  			centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

  			var azi = azimuth( centroid );

  			correctUV( uvA, j + 0, a, azi );
  			correctUV( uvB, j + 2, b, azi );
  			correctUV( uvC, j + 4, c, azi );

  		}

  	}

  	function correctUV( uv, stride, vector, azimuth ) {

  		if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

  			uvBuffer[ stride ] = uv.x - 1;

  		}

  		if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

  			uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

  		}

  	}

  	// Angle around the Y axis, counter-clockwise when looking from above.

  	function azimuth( vector ) {

  		return Math.atan2( vector.z, - vector.x );

  	}


  	// Angle above the XZ plane.

  	function inclination( vector ) {

  		return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

  	}

  }

  PolyhedronBufferGeometry$1.prototype = Object.create( BufferGeometry$1.prototype );
  PolyhedronBufferGeometry$1.prototype.constructor = PolyhedronBufferGeometry$1;

  /**
   * @author timothypratley / https://github.com/timothypratley
   * @author Mugen87 / https://github.com/Mugen87
   */

  // TetrahedronGeometry

  function TetrahedronGeometry$1( radius, detail ) {

  	Geometry$1.call( this );

  	this.type = 'TetrahedronGeometry';

  	this.parameters = {
  		radius: radius,
  		detail: detail
  	};

  	this.fromBufferGeometry( new TetrahedronBufferGeometry$1( radius, detail ) );
  	this.mergeVertices();

  }

  TetrahedronGeometry$1.prototype = Object.create( Geometry$1.prototype );
  TetrahedronGeometry$1.prototype.constructor = TetrahedronGeometry$1;

  // TetrahedronBufferGeometry

  function TetrahedronBufferGeometry$1( radius, detail ) {

  	var vertices = [
  		1, 1, 1, 	- 1, - 1, 1, 	- 1, 1, - 1, 	1, - 1, - 1
  	];

  	var indices = [
  		2, 1, 0, 	0, 3, 2,	1, 3, 0,	2, 3, 1
  	];

  	PolyhedronBufferGeometry$1.call( this, vertices, indices, radius, detail );

  	this.type = 'TetrahedronBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		detail: detail
  	};

  }

  TetrahedronBufferGeometry$1.prototype = Object.create( PolyhedronBufferGeometry$1.prototype );
  TetrahedronBufferGeometry$1.prototype.constructor = TetrahedronBufferGeometry$1;

  /**
   * @author timothypratley / https://github.com/timothypratley
   * @author Mugen87 / https://github.com/Mugen87
   */

  // OctahedronGeometry

  function OctahedronGeometry$1( radius, detail ) {

  	Geometry$1.call( this );

  	this.type = 'OctahedronGeometry';

  	this.parameters = {
  		radius: radius,
  		detail: detail
  	};

  	this.fromBufferGeometry( new OctahedronBufferGeometry$1( radius, detail ) );
  	this.mergeVertices();

  }

  OctahedronGeometry$1.prototype = Object.create( Geometry$1.prototype );
  OctahedronGeometry$1.prototype.constructor = OctahedronGeometry$1;

  // OctahedronBufferGeometry

  function OctahedronBufferGeometry$1( radius, detail ) {

  	var vertices = [
  		1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
  		0, - 1, 0, 	0, 0, 1,	0, 0, - 1
  	];

  	var indices = [
  		0, 2, 4,	0, 4, 3,	0, 3, 5,
  		0, 5, 2,	1, 2, 5,	1, 5, 3,
  		1, 3, 4,	1, 4, 2
  	];

  	PolyhedronBufferGeometry$1.call( this, vertices, indices, radius, detail );

  	this.type = 'OctahedronBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		detail: detail
  	};

  }

  OctahedronBufferGeometry$1.prototype = Object.create( PolyhedronBufferGeometry$1.prototype );
  OctahedronBufferGeometry$1.prototype.constructor = OctahedronBufferGeometry$1;

  /**
   * @author timothypratley / https://github.com/timothypratley
   * @author Mugen87 / https://github.com/Mugen87
   */

  // IcosahedronGeometry

  function IcosahedronGeometry$1( radius, detail ) {

  	Geometry$1.call( this );

  	this.type = 'IcosahedronGeometry';

  	this.parameters = {
  		radius: radius,
  		detail: detail
  	};

  	this.fromBufferGeometry( new IcosahedronBufferGeometry$1( radius, detail ) );
  	this.mergeVertices();

  }

  IcosahedronGeometry$1.prototype = Object.create( Geometry$1.prototype );
  IcosahedronGeometry$1.prototype.constructor = IcosahedronGeometry$1;

  // IcosahedronBufferGeometry

  function IcosahedronBufferGeometry$1( radius, detail ) {

  	var t = ( 1 + Math.sqrt( 5 ) ) / 2;

  	var vertices = [
  		- 1, t, 0,  	1, t, 0, 	- 1, - t, 0, 	1, - t, 0,
  		 0, - 1, t, 	0, 1, t,	0, - 1, - t, 	0, 1, - t,
  		 t, 0, - 1, 	t, 0, 1, 	- t, 0, - 1, 	- t, 0, 1
  	];

  	var indices = [
  		 0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
  		 1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
  		 3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
  		 4, 9, 5,  	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
  	];

  	PolyhedronBufferGeometry$1.call( this, vertices, indices, radius, detail );

  	this.type = 'IcosahedronBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		detail: detail
  	};

  }

  IcosahedronBufferGeometry$1.prototype = Object.create( PolyhedronBufferGeometry$1.prototype );
  IcosahedronBufferGeometry$1.prototype.constructor = IcosahedronBufferGeometry$1;

  /**
   * @author Abe Pazos / https://hamoid.com
   * @author Mugen87 / https://github.com/Mugen87
   */

  // DodecahedronGeometry

  function DodecahedronGeometry$1( radius, detail ) {

  	Geometry$1.call( this );

  	this.type = 'DodecahedronGeometry';

  	this.parameters = {
  		radius: radius,
  		detail: detail
  	};

  	this.fromBufferGeometry( new DodecahedronBufferGeometry$1( radius, detail ) );
  	this.mergeVertices();

  }

  DodecahedronGeometry$1.prototype = Object.create( Geometry$1.prototype );
  DodecahedronGeometry$1.prototype.constructor = DodecahedronGeometry$1;

  // DodecahedronBufferGeometry

  function DodecahedronBufferGeometry$1( radius, detail ) {

  	var t = ( 1 + Math.sqrt( 5 ) ) / 2;
  	var r = 1 / t;

  	var vertices = [

  		// (1, 1, 1)
  		- 1, - 1, - 1,	- 1, - 1, 1,
  		- 1, 1, - 1, - 1, 1, 1,
  		1, - 1, - 1, 1, - 1, 1,
  		1, 1, - 1, 1, 1, 1,

  		// (0, 1/, )
  		 0, - r, - t, 0, - r, t,
  		 0, r, - t, 0, r, t,

  		// (1/, , 0)
  		- r, - t, 0, - r, t, 0,
  		 r, - t, 0, r, t, 0,

  		// (, 0, 1/)
  		- t, 0, - r, t, 0, - r,
  		- t, 0, r, t, 0, r
  	];

  	var indices = [
  		3, 11, 7, 	3, 7, 15, 	3, 15, 13,
  		7, 19, 17, 	7, 17, 6, 	7, 6, 15,
  		17, 4, 8, 	17, 8, 10, 	17, 10, 6,
  		8, 0, 16, 	8, 16, 2, 	8, 2, 10,
  		0, 12, 1, 	0, 1, 18, 	0, 18, 16,
  		6, 10, 2, 	6, 2, 13, 	6, 13, 15,
  		2, 16, 18, 	2, 18, 3, 	2, 3, 13,
  		18, 1, 9, 	18, 9, 11, 	18, 11, 3,
  		4, 14, 12, 	4, 12, 0, 	4, 0, 8,
  		11, 9, 5, 	11, 5, 19, 	11, 19, 7,
  		19, 5, 14, 	19, 14, 4, 	19, 4, 17,
  		1, 12, 14, 	1, 14, 5, 	1, 5, 9
  	];

  	PolyhedronBufferGeometry$1.call( this, vertices, indices, radius, detail );

  	this.type = 'DodecahedronBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		detail: detail
  	};

  }

  DodecahedronBufferGeometry$1.prototype = Object.create( PolyhedronBufferGeometry$1.prototype );
  DodecahedronBufferGeometry$1.prototype.constructor = DodecahedronBufferGeometry$1;

  /**
   * @author oosmoxiecode / https://github.com/oosmoxiecode
   * @author WestLangley / https://github.com/WestLangley
   * @author zz85 / https://github.com/zz85
   * @author miningold / https://github.com/miningold
   * @author jonobr1 / https://github.com/jonobr1
   * @author Mugen87 / https://github.com/Mugen87
   *
   */

  // TubeGeometry

  function TubeGeometry$1( path, tubularSegments, radius, radialSegments, closed, taper ) {

  	Geometry$1.call( this );

  	this.type = 'TubeGeometry';

  	this.parameters = {
  		path: path,
  		tubularSegments: tubularSegments,
  		radius: radius,
  		radialSegments: radialSegments,
  		closed: closed
  	};

  	if ( taper !== undefined ) { console.warn( 'THREE.TubeGeometry: taper has been removed.' ); }

  	var bufferGeometry = new TubeBufferGeometry$1( path, tubularSegments, radius, radialSegments, closed );

  	// expose internals

  	this.tangents = bufferGeometry.tangents;
  	this.normals = bufferGeometry.normals;
  	this.binormals = bufferGeometry.binormals;

  	// create geometry

  	this.fromBufferGeometry( bufferGeometry );
  	this.mergeVertices();

  }

  TubeGeometry$1.prototype = Object.create( Geometry$1.prototype );
  TubeGeometry$1.prototype.constructor = TubeGeometry$1;

  // TubeBufferGeometry

  function TubeBufferGeometry$1( path, tubularSegments, radius, radialSegments, closed ) {

  	BufferGeometry$1.call( this );

  	this.type = 'TubeBufferGeometry';

  	this.parameters = {
  		path: path,
  		tubularSegments: tubularSegments,
  		radius: radius,
  		radialSegments: radialSegments,
  		closed: closed
  	};

  	tubularSegments = tubularSegments || 64;
  	radius = radius || 1;
  	radialSegments = radialSegments || 8;
  	closed = closed || false;

  	var frames = path.computeFrenetFrames( tubularSegments, closed );

  	// expose internals

  	this.tangents = frames.tangents;
  	this.normals = frames.normals;
  	this.binormals = frames.binormals;

  	// helper variables

  	var vertex = new Vector3$2();
  	var normal = new Vector3$2();
  	var uv = new Vector2$1();

  	var i, j;

  	// buffer

  	var vertices = [];
  	var normals = [];
  	var uvs = [];
  	var indices = [];

  	// create buffer data

  	generateBufferData();

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute$1( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute$1( uvs, 2 ) );

  	// functions

  	function generateBufferData() {

  		for ( i = 0; i < tubularSegments; i ++ ) {

  			generateSegment( i );

  		}

  		// if the geometry is not closed, generate the last row of vertices and normals
  		// at the regular position on the given path
  		//
  		// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

  		generateSegment( ( closed === false ) ? tubularSegments : 0 );

  		// uvs are generated in a separate function.
  		// this makes it easy compute correct values for closed geometries

  		generateUVs();

  		// finally create faces

  		generateIndices();

  	}

  	function generateSegment( i ) {

  		// we use getPointAt to sample evenly distributed points from the given path

  		var P = path.getPointAt( i / tubularSegments );

  		// retrieve corresponding normal and binormal

  		var N = frames.normals[ i ];
  		var B = frames.binormals[ i ];

  		// generate normals and vertices for the current segment

  		for ( j = 0; j <= radialSegments; j ++ ) {

  			var v = j / radialSegments * Math.PI * 2;

  			var sin = Math.sin( v );
  			var cos = - Math.cos( v );

  			// normal

  			normal.x = ( cos * N.x + sin * B.x );
  			normal.y = ( cos * N.y + sin * B.y );
  			normal.z = ( cos * N.z + sin * B.z );
  			normal.normalize();

  			normals.push( normal.x, normal.y, normal.z );

  			// vertex

  			vertex.x = P.x + radius * normal.x;
  			vertex.y = P.y + radius * normal.y;
  			vertex.z = P.z + radius * normal.z;

  			vertices.push( vertex.x, vertex.y, vertex.z );

  		}

  	}

  	function generateIndices() {

  		for ( j = 1; j <= tubularSegments; j ++ ) {

  			for ( i = 1; i <= radialSegments; i ++ ) {

  				var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
  				var b = ( radialSegments + 1 ) * j + ( i - 1 );
  				var c = ( radialSegments + 1 ) * j + i;
  				var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

  				// faces

  				indices.push( a, b, d );
  				indices.push( b, c, d );

  			}

  		}

  	}

  	function generateUVs() {

  		for ( i = 0; i <= tubularSegments; i ++ ) {

  			for ( j = 0; j <= radialSegments; j ++ ) {

  				uv.x = i / tubularSegments;
  				uv.y = j / radialSegments;

  				uvs.push( uv.x, uv.y );

  			}

  		}

  	}

  }

  TubeBufferGeometry$1.prototype = Object.create( BufferGeometry$1.prototype );
  TubeBufferGeometry$1.prototype.constructor = TubeBufferGeometry$1;

  /**
   * @author oosmoxiecode
   * @author Mugen87 / https://github.com/Mugen87
   *
   * based on http://www.blackpawn.com/texts/pqtorus/
   */

  // TorusKnotGeometry

  function TorusKnotGeometry$1( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {

  	Geometry$1.call( this );

  	this.type = 'TorusKnotGeometry';

  	this.parameters = {
  		radius: radius,
  		tube: tube,
  		tubularSegments: tubularSegments,
  		radialSegments: radialSegments,
  		p: p,
  		q: q
  	};

  	if ( heightScale !== undefined ) { console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' ); }

  	this.fromBufferGeometry( new TorusKnotBufferGeometry$1( radius, tube, tubularSegments, radialSegments, p, q ) );
  	this.mergeVertices();

  }

  TorusKnotGeometry$1.prototype = Object.create( Geometry$1.prototype );
  TorusKnotGeometry$1.prototype.constructor = TorusKnotGeometry$1;

  // TorusKnotBufferGeometry

  function TorusKnotBufferGeometry$1( radius, tube, tubularSegments, radialSegments, p, q ) {

  	BufferGeometry$1.call( this );

  	this.type = 'TorusKnotBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		tube: tube,
  		tubularSegments: tubularSegments,
  		radialSegments: radialSegments,
  		p: p,
  		q: q
  	};

  	radius = radius || 100;
  	tube = tube || 40;
  	tubularSegments = Math.floor( tubularSegments ) || 64;
  	radialSegments = Math.floor( radialSegments ) || 8;
  	p = p || 2;
  	q = q || 3;

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// helper variables

  	var i, j;

  	var vertex = new Vector3$2();
  	var normal = new Vector3$2();

  	var P1 = new Vector3$2();
  	var P2 = new Vector3$2();

  	var B = new Vector3$2();
  	var T = new Vector3$2();
  	var N = new Vector3$2();

  	// generate vertices, normals and uvs

  	for ( i = 0; i <= tubularSegments; ++ i ) {

  		// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

  		var u = i / tubularSegments * p * Math.PI * 2;

  		// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
  		// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

  		calculatePositionOnCurve( u, p, q, radius, P1 );
  		calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

  		// calculate orthonormal basis

  		T.subVectors( P2, P1 );
  		N.addVectors( P2, P1 );
  		B.crossVectors( T, N );
  		N.crossVectors( B, T );

  		// normalize B, N. T can be ignored, we don't use it

  		B.normalize();
  		N.normalize();

  		for ( j = 0; j <= radialSegments; ++ j ) {

  			// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
  			// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

  			var v = j / radialSegments * Math.PI * 2;
  			var cx = - tube * Math.cos( v );
  			var cy = tube * Math.sin( v );

  			// now calculate the final vertex position.
  			// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

  			vertex.x = P1.x + ( cx * N.x + cy * B.x );
  			vertex.y = P1.y + ( cx * N.y + cy * B.y );
  			vertex.z = P1.z + ( cx * N.z + cy * B.z );

  			vertices.push( vertex.x, vertex.y, vertex.z );

  			// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

  			normal.subVectors( vertex, P1 ).normalize();

  			normals.push( normal.x, normal.y, normal.z );

  			// uv

  			uvs.push( i / tubularSegments );
  			uvs.push( j / radialSegments );

  		}

  	}

  	// generate indices

  	for ( j = 1; j <= tubularSegments; j ++ ) {

  		for ( i = 1; i <= radialSegments; i ++ ) {

  			// indices

  			var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
  			var b = ( radialSegments + 1 ) * j + ( i - 1 );
  			var c = ( radialSegments + 1 ) * j + i;
  			var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

  			// faces

  			indices.push( a, b, d );
  			indices.push( b, c, d );

  		}

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute$1( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute$1( uvs, 2 ) );

  	// this function calculates the current position on the torus curve

  	function calculatePositionOnCurve( u, p, q, radius, position ) {

  		var cu = Math.cos( u );
  		var su = Math.sin( u );
  		var quOverP = q / p * u;
  		var cs = Math.cos( quOverP );

  		position.x = radius * ( 2 + cs ) * 0.5 * cu;
  		position.y = radius * ( 2 + cs ) * su * 0.5;
  		position.z = radius * Math.sin( quOverP ) * 0.5;

  	}

  }

  TorusKnotBufferGeometry$1.prototype = Object.create( BufferGeometry$1.prototype );
  TorusKnotBufferGeometry$1.prototype.constructor = TorusKnotBufferGeometry$1;

  /**
   * @author oosmoxiecode
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */

  // TorusGeometry

  function TorusGeometry$1( radius, tube, radialSegments, tubularSegments, arc ) {

  	Geometry$1.call( this );

  	this.type = 'TorusGeometry';

  	this.parameters = {
  		radius: radius,
  		tube: tube,
  		radialSegments: radialSegments,
  		tubularSegments: tubularSegments,
  		arc: arc
  	};

  	this.fromBufferGeometry( new TorusBufferGeometry$1( radius, tube, radialSegments, tubularSegments, arc ) );
  	this.mergeVertices();

  }

  TorusGeometry$1.prototype = Object.create( Geometry$1.prototype );
  TorusGeometry$1.prototype.constructor = TorusGeometry$1;

  // TorusBufferGeometry

  function TorusBufferGeometry$1( radius, tube, radialSegments, tubularSegments, arc ) {

  	BufferGeometry$1.call( this );

  	this.type = 'TorusBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		tube: tube,
  		radialSegments: radialSegments,
  		tubularSegments: tubularSegments,
  		arc: arc
  	};

  	radius = radius || 100;
  	tube = tube || 40;
  	radialSegments = Math.floor( radialSegments ) || 8;
  	tubularSegments = Math.floor( tubularSegments ) || 6;
  	arc = arc || Math.PI * 2;

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// helper variables

  	var center = new Vector3$2();
  	var vertex = new Vector3$2();
  	var normal = new Vector3$2();

  	var j, i;

  	// generate vertices, normals and uvs

  	for ( j = 0; j <= radialSegments; j ++ ) {

  		for ( i = 0; i <= tubularSegments; i ++ ) {

  			var u = i / tubularSegments * arc;
  			var v = j / radialSegments * Math.PI * 2;

  			// vertex

  			vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
  			vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
  			vertex.z = tube * Math.sin( v );

  			vertices.push( vertex.x, vertex.y, vertex.z );

  			// normal

  			center.x = radius * Math.cos( u );
  			center.y = radius * Math.sin( u );
  			normal.subVectors( vertex, center ).normalize();

  			normals.push( normal.x, normal.y, normal.z );

  			// uv

  			uvs.push( i / tubularSegments );
  			uvs.push( j / radialSegments );

  		}

  	}

  	// generate indices

  	for ( j = 1; j <= radialSegments; j ++ ) {

  		for ( i = 1; i <= tubularSegments; i ++ ) {

  			// indices

  			var a = ( tubularSegments + 1 ) * j + i - 1;
  			var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
  			var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
  			var d = ( tubularSegments + 1 ) * j + i;

  			// faces

  			indices.push( a, b, d );
  			indices.push( b, c, d );

  		}

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute$1( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute$1( uvs, 2 ) );

  }

  TorusBufferGeometry$1.prototype = Object.create( BufferGeometry$1.prototype );
  TorusBufferGeometry$1.prototype.constructor = TorusBufferGeometry$1;

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   */

  var ShapeUtils$1 = {

  	// calculate area of the contour polygon

  	area: function ( contour ) {

  		var n = contour.length;
  		var a = 0.0;

  		for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

  			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

  		}

  		return a * 0.5;

  	},

  	triangulate: ( function () {

  		/**
  		 * This code is a quick port of code written in C++ which was submitted to
  		 * flipcode.com by John W. Ratcliff  // July 22, 2000
  		 * See original code and more information here:
  		 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
  		 *
  		 * ported to actionscript by Zevan Rosser
  		 * www.actionsnippet.com
  		 *
  		 * ported to javascript by Joshua Koo
  		 * http://www.lab4games.net/zz85/blog
  		 *
  		 */

  		function snip( contour, u, v, w, n, verts ) {

  			var p;
  			var ax, ay, bx, by;
  			var cx, cy, px, py;

  			ax = contour[ verts[ u ] ].x;
  			ay = contour[ verts[ u ] ].y;

  			bx = contour[ verts[ v ] ].x;
  			by = contour[ verts[ v ] ].y;

  			cx = contour[ verts[ w ] ].x;
  			cy = contour[ verts[ w ] ].y;

  			if ( ( bx - ax ) * ( cy - ay ) - ( by - ay ) * ( cx - ax ) <= 0 ) { return false; }

  			var aX, aY, bX, bY, cX, cY;
  			var apx, apy, bpx, bpy, cpx, cpy;
  			var cCROSSap, bCROSScp, aCROSSbp;

  			aX = cx - bx; aY = cy - by;
  			bX = ax - cx; bY = ay - cy;
  			cX = bx - ax; cY = by - ay;

  			for ( p = 0; p < n; p ++ ) {

  				px = contour[ verts[ p ] ].x;
  				py = contour[ verts[ p ] ].y;

  				if ( ( ( px === ax ) && ( py === ay ) ) ||
  					 ( ( px === bx ) && ( py === by ) ) ||
  					 ( ( px === cx ) && ( py === cy ) ) )	{ continue; }

  				apx = px - ax; apy = py - ay;
  				bpx = px - bx; bpy = py - by;
  				cpx = px - cx; cpy = py - cy;

  				// see if p is inside triangle abc

  				aCROSSbp = aX * bpy - aY * bpx;
  				cCROSSap = cX * apy - cY * apx;
  				bCROSScp = bX * cpy - bY * cpx;

  				if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) { return false; }

  			}

  			return true;

  		}

  		// takes in an contour array and returns

  		return function triangulate( contour, indices ) {

  			var n = contour.length;

  			if ( n < 3 ) { return null; }

  			var result = [],
  				verts = [],
  				vertIndices = [];

  			/* we want a counter-clockwise polygon in verts */

  			var u, v, w;

  			if ( ShapeUtils$1.area( contour ) > 0.0 ) {

  				for ( v = 0; v < n; v ++ ) { verts[ v ] = v; }

  			} else {

  				for ( v = 0; v < n; v ++ ) { verts[ v ] = ( n - 1 ) - v; }

  			}

  			var nv = n;

  			/*  remove nv - 2 vertices, creating 1 triangle every time */

  			var count = 2 * nv; /* error detection */

  			for ( v = nv - 1; nv > 2; ) {

  				/* if we loop, it is probably a non-simple polygon */

  				if ( ( count -- ) <= 0 ) {

  					//** Triangulate: ERROR - probable bad polygon!

  					//throw ( "Warning, unable to triangulate polygon!" );
  					//return null;
  					// Sometimes warning is fine, especially polygons are triangulated in reverse.
  					console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );

  					if ( indices ) { return vertIndices; }
  					return result;

  				}

  				/* three consecutive vertices in current polygon, <u,v,w> */

  				u = v; if ( nv <= u ) { u = 0; } /* previous */
  				v = u + 1; if ( nv <= v ) { v = 0; } /* new v    */
  				w = v + 1; if ( nv <= w ) { w = 0; } /* next     */

  				if ( snip( contour, u, v, w, nv, verts ) ) {

  					var a, b, c, s, t;

  					/* true names of the vertices */

  					a = verts[ u ];
  					b = verts[ v ];
  					c = verts[ w ];

  					/* output Triangle */

  					result.push( [ contour[ a ],
  						contour[ b ],
  						contour[ c ] ] );


  					vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

  					/* remove v from the remaining polygon */

  					for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {

  						verts[ s ] = verts[ t ];

  					}

  					nv --;

  					/* reset error detection counter */

  					count = 2 * nv;

  				}

  			}

  			if ( indices ) { return vertIndices; }
  			return result;

  		};

  	} )(),

  	triangulateShape: function ( contour, holes ) {

  		function removeDupEndPts( points ) {

  			var l = points.length;

  			if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

  				points.pop();

  			}

  		}

  		removeDupEndPts( contour );
  		holes.forEach( removeDupEndPts );

  		function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {

  			// inOtherPt needs to be collinear to the inSegment
  			if ( inSegPt1.x !== inSegPt2.x ) {

  				if ( inSegPt1.x < inSegPt2.x ) {

  					return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );

  				} else {

  					return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );

  				}

  			} else {

  				if ( inSegPt1.y < inSegPt2.y ) {

  					return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );

  				} else {

  					return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );

  				}

  			}

  		}

  		function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {

  			var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x, seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
  			var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x, seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

  			var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
  			var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

  			var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
  			var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

  			if ( Math.abs( limit ) > Number.EPSILON ) {

  				// not parallel

  				var perpSeg2;
  				if ( limit > 0 ) {

  					if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		{ return []; }
  					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
  					if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		{ return []; }

  				} else {

  					if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		{ return []; }
  					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
  					if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		{ return []; }

  				}

  				// i.e. to reduce rounding errors
  				// intersection at endpoint of segment#1?
  				if ( perpSeg2 === 0 ) {

  					if ( ( inExcludeAdjacentSegs ) &&
  						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		{ return []; }
  					return [ inSeg1Pt1 ];

  				}
  				if ( perpSeg2 === limit ) {

  					if ( ( inExcludeAdjacentSegs ) &&
  						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		{ return []; }
  					return [ inSeg1Pt2 ];

  				}
  				// intersection at endpoint of segment#2?
  				if ( perpSeg1 === 0 )		{ return [ inSeg2Pt1 ]; }
  				if ( perpSeg1 === limit )	{ return [ inSeg2Pt2 ]; }

  				// return real intersection point
  				var factorSeg1 = perpSeg2 / limit;
  				return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx, y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

  			} else {

  				// parallel or collinear
  				if ( ( perpSeg1 !== 0 ) ||
  					 ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			{ return []; }

  				// they are collinear or degenerate
  				var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?
  				var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?
  				// both segments are points
  				if ( seg1Pt && seg2Pt ) {

  					if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
  						 ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		{ return []; }	// they are distinct  points
  					return [ inSeg1Pt1 ];                 						// they are the same point

  				}
  				// segment#1  is a single point
  				if ( seg1Pt ) {

  					if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		{ return []; }		// but not in segment#2
  					return [ inSeg1Pt1 ];

  				}
  				// segment#2  is a single point
  				if ( seg2Pt ) {

  					if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		{ return []; }		// but not in segment#1
  					return [ inSeg2Pt1 ];

  				}

  				// they are collinear segments, which might overlap
  				var seg1min, seg1max, seg1minVal, seg1maxVal;
  				var seg2min, seg2max, seg2minVal, seg2maxVal;
  				if ( seg1dx !== 0 ) {

  					// the segments are NOT on a vertical line
  					if ( inSeg1Pt1.x < inSeg1Pt2.x ) {

  						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
  						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;

  					} else {

  						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
  						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;

  					}
  					if ( inSeg2Pt1.x < inSeg2Pt2.x ) {

  						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
  						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;

  					} else {

  						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
  						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;

  					}

  				} else {

  					// the segments are on a vertical line
  					if ( inSeg1Pt1.y < inSeg1Pt2.y ) {

  						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
  						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;

  					} else {

  						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
  						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;

  					}
  					if ( inSeg2Pt1.y < inSeg2Pt2.y ) {

  						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
  						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;

  					} else {

  						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
  						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;

  					}

  				}
  				if ( seg1minVal <= seg2minVal ) {

  					if ( seg1maxVal < seg2minVal )	{ return []; }
  					if ( seg1maxVal === seg2minVal )	{

  						if ( inExcludeAdjacentSegs )		{ return []; }
  						return [ seg2min ];

  					}
  					if ( seg1maxVal <= seg2maxVal )	{ return [ seg2min, seg1max ]; }
  					return	[ seg2min, seg2max ];

  				} else {

  					if ( seg1minVal > seg2maxVal )	{ return []; }
  					if ( seg1minVal === seg2maxVal )	{

  						if ( inExcludeAdjacentSegs )		{ return []; }
  						return [ seg1min ];

  					}
  					if ( seg1maxVal <= seg2maxVal )	{ return [ seg1min, seg1max ]; }
  					return	[ seg1min, seg2max ];

  				}

  			}

  		}

  		function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {

  			// The order of legs is important

  			// translation of all points, so that Vertex is at (0,0)
  			var legFromPtX	= inLegFromPt.x - inVertex.x, legFromPtY = inLegFromPt.y - inVertex.y;
  			var legToPtX	= inLegToPt.x	- inVertex.x, legToPtY = inLegToPt.y	- inVertex.y;
  			var otherPtX	= inOtherPt.x	- inVertex.x, otherPtY = inOtherPt.y	- inVertex.y;

  			// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
  			var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
  			var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;

  			if ( Math.abs( from2toAngle ) > Number.EPSILON ) {

  				// angle != 180 deg.

  				var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
  				// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

  				if ( from2toAngle > 0 ) {

  					// main angle < 180 deg.
  					return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );

  				} else {

  					// main angle > 180 deg.
  					return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );

  				}

  			} else {

  				// angle == 180 deg.
  				// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
  				return	( from2otherAngle > 0 );

  			}

  		}


  		function removeHoles( contour, holes ) {

  			var shape = contour.concat(); // work on this shape
  			var hole;

  			function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {

  				// Check if hole point lies within angle around shape point
  				var lastShapeIdx = shape.length - 1;

  				var prevShapeIdx = inShapeIdx - 1;
  				if ( prevShapeIdx < 0 )			{ prevShapeIdx = lastShapeIdx; }

  				var nextShapeIdx = inShapeIdx + 1;
  				if ( nextShapeIdx > lastShapeIdx )	{ nextShapeIdx = 0; }

  				var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
  				if ( ! insideAngle ) {

  					// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
  					return	false;

  				}

  				// Check if shape point lies within angle around hole point
  				var lastHoleIdx = hole.length - 1;

  				var prevHoleIdx = inHoleIdx - 1;
  				if ( prevHoleIdx < 0 )			{ prevHoleIdx = lastHoleIdx; }

  				var nextHoleIdx = inHoleIdx + 1;
  				if ( nextHoleIdx > lastHoleIdx )	{ nextHoleIdx = 0; }

  				insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
  				if ( ! insideAngle ) {

  					// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
  					return	false;

  				}

  				return	true;

  			}

  			function intersectsShapeEdge( inShapePt, inHolePt ) {

  				// checks for intersections with shape edges
  				var sIdx, nextIdx, intersection;
  				for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {

  					nextIdx = sIdx + 1; nextIdx %= shape.length;
  					intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
  					if ( intersection.length > 0 )		{ return	true; }

  				}

  				return	false;

  			}

  			var indepHoles = [];

  			function intersectsHoleEdge( inShapePt, inHolePt ) {

  				// checks for intersections with hole edges
  				var ihIdx, chkHole,
  					hIdx, nextIdx, intersection;
  				for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {

  					chkHole = holes[ indepHoles[ ihIdx ] ];
  					for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {

  						nextIdx = hIdx + 1; nextIdx %= chkHole.length;
  						intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
  						if ( intersection.length > 0 )		{ return	true; }

  					}

  				}
  				return	false;

  			}

  			var holeIndex, shapeIndex,
  				shapePt, holePt,
  				holeIdx, cutKey, failedCuts = [],
  				tmpShape1, tmpShape2,
  				tmpHole1, tmpHole2;

  			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

  				indepHoles.push( h );

  			}

  			var minShapeIndex = 0;
  			var counter = indepHoles.length * 2;
  			while ( indepHoles.length > 0 ) {

  				counter --;
  				if ( counter < 0 ) {

  					console.log( 'THREE.ShapeUtils: Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!' );
  					break;

  				}

  				// search for shape-vertex and hole-vertex,
  				// which can be connected without intersections
  				for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

  					shapePt = shape[ shapeIndex ];
  					holeIndex	= - 1;

  					// search for hole which can be reached without intersections
  					for ( var h = 0; h < indepHoles.length; h ++ ) {

  						holeIdx = indepHoles[ h ];

  						// prevent multiple checks
  						cutKey = shapePt.x + ':' + shapePt.y + ':' + holeIdx;
  						if ( failedCuts[ cutKey ] !== undefined )			{ continue; }

  						hole = holes[ holeIdx ];
  						for ( var h2 = 0; h2 < hole.length; h2 ++ ) {

  							holePt = hole[ h2 ];
  							if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		{ continue; }
  							if ( intersectsShapeEdge( shapePt, holePt ) )		{ continue; }
  							if ( intersectsHoleEdge( shapePt, holePt ) )		{ continue; }

  							holeIndex = h2;
  							indepHoles.splice( h, 1 );

  							tmpShape1 = shape.slice( 0, shapeIndex + 1 );
  							tmpShape2 = shape.slice( shapeIndex );
  							tmpHole1 = hole.slice( holeIndex );
  							tmpHole2 = hole.slice( 0, holeIndex + 1 );

  							shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

  							minShapeIndex = shapeIndex;

  							// Debug only, to show the selected cuts
  							// glob_CutLines.push( [ shapePt, holePt ] );

  							break;

  						}
  						if ( holeIndex >= 0 )	{ break; }		// hole-vertex found

  						failedCuts[ cutKey ] = true;			// remember failure

  					}
  					if ( holeIndex >= 0 )	{ break; }		// hole-vertex found

  				}

  			}

  			return shape; 			/* shape with no holes */

  		}


  		var i, il, f, face,
  			key, index,
  			allPointsMap = {};

  		// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

  		var allpoints = contour.concat();

  		for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

  			Array.prototype.push.apply( allpoints, holes[ h ] );

  		}

  		//console.log( "allpoints",allpoints, allpoints.length );

  		// prepare all points map

  		for ( i = 0, il = allpoints.length; i < il; i ++ ) {

  			key = allpoints[ i ].x + ':' + allpoints[ i ].y;

  			if ( allPointsMap[ key ] !== undefined ) {

  				console.warn( 'THREE.ShapeUtils: Duplicate point', key, i );

  			}

  			allPointsMap[ key ] = i;

  		}

  		// remove holes by cutting paths to holes and adding them to the shape
  		var shapeWithoutHoles = removeHoles( contour, holes );

  		var triangles = ShapeUtils$1.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
  		//console.log( "triangles",triangles, triangles.length );

  		// check all face vertices against all points map

  		for ( i = 0, il = triangles.length; i < il; i ++ ) {

  			face = triangles[ i ];

  			for ( f = 0; f < 3; f ++ ) {

  				key = face[ f ].x + ':' + face[ f ].y;

  				index = allPointsMap[ key ];

  				if ( index !== undefined ) {

  					face[ f ] = index;

  				}

  			}

  		}

  		return triangles.concat();

  	},

  	isClockWise: function ( pts ) {

  		return ShapeUtils$1.area( pts ) < 0;

  	}

  };

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   *
   * Creates extruded geometry from a path shape.
   *
   * parameters = {
   *
   *  curveSegments: <int>, // number of points on the curves
   *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
   *  amount: <int>, // Depth to extrude the shape
   *
   *  bevelEnabled: <bool>, // turn on bevel
   *  bevelThickness: <float>, // how deep into the original shape bevel goes
   *  bevelSize: <float>, // how far from shape outline is bevel
   *  bevelSegments: <int>, // number of bevel layers
   *
   *  extrudePath: <THREE.Curve> // curve to extrude shape along
   *  frames: <Object> // containing arrays of tangents, normals, binormals
   *
   *  UVGenerator: <Object> // object that provides UV generator functions
   *
   * }
   */

  // ExtrudeGeometry

  function ExtrudeGeometry$1( shapes, options ) {

  	Geometry$1.call( this );

  	this.type = 'ExtrudeGeometry';

  	this.parameters = {
  		shapes: shapes,
  		options: options
  	};

  	this.fromBufferGeometry( new ExtrudeBufferGeometry$1( shapes, options ) );
  	this.mergeVertices();

  }

  ExtrudeGeometry$1.prototype = Object.create( Geometry$1.prototype );
  ExtrudeGeometry$1.prototype.constructor = ExtrudeGeometry$1;

  // ExtrudeBufferGeometry

  function ExtrudeBufferGeometry$1( shapes, options ) {

  	if ( typeof ( shapes ) === "undefined" ) {

  		return;

  	}

  	BufferGeometry$1.call( this );

  	this.type = 'ExtrudeBufferGeometry';

  	shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

  	this.addShapeList( shapes, options );

  	this.computeVertexNormals();

  	// can't really use automatic vertex normals
  	// as then front and back sides get smoothed too
  	// should do separate smoothing just for sides

  	//this.computeVertexNormals();

  	//console.log( "took", ( Date.now() - startTime ) );

  }

  ExtrudeBufferGeometry$1.prototype = Object.create( BufferGeometry$1.prototype );
  ExtrudeBufferGeometry$1.prototype.constructor = ExtrudeBufferGeometry$1;

  ExtrudeBufferGeometry$1.prototype.getArrays = function () {

  	var positionAttribute = this.getAttribute( "position" );
  	var verticesArray = positionAttribute ? Array.prototype.slice.call( positionAttribute.array ) : [];

  	var uvAttribute = this.getAttribute( "uv" );
  	var uvArray = uvAttribute ? Array.prototype.slice.call( uvAttribute.array ) : [];

  	var IndexAttribute = this.index;
  	var indicesArray = IndexAttribute ? Array.prototype.slice.call( IndexAttribute.array ) : [];

  	return {
  		position: verticesArray,
  		uv: uvArray,
  		index: indicesArray
  	};

  };

  ExtrudeBufferGeometry$1.prototype.addShapeList = function ( shapes, options ) {
  	var this$1 = this;


  	var sl = shapes.length;
  	options.arrays = this.getArrays();

  	for ( var s = 0; s < sl; s ++ ) {

  		var shape = shapes[ s ];
  		this$1.addShape( shape, options );

  	}

  	this.setIndex( options.arrays.index );
  	this.addAttribute( 'position', new Float32BufferAttribute$1( options.arrays.position, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute$1( options.arrays.uv, 2 ) );

  };

  ExtrudeBufferGeometry$1.prototype.addShape = function ( shape, options ) {

  	var arrays = options.arrays ? options.arrays : this.getArrays();
  	var verticesArray = arrays.position;
  	var indicesArray = arrays.index;
  	var uvArray = arrays.uv;

  	var placeholder = [];


  	var amount = options.amount !== undefined ? options.amount : 100;

  	var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
  	var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
  	var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

  	var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

  	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

  	var steps = options.steps !== undefined ? options.steps : 1;

  	var extrudePath = options.extrudePath;
  	var extrudePts, extrudeByPath = false;

  	// Use default WorldUVGenerator if no UV generators are specified.
  	var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry$1.WorldUVGenerator;

  	var splineTube, binormal, normal, position2;
  	if ( extrudePath ) {

  		extrudePts = extrudePath.getSpacedPoints( steps );

  		extrudeByPath = true;
  		bevelEnabled = false; // bevels not supported for path extrusion

  		// SETUP TNB variables

  		// TODO1 - have a .isClosed in spline?

  		splineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames( steps, false );

  		// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

  		binormal = new Vector3$2();
  		normal = new Vector3$2();
  		position2 = new Vector3$2();

  	}

  	// Safeguards if bevels are not enabled

  	if ( ! bevelEnabled ) {

  		bevelSegments = 0;
  		bevelThickness = 0;
  		bevelSize = 0;

  	}

  	// Variables initialization

  	var ahole, h, hl; // looping of holes
  	var scope = this;

  	var shapePoints = shape.extractPoints( curveSegments );

  	var vertices = shapePoints.shape;
  	var holes = shapePoints.holes;

  	var reverse = ! ShapeUtils$1.isClockWise( vertices );

  	if ( reverse ) {

  		vertices = vertices.reverse();

  		// Maybe we should also check if holes are in the opposite direction, just to be safe ...

  		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

  			ahole = holes[ h ];

  			if ( ShapeUtils$1.isClockWise( ahole ) ) {

  				holes[ h ] = ahole.reverse();

  			}

  		}

  	}


  	var faces = ShapeUtils$1.triangulateShape( vertices, holes );

  	/* Vertices */

  	var contour = vertices; // vertices has all points but contour has only points of circumference

  	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

  		ahole = holes[ h ];

  		vertices = vertices.concat( ahole );

  	}


  	function scalePt2( pt, vec, size ) {

  		if ( ! vec ) { console.error( "THREE.ExtrudeGeometry: vec does not exist" ); }

  		return vec.clone().multiplyScalar( size ).add( pt );

  	}

  	var b, bs, t, z,
  		vert, vlen = vertices.length,
  		face, flen = faces.length;


  	// Find directions for point movement


  	function getBevelVec( inPt, inPrev, inNext ) {

  		// computes for inPt the corresponding point inPt' on a new contour
  		//   shifted by 1 unit (length of normalized vector) to the left
  		// if we walk along contour clockwise, this new contour is outside the old one
  		//
  		// inPt' is the intersection of the two lines parallel to the two
  		//  adjacent edges of inPt at a distance of 1 unit on the left side.

  		var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

  		// good reading for geometry algorithms (here: line-line intersection)
  		// http://geomalgorithms.com/a05-_intersect-1.html

  		var v_prev_x = inPt.x - inPrev.x,
  			v_prev_y = inPt.y - inPrev.y;
  		var v_next_x = inNext.x - inPt.x,
  			v_next_y = inNext.y - inPt.y;

  		var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

  		// check for collinear edges
  		var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

  		if ( Math.abs( collinear0 ) > Number.EPSILON ) {

  			// not collinear

  			// length of vectors for normalizing

  			var v_prev_len = Math.sqrt( v_prev_lensq );
  			var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

  			// shift adjacent points by unit vectors to the left

  			var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
  			var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

  			var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
  			var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

  			// scaling factor for v_prev to intersection point

  			var sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
  					( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
  				( v_prev_x * v_next_y - v_prev_y * v_next_x );

  			// vector from inPt to intersection point

  			v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
  			v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

  			// Don't normalize!, otherwise sharp corners become ugly
  			//  but prevent crazy spikes
  			var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
  			if ( v_trans_lensq <= 2 ) {

  				return new Vector2$1( v_trans_x, v_trans_y );

  			} else {

  				shrink_by = Math.sqrt( v_trans_lensq / 2 );

  			}

  		} else {

  			// handle special case of collinear edges

  			var direction_eq = false; // assumes: opposite
  			if ( v_prev_x > Number.EPSILON ) {

  				if ( v_next_x > Number.EPSILON ) {

  					direction_eq = true;

  				}

  			} else {

  				if ( v_prev_x < - Number.EPSILON ) {

  					if ( v_next_x < - Number.EPSILON ) {

  						direction_eq = true;

  					}

  				} else {

  					if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

  						direction_eq = true;

  					}

  				}

  			}

  			if ( direction_eq ) {

  				// console.log("Warning: lines are a straight sequence");
  				v_trans_x = - v_prev_y;
  				v_trans_y = v_prev_x;
  				shrink_by = Math.sqrt( v_prev_lensq );

  			} else {

  				// console.log("Warning: lines are a straight spike");
  				v_trans_x = v_prev_x;
  				v_trans_y = v_prev_y;
  				shrink_by = Math.sqrt( v_prev_lensq / 2 );

  			}

  		}

  		return new Vector2$1( v_trans_x / shrink_by, v_trans_y / shrink_by );

  	}


  	var contourMovements = [];

  	for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

  		if ( j === il ) { j = 0; }
  		if ( k === il ) { k = 0; }

  		//  (j)---(i)---(k)
  		// console.log('i,j,k', i, j , k)

  		contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

  	}

  	var holesMovements = [],
  		oneHoleMovements, verticesMovements = contourMovements.concat();

  	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

  		ahole = holes[ h ];

  		oneHoleMovements = [];

  		for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

  			if ( j === il ) { j = 0; }
  			if ( k === il ) { k = 0; }

  			//  (j)---(i)---(k)
  			oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

  		}

  		holesMovements.push( oneHoleMovements );
  		verticesMovements = verticesMovements.concat( oneHoleMovements );

  	}


  	// Loop bevelSegments, 1 for the front, 1 for the back

  	for ( b = 0; b < bevelSegments; b ++ ) {

  		//for ( b = bevelSegments; b > 0; b -- ) {

  		t = b / bevelSegments;
  		z = bevelThickness * Math.cos( t * Math.PI / 2 );
  		bs = bevelSize * Math.sin( t * Math.PI / 2 );

  		// contract shape

  		for ( i = 0, il = contour.length; i < il; i ++ ) {

  			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

  			v( vert.x, vert.y, - z );

  		}

  		// expand holes

  		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

  			ahole = holes[ h ];
  			oneHoleMovements = holesMovements[ h ];

  			for ( i = 0, il = ahole.length; i < il; i ++ ) {

  				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

  				v( vert.x, vert.y, - z );

  			}

  		}

  	}

  	bs = bevelSize;

  	// Back facing vertices

  	for ( i = 0; i < vlen; i ++ ) {

  		vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

  		if ( ! extrudeByPath ) {

  			v( vert.x, vert.y, 0 );

  		} else {

  			// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

  			normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
  			binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

  			position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

  			v( position2.x, position2.y, position2.z );

  		}

  	}

  	// Add stepped vertices...
  	// Including front facing vertices

  	var s;

  	for ( s = 1; s <= steps; s ++ ) {

  		for ( i = 0; i < vlen; i ++ ) {

  			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

  			if ( ! extrudeByPath ) {

  				v( vert.x, vert.y, amount / steps * s );

  			} else {

  				// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

  				normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
  				binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

  				position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

  				v( position2.x, position2.y, position2.z );

  			}

  		}

  	}


  	// Add bevel segments planes

  	//for ( b = 1; b <= bevelSegments; b ++ ) {
  	for ( b = bevelSegments - 1; b >= 0; b -- ) {

  		t = b / bevelSegments;
  		z = bevelThickness * Math.cos( t * Math.PI / 2 );
  		bs = bevelSize * Math.sin( t * Math.PI / 2 );

  		// contract shape

  		for ( i = 0, il = contour.length; i < il; i ++ ) {

  			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
  			v( vert.x, vert.y, amount + z );

  		}

  		// expand holes

  		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

  			ahole = holes[ h ];
  			oneHoleMovements = holesMovements[ h ];

  			for ( i = 0, il = ahole.length; i < il; i ++ ) {

  				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

  				if ( ! extrudeByPath ) {

  					v( vert.x, vert.y, amount + z );

  				} else {

  					v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

  				}

  			}

  		}

  	}

  	/* Faces */

  	// Top and bottom faces

  	buildLidFaces();

  	// Sides faces

  	buildSideFaces();


  	/////  Internal functions

  	function buildLidFaces() {

  		var start = verticesArray.length / 3;

  		if ( bevelEnabled ) {

  			var layer = 0; // steps + 1
  			var offset = vlen * layer;

  			// Bottom faces

  			for ( i = 0; i < flen; i ++ ) {

  				face = faces[ i ];
  				f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

  			}

  			layer = steps + bevelSegments * 2;
  			offset = vlen * layer;

  			// Top faces

  			for ( i = 0; i < flen; i ++ ) {

  				face = faces[ i ];
  				f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

  			}

  		} else {

  			// Bottom faces

  			for ( i = 0; i < flen; i ++ ) {

  				face = faces[ i ];
  				f3( face[ 2 ], face[ 1 ], face[ 0 ] );

  			}

  			// Top faces

  			for ( i = 0; i < flen; i ++ ) {

  				face = faces[ i ];
  				f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

  			}

  		}

  		scope.addGroup( start, verticesArray.length / 3 - start, options.material !== undefined ? options.material : 0 );

  	}

  	// Create faces for the z-sides of the shape

  	function buildSideFaces() {

  		var start = verticesArray.length / 3;
  		var layeroffset = 0;
  		sidewalls( contour, layeroffset );
  		layeroffset += contour.length;

  		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

  			ahole = holes[ h ];
  			sidewalls( ahole, layeroffset );

  			//, true
  			layeroffset += ahole.length;

  		}


  		scope.addGroup( start, verticesArray.length / 3 - start, options.extrudeMaterial !== undefined ? options.extrudeMaterial : 1 );


  	}

  	function sidewalls( contour, layeroffset ) {

  		var j, k;
  		i = contour.length;

  		while ( -- i >= 0 ) {

  			j = i;
  			k = i - 1;
  			if ( k < 0 ) { k = contour.length - 1; }

  			//console.log('b', i,j, i-1, k,vertices.length);

  			var s = 0,
  				sl = steps + bevelSegments * 2;

  			for ( s = 0; s < sl; s ++ ) {

  				var slen1 = vlen * s;
  				var slen2 = vlen * ( s + 1 );

  				var a = layeroffset + j + slen1,
  					b = layeroffset + k + slen1,
  					c = layeroffset + k + slen2,
  					d = layeroffset + j + slen2;

  				f4( a, b, c, d );

  			}

  		}

  	}

  	function v( x, y, z ) {

  		placeholder.push( x );
  		placeholder.push( y );
  		placeholder.push( z );

  	}


  	function f3( a, b, c ) {

  		addVertex( a );
  		addVertex( b );
  		addVertex( c );

  		var nextIndex = verticesArray.length / 3;
  		var uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

  		addUV( uvs[ 0 ] );
  		addUV( uvs[ 1 ] );
  		addUV( uvs[ 2 ] );

  	}

  	function f4( a, b, c, d ) {

  		addVertex( a );
  		addVertex( b );
  		addVertex( d );

  		addVertex( b );
  		addVertex( c );
  		addVertex( d );


  		var nextIndex = verticesArray.length / 3;
  		var uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

  		addUV( uvs[ 0 ] );
  		addUV( uvs[ 1 ] );
  		addUV( uvs[ 3 ] );

  		addUV( uvs[ 1 ] );
  		addUV( uvs[ 2 ] );
  		addUV( uvs[ 3 ] );

  	}

  	function addVertex( index ) {

  		indicesArray.push( verticesArray.length / 3 );
  		verticesArray.push( placeholder[ index * 3 + 0 ] );
  		verticesArray.push( placeholder[ index * 3 + 1 ] );
  		verticesArray.push( placeholder[ index * 3 + 2 ] );

  	}


  	function addUV( vector2 ) {

  		uvArray.push( vector2.x );
  		uvArray.push( vector2.y );

  	}

  	if ( ! options.arrays ) {

  		this.setIndex( indicesArray );
  		this.addAttribute( 'position', new Float32BufferAttribute$1( verticesArray, 3 ) );
  		this.addAttribute( 'uv', new Float32BufferAttribute$1( options.arrays.uv, 2 ) );

  	}

  };

  ExtrudeGeometry$1.WorldUVGenerator = {

  	generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

  		var a_x = vertices[ indexA * 3 ];
  		var a_y = vertices[ indexA * 3 + 1 ];
  		var b_x = vertices[ indexB * 3 ];
  		var b_y = vertices[ indexB * 3 + 1 ];
  		var c_x = vertices[ indexC * 3 ];
  		var c_y = vertices[ indexC * 3 + 1 ];

  		return [
  			new Vector2$1( a_x, a_y ),
  			new Vector2$1( b_x, b_y ),
  			new Vector2$1( c_x, c_y )
  		];

  	},

  	generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

  		var a_x = vertices[ indexA * 3 ];
  		var a_y = vertices[ indexA * 3 + 1 ];
  		var a_z = vertices[ indexA * 3 + 2 ];
  		var b_x = vertices[ indexB * 3 ];
  		var b_y = vertices[ indexB * 3 + 1 ];
  		var b_z = vertices[ indexB * 3 + 2 ];
  		var c_x = vertices[ indexC * 3 ];
  		var c_y = vertices[ indexC * 3 + 1 ];
  		var c_z = vertices[ indexC * 3 + 2 ];
  		var d_x = vertices[ indexD * 3 ];
  		var d_y = vertices[ indexD * 3 + 1 ];
  		var d_z = vertices[ indexD * 3 + 2 ];

  		if ( Math.abs( a_y - b_y ) < 0.01 ) {

  			return [
  				new Vector2$1( a_x, 1 - a_z ),
  				new Vector2$1( b_x, 1 - b_z ),
  				new Vector2$1( c_x, 1 - c_z ),
  				new Vector2$1( d_x, 1 - d_z )
  			];

  		} else {

  			return [
  				new Vector2$1( a_y, 1 - a_z ),
  				new Vector2$1( b_y, 1 - b_z ),
  				new Vector2$1( c_y, 1 - c_z ),
  				new Vector2$1( d_y, 1 - d_z )
  			];

  		}

  	}
  };

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * @author alteredq / http://alteredqualia.com/
   *
   * Text = 3D Text
   *
   * parameters = {
   *  font: <THREE.Font>, // font
   *
   *  size: <float>, // size of the text
   *  height: <float>, // thickness to extrude text
   *  curveSegments: <int>, // number of points on the curves
   *
   *  bevelEnabled: <bool>, // turn on bevel
   *  bevelThickness: <float>, // how deep into text bevel goes
   *  bevelSize: <float> // how far from text outline is bevel
   * }
   */

  // TextGeometry

  function TextGeometry$1( text, parameters ) {

  	Geometry$1.call( this );

  	this.type = 'TextGeometry';

  	this.parameters = {
  		text: text,
  		parameters: parameters
  	};

  	this.fromBufferGeometry( new TextBufferGeometry$1( text, parameters ) );
  	this.mergeVertices();

  }

  TextGeometry$1.prototype = Object.create( Geometry$1.prototype );
  TextGeometry$1.prototype.constructor = TextGeometry$1;

  // TextBufferGeometry

  function TextBufferGeometry$1( text, parameters ) {

  	parameters = parameters || {};

  	var font = parameters.font;

  	if ( ! ( font && font.isFont ) ) {

  		console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
  		return new Geometry$1();

  	}

  	var shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );

  	// translate parameters to ExtrudeGeometry API

  	parameters.amount = parameters.height !== undefined ? parameters.height : 50;

  	// defaults

  	if ( parameters.bevelThickness === undefined ) { parameters.bevelThickness = 10; }
  	if ( parameters.bevelSize === undefined ) { parameters.bevelSize = 8; }
  	if ( parameters.bevelEnabled === undefined ) { parameters.bevelEnabled = false; }

  	ExtrudeBufferGeometry$1.call( this, shapes, parameters );

  	this.type = 'TextBufferGeometry';

  }

  TextBufferGeometry$1.prototype = Object.create( ExtrudeBufferGeometry$1.prototype );
  TextBufferGeometry$1.prototype.constructor = TextBufferGeometry$1;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author benaadams / https://twitter.com/ben_a_adams
   * @author Mugen87 / https://github.com/Mugen87
   */

  // SphereGeometry

  function SphereGeometry$1( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

  	Geometry$1.call( this );

  	this.type = 'SphereGeometry';

  	this.parameters = {
  		radius: radius,
  		widthSegments: widthSegments,
  		heightSegments: heightSegments,
  		phiStart: phiStart,
  		phiLength: phiLength,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  	this.fromBufferGeometry( new SphereBufferGeometry$1( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );
  	this.mergeVertices();

  }

  SphereGeometry$1.prototype = Object.create( Geometry$1.prototype );
  SphereGeometry$1.prototype.constructor = SphereGeometry$1;

  // SphereBufferGeometry

  function SphereBufferGeometry$1( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

  	BufferGeometry$1.call( this );

  	this.type = 'SphereBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		widthSegments: widthSegments,
  		heightSegments: heightSegments,
  		phiStart: phiStart,
  		phiLength: phiLength,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  	radius = radius || 50;

  	widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
  	heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

  	phiStart = phiStart !== undefined ? phiStart : 0;
  	phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

  	thetaStart = thetaStart !== undefined ? thetaStart : 0;
  	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

  	var thetaEnd = thetaStart + thetaLength;

  	var ix, iy;

  	var index = 0;
  	var grid = [];

  	var vertex = new Vector3$2();
  	var normal = new Vector3$2();

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// generate vertices, normals and uvs

  	for ( iy = 0; iy <= heightSegments; iy ++ ) {

  		var verticesRow = [];

  		var v = iy / heightSegments;

  		for ( ix = 0; ix <= widthSegments; ix ++ ) {

  			var u = ix / widthSegments;

  			// vertex

  			vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
  			vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
  			vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

  			vertices.push( vertex.x, vertex.y, vertex.z );

  			// normal

  			normal.set( vertex.x, vertex.y, vertex.z ).normalize();
  			normals.push( normal.x, normal.y, normal.z );

  			// uv

  			uvs.push( u, 1 - v );

  			verticesRow.push( index ++ );

  		}

  		grid.push( verticesRow );

  	}

  	// indices

  	for ( iy = 0; iy < heightSegments; iy ++ ) {

  		for ( ix = 0; ix < widthSegments; ix ++ ) {

  			var a = grid[ iy ][ ix + 1 ];
  			var b = grid[ iy ][ ix ];
  			var c = grid[ iy + 1 ][ ix ];
  			var d = grid[ iy + 1 ][ ix + 1 ];

  			if ( iy !== 0 || thetaStart > 0 ) { indices.push( a, b, d ); }
  			if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) { indices.push( b, c, d ); }

  		}

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute$1( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute$1( uvs, 2 ) );

  }

  SphereBufferGeometry$1.prototype = Object.create( BufferGeometry$1.prototype );
  SphereBufferGeometry$1.prototype.constructor = SphereBufferGeometry$1;

  /**
   * @author Kaleb Murphy
   * @author Mugen87 / https://github.com/Mugen87
   */

  // RingGeometry

  function RingGeometry$1( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

  	Geometry$1.call( this );

  	this.type = 'RingGeometry';

  	this.parameters = {
  		innerRadius: innerRadius,
  		outerRadius: outerRadius,
  		thetaSegments: thetaSegments,
  		phiSegments: phiSegments,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  	this.fromBufferGeometry( new RingBufferGeometry$1( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );
  	this.mergeVertices();

  }

  RingGeometry$1.prototype = Object.create( Geometry$1.prototype );
  RingGeometry$1.prototype.constructor = RingGeometry$1;

  // RingBufferGeometry

  function RingBufferGeometry$1( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

  	BufferGeometry$1.call( this );

  	this.type = 'RingBufferGeometry';

  	this.parameters = {
  		innerRadius: innerRadius,
  		outerRadius: outerRadius,
  		thetaSegments: thetaSegments,
  		phiSegments: phiSegments,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  	innerRadius = innerRadius || 20;
  	outerRadius = outerRadius || 50;

  	thetaStart = thetaStart !== undefined ? thetaStart : 0;
  	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

  	thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
  	phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// some helper variables

  	var segment;
  	var radius = innerRadius;
  	var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
  	var vertex = new Vector3$2();
  	var uv = new Vector2$1();
  	var j, i;

  	// generate vertices, normals and uvs

  	for ( j = 0; j <= phiSegments; j ++ ) {

  		for ( i = 0; i <= thetaSegments; i ++ ) {

  			// values are generate from the inside of the ring to the outside

  			segment = thetaStart + i / thetaSegments * thetaLength;

  			// vertex

  			vertex.x = radius * Math.cos( segment );
  			vertex.y = radius * Math.sin( segment );

  			vertices.push( vertex.x, vertex.y, vertex.z );

  			// normal

  			normals.push( 0, 0, 1 );

  			// uv

  			uv.x = ( vertex.x / outerRadius + 1 ) / 2;
  			uv.y = ( vertex.y / outerRadius + 1 ) / 2;

  			uvs.push( uv.x, uv.y );

  		}

  		// increase the radius for next row of vertices

  		radius += radiusStep;

  	}

  	// indices

  	for ( j = 0; j < phiSegments; j ++ ) {

  		var thetaSegmentLevel = j * ( thetaSegments + 1 );

  		for ( i = 0; i < thetaSegments; i ++ ) {

  			segment = i + thetaSegmentLevel;

  			var a = segment;
  			var b = segment + thetaSegments + 1;
  			var c = segment + thetaSegments + 2;
  			var d = segment + 1;

  			// faces

  			indices.push( a, b, d );
  			indices.push( b, c, d );

  		}

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute$1( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute$1( uvs, 2 ) );

  }

  RingBufferGeometry$1.prototype = Object.create( BufferGeometry$1.prototype );
  RingBufferGeometry$1.prototype.constructor = RingBufferGeometry$1;

  /**
   * @author astrodud / http://astrodud.isgreat.org/
   * @author zz85 / https://github.com/zz85
   * @author bhouston / http://clara.io
   * @author Mugen87 / https://github.com/Mugen87
   */

  // LatheGeometry

  function LatheGeometry$1( points, segments, phiStart, phiLength ) {

  	Geometry$1.call( this );

  	this.type = 'LatheGeometry';

  	this.parameters = {
  		points: points,
  		segments: segments,
  		phiStart: phiStart,
  		phiLength: phiLength
  	};

  	this.fromBufferGeometry( new LatheBufferGeometry$1( points, segments, phiStart, phiLength ) );
  	this.mergeVertices();

  }

  LatheGeometry$1.prototype = Object.create( Geometry$1.prototype );
  LatheGeometry$1.prototype.constructor = LatheGeometry$1;

  // LatheBufferGeometry

  function LatheBufferGeometry$1( points, segments, phiStart, phiLength ) {

  	BufferGeometry$1.call( this );

  	this.type = 'LatheBufferGeometry';

  	this.parameters = {
  		points: points,
  		segments: segments,
  		phiStart: phiStart,
  		phiLength: phiLength
  	};

  	segments = Math.floor( segments ) || 12;
  	phiStart = phiStart || 0;
  	phiLength = phiLength || Math.PI * 2;

  	// clamp phiLength so it's in range of [ 0, 2PI ]

  	phiLength = _Math$1.clamp( phiLength, 0, Math.PI * 2 );


  	// buffers

  	var indices = [];
  	var vertices = [];
  	var uvs = [];

  	// helper variables

  	var base;
  	var inverseSegments = 1.0 / segments;
  	var vertex = new Vector3$2();
  	var uv = new Vector2$1();
  	var i, j;

  	// generate vertices and uvs

  	for ( i = 0; i <= segments; i ++ ) {

  		var phi = phiStart + i * inverseSegments * phiLength;

  		var sin = Math.sin( phi );
  		var cos = Math.cos( phi );

  		for ( j = 0; j <= ( points.length - 1 ); j ++ ) {

  			// vertex

  			vertex.x = points[ j ].x * sin;
  			vertex.y = points[ j ].y;
  			vertex.z = points[ j ].x * cos;

  			vertices.push( vertex.x, vertex.y, vertex.z );

  			// uv

  			uv.x = i / segments;
  			uv.y = j / ( points.length - 1 );

  			uvs.push( uv.x, uv.y );


  		}

  	}

  	// indices

  	for ( i = 0; i < segments; i ++ ) {

  		for ( j = 0; j < ( points.length - 1 ); j ++ ) {

  			base = j + i * points.length;

  			var a = base;
  			var b = base + points.length;
  			var c = base + points.length + 1;
  			var d = base + 1;

  			// faces

  			indices.push( a, b, d );
  			indices.push( b, c, d );

  		}

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute$1( uvs, 2 ) );

  	// generate normals

  	this.computeVertexNormals();

  	// if the geometry is closed, we need to average the normals along the seam.
  	// because the corresponding vertices are identical (but still have different UVs).

  	if ( phiLength === Math.PI * 2 ) {

  		var normals = this.attributes.normal.array;
  		var n1 = new Vector3$2();
  		var n2 = new Vector3$2();
  		var n = new Vector3$2();

  		// this is the buffer offset for the last line of vertices

  		base = segments * points.length * 3;

  		for ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {

  			// select the normal of the vertex in the first line

  			n1.x = normals[ j + 0 ];
  			n1.y = normals[ j + 1 ];
  			n1.z = normals[ j + 2 ];

  			// select the normal of the vertex in the last line

  			n2.x = normals[ base + j + 0 ];
  			n2.y = normals[ base + j + 1 ];
  			n2.z = normals[ base + j + 2 ];

  			// average normals

  			n.addVectors( n1, n2 ).normalize();

  			// assign the new values to both normals

  			normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
  			normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
  			normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

  		}

  	}

  }

  LatheBufferGeometry$1.prototype = Object.create( BufferGeometry$1.prototype );
  LatheBufferGeometry$1.prototype.constructor = LatheBufferGeometry$1;

  /**
   * @author jonobr1 / http://jonobr1.com
   * @author Mugen87 / https://github.com/Mugen87
   */

  // ShapeGeometry

  function ShapeGeometry$1( shapes, curveSegments ) {

  	Geometry$1.call( this );

  	this.type = 'ShapeGeometry';

  	if ( typeof curveSegments === 'object' ) {

  		console.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );

  		curveSegments = curveSegments.curveSegments;

  	}

  	this.parameters = {
  		shapes: shapes,
  		curveSegments: curveSegments
  	};

  	this.fromBufferGeometry( new ShapeBufferGeometry$1( shapes, curveSegments ) );
  	this.mergeVertices();

  }

  ShapeGeometry$1.prototype = Object.create( Geometry$1.prototype );
  ShapeGeometry$1.prototype.constructor = ShapeGeometry$1;

  // ShapeBufferGeometry

  function ShapeBufferGeometry$1( shapes, curveSegments ) {
  	var this$1 = this;


  	BufferGeometry$1.call( this );

  	this.type = 'ShapeBufferGeometry';

  	this.parameters = {
  		shapes: shapes,
  		curveSegments: curveSegments
  	};

  	curveSegments = curveSegments || 12;

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// helper variables

  	var groupStart = 0;
  	var groupCount = 0;

  	// allow single and array values for "shapes" parameter

  	if ( Array.isArray( shapes ) === false ) {

  		addShape( shapes );

  	} else {

  		for ( var i = 0; i < shapes.length; i ++ ) {

  			addShape( shapes[ i ] );

  			this$1.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

  			groupStart += groupCount;
  			groupCount = 0;

  		}

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute$1( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute$1( uvs, 2 ) );


  	// helper functions

  	function addShape( shape ) {

  		var i, l, shapeHole;

  		var indexOffset = vertices.length / 3;
  		var points = shape.extractPoints( curveSegments );

  		var shapeVertices = points.shape;
  		var shapeHoles = points.holes;

  		// check direction of vertices

  		if ( ShapeUtils$1.isClockWise( shapeVertices ) === false ) {

  			shapeVertices = shapeVertices.reverse();

  			// also check if holes are in the opposite direction

  			for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

  				shapeHole = shapeHoles[ i ];

  				if ( ShapeUtils$1.isClockWise( shapeHole ) === true ) {

  					shapeHoles[ i ] = shapeHole.reverse();

  				}

  			}

  		}

  		var faces = ShapeUtils$1.triangulateShape( shapeVertices, shapeHoles );

  		// join vertices of inner and outer paths to a single array

  		for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

  			shapeHole = shapeHoles[ i ];
  			shapeVertices = shapeVertices.concat( shapeHole );

  		}

  		// vertices, normals, uvs

  		for ( i = 0, l = shapeVertices.length; i < l; i ++ ) {

  			var vertex = shapeVertices[ i ];

  			vertices.push( vertex.x, vertex.y, 0 );
  			normals.push( 0, 0, 1 );
  			uvs.push( vertex.x, vertex.y ); // world uvs

  		}

  		// incides

  		for ( i = 0, l = faces.length; i < l; i ++ ) {

  			var face = faces[ i ];

  			var a = face[ 0 ] + indexOffset;
  			var b = face[ 1 ] + indexOffset;
  			var c = face[ 2 ] + indexOffset;

  			indices.push( a, b, c );
  			groupCount += 3;

  		}

  	}

  }

  ShapeBufferGeometry$1.prototype = Object.create( BufferGeometry$1.prototype );
  ShapeBufferGeometry$1.prototype.constructor = ShapeBufferGeometry$1;

  /**
   * @author WestLangley / http://github.com/WestLangley
   * @author Mugen87 / https://github.com/Mugen87
   */

  function EdgesGeometry$1( geometry, thresholdAngle ) {

  	BufferGeometry$1.call( this );

  	this.type = 'EdgesGeometry';

  	this.parameters = {
  		thresholdAngle: thresholdAngle
  	};

  	thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

  	// buffer

  	var vertices = [];

  	// helper variables

  	var thresholdDot = Math.cos( _Math$1.DEG2RAD * thresholdAngle );
  	var edge = [ 0, 0 ], edges = {}, edge1, edge2;
  	var key, keys = [ 'a', 'b', 'c' ];

  	// prepare source geometry

  	var geometry2;

  	if ( geometry.isBufferGeometry ) {

  		geometry2 = new Geometry$1();
  		geometry2.fromBufferGeometry( geometry );

  	} else {

  		geometry2 = geometry.clone();

  	}

  	geometry2.mergeVertices();
  	geometry2.computeFaceNormals();

  	var sourceVertices = geometry2.vertices;
  	var faces = geometry2.faces;

  	// now create a data structure where each entry represents an edge with its adjoining faces

  	for ( var i = 0, l = faces.length; i < l; i ++ ) {

  		var face = faces[ i ];

  		for ( var j = 0; j < 3; j ++ ) {

  			edge1 = face[ keys[ j ] ];
  			edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
  			edge[ 0 ] = Math.min( edge1, edge2 );
  			edge[ 1 ] = Math.max( edge1, edge2 );

  			key = edge[ 0 ] + ',' + edge[ 1 ];

  			if ( edges[ key ] === undefined ) {

  				edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };

  			} else {

  				edges[ key ].face2 = i;

  			}

  		}

  	}

  	// generate vertices

  	for ( key in edges ) {

  		var e = edges[ key ];

  		// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.

  		if ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {

  			var vertex = sourceVertices[ e.index1 ];
  			vertices.push( vertex.x, vertex.y, vertex.z );

  			vertex = sourceVertices[ e.index2 ];
  			vertices.push( vertex.x, vertex.y, vertex.z );

  		}

  	}

  	// build geometry

  	this.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );

  }

  EdgesGeometry$1.prototype = Object.create( BufferGeometry$1.prototype );
  EdgesGeometry$1.prototype.constructor = EdgesGeometry$1;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */

  // CylinderGeometry

  function CylinderGeometry$1( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

  	Geometry$1.call( this );

  	this.type = 'CylinderGeometry';

  	this.parameters = {
  		radiusTop: radiusTop,
  		radiusBottom: radiusBottom,
  		height: height,
  		radialSegments: radialSegments,
  		heightSegments: heightSegments,
  		openEnded: openEnded,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  	this.fromBufferGeometry( new CylinderBufferGeometry$1( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
  	this.mergeVertices();

  }

  CylinderGeometry$1.prototype = Object.create( Geometry$1.prototype );
  CylinderGeometry$1.prototype.constructor = CylinderGeometry$1;

  // CylinderBufferGeometry

  function CylinderBufferGeometry$1( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

  	BufferGeometry$1.call( this );

  	this.type = 'CylinderBufferGeometry';

  	this.parameters = {
  		radiusTop: radiusTop,
  		radiusBottom: radiusBottom,
  		height: height,
  		radialSegments: radialSegments,
  		heightSegments: heightSegments,
  		openEnded: openEnded,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  	var scope = this;

  	radiusTop = radiusTop !== undefined ? radiusTop : 20;
  	radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
  	height = height !== undefined ? height : 100;

  	radialSegments = Math.floor( radialSegments ) || 8;
  	heightSegments = Math.floor( heightSegments ) || 1;

  	openEnded = openEnded !== undefined ? openEnded : false;
  	thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
  	thetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// helper variables

  	var index = 0;
  	var indexArray = [];
  	var halfHeight = height / 2;
  	var groupStart = 0;

  	// generate geometry

  	generateTorso();

  	if ( openEnded === false ) {

  		if ( radiusTop > 0 ) { generateCap( true ); }
  		if ( radiusBottom > 0 ) { generateCap( false ); }

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute$1( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute$1( uvs, 2 ) );

  	function generateTorso() {

  		var x, y;
  		var normal = new Vector3$2();
  		var vertex = new Vector3$2();

  		var groupCount = 0;

  		// this will be used to calculate the normal
  		var slope = ( radiusBottom - radiusTop ) / height;

  		// generate vertices, normals and uvs

  		for ( y = 0; y <= heightSegments; y ++ ) {

  			var indexRow = [];

  			var v = y / heightSegments;

  			// calculate the radius of the current row

  			var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

  			for ( x = 0; x <= radialSegments; x ++ ) {

  				var u = x / radialSegments;

  				var theta = u * thetaLength + thetaStart;

  				var sinTheta = Math.sin( theta );
  				var cosTheta = Math.cos( theta );

  				// vertex

  				vertex.x = radius * sinTheta;
  				vertex.y = - v * height + halfHeight;
  				vertex.z = radius * cosTheta;
  				vertices.push( vertex.x, vertex.y, vertex.z );

  				// normal

  				normal.set( sinTheta, slope, cosTheta ).normalize();
  				normals.push( normal.x, normal.y, normal.z );

  				// uv

  				uvs.push( u, 1 - v );

  				// save index of vertex in respective row

  				indexRow.push( index ++ );

  			}

  			// now save vertices of the row in our index array

  			indexArray.push( indexRow );

  		}

  		// generate indices

  		for ( x = 0; x < radialSegments; x ++ ) {

  			for ( y = 0; y < heightSegments; y ++ ) {

  				// we use the index array to access the correct indices

  				var a = indexArray[ y ][ x ];
  				var b = indexArray[ y + 1 ][ x ];
  				var c = indexArray[ y + 1 ][ x + 1 ];
  				var d = indexArray[ y ][ x + 1 ];

  				// faces

  				indices.push( a, b, d );
  				indices.push( b, c, d );

  				// update group counter

  				groupCount += 6;

  			}

  		}

  		// add a group to the geometry. this will ensure multi material support

  		scope.addGroup( groupStart, groupCount, 0 );

  		// calculate new start value for groups

  		groupStart += groupCount;

  	}

  	function generateCap( top ) {

  		var x, centerIndexStart, centerIndexEnd;

  		var uv = new Vector2$1();
  		var vertex = new Vector3$2();

  		var groupCount = 0;

  		var radius = ( top === true ) ? radiusTop : radiusBottom;
  		var sign = ( top === true ) ? 1 : - 1;

  		// save the index of the first center vertex
  		centerIndexStart = index;

  		// first we generate the center vertex data of the cap.
  		// because the geometry needs one set of uvs per face,
  		// we must generate a center vertex per face/segment

  		for ( x = 1; x <= radialSegments; x ++ ) {

  			// vertex

  			vertices.push( 0, halfHeight * sign, 0 );

  			// normal

  			normals.push( 0, sign, 0 );

  			// uv

  			uvs.push( 0.5, 0.5 );

  			// increase index

  			index ++;

  		}

  		// save the index of the last center vertex

  		centerIndexEnd = index;

  		// now we generate the surrounding vertices, normals and uvs

  		for ( x = 0; x <= radialSegments; x ++ ) {

  			var u = x / radialSegments;
  			var theta = u * thetaLength + thetaStart;

  			var cosTheta = Math.cos( theta );
  			var sinTheta = Math.sin( theta );

  			// vertex

  			vertex.x = radius * sinTheta;
  			vertex.y = halfHeight * sign;
  			vertex.z = radius * cosTheta;
  			vertices.push( vertex.x, vertex.y, vertex.z );

  			// normal

  			normals.push( 0, sign, 0 );

  			// uv

  			uv.x = ( cosTheta * 0.5 ) + 0.5;
  			uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
  			uvs.push( uv.x, uv.y );

  			// increase index

  			index ++;

  		}

  		// generate indices

  		for ( x = 0; x < radialSegments; x ++ ) {

  			var c = centerIndexStart + x;
  			var i = centerIndexEnd + x;

  			if ( top === true ) {

  				// face top

  				indices.push( i, i + 1, c );

  			} else {

  				// face bottom

  				indices.push( i + 1, i, c );

  			}

  			groupCount += 3;

  		}

  		// add a group to the geometry. this will ensure multi material support

  		scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

  		// calculate new start value for groups

  		groupStart += groupCount;

  	}

  }

  CylinderBufferGeometry$1.prototype = Object.create( BufferGeometry$1.prototype );
  CylinderBufferGeometry$1.prototype.constructor = CylinderBufferGeometry$1;

  /**
   * @author abelnation / http://github.com/abelnation
   */

  // ConeGeometry

  function ConeGeometry$1( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

  	CylinderGeometry$1.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

  	this.type = 'ConeGeometry';

  	this.parameters = {
  		radius: radius,
  		height: height,
  		radialSegments: radialSegments,
  		heightSegments: heightSegments,
  		openEnded: openEnded,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  }

  ConeGeometry$1.prototype = Object.create( CylinderGeometry$1.prototype );
  ConeGeometry$1.prototype.constructor = ConeGeometry$1;

  // ConeBufferGeometry

  function ConeBufferGeometry$1( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

  	CylinderBufferGeometry$1.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

  	this.type = 'ConeBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		height: height,
  		radialSegments: radialSegments,
  		heightSegments: heightSegments,
  		openEnded: openEnded,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  }

  ConeBufferGeometry$1.prototype = Object.create( CylinderBufferGeometry$1.prototype );
  ConeBufferGeometry$1.prototype.constructor = ConeBufferGeometry$1;

  /**
   * @author benaadams / https://twitter.com/ben_a_adams
   * @author Mugen87 / https://github.com/Mugen87
   * @author hughes
   */

  // CircleGeometry

  function CircleGeometry$1( radius, segments, thetaStart, thetaLength ) {

  	Geometry$1.call( this );

  	this.type = 'CircleGeometry';

  	this.parameters = {
  		radius: radius,
  		segments: segments,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  	this.fromBufferGeometry( new CircleBufferGeometry$1( radius, segments, thetaStart, thetaLength ) );
  	this.mergeVertices();

  }

  CircleGeometry$1.prototype = Object.create( Geometry$1.prototype );
  CircleGeometry$1.prototype.constructor = CircleGeometry$1;

  // CircleBufferGeometry

  function CircleBufferGeometry$1( radius, segments, thetaStart, thetaLength ) {

  	BufferGeometry$1.call( this );

  	this.type = 'CircleBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		segments: segments,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  	radius = radius || 50;
  	segments = segments !== undefined ? Math.max( 3, segments ) : 8;

  	thetaStart = thetaStart !== undefined ? thetaStart : 0;
  	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// helper variables

  	var i, s;
  	var vertex = new Vector3$2();
  	var uv = new Vector2$1();

  	// center point

  	vertices.push( 0, 0, 0 );
  	normals.push( 0, 0, 1 );
  	uvs.push( 0.5, 0.5 );

  	for ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {

  		var segment = thetaStart + s / segments * thetaLength;

  		// vertex

  		vertex.x = radius * Math.cos( segment );
  		vertex.y = radius * Math.sin( segment );

  		vertices.push( vertex.x, vertex.y, vertex.z );

  		// normal

  		normals.push( 0, 0, 1 );

  		// uvs

  		uv.x = ( vertices[ i ] / radius + 1 ) / 2;
  		uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

  		uvs.push( uv.x, uv.y );

  	}

  	// indices

  	for ( i = 1; i <= segments; i ++ ) {

  		indices.push( i, i + 1, 0 );

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute$1( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute$1( uvs, 2 ) );

  }

  CircleBufferGeometry$1.prototype = Object.create( BufferGeometry$1.prototype );
  CircleBufferGeometry$1.prototype.constructor = CircleBufferGeometry$1;



  var Geometries$1 = Object.freeze({
  	WireframeGeometry: WireframeGeometry$1,
  	ParametricGeometry: ParametricGeometry$1,
  	ParametricBufferGeometry: ParametricBufferGeometry$1,
  	TetrahedronGeometry: TetrahedronGeometry$1,
  	TetrahedronBufferGeometry: TetrahedronBufferGeometry$1,
  	OctahedronGeometry: OctahedronGeometry$1,
  	OctahedronBufferGeometry: OctahedronBufferGeometry$1,
  	IcosahedronGeometry: IcosahedronGeometry$1,
  	IcosahedronBufferGeometry: IcosahedronBufferGeometry$1,
  	DodecahedronGeometry: DodecahedronGeometry$1,
  	DodecahedronBufferGeometry: DodecahedronBufferGeometry$1,
  	PolyhedronGeometry: PolyhedronGeometry$1,
  	PolyhedronBufferGeometry: PolyhedronBufferGeometry$1,
  	TubeGeometry: TubeGeometry$1,
  	TubeBufferGeometry: TubeBufferGeometry$1,
  	TorusKnotGeometry: TorusKnotGeometry$1,
  	TorusKnotBufferGeometry: TorusKnotBufferGeometry$1,
  	TorusGeometry: TorusGeometry$1,
  	TorusBufferGeometry: TorusBufferGeometry$1,
  	TextGeometry: TextGeometry$1,
  	TextBufferGeometry: TextBufferGeometry$1,
  	SphereGeometry: SphereGeometry$1,
  	SphereBufferGeometry: SphereBufferGeometry$1,
  	RingGeometry: RingGeometry$1,
  	RingBufferGeometry: RingBufferGeometry$1,
  	PlaneGeometry: PlaneGeometry$1,
  	PlaneBufferGeometry: PlaneBufferGeometry$1,
  	LatheGeometry: LatheGeometry$1,
  	LatheBufferGeometry: LatheBufferGeometry$1,
  	ShapeGeometry: ShapeGeometry$1,
  	ShapeBufferGeometry: ShapeBufferGeometry$1,
  	ExtrudeGeometry: ExtrudeGeometry$1,
  	ExtrudeBufferGeometry: ExtrudeBufferGeometry$1,
  	EdgesGeometry: EdgesGeometry$1,
  	ConeGeometry: ConeGeometry$1,
  	ConeBufferGeometry: ConeBufferGeometry$1,
  	CylinderGeometry: CylinderGeometry$1,
  	CylinderBufferGeometry: CylinderBufferGeometry$1,
  	CircleGeometry: CircleGeometry$1,
  	CircleBufferGeometry: CircleBufferGeometry$1,
  	BoxGeometry: BoxGeometry$1,
  	BoxBufferGeometry: BoxBufferGeometry$1
  });

  /**
   * @author mrdoob / http://mrdoob.com/
   *
   * parameters = {
   *  color: <THREE.Color>,
   *  opacity: <float>
   * }
   */

  function ShadowMaterial$1( parameters ) {

  	Material$1.call( this );

  	this.type = 'ShadowMaterial';

  	this.color = new Color$1( 0x000000 );
  	this.opacity = 1.0;

  	this.lights = true;
  	this.transparent = true;

  	this.setValues( parameters );

  }

  ShadowMaterial$1.prototype = Object.create( Material$1.prototype );
  ShadowMaterial$1.prototype.constructor = ShadowMaterial$1;

  ShadowMaterial$1.prototype.isShadowMaterial = true;

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function RawShaderMaterial$1( parameters ) {

  	ShaderMaterial$1.call( this, parameters );

  	this.type = 'RawShaderMaterial';

  }

  RawShaderMaterial$1.prototype = Object.create( ShaderMaterial$1.prototype );
  RawShaderMaterial$1.prototype.constructor = RawShaderMaterial$1;

  RawShaderMaterial$1.prototype.isRawShaderMaterial = true;

  /**
   * @author WestLangley / http://github.com/WestLangley
   *
   * parameters = {
   *  color: <hex>,
   *  roughness: <float>,
   *  metalness: <float>,
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  emissive: <hex>,
   *  emissiveIntensity: <float>
   *  emissiveMap: new THREE.Texture( <Image> ),
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  roughnessMap: new THREE.Texture( <Image> ),
   *
   *  metalnessMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
   *  envMapIntensity: <float>
   *
   *  refractionRatio: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */

  function MeshStandardMaterial$1( parameters ) {

  	Material$1.call( this );

  	this.defines = { 'STANDARD': '' };

  	this.type = 'MeshStandardMaterial';

  	this.color = new Color$1( 0xffffff ); // diffuse
  	this.roughness = 0.5;
  	this.metalness = 0.5;

  	this.map = null;

  	this.lightMap = null;
  	this.lightMapIntensity = 1.0;

  	this.aoMap = null;
  	this.aoMapIntensity = 1.0;

  	this.emissive = new Color$1( 0x000000 );
  	this.emissiveIntensity = 1.0;
  	this.emissiveMap = null;

  	this.bumpMap = null;
  	this.bumpScale = 1;

  	this.normalMap = null;
  	this.normalScale = new Vector2$1( 1, 1 );

  	this.displacementMap = null;
  	this.displacementScale = 1;
  	this.displacementBias = 0;

  	this.roughnessMap = null;

  	this.metalnessMap = null;

  	this.alphaMap = null;

  	this.envMap = null;
  	this.envMapIntensity = 1.0;

  	this.refractionRatio = 0.98;

  	this.wireframe = false;
  	this.wireframeLinewidth = 1;
  	this.wireframeLinecap = 'round';
  	this.wireframeLinejoin = 'round';

  	this.skinning = false;
  	this.morphTargets = false;
  	this.morphNormals = false;

  	this.setValues( parameters );

  }

  MeshStandardMaterial$1.prototype = Object.create( Material$1.prototype );
  MeshStandardMaterial$1.prototype.constructor = MeshStandardMaterial$1;

  MeshStandardMaterial$1.prototype.isMeshStandardMaterial = true;

  MeshStandardMaterial$1.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.defines = { 'STANDARD': '' };

  	this.color.copy( source.color );
  	this.roughness = source.roughness;
  	this.metalness = source.metalness;

  	this.map = source.map;

  	this.lightMap = source.lightMap;
  	this.lightMapIntensity = source.lightMapIntensity;

  	this.aoMap = source.aoMap;
  	this.aoMapIntensity = source.aoMapIntensity;

  	this.emissive.copy( source.emissive );
  	this.emissiveMap = source.emissiveMap;
  	this.emissiveIntensity = source.emissiveIntensity;

  	this.bumpMap = source.bumpMap;
  	this.bumpScale = source.bumpScale;

  	this.normalMap = source.normalMap;
  	this.normalScale.copy( source.normalScale );

  	this.displacementMap = source.displacementMap;
  	this.displacementScale = source.displacementScale;
  	this.displacementBias = source.displacementBias;

  	this.roughnessMap = source.roughnessMap;

  	this.metalnessMap = source.metalnessMap;

  	this.alphaMap = source.alphaMap;

  	this.envMap = source.envMap;
  	this.envMapIntensity = source.envMapIntensity;

  	this.refractionRatio = source.refractionRatio;

  	this.wireframe = source.wireframe;
  	this.wireframeLinewidth = source.wireframeLinewidth;
  	this.wireframeLinecap = source.wireframeLinecap;
  	this.wireframeLinejoin = source.wireframeLinejoin;

  	this.skinning = source.skinning;
  	this.morphTargets = source.morphTargets;
  	this.morphNormals = source.morphNormals;

  	return this;

  };

  /**
   * @author WestLangley / http://github.com/WestLangley
   *
   * parameters = {
   *  reflectivity: <float>
   * }
   */

  function MeshPhysicalMaterial$1( parameters ) {

  	MeshStandardMaterial$1.call( this );

  	this.defines = { 'PHYSICAL': '' };

  	this.type = 'MeshPhysicalMaterial';

  	this.reflectivity = 0.5; // maps to F0 = 0.04

  	this.clearCoat = 0.0;
  	this.clearCoatRoughness = 0.0;

  	this.setValues( parameters );

  }

  MeshPhysicalMaterial$1.prototype = Object.create( MeshStandardMaterial$1.prototype );
  MeshPhysicalMaterial$1.prototype.constructor = MeshPhysicalMaterial$1;

  MeshPhysicalMaterial$1.prototype.isMeshPhysicalMaterial = true;

  MeshPhysicalMaterial$1.prototype.copy = function ( source ) {

  	MeshStandardMaterial$1.prototype.copy.call( this, source );

  	this.defines = { 'PHYSICAL': '' };

  	this.reflectivity = source.reflectivity;

  	this.clearCoat = source.clearCoat;
  	this.clearCoatRoughness = source.clearCoatRoughness;

  	return this;

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  specular: <hex>,
   *  shininess: <float>,
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  emissive: <hex>,
   *  emissiveIntensity: <float>
   *  emissiveMap: new THREE.Texture( <Image> ),
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  specularMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
   *  combine: THREE.Multiply,
   *  reflectivity: <float>,
   *  refractionRatio: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */

  function MeshPhongMaterial$1( parameters ) {

  	Material$1.call( this );

  	this.type = 'MeshPhongMaterial';

  	this.color = new Color$1( 0xffffff ); // diffuse
  	this.specular = new Color$1( 0x111111 );
  	this.shininess = 30;

  	this.map = null;

  	this.lightMap = null;
  	this.lightMapIntensity = 1.0;

  	this.aoMap = null;
  	this.aoMapIntensity = 1.0;

  	this.emissive = new Color$1( 0x000000 );
  	this.emissiveIntensity = 1.0;
  	this.emissiveMap = null;

  	this.bumpMap = null;
  	this.bumpScale = 1;

  	this.normalMap = null;
  	this.normalScale = new Vector2$1( 1, 1 );

  	this.displacementMap = null;
  	this.displacementScale = 1;
  	this.displacementBias = 0;

  	this.specularMap = null;

  	this.alphaMap = null;

  	this.envMap = null;
  	this.combine = MultiplyOperation$1;
  	this.reflectivity = 1;
  	this.refractionRatio = 0.98;

  	this.wireframe = false;
  	this.wireframeLinewidth = 1;
  	this.wireframeLinecap = 'round';
  	this.wireframeLinejoin = 'round';

  	this.skinning = false;
  	this.morphTargets = false;
  	this.morphNormals = false;

  	this.setValues( parameters );

  }

  MeshPhongMaterial$1.prototype = Object.create( Material$1.prototype );
  MeshPhongMaterial$1.prototype.constructor = MeshPhongMaterial$1;

  MeshPhongMaterial$1.prototype.isMeshPhongMaterial = true;

  MeshPhongMaterial$1.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.color.copy( source.color );
  	this.specular.copy( source.specular );
  	this.shininess = source.shininess;

  	this.map = source.map;

  	this.lightMap = source.lightMap;
  	this.lightMapIntensity = source.lightMapIntensity;

  	this.aoMap = source.aoMap;
  	this.aoMapIntensity = source.aoMapIntensity;

  	this.emissive.copy( source.emissive );
  	this.emissiveMap = source.emissiveMap;
  	this.emissiveIntensity = source.emissiveIntensity;

  	this.bumpMap = source.bumpMap;
  	this.bumpScale = source.bumpScale;

  	this.normalMap = source.normalMap;
  	this.normalScale.copy( source.normalScale );

  	this.displacementMap = source.displacementMap;
  	this.displacementScale = source.displacementScale;
  	this.displacementBias = source.displacementBias;

  	this.specularMap = source.specularMap;

  	this.alphaMap = source.alphaMap;

  	this.envMap = source.envMap;
  	this.combine = source.combine;
  	this.reflectivity = source.reflectivity;
  	this.refractionRatio = source.refractionRatio;

  	this.wireframe = source.wireframe;
  	this.wireframeLinewidth = source.wireframeLinewidth;
  	this.wireframeLinecap = source.wireframeLinecap;
  	this.wireframeLinejoin = source.wireframeLinejoin;

  	this.skinning = source.skinning;
  	this.morphTargets = source.morphTargets;
  	this.morphNormals = source.morphNormals;

  	return this;

  };

  /**
   * @author takahirox / http://github.com/takahirox
   *
   * parameters = {
   *  gradientMap: new THREE.Texture( <Image> )
   * }
   */

  function MeshToonMaterial$1( parameters ) {

  	MeshPhongMaterial$1.call( this );

  	this.defines = { 'TOON': '' };

  	this.type = 'MeshToonMaterial';

  	this.gradientMap = null;

  	this.setValues( parameters );

  }

  MeshToonMaterial$1.prototype = Object.create( MeshPhongMaterial$1.prototype );
  MeshToonMaterial$1.prototype.constructor = MeshToonMaterial$1;

  MeshToonMaterial$1.prototype.isMeshToonMaterial = true;

  MeshToonMaterial$1.prototype.copy = function ( source ) {

  	MeshPhongMaterial$1.prototype.copy.call( this, source );

  	this.gradientMap = source.gradientMap;

  	return this;

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author WestLangley / http://github.com/WestLangley
   *
   * parameters = {
   *  opacity: <float>,
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */

  function MeshNormalMaterial$1( parameters ) {

  	Material$1.call( this );

  	this.type = 'MeshNormalMaterial';

  	this.bumpMap = null;
  	this.bumpScale = 1;

  	this.normalMap = null;
  	this.normalScale = new Vector2$1( 1, 1 );

  	this.displacementMap = null;
  	this.displacementScale = 1;
  	this.displacementBias = 0;

  	this.wireframe = false;
  	this.wireframeLinewidth = 1;

  	this.fog = false;
  	this.lights = false;

  	this.skinning = false;
  	this.morphTargets = false;
  	this.morphNormals = false;

  	this.setValues( parameters );

  }

  MeshNormalMaterial$1.prototype = Object.create( Material$1.prototype );
  MeshNormalMaterial$1.prototype.constructor = MeshNormalMaterial$1;

  MeshNormalMaterial$1.prototype.isMeshNormalMaterial = true;

  MeshNormalMaterial$1.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.bumpMap = source.bumpMap;
  	this.bumpScale = source.bumpScale;

  	this.normalMap = source.normalMap;
  	this.normalScale.copy( source.normalScale );

  	this.displacementMap = source.displacementMap;
  	this.displacementScale = source.displacementScale;
  	this.displacementBias = source.displacementBias;

  	this.wireframe = source.wireframe;
  	this.wireframeLinewidth = source.wireframeLinewidth;

  	this.skinning = source.skinning;
  	this.morphTargets = source.morphTargets;
  	this.morphNormals = source.morphNormals;

  	return this;

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  emissive: <hex>,
   *  emissiveIntensity: <float>
   *  emissiveMap: new THREE.Texture( <Image> ),
   *
   *  specularMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
   *  combine: THREE.Multiply,
   *  reflectivity: <float>,
   *  refractionRatio: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */

  function MeshLambertMaterial$1( parameters ) {

  	Material$1.call( this );

  	this.type = 'MeshLambertMaterial';

  	this.color = new Color$1( 0xffffff ); // diffuse

  	this.map = null;

  	this.lightMap = null;
  	this.lightMapIntensity = 1.0;

  	this.aoMap = null;
  	this.aoMapIntensity = 1.0;

  	this.emissive = new Color$1( 0x000000 );
  	this.emissiveIntensity = 1.0;
  	this.emissiveMap = null;

  	this.specularMap = null;

  	this.alphaMap = null;

  	this.envMap = null;
  	this.combine = MultiplyOperation$1;
  	this.reflectivity = 1;
  	this.refractionRatio = 0.98;

  	this.wireframe = false;
  	this.wireframeLinewidth = 1;
  	this.wireframeLinecap = 'round';
  	this.wireframeLinejoin = 'round';

  	this.skinning = false;
  	this.morphTargets = false;
  	this.morphNormals = false;

  	this.setValues( parameters );

  }

  MeshLambertMaterial$1.prototype = Object.create( Material$1.prototype );
  MeshLambertMaterial$1.prototype.constructor = MeshLambertMaterial$1;

  MeshLambertMaterial$1.prototype.isMeshLambertMaterial = true;

  MeshLambertMaterial$1.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.color.copy( source.color );

  	this.map = source.map;

  	this.lightMap = source.lightMap;
  	this.lightMapIntensity = source.lightMapIntensity;

  	this.aoMap = source.aoMap;
  	this.aoMapIntensity = source.aoMapIntensity;

  	this.emissive.copy( source.emissive );
  	this.emissiveMap = source.emissiveMap;
  	this.emissiveIntensity = source.emissiveIntensity;

  	this.specularMap = source.specularMap;

  	this.alphaMap = source.alphaMap;

  	this.envMap = source.envMap;
  	this.combine = source.combine;
  	this.reflectivity = source.reflectivity;
  	this.refractionRatio = source.refractionRatio;

  	this.wireframe = source.wireframe;
  	this.wireframeLinewidth = source.wireframeLinewidth;
  	this.wireframeLinecap = source.wireframeLinecap;
  	this.wireframeLinejoin = source.wireframeLinejoin;

  	this.skinning = source.skinning;
  	this.morphTargets = source.morphTargets;
  	this.morphNormals = source.morphNormals;

  	return this;

  };

  /**
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *
   *  linewidth: <float>,
   *
   *  scale: <float>,
   *  dashSize: <float>,
   *  gapSize: <float>
   * }
   */

  function LineDashedMaterial$1( parameters ) {

  	LineBasicMaterial$1.call( this );

  	this.type = 'LineDashedMaterial';

  	this.scale = 1;
  	this.dashSize = 3;
  	this.gapSize = 1;

  	this.setValues( parameters );

  }

  LineDashedMaterial$1.prototype = Object.create( LineBasicMaterial$1.prototype );
  LineDashedMaterial$1.prototype.constructor = LineDashedMaterial$1;

  LineDashedMaterial$1.prototype.isLineDashedMaterial = true;

  LineDashedMaterial$1.prototype.copy = function ( source ) {

  	LineBasicMaterial$1.prototype.copy.call( this, source );

  	this.scale = source.scale;
  	this.dashSize = source.dashSize;
  	this.gapSize = source.gapSize;

  	return this;

  };



  var Materials$1 = Object.freeze({
  	ShadowMaterial: ShadowMaterial$1,
  	SpriteMaterial: SpriteMaterial$1,
  	RawShaderMaterial: RawShaderMaterial$1,
  	ShaderMaterial: ShaderMaterial$1,
  	PointsMaterial: PointsMaterial$1,
  	MeshPhysicalMaterial: MeshPhysicalMaterial$1,
  	MeshStandardMaterial: MeshStandardMaterial$1,
  	MeshPhongMaterial: MeshPhongMaterial$1,
  	MeshToonMaterial: MeshToonMaterial$1,
  	MeshNormalMaterial: MeshNormalMaterial$1,
  	MeshLambertMaterial: MeshLambertMaterial$1,
  	MeshDepthMaterial: MeshDepthMaterial$1,
  	MeshDistanceMaterial: MeshDistanceMaterial$1,
  	MeshBasicMaterial: MeshBasicMaterial$1,
  	LineDashedMaterial: LineDashedMaterial$1,
  	LineBasicMaterial: LineBasicMaterial$1,
  	Material: Material$1
  });

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  var Cache$1 = {

  	enabled: false,

  	files: {},

  	add: function ( key, file ) {

  		if ( this.enabled === false ) { return; }

  		// console.log( 'THREE.Cache', 'Adding key:', key );

  		this.files[ key ] = file;

  	},

  	get: function ( key ) {

  		if ( this.enabled === false ) { return; }

  		// console.log( 'THREE.Cache', 'Checking key:', key );

  		return this.files[ key ];

  	},

  	remove: function ( key ) {

  		delete this.files[ key ];

  	},

  	clear: function () {

  		this.files = {};

  	}

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function LoadingManager$1( onLoad, onProgress, onError ) {

  	var scope = this;

  	var isLoading = false, itemsLoaded = 0, itemsTotal = 0;

  	this.onStart = undefined;
  	this.onLoad = onLoad;
  	this.onProgress = onProgress;
  	this.onError = onError;

  	this.itemStart = function ( url ) {

  		itemsTotal ++;

  		if ( isLoading === false ) {

  			if ( scope.onStart !== undefined ) {

  				scope.onStart( url, itemsLoaded, itemsTotal );

  			}

  		}

  		isLoading = true;

  	};

  	this.itemEnd = function ( url ) {

  		itemsLoaded ++;

  		if ( scope.onProgress !== undefined ) {

  			scope.onProgress( url, itemsLoaded, itemsTotal );

  		}

  		if ( itemsLoaded === itemsTotal ) {

  			isLoading = false;

  			if ( scope.onLoad !== undefined ) {

  				scope.onLoad();

  			}

  		}

  	};

  	this.itemError = function ( url ) {

  		if ( scope.onError !== undefined ) {

  			scope.onError( url );

  		}

  	};

  }

  var DefaultLoadingManager$1 = new LoadingManager$1();

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function FileLoader$1( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager$1;

  }

  Object.assign( FileLoader$1.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {
  		var this$1 = this;


  		if ( url === undefined ) { url = ''; }

  		if ( this.path !== undefined ) { url = this.path + url; }

  		var scope = this;

  		var cached = Cache$1.get( url );

  		if ( cached !== undefined ) {

  			scope.manager.itemStart( url );

  			setTimeout( function () {

  				if ( onLoad ) { onLoad( cached ); }

  				scope.manager.itemEnd( url );

  			}, 0 );

  			return cached;

  		}

  		// Check for data: URI
  		var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
  		var dataUriRegexResult = url.match( dataUriRegex );

  		// Safari can not handle Data URIs through XMLHttpRequest so process manually
  		if ( dataUriRegexResult ) {

  			var mimeType = dataUriRegexResult[ 1 ];
  			var isBase64 = !! dataUriRegexResult[ 2 ];
  			var data = dataUriRegexResult[ 3 ];

  			data = window.decodeURIComponent( data );

  			if ( isBase64 ) { data = window.atob( data ); }

  			try {

  				var response;
  				var responseType = ( this.responseType || '' ).toLowerCase();

  				switch ( responseType ) {

  					case 'arraybuffer':
  					case 'blob':

  						var view = new Uint8Array( data.length );

  						for ( var i = 0; i < data.length; i ++ ) {

  							view[ i ] = data.charCodeAt( i );

  						}

  						if ( responseType === 'blob' ) {

  							response = new Blob( [ view.buffer ], { type: mimeType } );

  						} else {

  							response = view.buffer;

  						}

  						break;

  					case 'document':

  						var parser = new DOMParser();
  						response = parser.parseFromString( data, mimeType );

  						break;

  					case 'json':

  						response = JSON.parse( data );

  						break;

  					default: // 'text' or other

  						response = data;

  						break;

  				}

  				// Wait for next browser tick like standard XMLHttpRequest event dispatching does
  				window.setTimeout( function () {

  					if ( onLoad ) { onLoad( response ); }

  					scope.manager.itemEnd( url );

  				}, 0 );

  			} catch ( error ) {

  				// Wait for next browser tick like standard XMLHttpRequest event dispatching does
  				window.setTimeout( function () {

  					if ( onError ) { onError( error ); }

  					scope.manager.itemEnd( url );
  					scope.manager.itemError( url );

  				}, 0 );

  			}

  		} else {

  			var request = new XMLHttpRequest();
  			request.open( 'GET', url, true );

  			request.addEventListener( 'load', function ( event ) {

  				var response = event.target.response;

  				Cache$1.add( url, response );

  				if ( this.status === 200 ) {

  					if ( onLoad ) { onLoad( response ); }

  					scope.manager.itemEnd( url );

  				} else if ( this.status === 0 ) {

  					// Some browsers return HTTP Status 0 when using non-http protocol
  					// e.g. 'file://' or 'data://'. Handle as success.

  					console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

  					if ( onLoad ) { onLoad( response ); }

  					scope.manager.itemEnd( url );

  				} else {

  					if ( onError ) { onError( event ); }

  					scope.manager.itemEnd( url );
  					scope.manager.itemError( url );

  				}

  			}, false );

  			if ( onProgress !== undefined ) {

  				request.addEventListener( 'progress', function ( event ) {

  					onProgress( event );

  				}, false );

  			}

  			request.addEventListener( 'error', function ( event ) {

  				if ( onError ) { onError( event ); }

  				scope.manager.itemEnd( url );
  				scope.manager.itemError( url );

  			}, false );

  			if ( this.responseType !== undefined ) { request.responseType = this.responseType; }
  			if ( this.withCredentials !== undefined ) { request.withCredentials = this.withCredentials; }

  			if ( request.overrideMimeType ) { request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' ); }

  			for ( var header in this$1.requestHeader ) {

  				request.setRequestHeader( header, this$1.requestHeader[ header ] );

  			}

  			request.send( null );

  		}

  		scope.manager.itemStart( url );

  		return request;

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	},

  	setResponseType: function ( value ) {

  		this.responseType = value;
  		return this;

  	},

  	setWithCredentials: function ( value ) {

  		this.withCredentials = value;
  		return this;

  	},

  	setMimeType: function ( value ) {

  		this.mimeType = value;
  		return this;

  	},

  	setRequestHeader: function ( value ) {

  		this.requestHeader = value;
  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   *
   * Abstract Base class to block based textures loader (dds, pvr, ...)
   */

  function CompressedTextureLoader( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager$1;

  	// override in sub classes
  	this._parser = null;

  }

  Object.assign( CompressedTextureLoader.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var images = [];

  		var texture = new CompressedTexture();
  		texture.image = images;

  		var loader = new FileLoader$1( this.manager );
  		loader.setPath( this.path );
  		loader.setResponseType( 'arraybuffer' );

  		function loadTexture( i ) {

  			loader.load( url[ i ], function ( buffer ) {

  				var texDatas = scope._parser( buffer, true );

  				images[ i ] = {
  					width: texDatas.width,
  					height: texDatas.height,
  					format: texDatas.format,
  					mipmaps: texDatas.mipmaps
  				};

  				loaded += 1;

  				if ( loaded === 6 ) {

  					if ( texDatas.mipmapCount === 1 )
  						{ texture.minFilter = LinearFilter$1; }

  					texture.format = texDatas.format;
  					texture.needsUpdate = true;

  					if ( onLoad ) { onLoad( texture ); }

  				}

  			}, onProgress, onError );

  		}

  		if ( Array.isArray( url ) ) {

  			var loaded = 0;

  			for ( var i = 0, il = url.length; i < il; ++ i ) {

  				loadTexture( i );

  			}

  		} else {

  			// compressed cubemap texture stored in a single DDS file

  			loader.load( url, function ( buffer ) {

  				var texDatas = scope._parser( buffer, true );

  				if ( texDatas.isCubemap ) {

  					var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

  					for ( var f = 0; f < faces; f ++ ) {

  						images[ f ] = { mipmaps: [] };

  						for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

  							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
  							images[ f ].format = texDatas.format;
  							images[ f ].width = texDatas.width;
  							images[ f ].height = texDatas.height;

  						}

  					}

  				} else {

  					texture.image.width = texDatas.width;
  					texture.image.height = texDatas.height;
  					texture.mipmaps = texDatas.mipmaps;

  				}

  				if ( texDatas.mipmapCount === 1 ) {

  					texture.minFilter = LinearFilter$1;

  				}

  				texture.format = texDatas.format;
  				texture.needsUpdate = true;

  				if ( onLoad ) { onLoad( texture ); }

  			}, onProgress, onError );

  		}

  		return texture;

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	}

  } );

  /**
   * @author Nikos M. / https://github.com/foo123/
   *
   * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
   */

  function DataTextureLoader( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager$1;

  	// override in sub classes
  	this._parser = null;

  }

  Object.assign( DataTextureLoader.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var texture = new DataTexture();

  		var loader = new FileLoader$1( this.manager );
  		loader.setResponseType( 'arraybuffer' );

  		loader.load( url, function ( buffer ) {

  			var texData = scope._parser( buffer );

  			if ( ! texData ) { return; }

  			if ( undefined !== texData.image ) {

  				texture.image = texData.image;

  			} else if ( undefined !== texData.data ) {

  				texture.image.width = texData.width;
  				texture.image.height = texData.height;
  				texture.image.data = texData.data;

  			}

  			texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping$1;
  			texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping$1;

  			texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter$1;
  			texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter$1;

  			texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

  			if ( undefined !== texData.format ) {

  				texture.format = texData.format;

  			}
  			if ( undefined !== texData.type ) {

  				texture.type = texData.type;

  			}

  			if ( undefined !== texData.mipmaps ) {

  				texture.mipmaps = texData.mipmaps;

  			}

  			if ( 1 === texData.mipmapCount ) {

  				texture.minFilter = LinearFilter$1;

  			}

  			texture.needsUpdate = true;

  			if ( onLoad ) { onLoad( texture, texData ); }

  		}, onProgress, onError );


  		return texture;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function ImageLoader$1( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager$1;

  }

  Object.assign( ImageLoader$1.prototype, {

  	crossOrigin: 'Anonymous',

  	load: function ( url, onLoad, onProgress, onError ) {

  		if ( url === undefined ) { url = ''; }

  		if ( this.path !== undefined ) { url = this.path + url; }

  		var scope = this;

  		var cached = Cache$1.get( url );

  		if ( cached !== undefined ) {

  			scope.manager.itemStart( url );

  			setTimeout( function () {

  				if ( onLoad ) { onLoad( cached ); }

  				scope.manager.itemEnd( url );

  			}, 0 );

  			return cached;

  		}

  		var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );

  		image.addEventListener( 'load', function () {

  			Cache$1.add( url, this );

  			if ( onLoad ) { onLoad( this ); }

  			scope.manager.itemEnd( url );

  		}, false );

  		/*
  		image.addEventListener( 'progress', function ( event ) {

  			if ( onProgress ) onProgress( event );

  		}, false );
  		*/

  		image.addEventListener( 'error', function ( event ) {

  			if ( onError ) { onError( event ); }

  			scope.manager.itemEnd( url );
  			scope.manager.itemError( url );

  		}, false );

  		if ( url.substr( 0, 5 ) !== 'data:' ) {

  			if ( this.crossOrigin !== undefined ) { image.crossOrigin = this.crossOrigin; }

  		}

  		scope.manager.itemStart( url );

  		image.src = url;

  		return image;

  	},

  	setCrossOrigin: function ( value ) {

  		this.crossOrigin = value;
  		return this;

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function CubeTextureLoader( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager$1;

  }

  Object.assign( CubeTextureLoader.prototype, {

  	crossOrigin: 'Anonymous',

  	load: function ( urls, onLoad, onProgress, onError ) {

  		var texture = new CubeTexture();

  		var loader = new ImageLoader$1( this.manager );
  		loader.setCrossOrigin( this.crossOrigin );
  		loader.setPath( this.path );

  		var loaded = 0;

  		function loadTexture( i ) {

  			loader.load( urls[ i ], function ( image ) {

  				texture.images[ i ] = image;

  				loaded ++;

  				if ( loaded === 6 ) {

  					texture.needsUpdate = true;

  					if ( onLoad ) { onLoad( texture ); }

  				}

  			}, undefined, onError );

  		}

  		for ( var i = 0; i < urls.length; ++ i ) {

  			loadTexture( i );

  		}

  		return texture;

  	},

  	setCrossOrigin: function ( value ) {

  		this.crossOrigin = value;
  		return this;

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function TextureLoader$1( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager$1;

  }

  Object.assign( TextureLoader$1.prototype, {

  	crossOrigin: 'Anonymous',

  	load: function ( url, onLoad, onProgress, onError ) {

  		var loader = new ImageLoader$1( this.manager );
  		loader.setCrossOrigin( this.crossOrigin );
  		loader.setPath( this.path );

  		var texture = new Texture$1();
  		texture.image = loader.load( url, function () {

  			// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
  			var isJPEG = url.search( /\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

  			texture.format = isJPEG ? RGBFormat$1 : RGBAFormat$1;
  			texture.needsUpdate = true;

  			if ( onLoad !== undefined ) {

  				onLoad( texture );

  			}

  		}, onProgress, onError );

  		return texture;

  	},

  	setCrossOrigin: function ( value ) {

  		this.crossOrigin = value;
  		return this;

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  function Light$1( color, intensity ) {

  	Object3D$1.call( this );

  	this.type = 'Light';

  	this.color = new Color$1( color );
  	this.intensity = intensity !== undefined ? intensity : 1;

  	this.receiveShadow = undefined;

  }

  Light$1.prototype = Object.assign( Object.create( Object3D$1.prototype ), {

  	constructor: Light$1,

  	isLight: true,

  	copy: function ( source ) {

  		Object3D$1.prototype.copy.call( this, source );

  		this.color.copy( source.color );
  		this.intensity = source.intensity;

  		return this;

  	},

  	toJSON: function ( meta ) {

  		var data = Object3D$1.prototype.toJSON.call( this, meta );

  		data.object.color = this.color.getHex();
  		data.object.intensity = this.intensity;

  		if ( this.groundColor !== undefined ) { data.object.groundColor = this.groundColor.getHex(); }

  		if ( this.distance !== undefined ) { data.object.distance = this.distance; }
  		if ( this.angle !== undefined ) { data.object.angle = this.angle; }
  		if ( this.decay !== undefined ) { data.object.decay = this.decay; }
  		if ( this.penumbra !== undefined ) { data.object.penumbra = this.penumbra; }

  		if ( this.shadow !== undefined ) { data.object.shadow = this.shadow.toJSON(); }

  		return data;

  	}

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function HemisphereLight$1( skyColor, groundColor, intensity ) {

  	Light$1.call( this, skyColor, intensity );

  	this.type = 'HemisphereLight';

  	this.castShadow = undefined;

  	this.position.copy( Object3D$1.DefaultUp );
  	this.updateMatrix();

  	this.groundColor = new Color$1( groundColor );

  }

  HemisphereLight$1.prototype = Object.assign( Object.create( Light$1.prototype ), {

  	constructor: HemisphereLight$1,

  	isHemisphereLight: true,

  	copy: function ( source ) {

  		Light$1.prototype.copy.call( this, source );

  		this.groundColor.copy( source.groundColor );

  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function LightShadow$1( camera ) {

  	this.camera = camera;

  	this.bias = 0;
  	this.radius = 1;

  	this.mapSize = new Vector2$1( 512, 512 );

  	this.map = null;
  	this.matrix = new Matrix4$1();

  }

  Object.assign( LightShadow$1.prototype, {

  	copy: function ( source ) {

  		this.camera = source.camera.clone();

  		this.bias = source.bias;
  		this.radius = source.radius;

  		this.mapSize.copy( source.mapSize );

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	toJSON: function () {

  		var object = {};

  		if ( this.bias !== 0 ) { object.bias = this.bias; }
  		if ( this.radius !== 1 ) { object.radius = this.radius; }
  		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) { object.mapSize = this.mapSize.toArray(); }

  		object.camera = this.camera.toJSON( false ).object;
  		delete object.camera.matrix;

  		return object;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function SpotLightShadow$1() {

  	LightShadow$1.call( this, new PerspectiveCamera$1( 50, 1, 0.5, 500 ) );

  }

  SpotLightShadow$1.prototype = Object.assign( Object.create( LightShadow$1.prototype ), {

  	constructor: SpotLightShadow$1,

  	isSpotLightShadow: true,

  	update: function ( light ) {

  		var camera = this.camera;

  		var fov = _Math$1.RAD2DEG * 2 * light.angle;
  		var aspect = this.mapSize.width / this.mapSize.height;
  		var far = light.distance || camera.far;

  		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

  			camera.fov = fov;
  			camera.aspect = aspect;
  			camera.far = far;
  			camera.updateProjectionMatrix();

  		}

  	}

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function SpotLight$1( color, intensity, distance, angle, penumbra, decay ) {

  	Light$1.call( this, color, intensity );

  	this.type = 'SpotLight';

  	this.position.copy( Object3D$1.DefaultUp );
  	this.updateMatrix();

  	this.target = new Object3D$1();

  	Object.defineProperty( this, 'power', {
  		get: function () {

  			// intensity = power per solid angle.
  			// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
  			return this.intensity * Math.PI;

  		},
  		set: function ( power ) {

  			// intensity = power per solid angle.
  			// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
  			this.intensity = power / Math.PI;

  		}
  	} );

  	this.distance = ( distance !== undefined ) ? distance : 0;
  	this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
  	this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
  	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

  	this.shadow = new SpotLightShadow$1();

  }

  SpotLight$1.prototype = Object.assign( Object.create( Light$1.prototype ), {

  	constructor: SpotLight$1,

  	isSpotLight: true,

  	copy: function ( source ) {

  		Light$1.prototype.copy.call( this, source );

  		this.distance = source.distance;
  		this.angle = source.angle;
  		this.penumbra = source.penumbra;
  		this.decay = source.decay;

  		this.target = source.target.clone();

  		this.shadow = source.shadow.clone();

  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */


  function PointLight$1( color, intensity, distance, decay ) {

  	Light$1.call( this, color, intensity );

  	this.type = 'PointLight';

  	Object.defineProperty( this, 'power', {
  		get: function () {

  			// intensity = power per solid angle.
  			// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
  			return this.intensity * 4 * Math.PI;

  		},
  		set: function ( power ) {

  			// intensity = power per solid angle.
  			// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
  			this.intensity = power / ( 4 * Math.PI );

  		}
  	} );

  	this.distance = ( distance !== undefined ) ? distance : 0;
  	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

  	this.shadow = new LightShadow$1( new PerspectiveCamera$1( 90, 1, 0.5, 500 ) );

  }

  PointLight$1.prototype = Object.assign( Object.create( Light$1.prototype ), {

  	constructor: PointLight$1,

  	isPointLight: true,

  	copy: function ( source ) {

  		Light$1.prototype.copy.call( this, source );

  		this.distance = source.distance;
  		this.decay = source.decay;

  		this.shadow = source.shadow.clone();

  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function DirectionalLightShadow$1( ) {

  	LightShadow$1.call( this, new OrthographicCamera$1( - 5, 5, 5, - 5, 0.5, 500 ) );

  }

  DirectionalLightShadow$1.prototype = Object.assign( Object.create( LightShadow$1.prototype ), {

  	constructor: DirectionalLightShadow$1

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  function DirectionalLight$1( color, intensity ) {

  	Light$1.call( this, color, intensity );

  	this.type = 'DirectionalLight';

  	this.position.copy( Object3D$1.DefaultUp );
  	this.updateMatrix();

  	this.target = new Object3D$1();

  	this.shadow = new DirectionalLightShadow$1();

  }

  DirectionalLight$1.prototype = Object.assign( Object.create( Light$1.prototype ), {

  	constructor: DirectionalLight$1,

  	isDirectionalLight: true,

  	copy: function ( source ) {

  		Light$1.prototype.copy.call( this, source );

  		this.target = source.target.clone();

  		this.shadow = source.shadow.clone();

  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function AmbientLight$1( color, intensity ) {

  	Light$1.call( this, color, intensity );

  	this.type = 'AmbientLight';

  	this.castShadow = undefined;

  }

  AmbientLight$1.prototype = Object.assign( Object.create( Light$1.prototype ), {

  	constructor: AmbientLight$1,

  	isAmbientLight: true

  } );

  /**
   * @author abelnation / http://github.com/abelnation
   */

  function RectAreaLight$1( color, intensity, width, height ) {

  	Light$1.call( this, color, intensity );

  	this.type = 'RectAreaLight';

  	this.position.set( 0, 1, 0 );
  	this.updateMatrix();

  	this.width = ( width !== undefined ) ? width : 10;
  	this.height = ( height !== undefined ) ? height : 10;

  	// TODO (abelnation): distance/decay

  	// TODO (abelnation): update method for RectAreaLight to update transform to lookat target

  	// TODO (abelnation): shadows

  }

  // TODO (abelnation): RectAreaLight update when light shape is changed
  RectAreaLight$1.prototype = Object.assign( Object.create( Light$1.prototype ), {

  	constructor: RectAreaLight$1,

  	isRectAreaLight: true,

  	copy: function ( source ) {

  		Light$1.prototype.copy.call( this, source );

  		this.width = source.width;
  		this.height = source.height;

  		return this;

  	},

  	toJSON: function ( meta ) {

  		var data = Light$1.prototype.toJSON.call( this, meta );

  		data.object.width = this.width;
  		data.object.height = this.height;

  		return data;

  	}

  } );

  /**
   * @author tschw
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   */

  var AnimationUtils$1 = {

  	// same as Array.prototype.slice, but also works on typed arrays
  	arraySlice: function ( array, from, to ) {

  		if ( AnimationUtils$1.isTypedArray( array ) ) {

  			// in ios9 array.subarray(from, undefined) will return empty array
  			// but array.subarray(from) or array.subarray(from, len) is correct
  			return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

  		}

  		return array.slice( from, to );

  	},

  	// converts an array to a specific type
  	convertArray: function ( array, type, forceClone ) {

  		if ( ! array || // let 'undefined' and 'null' pass
  				! forceClone && array.constructor === type ) { return array; }

  		if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

  			return new type( array ); // create typed array

  		}

  		return Array.prototype.slice.call( array ); // create Array

  	},

  	isTypedArray: function ( object ) {

  		return ArrayBuffer.isView( object ) &&
  				! ( object instanceof DataView );

  	},

  	// returns an array by which times and values can be sorted
  	getKeyframeOrder: function ( times ) {

  		function compareTime( i, j ) {

  			return times[ i ] - times[ j ];

  		}

  		var n = times.length;
  		var result = new Array( n );
  		for ( var i = 0; i !== n; ++ i ) { result[ i ] = i; }

  		result.sort( compareTime );

  		return result;

  	},

  	// uses the array previously returned by 'getKeyframeOrder' to sort data
  	sortedArray: function ( values, stride, order ) {

  		var nValues = values.length;
  		var result = new values.constructor( nValues );

  		for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

  			var srcOffset = order[ i ] * stride;

  			for ( var j = 0; j !== stride; ++ j ) {

  				result[ dstOffset ++ ] = values[ srcOffset + j ];

  			}

  		}

  		return result;

  	},

  	// function for parsing AOS keyframe formats
  	flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {

  		var i = 1, key = jsonKeys[ 0 ];

  		while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

  			key = jsonKeys[ i ++ ];

  		}

  		if ( key === undefined ) { return; } // no data

  		var value = key[ valuePropertyName ];
  		if ( value === undefined ) { return; } // no data

  		if ( Array.isArray( value ) ) {

  			do {

  				value = key[ valuePropertyName ];

  				if ( value !== undefined ) {

  					times.push( key.time );
  					values.push.apply( values, value ); // push all elements

  				}

  				key = jsonKeys[ i ++ ];

  			} while ( key !== undefined );

  		} else if ( value.toArray !== undefined ) {

  			// ...assume THREE.Math-ish

  			do {

  				value = key[ valuePropertyName ];

  				if ( value !== undefined ) {

  					times.push( key.time );
  					value.toArray( values, values.length );

  				}

  				key = jsonKeys[ i ++ ];

  			} while ( key !== undefined );

  		} else {

  			// otherwise push as-is

  			do {

  				value = key[ valuePropertyName ];

  				if ( value !== undefined ) {

  					times.push( key.time );
  					values.push( value );

  				}

  				key = jsonKeys[ i ++ ];

  			} while ( key !== undefined );

  		}

  	}

  };

  /**
   * Abstract base class of interpolants over parametric samples.
   *
   * The parameter domain is one dimensional, typically the time or a path
   * along a curve defined by the data.
   *
   * The sample values can have any dimensionality and derived classes may
   * apply special interpretations to the data.
   *
   * This class provides the interval seek in a Template Method, deferring
   * the actual interpolation to derived classes.
   *
   * Time complexity is O(1) for linear access crossing at most two points
   * and O(log N) for random access, where N is the number of positions.
   *
   * References:
   *
   * 		http://www.oodesign.com/template-method-pattern.html
   *
   * @author tschw
   */

  function Interpolant$1( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  	this.parameterPositions = parameterPositions;
  	this._cachedIndex = 0;

  	this.resultBuffer = resultBuffer !== undefined ?
  		resultBuffer : new sampleValues.constructor( sampleSize );
  	this.sampleValues = sampleValues;
  	this.valueSize = sampleSize;

  }

  Object.assign( Interpolant$1.prototype, {

  	evaluate: function ( t ) {
  		var this$1 = this;


  		var pp = this.parameterPositions,
  			i1 = this._cachedIndex,

  			t1 = pp[ i1 ],
  			t0 = pp[ i1 - 1 ];

  		validate_interval: {

  			seek: {

  				var right;

  				linear_scan: {

  					//- See http://jsperf.com/comparison-to-undefined/3
  					//- slower code:
  					//-
  					//- 				if ( t >= t1 || t1 === undefined ) {
  					forward_scan: if ( ! ( t < t1 ) ) {

  						for ( var giveUpAt = i1 + 2; ; ) {

  							if ( t1 === undefined ) {

  								if ( t < t0 ) { break forward_scan; }

  								// after end

  								i1 = pp.length;
  								this$1._cachedIndex = i1;
  								return this$1.afterEnd_( i1 - 1, t, t0 );

  							}

  							if ( i1 === giveUpAt ) { break; } // this loop

  							t0 = t1;
  							t1 = pp[ ++ i1 ];

  							if ( t < t1 ) {

  								// we have arrived at the sought interval
  								break seek;

  							}

  						}

  						// prepare binary search on the right side of the index
  						right = pp.length;
  						break linear_scan;

  					}

  					//- slower code:
  					//-					if ( t < t0 || t0 === undefined ) {
  					if ( ! ( t >= t0 ) ) {

  						// looping?

  						var t1global = pp[ 1 ];

  						if ( t < t1global ) {

  							i1 = 2; // + 1, using the scan for the details
  							t0 = t1global;

  						}

  						// linear reverse scan

  						for ( var giveUpAt = i1 - 2; ; ) {

  							if ( t0 === undefined ) {

  								// before start

  								this$1._cachedIndex = 0;
  								return this$1.beforeStart_( 0, t, t1 );

  							}

  							if ( i1 === giveUpAt ) { break; } // this loop

  							t1 = t0;
  							t0 = pp[ -- i1 - 1 ];

  							if ( t >= t0 ) {

  								// we have arrived at the sought interval
  								break seek;

  							}

  						}

  						// prepare binary search on the left side of the index
  						right = i1;
  						i1 = 0;
  						break linear_scan;

  					}

  					// the interval is valid

  					break validate_interval;

  				} // linear scan

  				// binary search

  				while ( i1 < right ) {

  					var mid = ( i1 + right ) >>> 1;

  					if ( t < pp[ mid ] ) {

  						right = mid;

  					} else {

  						i1 = mid + 1;

  					}

  				}

  				t1 = pp[ i1 ];
  				t0 = pp[ i1 - 1 ];

  				// check boundary cases, again

  				if ( t0 === undefined ) {

  					this._cachedIndex = 0;
  					return this.beforeStart_( 0, t, t1 );

  				}

  				if ( t1 === undefined ) {

  					i1 = pp.length;
  					this._cachedIndex = i1;
  					return this.afterEnd_( i1 - 1, t0, t );

  				}

  			} // seek

  			this._cachedIndex = i1;

  			this.intervalChanged_( i1, t0, t1 );

  		} // validate_interval

  		return this.interpolate_( i1, t0, t, t1 );

  	},

  	settings: null, // optional, subclass-specific settings structure
  	// Note: The indirection allows central control of many interpolants.

  	// --- Protected interface

  	DefaultSettings_: {},

  	getSettings_: function () {

  		return this.settings || this.DefaultSettings_;

  	},

  	copySampleValue_: function ( index ) {

  		// copies a sample value to the result buffer

  		var result = this.resultBuffer,
  			values = this.sampleValues,
  			stride = this.valueSize,
  			offset = index * stride;

  		for ( var i = 0; i !== stride; ++ i ) {

  			result[ i ] = values[ offset + i ];

  		}

  		return result;

  	},

  	// Template methods for derived classes:

  	interpolate_: function ( /* i1, t0, t, t1 */ ) {

  		throw new Error( 'call to abstract method' );
  		// implementations shall return this.resultBuffer

  	},

  	intervalChanged_: function ( /* i1, t0, t1 */ ) {

  		// empty

  	}

  } );

  //!\ DECLARE ALIAS AFTER assign prototype !
  Object.assign( Interpolant$1.prototype, {

  	//( 0, t, t0 ), returns this.resultBuffer
  	beforeStart_: Interpolant$1.prototype.copySampleValue_,

  	//( N-1, tN-1, t ), returns this.resultBuffer
  	afterEnd_: Interpolant$1.prototype.copySampleValue_,

  } );

  /**
   * Fast and simple cubic spline interpolant.
   *
   * It was derived from a Hermitian construction setting the first derivative
   * at each sample position to the linear slope between neighboring positions
   * over their parameter interval.
   *
   * @author tschw
   */

  function CubicInterpolant$1( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  	Interpolant$1.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

  	this._weightPrev = - 0;
  	this._offsetPrev = - 0;
  	this._weightNext = - 0;
  	this._offsetNext = - 0;

  }

  CubicInterpolant$1.prototype = Object.assign( Object.create( Interpolant$1.prototype ), {

  	constructor: CubicInterpolant$1,

  	DefaultSettings_: {

  		endingStart: ZeroCurvatureEnding$1,
  		endingEnd: ZeroCurvatureEnding$1

  	},

  	intervalChanged_: function ( i1, t0, t1 ) {

  		var pp = this.parameterPositions,
  			iPrev = i1 - 2,
  			iNext = i1 + 1,

  			tPrev = pp[ iPrev ],
  			tNext = pp[ iNext ];

  		if ( tPrev === undefined ) {

  			switch ( this.getSettings_().endingStart ) {

  				case ZeroSlopeEnding$1:

  					// f'(t0) = 0
  					iPrev = i1;
  					tPrev = 2 * t0 - t1;

  					break;

  				case WrapAroundEnding$1:

  					// use the other end of the curve
  					iPrev = pp.length - 2;
  					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

  					break;

  				default: // ZeroCurvatureEnding

  					// f''(t0) = 0 a.k.a. Natural Spline
  					iPrev = i1;
  					tPrev = t1;

  			}

  		}

  		if ( tNext === undefined ) {

  			switch ( this.getSettings_().endingEnd ) {

  				case ZeroSlopeEnding$1:

  					// f'(tN) = 0
  					iNext = i1;
  					tNext = 2 * t1 - t0;

  					break;

  				case WrapAroundEnding$1:

  					// use the other end of the curve
  					iNext = 1;
  					tNext = t1 + pp[ 1 ] - pp[ 0 ];

  					break;

  				default: // ZeroCurvatureEnding

  					// f''(tN) = 0, a.k.a. Natural Spline
  					iNext = i1 - 1;
  					tNext = t0;

  			}

  		}

  		var halfDt = ( t1 - t0 ) * 0.5,
  			stride = this.valueSize;

  		this._weightPrev = halfDt / ( t0 - tPrev );
  		this._weightNext = halfDt / ( tNext - t1 );
  		this._offsetPrev = iPrev * stride;
  		this._offsetNext = iNext * stride;

  	},

  	interpolate_: function ( i1, t0, t, t1 ) {

  		var result = this.resultBuffer,
  			values = this.sampleValues,
  			stride = this.valueSize,

  			o1 = i1 * stride,		o0 = o1 - stride,
  			oP = this._offsetPrev, 	oN = this._offsetNext,
  			wP = this._weightPrev,	wN = this._weightNext,

  			p = ( t - t0 ) / ( t1 - t0 ),
  			pp = p * p,
  			ppp = pp * p;

  		// evaluate polynomials

  		var sP = - wP * ppp + 2 * wP * pp - wP * p;
  		var s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
  		var s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
  		var sN = wN * ppp - wN * pp;

  		// combine data linearly

  		for ( var i = 0; i !== stride; ++ i ) {

  			result[ i ] =
  					sP * values[ oP + i ] +
  					s0 * values[ o0 + i ] +
  					s1 * values[ o1 + i ] +
  					sN * values[ oN + i ];

  		}

  		return result;

  	}

  } );

  /**
   * @author tschw
   */

  function LinearInterpolant$1( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  	Interpolant$1.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

  }

  LinearInterpolant$1.prototype = Object.assign( Object.create( Interpolant$1.prototype ), {

  	constructor: LinearInterpolant$1,

  	interpolate_: function ( i1, t0, t, t1 ) {

  		var result = this.resultBuffer,
  			values = this.sampleValues,
  			stride = this.valueSize,

  			offset1 = i1 * stride,
  			offset0 = offset1 - stride,

  			weight1 = ( t - t0 ) / ( t1 - t0 ),
  			weight0 = 1 - weight1;

  		for ( var i = 0; i !== stride; ++ i ) {

  			result[ i ] =
  					values[ offset0 + i ] * weight0 +
  					values[ offset1 + i ] * weight1;

  		}

  		return result;

  	}

  } );

  /**
   *
   * Interpolant that evaluates to the sample value at the position preceeding
   * the parameter.
   *
   * @author tschw
   */

  function DiscreteInterpolant$1( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  	Interpolant$1.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

  }

  DiscreteInterpolant$1.prototype = Object.assign( Object.create( Interpolant$1.prototype ), {

  	constructor: DiscreteInterpolant$1,

  	interpolate_: function ( i1 /* t0, t, t1 */ ) {

  		return this.copySampleValue_( i1 - 1 );

  	}

  } );

  var KeyframeTrackPrototype$1;

  KeyframeTrackPrototype$1 = {

  	TimeBufferType: Float32Array,
  	ValueBufferType: Float32Array,

  	DefaultInterpolation: InterpolateLinear$1,

  	InterpolantFactoryMethodDiscrete: function ( result ) {

  		return new DiscreteInterpolant$1( this.times, this.values, this.getValueSize(), result );

  	},

  	InterpolantFactoryMethodLinear: function ( result ) {

  		return new LinearInterpolant$1( this.times, this.values, this.getValueSize(), result );

  	},

  	InterpolantFactoryMethodSmooth: function ( result ) {

  		return new CubicInterpolant$1( this.times, this.values, this.getValueSize(), result );

  	},

  	setInterpolation: function ( interpolation ) {

  		var factoryMethod;

  		switch ( interpolation ) {

  			case InterpolateDiscrete$1:

  				factoryMethod = this.InterpolantFactoryMethodDiscrete;

  				break;

  			case InterpolateLinear$1:

  				factoryMethod = this.InterpolantFactoryMethodLinear;

  				break;

  			case InterpolateSmooth$1:

  				factoryMethod = this.InterpolantFactoryMethodSmooth;

  				break;

  		}

  		if ( factoryMethod === undefined ) {

  			var message = "unsupported interpolation for " +
  					this.ValueTypeName + " keyframe track named " + this.name;

  			if ( this.createInterpolant === undefined ) {

  				// fall back to default, unless the default itself is messed up
  				if ( interpolation !== this.DefaultInterpolation ) {

  					this.setInterpolation( this.DefaultInterpolation );

  				} else {

  					throw new Error( message ); // fatal, in this case

  				}

  			}

  			console.warn( 'THREE.KeyframeTrackPrototype:', message );
  			return;

  		}

  		this.createInterpolant = factoryMethod;

  	},

  	getInterpolation: function () {

  		switch ( this.createInterpolant ) {

  			case this.InterpolantFactoryMethodDiscrete:

  				return InterpolateDiscrete$1;

  			case this.InterpolantFactoryMethodLinear:

  				return InterpolateLinear$1;

  			case this.InterpolantFactoryMethodSmooth:

  				return InterpolateSmooth$1;

  		}

  	},

  	getValueSize: function () {

  		return this.values.length / this.times.length;

  	},

  	// move all keyframes either forwards or backwards in time
  	shift: function ( timeOffset ) {

  		if ( timeOffset !== 0.0 ) {

  			var times = this.times;

  			for ( var i = 0, n = times.length; i !== n; ++ i ) {

  				times[ i ] += timeOffset;

  			}

  		}

  		return this;

  	},

  	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  	scale: function ( timeScale ) {

  		if ( timeScale !== 1.0 ) {

  			var times = this.times;

  			for ( var i = 0, n = times.length; i !== n; ++ i ) {

  				times[ i ] *= timeScale;

  			}

  		}

  		return this;

  	},

  	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  	trim: function ( startTime, endTime ) {

  		var times = this.times,
  			nKeys = times.length,
  			from = 0,
  			to = nKeys - 1;

  		while ( from !== nKeys && times[ from ] < startTime ) { ++ from; }
  		while ( to !== - 1 && times[ to ] > endTime ) { -- to; }

  		++ to; // inclusive -> exclusive bound

  		if ( from !== 0 || to !== nKeys ) {

  			// empty tracks are forbidden, so keep at least one keyframe
  			if ( from >= to ) { to = Math.max( to, 1 ), from = to - 1; }

  			var stride = this.getValueSize();
  			this.times = AnimationUtils$1.arraySlice( times, from, to );
  			this.values = AnimationUtils$1.arraySlice( this.values, from * stride, to * stride );

  		}

  		return this;

  	},

  	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  	validate: function () {
  		var this$1 = this;


  		var valid = true;

  		var valueSize = this.getValueSize();
  		if ( valueSize - Math.floor( valueSize ) !== 0 ) {

  			console.error( 'THREE.KeyframeTrackPrototype: Invalid value size in track.', this );
  			valid = false;

  		}

  		var times = this.times,
  			values = this.values,

  			nKeys = times.length;

  		if ( nKeys === 0 ) {

  			console.error( 'THREE.KeyframeTrackPrototype: Track is empty.', this );
  			valid = false;

  		}

  		var prevTime = null;

  		for ( var i = 0; i !== nKeys; i ++ ) {

  			var currTime = times[ i ];

  			if ( typeof currTime === 'number' && isNaN( currTime ) ) {

  				console.error( 'THREE.KeyframeTrackPrototype: Time is not a valid number.', this$1, i, currTime );
  				valid = false;
  				break;

  			}

  			if ( prevTime !== null && prevTime > currTime ) {

  				console.error( 'THREE.KeyframeTrackPrototype: Out of order keys.', this$1, i, currTime, prevTime );
  				valid = false;
  				break;

  			}

  			prevTime = currTime;

  		}

  		if ( values !== undefined ) {

  			if ( AnimationUtils$1.isTypedArray( values ) ) {

  				for ( var i = 0, n = values.length; i !== n; ++ i ) {

  					var value = values[ i ];

  					if ( isNaN( value ) ) {

  						console.error( 'THREE.KeyframeTrackPrototype: Value is not a valid number.', this$1, i, value );
  						valid = false;
  						break;

  					}

  				}

  			}

  		}

  		return valid;

  	},

  	// removes equivalent sequential keys as common in morph target sequences
  	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  	optimize: function () {

  		var times = this.times,
  			values = this.values,
  			stride = this.getValueSize(),

  			smoothInterpolation = this.getInterpolation() === InterpolateSmooth$1,

  			writeIndex = 1,
  			lastIndex = times.length - 1;

  		for ( var i = 1; i < lastIndex; ++ i ) {

  			var keep = false;

  			var time = times[ i ];
  			var timeNext = times[ i + 1 ];

  			// remove adjacent keyframes scheduled at the same time

  			if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {

  				if ( ! smoothInterpolation ) {

  					// remove unnecessary keyframes same as their neighbors

  					var offset = i * stride,
  						offsetP = offset - stride,
  						offsetN = offset + stride;

  					for ( var j = 0; j !== stride; ++ j ) {

  						var value = values[ offset + j ];

  						if ( value !== values[ offsetP + j ] ||
  								value !== values[ offsetN + j ] ) {

  							keep = true;
  							break;

  						}

  					}

  				} else { keep = true; }

  			}

  			// in-place compaction

  			if ( keep ) {

  				if ( i !== writeIndex ) {

  					times[ writeIndex ] = times[ i ];

  					var readOffset = i * stride,
  						writeOffset = writeIndex * stride;

  					for ( var j = 0; j !== stride; ++ j )

  						{ values[ writeOffset + j ] = values[ readOffset + j ]; }

  				}

  				++ writeIndex;

  			}

  		}

  		// flush last keyframe (compaction looks ahead)

  		if ( lastIndex > 0 ) {

  			times[ writeIndex ] = times[ lastIndex ];

  			for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j )

  				{ values[ writeOffset + j ] = values[ readOffset + j ]; }

  			++ writeIndex;

  		}

  		if ( writeIndex !== times.length ) {

  			this.times = AnimationUtils$1.arraySlice( times, 0, writeIndex );
  			this.values = AnimationUtils$1.arraySlice( values, 0, writeIndex * stride );

  		}

  		return this;

  	}

  };

  function KeyframeTrackConstructor$1( name, times, values, interpolation ) {

  	if ( name === undefined ) { throw new Error( 'track name is undefined' ); }

  	if ( times === undefined || times.length === 0 ) {

  		throw new Error( 'no keyframes in track named ' + name );

  	}

  	this.name = name;

  	this.times = AnimationUtils$1.convertArray( times, this.TimeBufferType );
  	this.values = AnimationUtils$1.convertArray( values, this.ValueBufferType );

  	this.setInterpolation( interpolation || this.DefaultInterpolation );

  	this.validate();
  	this.optimize();

  }

  /**
   *
   * A Track of vectored keyframe values.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function VectorKeyframeTrack$1( name, times, values, interpolation ) {

  	KeyframeTrackConstructor$1.call( this, name, times, values, interpolation );

  }

  VectorKeyframeTrack$1.prototype = Object.assign( Object.create( KeyframeTrackPrototype$1 ), {

  	constructor: VectorKeyframeTrack$1,

  	ValueTypeName: 'vector'

  	// ValueBufferType is inherited

  	// DefaultInterpolation is inherited

  } );

  /**
   * Spherical linear unit quaternion interpolant.
   *
   * @author tschw
   */

  function QuaternionLinearInterpolant$1( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  	Interpolant$1.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

  }

  QuaternionLinearInterpolant$1.prototype = Object.assign( Object.create( Interpolant$1.prototype ), {

  	constructor: QuaternionLinearInterpolant$1,

  	interpolate_: function ( i1, t0, t, t1 ) {

  		var result = this.resultBuffer,
  			values = this.sampleValues,
  			stride = this.valueSize,

  			offset = i1 * stride,

  			alpha = ( t - t0 ) / ( t1 - t0 );

  		for ( var end = offset + stride; offset !== end; offset += 4 ) {

  			Quaternion$1.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

  		}

  		return result;

  	}

  } );

  /**
   *
   * A Track of quaternion keyframe values.
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function QuaternionKeyframeTrack$1( name, times, values, interpolation ) {

  	KeyframeTrackConstructor$1.call( this, name, times, values, interpolation );

  }

  QuaternionKeyframeTrack$1.prototype = Object.assign( Object.create( KeyframeTrackPrototype$1 ), {

  	constructor: QuaternionKeyframeTrack$1,

  	ValueTypeName: 'quaternion',

  	// ValueBufferType is inherited

  	DefaultInterpolation: InterpolateLinear$1,

  	InterpolantFactoryMethodLinear: function ( result ) {

  		return new QuaternionLinearInterpolant$1( this.times, this.values, this.getValueSize(), result );

  	},

  	InterpolantFactoryMethodSmooth: undefined // not yet implemented

  } );

  /**
   *
   * A Track of numeric keyframe values.
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function NumberKeyframeTrack$1( name, times, values, interpolation ) {

  	KeyframeTrackConstructor$1.call( this, name, times, values, interpolation );

  }

  NumberKeyframeTrack$1.prototype = Object.assign( Object.create( KeyframeTrackPrototype$1 ), {

  	constructor: NumberKeyframeTrack$1,

  	ValueTypeName: 'number'

  	// ValueBufferType is inherited

  	// DefaultInterpolation is inherited

  } );

  /**
   *
   * A Track that interpolates Strings
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function StringKeyframeTrack$1( name, times, values, interpolation ) {

  	KeyframeTrackConstructor$1.call( this, name, times, values, interpolation );

  }

  StringKeyframeTrack$1.prototype = Object.assign( Object.create( KeyframeTrackPrototype$1 ), {

  	constructor: StringKeyframeTrack$1,

  	ValueTypeName: 'string',
  	ValueBufferType: Array,

  	DefaultInterpolation: InterpolateDiscrete$1,

  	InterpolantFactoryMethodLinear: undefined,

  	InterpolantFactoryMethodSmooth: undefined

  } );

  /**
   *
   * A Track of Boolean keyframe values.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function BooleanKeyframeTrack$1( name, times, values ) {

  	KeyframeTrackConstructor$1.call( this, name, times, values );

  }

  BooleanKeyframeTrack$1.prototype = Object.assign( Object.create( KeyframeTrackPrototype$1 ), {

  	constructor: BooleanKeyframeTrack$1,

  	ValueTypeName: 'bool',
  	ValueBufferType: Array,

  	DefaultInterpolation: InterpolateDiscrete$1,

  	InterpolantFactoryMethodLinear: undefined,
  	InterpolantFactoryMethodSmooth: undefined

  	// Note: Actually this track could have a optimized / compressed
  	// representation of a single value and a custom interpolant that
  	// computes "firstValue ^ isOdd( index )".

  } );

  /**
   *
   * A Track of keyframe values that represent color.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function ColorKeyframeTrack$1( name, times, values, interpolation ) {

  	KeyframeTrackConstructor$1.call( this, name, times, values, interpolation );

  }

  ColorKeyframeTrack$1.prototype = Object.assign( Object.create( KeyframeTrackPrototype$1 ), {

  	constructor: ColorKeyframeTrack$1,

  	ValueTypeName: 'color'

  	// ValueBufferType is inherited

  	// DefaultInterpolation is inherited


  	// Note: Very basic implementation and nothing special yet.
  	// However, this is the place for color space parameterization.

  } );

  /**
   *
   * A timed sequence of keyframes for a specific property.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function KeyframeTrack$1( name, times, values, interpolation ) {

  	KeyframeTrackConstructor$1.apply( this, name, times, values, interpolation );

  }

  KeyframeTrack$1.prototype = KeyframeTrackPrototype$1;
  KeyframeTrackPrototype$1.constructor = KeyframeTrack$1;

  // Static methods:

  Object.assign( KeyframeTrack$1, {

  	// Serialization (in static context, because of constructor invocation
  	// and automatic invocation of .toJSON):

  	parse: function ( json ) {

  		if ( json.type === undefined ) {

  			throw new Error( 'track type undefined, can not parse' );

  		}

  		var trackType = KeyframeTrack$1._getTrackTypeForValueTypeName( json.type );

  		if ( json.times === undefined ) {

  			var times = [], values = [];

  			AnimationUtils$1.flattenJSON( json.keys, times, values, 'value' );

  			json.times = times;
  			json.values = values;

  		}

  		// derived classes can define a static parse method
  		if ( trackType.parse !== undefined ) {

  			return trackType.parse( json );

  		} else {

  			// by default, we assume a constructor compatible with the base
  			return new trackType( json.name, json.times, json.values, json.interpolation );

  		}

  	},

  	toJSON: function ( track ) {

  		var trackType = track.constructor;

  		var json;

  		// derived classes can define a static toJSON method
  		if ( trackType.toJSON !== undefined ) {

  			json = trackType.toJSON( track );

  		} else {

  			// by default, we assume the data can be serialized as-is
  			json = {

  				'name': track.name,
  				'times': AnimationUtils$1.convertArray( track.times, Array ),
  				'values': AnimationUtils$1.convertArray( track.values, Array )

  			};

  			var interpolation = track.getInterpolation();

  			if ( interpolation !== track.DefaultInterpolation ) {

  				json.interpolation = interpolation;

  			}

  		}

  		json.type = track.ValueTypeName; // mandatory

  		return json;

  	},

  	_getTrackTypeForValueTypeName: function ( typeName ) {

  		switch ( typeName.toLowerCase() ) {

  			case 'scalar':
  			case 'double':
  			case 'float':
  			case 'number':
  			case 'integer':

  				return NumberKeyframeTrack$1;

  			case 'vector':
  			case 'vector2':
  			case 'vector3':
  			case 'vector4':

  				return VectorKeyframeTrack$1;

  			case 'color':

  				return ColorKeyframeTrack$1;

  			case 'quaternion':

  				return QuaternionKeyframeTrack$1;

  			case 'bool':
  			case 'boolean':

  				return BooleanKeyframeTrack$1;

  			case 'string':

  				return StringKeyframeTrack$1;

  		}

  		throw new Error( 'Unsupported typeName: ' + typeName );

  	}

  } );

  /**
   *
   * Reusable set of Tracks that represent an animation.
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   */

  function AnimationClip$1( name, duration, tracks ) {

  	this.name = name;
  	this.tracks = tracks;
  	this.duration = ( duration !== undefined ) ? duration : - 1;

  	this.uuid = _Math$1.generateUUID();

  	// this means it should figure out its duration by scanning the tracks
  	if ( this.duration < 0 ) {

  		this.resetDuration();

  	}

  	this.optimize();

  }

  Object.assign( AnimationClip$1, {

  	parse: function ( json ) {

  		var tracks = [],
  			jsonTracks = json.tracks,
  			frameTime = 1.0 / ( json.fps || 1.0 );

  		for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {

  			tracks.push( KeyframeTrack$1.parse( jsonTracks[ i ] ).scale( frameTime ) );

  		}

  		return new AnimationClip$1( json.name, json.duration, tracks );

  	},

  	toJSON: function ( clip ) {

  		var tracks = [],
  			clipTracks = clip.tracks;

  		var json = {

  			'name': clip.name,
  			'duration': clip.duration,
  			'tracks': tracks

  		};

  		for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {

  			tracks.push( KeyframeTrack$1.toJSON( clipTracks[ i ] ) );

  		}

  		return json;

  	},

  	CreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {

  		var numMorphTargets = morphTargetSequence.length;
  		var tracks = [];

  		for ( var i = 0; i < numMorphTargets; i ++ ) {

  			var times = [];
  			var values = [];

  			times.push(
  				( i + numMorphTargets - 1 ) % numMorphTargets,
  				i,
  				( i + 1 ) % numMorphTargets );

  			values.push( 0, 1, 0 );

  			var order = AnimationUtils$1.getKeyframeOrder( times );
  			times = AnimationUtils$1.sortedArray( times, 1, order );
  			values = AnimationUtils$1.sortedArray( values, 1, order );

  			// if there is a key at the first frame, duplicate it as the
  			// last frame as well for perfect loop.
  			if ( ! noLoop && times[ 0 ] === 0 ) {

  				times.push( numMorphTargets );
  				values.push( values[ 0 ] );

  			}

  			tracks.push(
  				new NumberKeyframeTrack$1(
  					'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
  					times, values
  				).scale( 1.0 / fps ) );

  		}

  		return new AnimationClip$1( name, - 1, tracks );

  	},

  	findByName: function ( objectOrClipArray, name ) {

  		var clipArray = objectOrClipArray;

  		if ( ! Array.isArray( objectOrClipArray ) ) {

  			var o = objectOrClipArray;
  			clipArray = o.geometry && o.geometry.animations || o.animations;

  		}

  		for ( var i = 0; i < clipArray.length; i ++ ) {

  			if ( clipArray[ i ].name === name ) {

  				return clipArray[ i ];

  			}

  		}

  		return null;

  	},

  	CreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {

  		var animationToMorphTargets = {};

  		// tested with https://regex101.com/ on trick sequences
  		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
  		var pattern = /^([\w-]*?)([\d]+)$/;

  		// sort morph target names into animation groups based
  		// patterns like Walk_001, Walk_002, Run_001, Run_002
  		for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

  			var morphTarget = morphTargets[ i ];
  			var parts = morphTarget.name.match( pattern );

  			if ( parts && parts.length > 1 ) {

  				var name = parts[ 1 ];

  				var animationMorphTargets = animationToMorphTargets[ name ];
  				if ( ! animationMorphTargets ) {

  					animationToMorphTargets[ name ] = animationMorphTargets = [];

  				}

  				animationMorphTargets.push( morphTarget );

  			}

  		}

  		var clips = [];

  		for ( var name in animationToMorphTargets ) {

  			clips.push( AnimationClip$1.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

  		}

  		return clips;

  	},

  	// parse the animation.hierarchy format
  	parseAnimation: function ( animation, bones ) {

  		if ( ! animation ) {

  			console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
  			return null;

  		}

  		var addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

  			// only return track if there are actually keys.
  			if ( animationKeys.length !== 0 ) {

  				var times = [];
  				var values = [];

  				AnimationUtils$1.flattenJSON( animationKeys, times, values, propertyName );

  				// empty keys are filtered out, so check again
  				if ( times.length !== 0 ) {

  					destTracks.push( new trackType( trackName, times, values ) );

  				}

  			}

  		};

  		var tracks = [];

  		var clipName = animation.name || 'default';
  		// automatic length determination in AnimationClip.
  		var duration = animation.length || - 1;
  		var fps = animation.fps || 30;

  		var hierarchyTracks = animation.hierarchy || [];

  		for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

  			var animationKeys = hierarchyTracks[ h ].keys;

  			// skip empty tracks
  			if ( ! animationKeys || animationKeys.length === 0 ) { continue; }

  			// process morph targets
  			if ( animationKeys[ 0 ].morphTargets ) {

  				// figure out all morph targets used in this track
  				var morphTargetNames = {};

  				for ( var k = 0; k < animationKeys.length; k ++ ) {

  					if ( animationKeys[ k ].morphTargets ) {

  						for ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

  							morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

  						}

  					}

  				}

  				// create a track for each morph target with all zero
  				// morphTargetInfluences except for the keys in which
  				// the morphTarget is named.
  				for ( var morphTargetName in morphTargetNames ) {

  					var times = [];
  					var values = [];

  					for ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

  						var animationKey = animationKeys[ k ];

  						times.push( animationKey.time );
  						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

  					}

  					tracks.push( new NumberKeyframeTrack$1( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

  				}

  				duration = morphTargetNames.length * ( fps || 1.0 );

  			} else {

  				// ...assume skeletal animation

  				var boneName = '.bones[' + bones[ h ].name + ']';

  				addNonemptyTrack(
  					VectorKeyframeTrack$1, boneName + '.position',
  					animationKeys, 'pos', tracks );

  				addNonemptyTrack(
  					QuaternionKeyframeTrack$1, boneName + '.quaternion',
  					animationKeys, 'rot', tracks );

  				addNonemptyTrack(
  					VectorKeyframeTrack$1, boneName + '.scale',
  					animationKeys, 'scl', tracks );

  			}

  		}

  		if ( tracks.length === 0 ) {

  			return null;

  		}

  		var clip = new AnimationClip$1( clipName, duration, tracks );

  		return clip;

  	}

  } );

  Object.assign( AnimationClip$1.prototype, {

  	resetDuration: function () {
  		var this$1 = this;


  		var tracks = this.tracks, duration = 0;

  		for ( var i = 0, n = tracks.length; i !== n; ++ i ) {

  			var track = this$1.tracks[ i ];

  			duration = Math.max( duration, track.times[ track.times.length - 1 ] );

  		}

  		this.duration = duration;

  	},

  	trim: function () {
  		var this$1 = this;


  		for ( var i = 0; i < this.tracks.length; i ++ ) {

  			this$1.tracks[ i ].trim( 0, this$1.duration );

  		}

  		return this;

  	},

  	optimize: function () {
  		var this$1 = this;


  		for ( var i = 0; i < this.tracks.length; i ++ ) {

  			this$1.tracks[ i ].optimize();

  		}

  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function MaterialLoader$1( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager$1;
  	this.textures = {};

  }

  Object.assign( MaterialLoader$1.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var loader = new FileLoader$1( scope.manager );
  		loader.load( url, function ( text ) {

  			onLoad( scope.parse( JSON.parse( text ) ) );

  		}, onProgress, onError );

  	},

  	setTextures: function ( value ) {

  		this.textures = value;

  	},

  	parse: function ( json ) {

  		var textures = this.textures;

  		function getTexture( name ) {

  			if ( textures[ name ] === undefined ) {

  				console.warn( 'THREE.MaterialLoader: Undefined texture', name );

  			}

  			return textures[ name ];

  		}

  		var material = new Materials$1[ json.type ]();

  		if ( json.uuid !== undefined ) { material.uuid = json.uuid; }
  		if ( json.name !== undefined ) { material.name = json.name; }
  		if ( json.color !== undefined ) { material.color.setHex( json.color ); }
  		if ( json.roughness !== undefined ) { material.roughness = json.roughness; }
  		if ( json.metalness !== undefined ) { material.metalness = json.metalness; }
  		if ( json.emissive !== undefined ) { material.emissive.setHex( json.emissive ); }
  		if ( json.specular !== undefined ) { material.specular.setHex( json.specular ); }
  		if ( json.shininess !== undefined ) { material.shininess = json.shininess; }
  		if ( json.clearCoat !== undefined ) { material.clearCoat = json.clearCoat; }
  		if ( json.clearCoatRoughness !== undefined ) { material.clearCoatRoughness = json.clearCoatRoughness; }
  		if ( json.uniforms !== undefined ) { material.uniforms = json.uniforms; }
  		if ( json.vertexShader !== undefined ) { material.vertexShader = json.vertexShader; }
  		if ( json.fragmentShader !== undefined ) { material.fragmentShader = json.fragmentShader; }
  		if ( json.vertexColors !== undefined ) { material.vertexColors = json.vertexColors; }
  		if ( json.fog !== undefined ) { material.fog = json.fog; }
  		if ( json.flatShading !== undefined ) { material.flatShading = json.flatShading; }
  		if ( json.blending !== undefined ) { material.blending = json.blending; }
  		if ( json.side !== undefined ) { material.side = json.side; }
  		if ( json.opacity !== undefined ) { material.opacity = json.opacity; }
  		if ( json.transparent !== undefined ) { material.transparent = json.transparent; }
  		if ( json.alphaTest !== undefined ) { material.alphaTest = json.alphaTest; }
  		if ( json.depthTest !== undefined ) { material.depthTest = json.depthTest; }
  		if ( json.depthWrite !== undefined ) { material.depthWrite = json.depthWrite; }
  		if ( json.colorWrite !== undefined ) { material.colorWrite = json.colorWrite; }
  		if ( json.wireframe !== undefined ) { material.wireframe = json.wireframe; }
  		if ( json.wireframeLinewidth !== undefined ) { material.wireframeLinewidth = json.wireframeLinewidth; }
  		if ( json.wireframeLinecap !== undefined ) { material.wireframeLinecap = json.wireframeLinecap; }
  		if ( json.wireframeLinejoin !== undefined ) { material.wireframeLinejoin = json.wireframeLinejoin; }

  		if ( json.skinning !== undefined ) { material.skinning = json.skinning; }
  		if ( json.morphTargets !== undefined ) { material.morphTargets = json.morphTargets; }
  		if ( json.dithering !== undefined ) { material.dithering = json.dithering; }

  		if ( json.visible !== undefined ) { material.visible = json.visible; }
  		if ( json.userData !== undefined ) { material.userData = json.userData; }

  		// Deprecated

  		if ( json.shading !== undefined ) { material.flatShading = json.shading === 1; } // THREE.FlatShading

  		// for PointsMaterial

  		if ( json.size !== undefined ) { material.size = json.size; }
  		if ( json.sizeAttenuation !== undefined ) { material.sizeAttenuation = json.sizeAttenuation; }

  		// maps

  		if ( json.map !== undefined ) { material.map = getTexture( json.map ); }

  		if ( json.alphaMap !== undefined ) {

  			material.alphaMap = getTexture( json.alphaMap );
  			material.transparent = true;

  		}

  		if ( json.bumpMap !== undefined ) { material.bumpMap = getTexture( json.bumpMap ); }
  		if ( json.bumpScale !== undefined ) { material.bumpScale = json.bumpScale; }

  		if ( json.normalMap !== undefined ) { material.normalMap = getTexture( json.normalMap ); }
  		if ( json.normalScale !== undefined ) {

  			var normalScale = json.normalScale;

  			if ( Array.isArray( normalScale ) === false ) {

  				// Blender exporter used to export a scalar. See #7459

  				normalScale = [ normalScale, normalScale ];

  			}

  			material.normalScale = new Vector2$1().fromArray( normalScale );

  		}

  		if ( json.displacementMap !== undefined ) { material.displacementMap = getTexture( json.displacementMap ); }
  		if ( json.displacementScale !== undefined ) { material.displacementScale = json.displacementScale; }
  		if ( json.displacementBias !== undefined ) { material.displacementBias = json.displacementBias; }

  		if ( json.roughnessMap !== undefined ) { material.roughnessMap = getTexture( json.roughnessMap ); }
  		if ( json.metalnessMap !== undefined ) { material.metalnessMap = getTexture( json.metalnessMap ); }

  		if ( json.emissiveMap !== undefined ) { material.emissiveMap = getTexture( json.emissiveMap ); }
  		if ( json.emissiveIntensity !== undefined ) { material.emissiveIntensity = json.emissiveIntensity; }

  		if ( json.specularMap !== undefined ) { material.specularMap = getTexture( json.specularMap ); }

  		if ( json.envMap !== undefined ) { material.envMap = getTexture( json.envMap ); }

  		if ( json.reflectivity !== undefined ) { material.reflectivity = json.reflectivity; }

  		if ( json.lightMap !== undefined ) { material.lightMap = getTexture( json.lightMap ); }
  		if ( json.lightMapIntensity !== undefined ) { material.lightMapIntensity = json.lightMapIntensity; }

  		if ( json.aoMap !== undefined ) { material.aoMap = getTexture( json.aoMap ); }
  		if ( json.aoMapIntensity !== undefined ) { material.aoMapIntensity = json.aoMapIntensity; }

  		if ( json.gradientMap !== undefined ) { material.gradientMap = getTexture( json.gradientMap ); }

  		return material;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function BufferGeometryLoader$1( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager$1;

  }

  Object.assign( BufferGeometryLoader$1.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var loader = new FileLoader$1( scope.manager );
  		loader.load( url, function ( text ) {

  			onLoad( scope.parse( JSON.parse( text ) ) );

  		}, onProgress, onError );

  	},

  	parse: function ( json ) {

  		var geometry = new BufferGeometry$1();

  		var index = json.data.index;

  		if ( index !== undefined ) {

  			var typedArray = new TYPED_ARRAYS$1[ index.type ]( index.array );
  			geometry.setIndex( new BufferAttribute$1( typedArray, 1 ) );

  		}

  		var attributes = json.data.attributes;

  		for ( var key in attributes ) {

  			var attribute = attributes[ key ];
  			var typedArray = new TYPED_ARRAYS$1[ attribute.type ]( attribute.array );

  			geometry.addAttribute( key, new BufferAttribute$1( typedArray, attribute.itemSize, attribute.normalized ) );

  		}

  		var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

  		if ( groups !== undefined ) {

  			for ( var i = 0, n = groups.length; i !== n; ++ i ) {

  				var group = groups[ i ];

  				geometry.addGroup( group.start, group.count, group.materialIndex );

  			}

  		}

  		var boundingSphere = json.data.boundingSphere;

  		if ( boundingSphere !== undefined ) {

  			var center = new Vector3$2();

  			if ( boundingSphere.center !== undefined ) {

  				center.fromArray( boundingSphere.center );

  			}

  			geometry.boundingSphere = new Sphere$1( center, boundingSphere.radius );

  		}

  		return geometry;

  	}

  } );

  var TYPED_ARRAYS$1 = {
  	Int8Array: Int8Array,
  	Uint8Array: Uint8Array,
  	// Workaround for IE11 pre KB2929437. See #11440
  	Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
  	Int16Array: Int16Array,
  	Uint16Array: Uint16Array,
  	Int32Array: Int32Array,
  	Uint32Array: Uint32Array,
  	Float32Array: Float32Array,
  	Float64Array: Float64Array
  };

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function Loader$1() {

  	this.onLoadStart = function () {};
  	this.onLoadProgress = function () {};
  	this.onLoadComplete = function () {};

  }

  Loader$1.Handlers = {

  	handlers: [],

  	add: function ( regex, loader ) {

  		this.handlers.push( regex, loader );

  	},

  	get: function ( file ) {

  		var handlers = this.handlers;

  		for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

  			var regex = handlers[ i ];
  			var loader = handlers[ i + 1 ];

  			if ( regex.test( file ) ) {

  				return loader;

  			}

  		}

  		return null;

  	}

  };

  Object.assign( Loader$1.prototype, {

  	crossOrigin: undefined,

  	extractUrlBase: function ( url ) {

  		var parts = url.split( '/' );

  		if ( parts.length === 1 ) { return './'; }

  		parts.pop();

  		return parts.join( '/' ) + '/';

  	},

  	initMaterials: function ( materials, texturePath, crossOrigin ) {
  		var this$1 = this;


  		var array = [];

  		for ( var i = 0; i < materials.length; ++ i ) {

  			array[ i ] = this$1.createMaterial( materials[ i ], texturePath, crossOrigin );

  		}

  		return array;

  	},

  	createMaterial: ( function () {

  		var BlendingMode = {
  			NoBlending: NoBlending$1,
  			NormalBlending: NormalBlending$1,
  			AdditiveBlending: AdditiveBlending$1,
  			SubtractiveBlending: SubtractiveBlending$1,
  			MultiplyBlending: MultiplyBlending$1,
  			CustomBlending: CustomBlending$1
  		};

  		var color = new Color$1();
  		var textureLoader = new TextureLoader$1();
  		var materialLoader = new MaterialLoader$1();

  		return function createMaterial( m, texturePath, crossOrigin ) {

  			// convert from old material format

  			var textures = {};

  			function loadTexture( path, repeat, offset, wrap, anisotropy ) {

  				var fullPath = texturePath + path;
  				var loader = Loader$1.Handlers.get( fullPath );

  				var texture;

  				if ( loader !== null ) {

  					texture = loader.load( fullPath );

  				} else {

  					textureLoader.setCrossOrigin( crossOrigin );
  					texture = textureLoader.load( fullPath );

  				}

  				if ( repeat !== undefined ) {

  					texture.repeat.fromArray( repeat );

  					if ( repeat[ 0 ] !== 1 ) { texture.wrapS = RepeatWrapping$1; }
  					if ( repeat[ 1 ] !== 1 ) { texture.wrapT = RepeatWrapping$1; }

  				}

  				if ( offset !== undefined ) {

  					texture.offset.fromArray( offset );

  				}

  				if ( wrap !== undefined ) {

  					if ( wrap[ 0 ] === 'repeat' ) { texture.wrapS = RepeatWrapping$1; }
  					if ( wrap[ 0 ] === 'mirror' ) { texture.wrapS = MirroredRepeatWrapping$1; }

  					if ( wrap[ 1 ] === 'repeat' ) { texture.wrapT = RepeatWrapping$1; }
  					if ( wrap[ 1 ] === 'mirror' ) { texture.wrapT = MirroredRepeatWrapping$1; }

  				}

  				if ( anisotropy !== undefined ) {

  					texture.anisotropy = anisotropy;

  				}

  				var uuid = _Math$1.generateUUID();

  				textures[ uuid ] = texture;

  				return uuid;

  			}

  			//

  			var json = {
  				uuid: _Math$1.generateUUID(),
  				type: 'MeshLambertMaterial'
  			};

  			for ( var name in m ) {

  				var value = m[ name ];

  				switch ( name ) {

  					case 'DbgColor':
  					case 'DbgIndex':
  					case 'opticalDensity':
  					case 'illumination':
  						break;
  					case 'DbgName':
  						json.name = value;
  						break;
  					case 'blending':
  						json.blending = BlendingMode[ value ];
  						break;
  					case 'colorAmbient':
  					case 'mapAmbient':
  						console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
  						break;
  					case 'colorDiffuse':
  						json.color = color.fromArray( value ).getHex();
  						break;
  					case 'colorSpecular':
  						json.specular = color.fromArray( value ).getHex();
  						break;
  					case 'colorEmissive':
  						json.emissive = color.fromArray( value ).getHex();
  						break;
  					case 'specularCoef':
  						json.shininess = value;
  						break;
  					case 'shading':
  						if ( value.toLowerCase() === 'basic' ) { json.type = 'MeshBasicMaterial'; }
  						if ( value.toLowerCase() === 'phong' ) { json.type = 'MeshPhongMaterial'; }
  						if ( value.toLowerCase() === 'standard' ) { json.type = 'MeshStandardMaterial'; }
  						break;
  					case 'mapDiffuse':
  						json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
  						break;
  					case 'mapDiffuseRepeat':
  					case 'mapDiffuseOffset':
  					case 'mapDiffuseWrap':
  					case 'mapDiffuseAnisotropy':
  						break;
  					case 'mapEmissive':
  						json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );
  						break;
  					case 'mapEmissiveRepeat':
  					case 'mapEmissiveOffset':
  					case 'mapEmissiveWrap':
  					case 'mapEmissiveAnisotropy':
  						break;
  					case 'mapLight':
  						json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
  						break;
  					case 'mapLightRepeat':
  					case 'mapLightOffset':
  					case 'mapLightWrap':
  					case 'mapLightAnisotropy':
  						break;
  					case 'mapAO':
  						json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
  						break;
  					case 'mapAORepeat':
  					case 'mapAOOffset':
  					case 'mapAOWrap':
  					case 'mapAOAnisotropy':
  						break;
  					case 'mapBump':
  						json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
  						break;
  					case 'mapBumpScale':
  						json.bumpScale = value;
  						break;
  					case 'mapBumpRepeat':
  					case 'mapBumpOffset':
  					case 'mapBumpWrap':
  					case 'mapBumpAnisotropy':
  						break;
  					case 'mapNormal':
  						json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
  						break;
  					case 'mapNormalFactor':
  						json.normalScale = [ value, value ];
  						break;
  					case 'mapNormalRepeat':
  					case 'mapNormalOffset':
  					case 'mapNormalWrap':
  					case 'mapNormalAnisotropy':
  						break;
  					case 'mapSpecular':
  						json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
  						break;
  					case 'mapSpecularRepeat':
  					case 'mapSpecularOffset':
  					case 'mapSpecularWrap':
  					case 'mapSpecularAnisotropy':
  						break;
  					case 'mapMetalness':
  						json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );
  						break;
  					case 'mapMetalnessRepeat':
  					case 'mapMetalnessOffset':
  					case 'mapMetalnessWrap':
  					case 'mapMetalnessAnisotropy':
  						break;
  					case 'mapRoughness':
  						json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );
  						break;
  					case 'mapRoughnessRepeat':
  					case 'mapRoughnessOffset':
  					case 'mapRoughnessWrap':
  					case 'mapRoughnessAnisotropy':
  						break;
  					case 'mapAlpha':
  						json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
  						break;
  					case 'mapAlphaRepeat':
  					case 'mapAlphaOffset':
  					case 'mapAlphaWrap':
  					case 'mapAlphaAnisotropy':
  						break;
  					case 'flipSided':
  						json.side = BackSide$1;
  						break;
  					case 'doubleSided':
  						json.side = DoubleSide$1;
  						break;
  					case 'transparency':
  						console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
  						json.opacity = value;
  						break;
  					case 'depthTest':
  					case 'depthWrite':
  					case 'colorWrite':
  					case 'opacity':
  					case 'reflectivity':
  					case 'transparent':
  					case 'visible':
  					case 'wireframe':
  						json[ name ] = value;
  						break;
  					case 'vertexColors':
  						if ( value === true ) { json.vertexColors = VertexColors$1; }
  						if ( value === 'face' ) { json.vertexColors = FaceColors$1; }
  						break;
  					default:
  						console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
  						break;

  				}

  			}

  			if ( json.type === 'MeshBasicMaterial' ) { delete json.emissive; }
  			if ( json.type !== 'MeshPhongMaterial' ) { delete json.specular; }

  			if ( json.opacity < 1 ) { json.transparent = true; }

  			materialLoader.setTextures( textures );

  			return materialLoader.parse( json );

  		};

  	} )()

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  function JSONLoader$1( manager ) {

  	if ( typeof manager === 'boolean' ) {

  		console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
  		manager = undefined;

  	}

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager$1;

  	this.withCredentials = false;

  }

  Object.assign( JSONLoader$1.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : Loader$1.prototype.extractUrlBase( url );

  		var loader = new FileLoader$1( this.manager );
  		loader.setWithCredentials( this.withCredentials );
  		loader.load( url, function ( text ) {

  			var json = JSON.parse( text );
  			var metadata = json.metadata;

  			if ( metadata !== undefined ) {

  				var type = metadata.type;

  				if ( type !== undefined ) {

  					if ( type.toLowerCase() === 'object' ) {

  						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
  						return;

  					}

  					if ( type.toLowerCase() === 'scene' ) {

  						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
  						return;

  					}

  				}

  			}

  			var object = scope.parse( json, texturePath );
  			onLoad( object.geometry, object.materials );

  		}, onProgress, onError );

  	},

  	setTexturePath: function ( value ) {

  		this.texturePath = value;

  	},

  	parse: ( function () {

  		function parseModel( json, geometry ) {

  			function isBitSet( value, position ) {

  				return value & ( 1 << position );

  			}

  			var i, j, fi,

  				offset, zLength,

  				colorIndex, normalIndex, uvIndex, materialIndex,

  				type,
  				isQuad,
  				hasMaterial,
  				hasFaceVertexUv,
  				hasFaceNormal, hasFaceVertexNormal,
  				hasFaceColor, hasFaceVertexColor,

  				vertex, face, faceA, faceB, hex, normal,

  				uvLayer, uv, u, v,

  				faces = json.faces,
  				vertices = json.vertices,
  				normals = json.normals,
  				colors = json.colors,

  				scale = json.scale,

  				nUvLayers = 0;


  			if ( json.uvs !== undefined ) {

  				// disregard empty arrays

  				for ( i = 0; i < json.uvs.length; i ++ ) {

  					if ( json.uvs[ i ].length ) { nUvLayers ++; }

  				}

  				for ( i = 0; i < nUvLayers; i ++ ) {

  					geometry.faceVertexUvs[ i ] = [];

  				}

  			}

  			offset = 0;
  			zLength = vertices.length;

  			while ( offset < zLength ) {

  				vertex = new Vector3$2();

  				vertex.x = vertices[ offset ++ ] * scale;
  				vertex.y = vertices[ offset ++ ] * scale;
  				vertex.z = vertices[ offset ++ ] * scale;

  				geometry.vertices.push( vertex );

  			}

  			offset = 0;
  			zLength = faces.length;

  			while ( offset < zLength ) {

  				type = faces[ offset ++ ];

  				isQuad = isBitSet( type, 0 );
  				hasMaterial = isBitSet( type, 1 );
  				hasFaceVertexUv = isBitSet( type, 3 );
  				hasFaceNormal = isBitSet( type, 4 );
  				hasFaceVertexNormal = isBitSet( type, 5 );
  				hasFaceColor = isBitSet( type, 6 );
  				hasFaceVertexColor = isBitSet( type, 7 );

  				// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

  				if ( isQuad ) {

  					faceA = new Face3$2();
  					faceA.a = faces[ offset ];
  					faceA.b = faces[ offset + 1 ];
  					faceA.c = faces[ offset + 3 ];

  					faceB = new Face3$2();
  					faceB.a = faces[ offset + 1 ];
  					faceB.b = faces[ offset + 2 ];
  					faceB.c = faces[ offset + 3 ];

  					offset += 4;

  					if ( hasMaterial ) {

  						materialIndex = faces[ offset ++ ];
  						faceA.materialIndex = materialIndex;
  						faceB.materialIndex = materialIndex;

  					}

  					// to get face <=> uv index correspondence

  					fi = geometry.faces.length;

  					if ( hasFaceVertexUv ) {

  						for ( i = 0; i < nUvLayers; i ++ ) {

  							uvLayer = json.uvs[ i ];

  							geometry.faceVertexUvs[ i ][ fi ] = [];
  							geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

  							for ( j = 0; j < 4; j ++ ) {

  								uvIndex = faces[ offset ++ ];

  								u = uvLayer[ uvIndex * 2 ];
  								v = uvLayer[ uvIndex * 2 + 1 ];

  								uv = new Vector2$1( u, v );

  								if ( j !== 2 ) { geometry.faceVertexUvs[ i ][ fi ].push( uv ); }
  								if ( j !== 0 ) { geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv ); }

  							}

  						}

  					}

  					if ( hasFaceNormal ) {

  						normalIndex = faces[ offset ++ ] * 3;

  						faceA.normal.set(
  							normals[ normalIndex ++ ],
  							normals[ normalIndex ++ ],
  							normals[ normalIndex ]
  						);

  						faceB.normal.copy( faceA.normal );

  					}

  					if ( hasFaceVertexNormal ) {

  						for ( i = 0; i < 4; i ++ ) {

  							normalIndex = faces[ offset ++ ] * 3;

  							normal = new Vector3$2(
  								normals[ normalIndex ++ ],
  								normals[ normalIndex ++ ],
  								normals[ normalIndex ]
  							);


  							if ( i !== 2 ) { faceA.vertexNormals.push( normal ); }
  							if ( i !== 0 ) { faceB.vertexNormals.push( normal ); }

  						}

  					}


  					if ( hasFaceColor ) {

  						colorIndex = faces[ offset ++ ];
  						hex = colors[ colorIndex ];

  						faceA.color.setHex( hex );
  						faceB.color.setHex( hex );

  					}


  					if ( hasFaceVertexColor ) {

  						for ( i = 0; i < 4; i ++ ) {

  							colorIndex = faces[ offset ++ ];
  							hex = colors[ colorIndex ];

  							if ( i !== 2 ) { faceA.vertexColors.push( new Color$1( hex ) ); }
  							if ( i !== 0 ) { faceB.vertexColors.push( new Color$1( hex ) ); }

  						}

  					}

  					geometry.faces.push( faceA );
  					geometry.faces.push( faceB );

  				} else {

  					face = new Face3$2();
  					face.a = faces[ offset ++ ];
  					face.b = faces[ offset ++ ];
  					face.c = faces[ offset ++ ];

  					if ( hasMaterial ) {

  						materialIndex = faces[ offset ++ ];
  						face.materialIndex = materialIndex;

  					}

  					// to get face <=> uv index correspondence

  					fi = geometry.faces.length;

  					if ( hasFaceVertexUv ) {

  						for ( i = 0; i < nUvLayers; i ++ ) {

  							uvLayer = json.uvs[ i ];

  							geometry.faceVertexUvs[ i ][ fi ] = [];

  							for ( j = 0; j < 3; j ++ ) {

  								uvIndex = faces[ offset ++ ];

  								u = uvLayer[ uvIndex * 2 ];
  								v = uvLayer[ uvIndex * 2 + 1 ];

  								uv = new Vector2$1( u, v );

  								geometry.faceVertexUvs[ i ][ fi ].push( uv );

  							}

  						}

  					}

  					if ( hasFaceNormal ) {

  						normalIndex = faces[ offset ++ ] * 3;

  						face.normal.set(
  							normals[ normalIndex ++ ],
  							normals[ normalIndex ++ ],
  							normals[ normalIndex ]
  						);

  					}

  					if ( hasFaceVertexNormal ) {

  						for ( i = 0; i < 3; i ++ ) {

  							normalIndex = faces[ offset ++ ] * 3;

  							normal = new Vector3$2(
  								normals[ normalIndex ++ ],
  								normals[ normalIndex ++ ],
  								normals[ normalIndex ]
  							);

  							face.vertexNormals.push( normal );

  						}

  					}


  					if ( hasFaceColor ) {

  						colorIndex = faces[ offset ++ ];
  						face.color.setHex( colors[ colorIndex ] );

  					}


  					if ( hasFaceVertexColor ) {

  						for ( i = 0; i < 3; i ++ ) {

  							colorIndex = faces[ offset ++ ];
  							face.vertexColors.push( new Color$1( colors[ colorIndex ] ) );

  						}

  					}

  					geometry.faces.push( face );

  				}

  			}

  		}

  		function parseSkin( json, geometry ) {

  			var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

  			if ( json.skinWeights ) {

  				for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

  					var x = json.skinWeights[ i ];
  					var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
  					var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
  					var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

  					geometry.skinWeights.push( new Vector4$1( x, y, z, w ) );

  				}

  			}

  			if ( json.skinIndices ) {

  				for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

  					var a = json.skinIndices[ i ];
  					var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
  					var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
  					var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

  					geometry.skinIndices.push( new Vector4$1( a, b, c, d ) );

  				}

  			}

  			geometry.bones = json.bones;

  			if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

  				console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
  					geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

  			}

  		}

  		function parseMorphing( json, geometry ) {

  			var scale = json.scale;

  			if ( json.morphTargets !== undefined ) {

  				for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {

  					geometry.morphTargets[ i ] = {};
  					geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
  					geometry.morphTargets[ i ].vertices = [];

  					var dstVertices = geometry.morphTargets[ i ].vertices;
  					var srcVertices = json.morphTargets[ i ].vertices;

  					for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

  						var vertex = new Vector3$2();
  						vertex.x = srcVertices[ v ] * scale;
  						vertex.y = srcVertices[ v + 1 ] * scale;
  						vertex.z = srcVertices[ v + 2 ] * scale;

  						dstVertices.push( vertex );

  					}

  				}

  			}

  			if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {

  				console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );

  				var faces = geometry.faces;
  				var morphColors = json.morphColors[ 0 ].colors;

  				for ( var i = 0, l = faces.length; i < l; i ++ ) {

  					faces[ i ].color.fromArray( morphColors, i * 3 );

  				}

  			}

  		}

  		function parseAnimations( json, geometry ) {

  			var outputAnimations = [];

  			// parse old style Bone/Hierarchy animations
  			var animations = [];

  			if ( json.animation !== undefined ) {

  				animations.push( json.animation );

  			}

  			if ( json.animations !== undefined ) {

  				if ( json.animations.length ) {

  					animations = animations.concat( json.animations );

  				} else {

  					animations.push( json.animations );

  				}

  			}

  			for ( var i = 0; i < animations.length; i ++ ) {

  				var clip = AnimationClip$1.parseAnimation( animations[ i ], geometry.bones );
  				if ( clip ) { outputAnimations.push( clip ); }

  			}

  			// parse implicit morph animations
  			if ( geometry.morphTargets ) {

  				// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
  				var morphAnimationClips = AnimationClip$1.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
  				outputAnimations = outputAnimations.concat( morphAnimationClips );

  			}

  			if ( outputAnimations.length > 0 ) { geometry.animations = outputAnimations; }

  		}

  		return function ( json, texturePath ) {

  			if ( json.data !== undefined ) {

  				// Geometry 4.0 spec
  				json = json.data;

  			}

  			if ( json.scale !== undefined ) {

  				json.scale = 1.0 / json.scale;

  			} else {

  				json.scale = 1.0;

  			}

  			var geometry = new Geometry$1();

  			parseModel( json, geometry );
  			parseSkin( json, geometry );
  			parseMorphing( json, geometry );
  			parseAnimations( json, geometry );

  			geometry.computeFaceNormals();
  			geometry.computeBoundingSphere();

  			if ( json.materials === undefined || json.materials.length === 0 ) {

  				return { geometry: geometry };

  			} else {

  				var materials = Loader$1.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

  				return { geometry: geometry, materials: materials };

  			}

  		};

  	} )()

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function ObjectLoader$1( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager$1;
  	this.texturePath = '';

  }

  Object.assign( ObjectLoader$1.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {

  		if ( this.texturePath === '' ) {

  			this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

  		}

  		var scope = this;

  		var loader = new FileLoader$1( scope.manager );
  		loader.load( url, function ( text ) {

  			var json = null;

  			try {

  				json = JSON.parse( text );

  			} catch ( error ) {

  				if ( onError !== undefined ) { onError( error ); }

  				console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );

  				return;

  			}

  			var metadata = json.metadata;

  			if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

  				console.error( 'THREE.ObjectLoader: Can\'t load ' + url + '. Use THREE.JSONLoader instead.' );
  				return;

  			}

  			scope.parse( json, onLoad );

  		}, onProgress, onError );

  	},

  	setTexturePath: function ( value ) {

  		this.texturePath = value;

  	},

  	setCrossOrigin: function ( value ) {

  		this.crossOrigin = value;

  	},

  	parse: function ( json, onLoad ) {

  		var geometries = this.parseGeometries( json.geometries );

  		var images = this.parseImages( json.images, function () {

  			if ( onLoad !== undefined ) { onLoad( object ); }

  		} );

  		var textures = this.parseTextures( json.textures, images );
  		var materials = this.parseMaterials( json.materials, textures );

  		var object = this.parseObject( json.object, geometries, materials );

  		if ( json.animations ) {

  			object.animations = this.parseAnimations( json.animations );

  		}

  		if ( json.images === undefined || json.images.length === 0 ) {

  			if ( onLoad !== undefined ) { onLoad( object ); }

  		}

  		return object;

  	},

  	parseGeometries: function ( json ) {
  		var this$1 = this;


  		var geometries = {};

  		if ( json !== undefined ) {

  			var geometryLoader = new JSONLoader$1();
  			var bufferGeometryLoader = new BufferGeometryLoader$1();

  			for ( var i = 0, l = json.length; i < l; i ++ ) {

  				var geometry;
  				var data = json[ i ];

  				switch ( data.type ) {

  					case 'PlaneGeometry':
  					case 'PlaneBufferGeometry':

  						geometry = new Geometries$1[ data.type ](
  							data.width,
  							data.height,
  							data.widthSegments,
  							data.heightSegments
  						);

  						break;

  					case 'BoxGeometry':
  					case 'BoxBufferGeometry':
  					case 'CubeGeometry': // backwards compatible

  						geometry = new Geometries$1[ data.type ](
  							data.width,
  							data.height,
  							data.depth,
  							data.widthSegments,
  							data.heightSegments,
  							data.depthSegments
  						);

  						break;

  					case 'CircleGeometry':
  					case 'CircleBufferGeometry':

  						geometry = new Geometries$1[ data.type ](
  							data.radius,
  							data.segments,
  							data.thetaStart,
  							data.thetaLength
  						);

  						break;

  					case 'CylinderGeometry':
  					case 'CylinderBufferGeometry':

  						geometry = new Geometries$1[ data.type ](
  							data.radiusTop,
  							data.radiusBottom,
  							data.height,
  							data.radialSegments,
  							data.heightSegments,
  							data.openEnded,
  							data.thetaStart,
  							data.thetaLength
  						);

  						break;

  					case 'ConeGeometry':
  					case 'ConeBufferGeometry':

  						geometry = new Geometries$1[ data.type ](
  							data.radius,
  							data.height,
  							data.radialSegments,
  							data.heightSegments,
  							data.openEnded,
  							data.thetaStart,
  							data.thetaLength
  						);

  						break;

  					case 'SphereGeometry':
  					case 'SphereBufferGeometry':

  						geometry = new Geometries$1[ data.type ](
  							data.radius,
  							data.widthSegments,
  							data.heightSegments,
  							data.phiStart,
  							data.phiLength,
  							data.thetaStart,
  							data.thetaLength
  						);

  						break;

  					case 'DodecahedronGeometry':
  					case 'IcosahedronGeometry':
  					case 'OctahedronGeometry':
  					case 'TetrahedronGeometry':

  						geometry = new Geometries$1[ data.type ](
  							data.radius,
  							data.detail
  						);

  						break;

  					case 'RingGeometry':
  					case 'RingBufferGeometry':

  						geometry = new Geometries$1[ data.type ](
  							data.innerRadius,
  							data.outerRadius,
  							data.thetaSegments,
  							data.phiSegments,
  							data.thetaStart,
  							data.thetaLength
  						);

  						break;

  					case 'TorusGeometry':
  					case 'TorusBufferGeometry':

  						geometry = new Geometries$1[ data.type ](
  							data.radius,
  							data.tube,
  							data.radialSegments,
  							data.tubularSegments,
  							data.arc
  						);

  						break;

  					case 'TorusKnotGeometry':
  					case 'TorusKnotBufferGeometry':

  						geometry = new Geometries$1[ data.type ](
  							data.radius,
  							data.tube,
  							data.tubularSegments,
  							data.radialSegments,
  							data.p,
  							data.q
  						);

  						break;

  					case 'LatheGeometry':
  					case 'LatheBufferGeometry':

  						geometry = new Geometries$1[ data.type ](
  							data.points,
  							data.segments,
  							data.phiStart,
  							data.phiLength
  						);

  						break;

  					case 'BufferGeometry':

  						geometry = bufferGeometryLoader.parse( data );

  						break;

  					case 'Geometry':

  						geometry = geometryLoader.parse( data, this$1.texturePath ).geometry;

  						break;

  					default:

  						console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

  						continue;

  				}

  				geometry.uuid = data.uuid;

  				if ( data.name !== undefined ) { geometry.name = data.name; }

  				geometries[ data.uuid ] = geometry;

  			}

  		}

  		return geometries;

  	},

  	parseMaterials: function ( json, textures ) {

  		var materials = {};

  		if ( json !== undefined ) {

  			var loader = new MaterialLoader$1();
  			loader.setTextures( textures );

  			for ( var i = 0, l = json.length; i < l; i ++ ) {

  				var data = json[ i ];

  				if ( data.type === 'MultiMaterial' ) {

  					// Deprecated

  					var array = [];

  					for ( var j = 0; j < data.materials.length; j ++ ) {

  						array.push( loader.parse( data.materials[ j ] ) );

  					}

  					materials[ data.uuid ] = array;

  				} else {

  					materials[ data.uuid ] = loader.parse( data );

  				}

  			}

  		}

  		return materials;

  	},

  	parseAnimations: function ( json ) {

  		var animations = [];

  		for ( var i = 0; i < json.length; i ++ ) {

  			var clip = AnimationClip$1.parse( json[ i ] );

  			animations.push( clip );

  		}

  		return animations;

  	},

  	parseImages: function ( json, onLoad ) {

  		var scope = this;
  		var images = {};

  		function loadImage( url ) {

  			scope.manager.itemStart( url );

  			return loader.load( url, function () {

  				scope.manager.itemEnd( url );

  			}, undefined, function () {

  				scope.manager.itemEnd( url );
  				scope.manager.itemError( url );

  			} );

  		}

  		if ( json !== undefined && json.length > 0 ) {

  			var manager = new LoadingManager$1( onLoad );

  			var loader = new ImageLoader$1( manager );
  			loader.setCrossOrigin( this.crossOrigin );

  			for ( var i = 0, l = json.length; i < l; i ++ ) {

  				var image = json[ i ];
  				var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

  				images[ image.uuid ] = loadImage( path );

  			}

  		}

  		return images;

  	},

  	parseTextures: function ( json, images ) {

  		function parseConstant( value, type ) {

  			if ( typeof value === 'number' ) { return value; }

  			console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

  			return type[ value ];

  		}

  		var textures = {};

  		if ( json !== undefined ) {

  			for ( var i = 0, l = json.length; i < l; i ++ ) {

  				var data = json[ i ];

  				if ( data.image === undefined ) {

  					console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

  				}

  				if ( images[ data.image ] === undefined ) {

  					console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

  				}

  				var texture = new Texture$1( images[ data.image ] );
  				texture.needsUpdate = true;

  				texture.uuid = data.uuid;

  				if ( data.name !== undefined ) { texture.name = data.name; }

  				if ( data.mapping !== undefined ) { texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING$1 ); }

  				if ( data.offset !== undefined ) { texture.offset.fromArray( data.offset ); }
  				if ( data.repeat !== undefined ) { texture.repeat.fromArray( data.repeat ); }
  				if ( data.center !== undefined ) { texture.center.fromArray( data.center ); }
  				if ( data.rotation !== undefined ) { texture.rotation = data.rotation; }

  				if ( data.wrap !== undefined ) {

  					texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING$1 );
  					texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING$1 );

  				}

  				if ( data.minFilter !== undefined ) { texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER$1 ); }
  				if ( data.magFilter !== undefined ) { texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER$1 ); }
  				if ( data.anisotropy !== undefined ) { texture.anisotropy = data.anisotropy; }

  				if ( data.flipY !== undefined ) { texture.flipY = data.flipY; }

  				textures[ data.uuid ] = texture;

  			}

  		}

  		return textures;

  	},

  	parseObject: function () {

  		var matrix = new Matrix4$1();

  		return function parseObject( data, geometries, materials ) {
  			var this$1 = this;


  			var object;

  			function getGeometry( name ) {

  				if ( geometries[ name ] === undefined ) {

  					console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

  				}

  				return geometries[ name ];

  			}

  			function getMaterial( name ) {

  				if ( name === undefined ) { return undefined; }

  				if ( Array.isArray( name ) ) {

  					var array = [];

  					for ( var i = 0, l = name.length; i < l; i ++ ) {

  						var uuid = name[ i ];

  						if ( materials[ uuid ] === undefined ) {

  							console.warn( 'THREE.ObjectLoader: Undefined material', uuid );

  						}

  						array.push( materials[ uuid ] );

  					}

  					return array;

  				}

  				if ( materials[ name ] === undefined ) {

  					console.warn( 'THREE.ObjectLoader: Undefined material', name );

  				}

  				return materials[ name ];

  			}

  			switch ( data.type ) {

  				case 'Scene':

  					object = new Scene$1();

  					if ( data.background !== undefined ) {

  						if ( Number.isInteger( data.background ) ) {

  							object.background = new Color$1( data.background );

  						}

  					}

  					if ( data.fog !== undefined ) {

  						if ( data.fog.type === 'Fog' ) {

  							object.fog = new Fog$1( data.fog.color, data.fog.near, data.fog.far );

  						} else if ( data.fog.type === 'FogExp2' ) {

  							object.fog = new FogExp2$1( data.fog.color, data.fog.density );

  						}

  					}

  					break;

  				case 'PerspectiveCamera':

  					object = new PerspectiveCamera$1( data.fov, data.aspect, data.near, data.far );

  					if ( data.focus !== undefined ) { object.focus = data.focus; }
  					if ( data.zoom !== undefined ) { object.zoom = data.zoom; }
  					if ( data.filmGauge !== undefined ) { object.filmGauge = data.filmGauge; }
  					if ( data.filmOffset !== undefined ) { object.filmOffset = data.filmOffset; }
  					if ( data.view !== undefined ) { object.view = Object.assign( {}, data.view ); }

  					break;

  				case 'OrthographicCamera':

  					object = new OrthographicCamera$1( data.left, data.right, data.top, data.bottom, data.near, data.far );

  					break;

  				case 'AmbientLight':

  					object = new AmbientLight$1( data.color, data.intensity );

  					break;

  				case 'DirectionalLight':

  					object = new DirectionalLight$1( data.color, data.intensity );

  					break;

  				case 'PointLight':

  					object = new PointLight$1( data.color, data.intensity, data.distance, data.decay );

  					break;

  				case 'RectAreaLight':

  					object = new RectAreaLight$1( data.color, data.intensity, data.width, data.height );

  					break;

  				case 'SpotLight':

  					object = new SpotLight$1( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

  					break;

  				case 'HemisphereLight':

  					object = new HemisphereLight$1( data.color, data.groundColor, data.intensity );

  					break;

  				case 'SkinnedMesh':

  					console.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' );

  				case 'Mesh':

  					var geometry = getGeometry( data.geometry );
  					var material = getMaterial( data.material );

  					if ( geometry.bones && geometry.bones.length > 0 ) {

  						object = new SkinnedMesh$1( geometry, material );

  					} else {

  						object = new Mesh$1( geometry, material );

  					}

  					break;

  				case 'LOD':

  					object = new LOD$1();

  					break;

  				case 'Line':

  					object = new Line$1( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

  					break;

  				case 'LineLoop':

  					object = new LineLoop$1( getGeometry( data.geometry ), getMaterial( data.material ) );

  					break;

  				case 'LineSegments':

  					object = new LineSegments$1( getGeometry( data.geometry ), getMaterial( data.material ) );

  					break;

  				case 'PointCloud':
  				case 'Points':

  					object = new Points$1( getGeometry( data.geometry ), getMaterial( data.material ) );

  					break;

  				case 'Sprite':

  					object = new Sprite$1( getMaterial( data.material ) );

  					break;

  				case 'Group':

  					object = new Group$1();

  					break;

  				default:

  					object = new Object3D$1();

  			}

  			object.uuid = data.uuid;

  			if ( data.name !== undefined ) { object.name = data.name; }
  			if ( data.matrix !== undefined ) {

  				matrix.fromArray( data.matrix );
  				matrix.decompose( object.position, object.quaternion, object.scale );

  			} else {

  				if ( data.position !== undefined ) { object.position.fromArray( data.position ); }
  				if ( data.rotation !== undefined ) { object.rotation.fromArray( data.rotation ); }
  				if ( data.quaternion !== undefined ) { object.quaternion.fromArray( data.quaternion ); }
  				if ( data.scale !== undefined ) { object.scale.fromArray( data.scale ); }

  			}

  			if ( data.castShadow !== undefined ) { object.castShadow = data.castShadow; }
  			if ( data.receiveShadow !== undefined ) { object.receiveShadow = data.receiveShadow; }

  			if ( data.shadow ) {

  				if ( data.shadow.bias !== undefined ) { object.shadow.bias = data.shadow.bias; }
  				if ( data.shadow.radius !== undefined ) { object.shadow.radius = data.shadow.radius; }
  				if ( data.shadow.mapSize !== undefined ) { object.shadow.mapSize.fromArray( data.shadow.mapSize ); }
  				if ( data.shadow.camera !== undefined ) { object.shadow.camera = this.parseObject( data.shadow.camera ); }

  			}

  			if ( data.visible !== undefined ) { object.visible = data.visible; }
  			if ( data.userData !== undefined ) { object.userData = data.userData; }

  			if ( data.children !== undefined ) {

  				var children = data.children;

  				for ( var i = 0; i < children.length; i ++ ) {

  					object.add( this$1.parseObject( children[ i ], geometries, materials ) );

  				}

  			}

  			if ( data.type === 'LOD' ) {

  				var levels = data.levels;

  				for ( var l = 0; l < levels.length; l ++ ) {

  					var level = levels[ l ];
  					var child = object.getObjectByProperty( 'uuid', level.object );

  					if ( child !== undefined ) {

  						object.addLevel( child, level.distance );

  					}

  				}

  			}

  			return object;

  		};

  	}()

  } );

  var TEXTURE_MAPPING$1 = {
  	UVMapping: UVMapping$1,
  	CubeReflectionMapping: CubeReflectionMapping$1,
  	CubeRefractionMapping: CubeRefractionMapping$1,
  	EquirectangularReflectionMapping: EquirectangularReflectionMapping$1,
  	EquirectangularRefractionMapping: EquirectangularRefractionMapping$1,
  	SphericalReflectionMapping: SphericalReflectionMapping$1,
  	CubeUVReflectionMapping: CubeUVReflectionMapping$1,
  	CubeUVRefractionMapping: CubeUVRefractionMapping$1
  };

  var TEXTURE_WRAPPING$1 = {
  	RepeatWrapping: RepeatWrapping$1,
  	ClampToEdgeWrapping: ClampToEdgeWrapping$1,
  	MirroredRepeatWrapping: MirroredRepeatWrapping$1
  };

  var TEXTURE_FILTER$1 = {
  	NearestFilter: NearestFilter$1,
  	NearestMipMapNearestFilter: NearestMipMapNearestFilter$1,
  	NearestMipMapLinearFilter: NearestMipMapLinearFilter$1,
  	LinearFilter: LinearFilter$1,
  	LinearMipMapNearestFilter: LinearMipMapNearestFilter$1,
  	LinearMipMapLinearFilter: LinearMipMapLinearFilter$1
  };

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   *
   * Bezier Curves formulas obtained from
   * http://en.wikipedia.org/wiki/Bzier_curve
   */

  function CatmullRom( t, p0, p1, p2, p3 ) {

  	var v0 = ( p2 - p0 ) * 0.5;
  	var v1 = ( p3 - p1 ) * 0.5;
  	var t2 = t * t;
  	var t3 = t * t2;
  	return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

  }

  //

  function QuadraticBezierP0( t, p ) {

  	var k = 1 - t;
  	return k * k * p;

  }

  function QuadraticBezierP1( t, p ) {

  	return 2 * ( 1 - t ) * t * p;

  }

  function QuadraticBezierP2( t, p ) {

  	return t * t * p;

  }

  function QuadraticBezier( t, p0, p1, p2 ) {

  	return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
  		QuadraticBezierP2( t, p2 );

  }

  //

  function CubicBezierP0( t, p ) {

  	var k = 1 - t;
  	return k * k * k * p;

  }

  function CubicBezierP1( t, p ) {

  	var k = 1 - t;
  	return 3 * k * k * t * p;

  }

  function CubicBezierP2( t, p ) {

  	return 3 * ( 1 - t ) * t * t * p;

  }

  function CubicBezierP3( t, p ) {

  	return t * t * t * p;

  }

  function CubicBezier( t, p0, p1, p2, p3 ) {

  	return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
  		CubicBezierP3( t, p3 );

  }

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * Extensible curve object
   *
   * Some common of curve methods:
   * .getPoint(t), getTangent(t)
   * .getPointAt(u), getTangentAt(u)
   * .getPoints(), .getSpacedPoints()
   * .getLength()
   * .updateArcLengths()
   *
   * This following curves inherit from THREE.Curve:
   *
   * -- 2D curves --
   * THREE.ArcCurve
   * THREE.CubicBezierCurve
   * THREE.EllipseCurve
   * THREE.LineCurve
   * THREE.QuadraticBezierCurve
   * THREE.SplineCurve
   *
   * -- 3D curves --
   * THREE.CatmullRomCurve3
   * THREE.CubicBezierCurve3
   * THREE.LineCurve3
   * THREE.QuadraticBezierCurve3
   *
   * A series of curves can be represented as a THREE.CurvePath.
   *
   **/

  /**************************************************************
   *	Abstract Curve base class
   **************************************************************/

  function Curve() {

  	this.arcLengthDivisions = 200;

  }

  Object.assign( Curve.prototype, {

  	// Virtual base class method to overwrite and implement in subclasses
  	//	- t [0 .. 1]

  	getPoint: function () {

  		console.warn( 'THREE.Curve: .getPoint() not implemented.' );
  		return null;

  	},

  	// Get point at relative position in curve according to arc length
  	// - u [0 .. 1]

  	getPointAt: function ( u ) {

  		var t = this.getUtoTmapping( u );
  		return this.getPoint( t );

  	},

  	// Get sequence of points using getPoint( t )

  	getPoints: function ( divisions ) {
  		var this$1 = this;


  		if ( divisions === undefined ) { divisions = 5; }

  		var points = [];

  		for ( var d = 0; d <= divisions; d ++ ) {

  			points.push( this$1.getPoint( d / divisions ) );

  		}

  		return points;

  	},

  	// Get sequence of points using getPointAt( u )

  	getSpacedPoints: function ( divisions ) {
  		var this$1 = this;


  		if ( divisions === undefined ) { divisions = 5; }

  		var points = [];

  		for ( var d = 0; d <= divisions; d ++ ) {

  			points.push( this$1.getPointAt( d / divisions ) );

  		}

  		return points;

  	},

  	// Get total curve arc length

  	getLength: function () {

  		var lengths = this.getLengths();
  		return lengths[ lengths.length - 1 ];

  	},

  	// Get list of cumulative segment lengths

  	getLengths: function ( divisions ) {
  		var this$1 = this;


  		if ( divisions === undefined ) { divisions = this.arcLengthDivisions; }

  		if ( this.cacheArcLengths &&
  			( this.cacheArcLengths.length === divisions + 1 ) &&
  			! this.needsUpdate ) {

  			return this.cacheArcLengths;

  		}

  		this.needsUpdate = false;

  		var cache = [];
  		var current, last = this.getPoint( 0 );
  		var p, sum = 0;

  		cache.push( 0 );

  		for ( p = 1; p <= divisions; p ++ ) {

  			current = this$1.getPoint( p / divisions );
  			sum += current.distanceTo( last );
  			cache.push( sum );
  			last = current;

  		}

  		this.cacheArcLengths = cache;

  		return cache; // { sums: cache, sum: sum }; Sum is in the last element.

  	},

  	updateArcLengths: function () {

  		this.needsUpdate = true;
  		this.getLengths();

  	},

  	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

  	getUtoTmapping: function ( u, distance ) {

  		var arcLengths = this.getLengths();

  		var i = 0, il = arcLengths.length;

  		var targetArcLength; // The targeted u distance value to get

  		if ( distance ) {

  			targetArcLength = distance;

  		} else {

  			targetArcLength = u * arcLengths[ il - 1 ];

  		}

  		// binary search for the index with largest value smaller than target u distance

  		var low = 0, high = il - 1, comparison;

  		while ( low <= high ) {

  			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

  			comparison = arcLengths[ i ] - targetArcLength;

  			if ( comparison < 0 ) {

  				low = i + 1;

  			} else if ( comparison > 0 ) {

  				high = i - 1;

  			} else {

  				high = i;
  				break;

  				// DONE

  			}

  		}

  		i = high;

  		if ( arcLengths[ i ] === targetArcLength ) {

  			return i / ( il - 1 );

  		}

  		// we could get finer grain at lengths, or use simple interpolation between two points

  		var lengthBefore = arcLengths[ i ];
  		var lengthAfter = arcLengths[ i + 1 ];

  		var segmentLength = lengthAfter - lengthBefore;

  		// determine where we are between the 'before' and 'after' points

  		var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

  		// add that fractional amount to t

  		var t = ( i + segmentFraction ) / ( il - 1 );

  		return t;

  	},

  	// Returns a unit vector tangent at t
  	// In case any sub curve does not implement its tangent derivation,
  	// 2 points a small delta apart will be used to find its gradient
  	// which seems to give a reasonable approximation

  	getTangent: function ( t ) {

  		var delta = 0.0001;
  		var t1 = t - delta;
  		var t2 = t + delta;

  		// Capping in case of danger

  		if ( t1 < 0 ) { t1 = 0; }
  		if ( t2 > 1 ) { t2 = 1; }

  		var pt1 = this.getPoint( t1 );
  		var pt2 = this.getPoint( t2 );

  		var vec = pt2.clone().sub( pt1 );
  		return vec.normalize();

  	},

  	getTangentAt: function ( u ) {

  		var t = this.getUtoTmapping( u );
  		return this.getTangent( t );

  	},

  	computeFrenetFrames: function ( segments, closed ) {
  		var this$1 = this;


  		// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

  		var normal = new Vector3$2();

  		var tangents = [];
  		var normals = [];
  		var binormals = [];

  		var vec = new Vector3$2();
  		var mat = new Matrix4$1();

  		var i, u, theta;

  		// compute the tangent vectors for each segment on the curve

  		for ( i = 0; i <= segments; i ++ ) {

  			u = i / segments;

  			tangents[ i ] = this$1.getTangentAt( u );
  			tangents[ i ].normalize();

  		}

  		// select an initial normal vector perpendicular to the first tangent vector,
  		// and in the direction of the minimum tangent xyz component

  		normals[ 0 ] = new Vector3$2();
  		binormals[ 0 ] = new Vector3$2();
  		var min = Number.MAX_VALUE;
  		var tx = Math.abs( tangents[ 0 ].x );
  		var ty = Math.abs( tangents[ 0 ].y );
  		var tz = Math.abs( tangents[ 0 ].z );

  		if ( tx <= min ) {

  			min = tx;
  			normal.set( 1, 0, 0 );

  		}

  		if ( ty <= min ) {

  			min = ty;
  			normal.set( 0, 1, 0 );

  		}

  		if ( tz <= min ) {

  			normal.set( 0, 0, 1 );

  		}

  		vec.crossVectors( tangents[ 0 ], normal ).normalize();

  		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
  		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


  		// compute the slowly-varying normal and binormal vectors for each segment on the curve

  		for ( i = 1; i <= segments; i ++ ) {

  			normals[ i ] = normals[ i - 1 ].clone();

  			binormals[ i ] = binormals[ i - 1 ].clone();

  			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

  			if ( vec.length() > Number.EPSILON ) {

  				vec.normalize();

  				theta = Math.acos( _Math$1.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

  				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

  			}

  			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

  		}

  		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

  		if ( closed === true ) {

  			theta = Math.acos( _Math$1.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
  			theta /= segments;

  			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

  				theta = - theta;

  			}

  			for ( i = 1; i <= segments; i ++ ) {

  				// twist a little...
  				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
  				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

  			}

  		}

  		return {
  			tangents: tangents,
  			normals: normals,
  			binormals: binormals
  		};

  	}

  } );

  function LineCurve( v1, v2 ) {

  	Curve.call( this );

  	this.v1 = v1;
  	this.v2 = v2;

  }

  LineCurve.prototype = Object.create( Curve.prototype );
  LineCurve.prototype.constructor = LineCurve;

  LineCurve.prototype.isLineCurve = true;

  LineCurve.prototype.getPoint = function ( t ) {

  	if ( t === 1 ) {

  		return this.v2.clone();

  	}

  	var point = this.v2.clone().sub( this.v1 );
  	point.multiplyScalar( t ).add( this.v1 );

  	return point;

  };

  // Line curve is linear, so we can overwrite default getPointAt

  LineCurve.prototype.getPointAt = function ( u ) {

  	return this.getPoint( u );

  };

  LineCurve.prototype.getTangent = function ( /* t */ ) {

  	var tangent = this.v2.clone().sub( this.v1 );

  	return tangent.normalize();

  };

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   *
   **/

  /**************************************************************
   *	Curved Path - a curve path is simply a array of connected
   *  curves, but retains the api of a curve
   **************************************************************/

  function CurvePath() {

  	Curve.call( this );

  	this.curves = [];

  	this.autoClose = false; // Automatically closes the path

  }

  CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {

  	constructor: CurvePath,

  	add: function ( curve ) {

  		this.curves.push( curve );

  	},

  	closePath: function () {

  		// Add a line curve if start and end of lines are not connected
  		var startPoint = this.curves[ 0 ].getPoint( 0 );
  		var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

  		if ( ! startPoint.equals( endPoint ) ) {

  			this.curves.push( new LineCurve( endPoint, startPoint ) );

  		}

  	},

  	// To get accurate point with reference to
  	// entire path distance at time t,
  	// following has to be done:

  	// 1. Length of each sub path have to be known
  	// 2. Locate and identify type of curve
  	// 3. Get t for the curve
  	// 4. Return curve.getPointAt(t')

  	getPoint: function ( t ) {
  		var this$1 = this;


  		var d = t * this.getLength();
  		var curveLengths = this.getCurveLengths();
  		var i = 0;

  		// To think about boundaries points.

  		while ( i < curveLengths.length ) {

  			if ( curveLengths[ i ] >= d ) {

  				var diff = curveLengths[ i ] - d;
  				var curve = this$1.curves[ i ];

  				var segmentLength = curve.getLength();
  				var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

  				return curve.getPointAt( u );

  			}

  			i ++;

  		}

  		return null;

  		// loop where sum != 0, sum > d , sum+1 <d

  	},

  	// We cannot use the default THREE.Curve getPoint() with getLength() because in
  	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  	// getPoint() depends on getLength

  	getLength: function () {

  		var lens = this.getCurveLengths();
  		return lens[ lens.length - 1 ];

  	},

  	// cacheLengths must be recalculated.
  	updateArcLengths: function () {

  		this.needsUpdate = true;
  		this.cacheLengths = null;
  		this.getCurveLengths();

  	},

  	// Compute lengths and cache them
  	// We cannot overwrite getLengths() because UtoT mapping uses it.

  	getCurveLengths: function () {
  		var this$1 = this;


  		// We use cache values if curves and cache array are same length

  		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

  			return this.cacheLengths;

  		}

  		// Get length of sub-curve
  		// Push sums into cached array

  		var lengths = [], sums = 0;

  		for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

  			sums += this$1.curves[ i ].getLength();
  			lengths.push( sums );

  		}

  		this.cacheLengths = lengths;

  		return lengths;

  	},

  	getSpacedPoints: function ( divisions ) {
  		var this$1 = this;


  		if ( divisions === undefined ) { divisions = 40; }

  		var points = [];

  		for ( var i = 0; i <= divisions; i ++ ) {

  			points.push( this$1.getPoint( i / divisions ) );

  		}

  		if ( this.autoClose ) {

  			points.push( points[ 0 ] );

  		}

  		return points;

  	},

  	getPoints: function ( divisions ) {

  		divisions = divisions || 12;

  		var points = [], last;

  		for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {

  			var curve = curves[ i ];
  			var resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2
  				: ( curve && curve.isLineCurve ) ? 1
  					: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length
  						: divisions;

  			var pts = curve.getPoints( resolution );

  			for ( var j = 0; j < pts.length; j ++ ) {

  				var point = pts[ j ];

  				if ( last && last.equals( point ) ) { continue; } // ensures no consecutive points are duplicates

  				points.push( point );
  				last = point;

  			}

  		}

  		if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

  			points.push( points[ 0 ] );

  		}

  		return points;

  	},

  	/**************************************************************
  	 *	Create Geometries Helpers
  	 **************************************************************/

  	/// Generate geometry from path points (for Line or Points objects)

  	createPointsGeometry: function ( divisions ) {

  		var pts = this.getPoints( divisions );
  		return this.createGeometry( pts );

  	},

  	// Generate geometry from equidistant sampling along the path

  	createSpacedPointsGeometry: function ( divisions ) {

  		var pts = this.getSpacedPoints( divisions );
  		return this.createGeometry( pts );

  	},

  	createGeometry: function ( points ) {

  		var geometry = new Geometry$1();

  		for ( var i = 0, l = points.length; i < l; i ++ ) {

  			var point = points[ i ];
  			geometry.vertices.push( new Vector3$2( point.x, point.y, point.z || 0 ) );

  		}

  		return geometry;

  	}

  } );

  function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

  	Curve.call( this );

  	this.aX = aX;
  	this.aY = aY;

  	this.xRadius = xRadius;
  	this.yRadius = yRadius;

  	this.aStartAngle = aStartAngle;
  	this.aEndAngle = aEndAngle;

  	this.aClockwise = aClockwise;

  	this.aRotation = aRotation || 0;

  }

  EllipseCurve.prototype = Object.create( Curve.prototype );
  EllipseCurve.prototype.constructor = EllipseCurve;

  EllipseCurve.prototype.isEllipseCurve = true;

  EllipseCurve.prototype.getPoint = function ( t ) {

  	var twoPi = Math.PI * 2;
  	var deltaAngle = this.aEndAngle - this.aStartAngle;
  	var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

  	// ensures that deltaAngle is 0 .. 2 PI
  	while ( deltaAngle < 0 ) { deltaAngle += twoPi; }
  	while ( deltaAngle > twoPi ) { deltaAngle -= twoPi; }

  	if ( deltaAngle < Number.EPSILON ) {

  		if ( samePoints ) {

  			deltaAngle = 0;

  		} else {

  			deltaAngle = twoPi;

  		}

  	}

  	if ( this.aClockwise === true && ! samePoints ) {

  		if ( deltaAngle === twoPi ) {

  			deltaAngle = - twoPi;

  		} else {

  			deltaAngle = deltaAngle - twoPi;

  		}

  	}

  	var angle = this.aStartAngle + t * deltaAngle;
  	var x = this.aX + this.xRadius * Math.cos( angle );
  	var y = this.aY + this.yRadius * Math.sin( angle );

  	if ( this.aRotation !== 0 ) {

  		var cos = Math.cos( this.aRotation );
  		var sin = Math.sin( this.aRotation );

  		var tx = x - this.aX;
  		var ty = y - this.aY;

  		// Rotate the point about the center of the ellipse.
  		x = tx * cos - ty * sin + this.aX;
  		y = tx * sin + ty * cos + this.aY;

  	}

  	return new Vector2$1( x, y );

  };

  function SplineCurve( points /* array of Vector2 */ ) {

  	Curve.call( this );

  	this.points = ( points === undefined ) ? [] : points;

  }

  SplineCurve.prototype = Object.create( Curve.prototype );
  SplineCurve.prototype.constructor = SplineCurve;

  SplineCurve.prototype.isSplineCurve = true;

  SplineCurve.prototype.getPoint = function ( t ) {

  	var points = this.points;
  	var point = ( points.length - 1 ) * t;

  	var intPoint = Math.floor( point );
  	var weight = point - intPoint;

  	var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
  	var point1 = points[ intPoint ];
  	var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
  	var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

  	return new Vector2$1(
  		CatmullRom( weight, point0.x, point1.x, point2.x, point3.x ),
  		CatmullRom( weight, point0.y, point1.y, point2.y, point3.y )
  	);

  };

  function CubicBezierCurve( v0, v1, v2, v3 ) {

  	Curve.call( this );

  	this.v0 = v0;
  	this.v1 = v1;
  	this.v2 = v2;
  	this.v3 = v3;

  }

  CubicBezierCurve.prototype = Object.create( Curve.prototype );
  CubicBezierCurve.prototype.constructor = CubicBezierCurve;

  CubicBezierCurve.prototype.getPoint = function ( t ) {

  	var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

  	return new Vector2$1(
  		CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
  		CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
  	);

  };

  function QuadraticBezierCurve( v0, v1, v2 ) {

  	Curve.call( this );

  	this.v0 = v0;
  	this.v1 = v1;
  	this.v2 = v2;

  }

  QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
  QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;

  QuadraticBezierCurve.prototype.getPoint = function ( t ) {

  	var v0 = this.v0, v1 = this.v1, v2 = this.v2;

  	return new Vector2$1(
  		QuadraticBezier( t, v0.x, v1.x, v2.x ),
  		QuadraticBezier( t, v0.y, v1.y, v2.y )
  	);

  };

  var PathPrototype = Object.assign( Object.create( CurvePath.prototype ), {

  	fromPoints: function ( vectors ) {
  		var this$1 = this;


  		this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

  		for ( var i = 1, l = vectors.length; i < l; i ++ ) {

  			this$1.lineTo( vectors[ i ].x, vectors[ i ].y );

  		}

  	},

  	moveTo: function ( x, y ) {

  		this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

  	},

  	lineTo: function ( x, y ) {

  		var curve = new LineCurve( this.currentPoint.clone(), new Vector2$1( x, y ) );
  		this.curves.push( curve );

  		this.currentPoint.set( x, y );

  	},

  	quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

  		var curve = new QuadraticBezierCurve(
  			this.currentPoint.clone(),
  			new Vector2$1( aCPx, aCPy ),
  			new Vector2$1( aX, aY )
  		);

  		this.curves.push( curve );

  		this.currentPoint.set( aX, aY );

  	},

  	bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

  		var curve = new CubicBezierCurve(
  			this.currentPoint.clone(),
  			new Vector2$1( aCP1x, aCP1y ),
  			new Vector2$1( aCP2x, aCP2y ),
  			new Vector2$1( aX, aY )
  		);

  		this.curves.push( curve );

  		this.currentPoint.set( aX, aY );

  	},

  	splineThru: function ( pts /*Array of Vector*/ ) {

  		var npts = [ this.currentPoint.clone() ].concat( pts );

  		var curve = new SplineCurve( npts );
  		this.curves.push( curve );

  		this.currentPoint.copy( pts[ pts.length - 1 ] );

  	},

  	arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

  		var x0 = this.currentPoint.x;
  		var y0 = this.currentPoint.y;

  		this.absarc( aX + x0, aY + y0, aRadius,
  			aStartAngle, aEndAngle, aClockwise );

  	},

  	absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

  		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

  	},

  	ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

  		var x0 = this.currentPoint.x;
  		var y0 = this.currentPoint.y;

  		this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

  	},

  	absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

  		var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

  		if ( this.curves.length > 0 ) {

  			// if a previous curve is present, attempt to join
  			var firstPoint = curve.getPoint( 0 );

  			if ( ! firstPoint.equals( this.currentPoint ) ) {

  				this.lineTo( firstPoint.x, firstPoint.y );

  			}

  		}

  		this.curves.push( curve );

  		var lastPoint = curve.getPoint( 1 );
  		this.currentPoint.copy( lastPoint );

  	}

  } );

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * Creates free form 2d path using series of points, lines or curves.
   **/

  function Path( points ) {

  	CurvePath.call( this );
  	this.currentPoint = new Vector2$1();

  	if ( points ) {

  		this.fromPoints( points );

  	}

  }

  Path.prototype = PathPrototype;
  PathPrototype.constructor = Path;

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * Defines a 2d shape plane using paths.
   **/

  // STEP 1 Create a path.
  // STEP 2 Turn path into shape.
  // STEP 3 ExtrudeGeometry takes in Shape/Shapes
  // STEP 3a - Extract points from each shape, turn to vertices
  // STEP 3b - Triangulate each shape, add faces.

  function Shape() {

  	Path.apply( this, arguments );

  	this.holes = [];

  }

  Shape.prototype = Object.assign( Object.create( PathPrototype ), {

  	constructor: Shape,

  	getPointsHoles: function ( divisions ) {
  		var this$1 = this;


  		var holesPts = [];

  		for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

  			holesPts[ i ] = this$1.holes[ i ].getPoints( divisions );

  		}

  		return holesPts;

  	},

  	// Get points of shape and holes (keypoints based on segments parameter)

  	extractAllPoints: function ( divisions ) {

  		return {

  			shape: this.getPoints( divisions ),
  			holes: this.getPointsHoles( divisions )

  		};

  	},

  	extractPoints: function ( divisions ) {

  		return this.extractAllPoints( divisions );

  	}

  } );

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
   **/

  function ShapePath() {

  	this.subPaths = [];
  	this.currentPath = null;

  }

  Object.assign( ShapePath.prototype, {

  	moveTo: function ( x, y ) {

  		this.currentPath = new Path();
  		this.subPaths.push( this.currentPath );
  		this.currentPath.moveTo( x, y );

  	},

  	lineTo: function ( x, y ) {

  		this.currentPath.lineTo( x, y );

  	},

  	quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

  		this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );

  	},

  	bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

  		this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );

  	},

  	splineThru: function ( pts ) {

  		this.currentPath.splineThru( pts );

  	},

  	toShapes: function ( isCCW, noHoles ) {

  		function toShapesNoHoles( inSubpaths ) {

  			var shapes = [];

  			for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

  				var tmpPath = inSubpaths[ i ];

  				var tmpShape = new Shape();
  				tmpShape.curves = tmpPath.curves;

  				shapes.push( tmpShape );

  			}

  			return shapes;

  		}

  		function isPointInsidePolygon( inPt, inPolygon ) {

  			var polyLen = inPolygon.length;

  			// inPt on polygon contour => immediate success    or
  			// toggling of inside/outside at every single! intersection point of an edge
  			//  with the horizontal line through inPt, left of inPt
  			//  not counting lowerY endpoints of edges and whole edges on that line
  			var inside = false;
  			for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

  				var edgeLowPt = inPolygon[ p ];
  				var edgeHighPt = inPolygon[ q ];

  				var edgeDx = edgeHighPt.x - edgeLowPt.x;
  				var edgeDy = edgeHighPt.y - edgeLowPt.y;

  				if ( Math.abs( edgeDy ) > Number.EPSILON ) {

  					// not parallel
  					if ( edgeDy < 0 ) {

  						edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;
  						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

  					}
  					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		{ continue; }

  					if ( inPt.y === edgeLowPt.y ) {

  						if ( inPt.x === edgeLowPt.x )		{ return	true; }		// inPt is on contour ?
  						// continue;				// no intersection or edgeLowPt => doesn't count !!!

  					} else {

  						var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
  						if ( perpEdge === 0 )				{ return	true; }		// inPt is on contour ?
  						if ( perpEdge < 0 ) 				{ continue; }
  						inside = ! inside;		// true intersection left of inPt

  					}

  				} else {

  					// parallel or collinear
  					if ( inPt.y !== edgeLowPt.y ) 		{ continue; }			// parallel
  					// edge lies on the same horizontal line as inPt
  					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
  						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		{ return	true; }	// inPt: Point on contour !
  					// continue;

  				}

  			}

  			return	inside;

  		}

  		var isClockWise = ShapeUtils$1.isClockWise;

  		var subPaths = this.subPaths;
  		if ( subPaths.length === 0 ) { return []; }

  		if ( noHoles === true )	{ return	toShapesNoHoles( subPaths ); }


  		var solid, tmpPath, tmpShape, shapes = [];

  		if ( subPaths.length === 1 ) {

  			tmpPath = subPaths[ 0 ];
  			tmpShape = new Shape();
  			tmpShape.curves = tmpPath.curves;
  			shapes.push( tmpShape );
  			return shapes;

  		}

  		var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
  		holesFirst = isCCW ? ! holesFirst : holesFirst;

  		// console.log("Holes first", holesFirst);

  		var betterShapeHoles = [];
  		var newShapes = [];
  		var newShapeHoles = [];
  		var mainIdx = 0;
  		var tmpPoints;

  		newShapes[ mainIdx ] = undefined;
  		newShapeHoles[ mainIdx ] = [];

  		for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

  			tmpPath = subPaths[ i ];
  			tmpPoints = tmpPath.getPoints();
  			solid = isClockWise( tmpPoints );
  			solid = isCCW ? ! solid : solid;

  			if ( solid ) {

  				if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	{ mainIdx ++; }

  				newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
  				newShapes[ mainIdx ].s.curves = tmpPath.curves;

  				if ( holesFirst )	{ mainIdx ++; }
  				newShapeHoles[ mainIdx ] = [];

  				//console.log('cw', i);

  			} else {

  				newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

  				//console.log('ccw', i);

  			}

  		}

  		// only Holes? -> probably all Shapes with wrong orientation
  		if ( ! newShapes[ 0 ] )	{ return	toShapesNoHoles( subPaths ); }


  		if ( newShapes.length > 1 ) {

  			var ambiguous = false;
  			var toChange = [];

  			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

  				betterShapeHoles[ sIdx ] = [];

  			}

  			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

  				var sho = newShapeHoles[ sIdx ];

  				for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

  					var ho = sho[ hIdx ];
  					var hole_unassigned = true;

  					for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

  						if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

  							if ( sIdx !== s2Idx )	{ toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } ); }
  							if ( hole_unassigned ) {

  								hole_unassigned = false;
  								betterShapeHoles[ s2Idx ].push( ho );

  							} else {

  								ambiguous = true;

  							}

  						}

  					}
  					if ( hole_unassigned ) {

  						betterShapeHoles[ sIdx ].push( ho );

  					}

  				}

  			}
  			// console.log("ambiguous: ", ambiguous);
  			if ( toChange.length > 0 ) {

  				// console.log("to change: ", toChange);
  				if ( ! ambiguous )	{ newShapeHoles = betterShapeHoles; }

  			}

  		}

  		var tmpHoles;

  		for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

  			tmpShape = newShapes[ i ].s;
  			shapes.push( tmpShape );
  			tmpHoles = newShapeHoles[ i ];

  			for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

  				tmpShape.holes.push( tmpHoles[ j ].h );

  			}

  		}

  		//console.log("shape", shapes);

  		return shapes;

  	}

  } );

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * @author mrdoob / http://mrdoob.com/
   */

  function Font( data ) {

  	this.data = data;

  }

  Object.assign( Font.prototype, {

  	isFont: true,

  	generateShapes: function ( text, size, divisions ) {

  		function createPaths( text ) {

  			var chars = String( text ).split( '' );
  			var scale = size / data.resolution;
  			var line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;

  			var offsetX = 0, offsetY = 0;

  			var paths = [];

  			for ( var i = 0; i < chars.length; i ++ ) {

  				var char = chars[ i ];

  				if ( char === '\n' ) {

  					offsetX = 0;
  					offsetY -= line_height;

  				} else {

  					var ret = createPath( char, scale, offsetX, offsetY );
  					offsetX += ret.offsetX;
  					paths.push( ret.path );

  				}

  			}

  			return paths;

  		}

  		function createPath( c, scale, offsetX, offsetY ) {

  			var glyph = data.glyphs[ c ] || data.glyphs[ '?' ];

  			if ( ! glyph ) { return; }

  			var path = new ShapePath();

  			var pts = [];
  			var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;

  			if ( glyph.o ) {

  				var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

  				for ( var i = 0, l = outline.length; i < l; ) {

  					var action = outline[ i ++ ];

  					switch ( action ) {

  						case 'm': // moveTo

  							x = outline[ i ++ ] * scale + offsetX;
  							y = outline[ i ++ ] * scale + offsetY;

  							path.moveTo( x, y );

  							break;

  						case 'l': // lineTo

  							x = outline[ i ++ ] * scale + offsetX;
  							y = outline[ i ++ ] * scale + offsetY;

  							path.lineTo( x, y );

  							break;

  						case 'q': // quadraticCurveTo

  							cpx = outline[ i ++ ] * scale + offsetX;
  							cpy = outline[ i ++ ] * scale + offsetY;
  							cpx1 = outline[ i ++ ] * scale + offsetX;
  							cpy1 = outline[ i ++ ] * scale + offsetY;

  							path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

  							laste = pts[ pts.length - 1 ];

  							if ( laste ) {

  								cpx0 = laste.x;
  								cpy0 = laste.y;

  								

  							}

  							break;

  						case 'b': // bezierCurveTo

  							cpx = outline[ i ++ ] * scale + offsetX;
  							cpy = outline[ i ++ ] * scale + offsetY;
  							cpx1 = outline[ i ++ ] * scale + offsetX;
  							cpy1 = outline[ i ++ ] * scale + offsetY;
  							cpx2 = outline[ i ++ ] * scale + offsetX;
  							cpy2 = outline[ i ++ ] * scale + offsetY;

  							path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

  							laste = pts[ pts.length - 1 ];

  							if ( laste ) {

  								cpx0 = laste.x;
  								cpy0 = laste.y;

  								

  							}

  							break;

  					}

  				}

  			}

  			return { offsetX: glyph.ha * scale, path: path };

  		}

  		//

  		if ( size === undefined ) { size = 100; }
  		if ( divisions === undefined ) { divisions = 4; }

  		var data = this.data;

  		var paths = createPaths( text );
  		var shapes = [];

  		for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

  			Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

  		}

  		return shapes;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function FontLoader( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager$1;

  }

  Object.assign( FontLoader.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var loader = new FileLoader$1( this.manager );
  		loader.setPath( this.path );
  		loader.load( url, function ( text ) {

  			var json;

  			try {

  				json = JSON.parse( text );

  			} catch ( e ) {

  				console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
  				json = JSON.parse( text.substring( 65, text.length - 2 ) );

  			}

  			var font = scope.parse( json );

  			if ( onLoad ) { onLoad( font ); }

  		}, onProgress, onError );

  	},

  	parse: function ( json ) {

  		return new Font( json );

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	}

  } );

  var context;

  var AudioContext = {

  	getContext: function () {

  		if ( context === undefined ) {

  			context = new ( window.AudioContext || window.webkitAudioContext )();

  		}

  		return context;

  	},

  	setContext: function ( value ) {

  		context = value;

  	}

  };

  /**
   * @author Reece Aaron Lecrivain / http://reecenotes.com/
   */

  function AudioLoader( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager$1;

  }

  Object.assign( AudioLoader.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {

  		var loader = new FileLoader$1( this.manager );
  		loader.setResponseType( 'arraybuffer' );
  		loader.load( url, function ( buffer ) {

  			var context = AudioContext.getContext();

  			context.decodeAudioData( buffer, function ( audioBuffer ) {

  				onLoad( audioBuffer );

  			} );

  		}, onProgress, onError );

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function StereoCamera() {

  	this.type = 'StereoCamera';

  	this.aspect = 1;

  	this.eyeSep = 0.064;

  	this.cameraL = new PerspectiveCamera$1();
  	this.cameraL.layers.enable( 1 );
  	this.cameraL.matrixAutoUpdate = false;

  	this.cameraR = new PerspectiveCamera$1();
  	this.cameraR.layers.enable( 2 );
  	this.cameraR.matrixAutoUpdate = false;

  }

  Object.assign( StereoCamera.prototype, {

  	update: ( function () {

  		var instance, focus, fov, aspect, near, far, zoom, eyeSep;

  		var eyeRight = new Matrix4$1();
  		var eyeLeft = new Matrix4$1();

  		return function update( camera ) {

  			var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
  												aspect !== camera.aspect * this.aspect || near !== camera.near ||
  												far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;

  			if ( needsUpdate ) {

  				instance = this;
  				focus = camera.focus;
  				fov = camera.fov;
  				aspect = camera.aspect * this.aspect;
  				near = camera.near;
  				far = camera.far;
  				zoom = camera.zoom;

  				// Off-axis stereoscopic effect based on
  				// http://paulbourke.net/stereographics/stereorender/

  				var projectionMatrix = camera.projectionMatrix.clone();
  				eyeSep = this.eyeSep / 2;
  				var eyeSepOnProjection = eyeSep * near / focus;
  				var ymax = ( near * Math.tan( _Math$1.DEG2RAD * fov * 0.5 ) ) / zoom;
  				var xmin, xmax;

  				// translate xOffset

  				eyeLeft.elements[ 12 ] = - eyeSep;
  				eyeRight.elements[ 12 ] = eyeSep;

  				// for left eye

  				xmin = - ymax * aspect + eyeSepOnProjection;
  				xmax = ymax * aspect + eyeSepOnProjection;

  				projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
  				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

  				this.cameraL.projectionMatrix.copy( projectionMatrix );

  				// for right eye

  				xmin = - ymax * aspect - eyeSepOnProjection;
  				xmax = ymax * aspect - eyeSepOnProjection;

  				projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
  				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

  				this.cameraR.projectionMatrix.copy( projectionMatrix );

  			}

  			this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
  			this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );

  		};

  	} )()

  } );

  /**
   * Camera for rendering cube maps
   *	- renders scene into axis-aligned cube
   *
   * @author alteredq / http://alteredqualia.com/
   */

  function CubeCamera( near, far, cubeResolution ) {

  	Object3D$1.call( this );

  	this.type = 'CubeCamera';

  	var fov = 90, aspect = 1;

  	var cameraPX = new PerspectiveCamera$1( fov, aspect, near, far );
  	cameraPX.up.set( 0, - 1, 0 );
  	cameraPX.lookAt( new Vector3$2( 1, 0, 0 ) );
  	this.add( cameraPX );

  	var cameraNX = new PerspectiveCamera$1( fov, aspect, near, far );
  	cameraNX.up.set( 0, - 1, 0 );
  	cameraNX.lookAt( new Vector3$2( - 1, 0, 0 ) );
  	this.add( cameraNX );

  	var cameraPY = new PerspectiveCamera$1( fov, aspect, near, far );
  	cameraPY.up.set( 0, 0, 1 );
  	cameraPY.lookAt( new Vector3$2( 0, 1, 0 ) );
  	this.add( cameraPY );

  	var cameraNY = new PerspectiveCamera$1( fov, aspect, near, far );
  	cameraNY.up.set( 0, 0, - 1 );
  	cameraNY.lookAt( new Vector3$2( 0, - 1, 0 ) );
  	this.add( cameraNY );

  	var cameraPZ = new PerspectiveCamera$1( fov, aspect, near, far );
  	cameraPZ.up.set( 0, - 1, 0 );
  	cameraPZ.lookAt( new Vector3$2( 0, 0, 1 ) );
  	this.add( cameraPZ );

  	var cameraNZ = new PerspectiveCamera$1( fov, aspect, near, far );
  	cameraNZ.up.set( 0, - 1, 0 );
  	cameraNZ.lookAt( new Vector3$2( 0, 0, - 1 ) );
  	this.add( cameraNZ );

  	var options = { format: RGBFormat$1, magFilter: LinearFilter$1, minFilter: LinearFilter$1 };

  	this.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );
  	this.renderTarget.texture.name = "CubeCamera";

  	this.update = function ( renderer, scene ) {

  		if ( this.parent === null ) { this.updateMatrixWorld(); }

  		var renderTarget = this.renderTarget;
  		var generateMipmaps = renderTarget.texture.generateMipmaps;

  		renderTarget.texture.generateMipmaps = false;

  		renderTarget.activeCubeFace = 0;
  		renderer.render( scene, cameraPX, renderTarget );

  		renderTarget.activeCubeFace = 1;
  		renderer.render( scene, cameraNX, renderTarget );

  		renderTarget.activeCubeFace = 2;
  		renderer.render( scene, cameraPY, renderTarget );

  		renderTarget.activeCubeFace = 3;
  		renderer.render( scene, cameraNY, renderTarget );

  		renderTarget.activeCubeFace = 4;
  		renderer.render( scene, cameraPZ, renderTarget );

  		renderTarget.texture.generateMipmaps = generateMipmaps;

  		renderTarget.activeCubeFace = 5;
  		renderer.render( scene, cameraNZ, renderTarget );

  		renderer.setRenderTarget( null );

  	};

  	this.clear = function ( renderer, color, depth, stencil ) {

  		var renderTarget = this.renderTarget;

  		for ( var i = 0; i < 6; i ++ ) {

  			renderTarget.activeCubeFace = i;
  			renderer.setRenderTarget( renderTarget );

  			renderer.clear( color, depth, stencil );

  		}

  		renderer.setRenderTarget( null );

  	};

  }

  CubeCamera.prototype = Object.create( Object3D$1.prototype );
  CubeCamera.prototype.constructor = CubeCamera;

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function AudioListener() {

  	Object3D$1.call( this );

  	this.type = 'AudioListener';

  	this.context = AudioContext.getContext();

  	this.gain = this.context.createGain();
  	this.gain.connect( this.context.destination );

  	this.filter = null;

  }

  AudioListener.prototype = Object.assign( Object.create( Object3D$1.prototype ), {

  	constructor: AudioListener,

  	getInput: function () {

  		return this.gain;

  	},

  	removeFilter: function ( ) {

  		if ( this.filter !== null ) {

  			this.gain.disconnect( this.filter );
  			this.filter.disconnect( this.context.destination );
  			this.gain.connect( this.context.destination );
  			this.filter = null;

  		}

  	},

  	getFilter: function () {

  		return this.filter;

  	},

  	setFilter: function ( value ) {

  		if ( this.filter !== null ) {

  			this.gain.disconnect( this.filter );
  			this.filter.disconnect( this.context.destination );

  		} else {

  			this.gain.disconnect( this.context.destination );

  		}

  		this.filter = value;
  		this.gain.connect( this.filter );
  		this.filter.connect( this.context.destination );

  	},

  	getMasterVolume: function () {

  		return this.gain.gain.value;

  	},

  	setMasterVolume: function ( value ) {

  		this.gain.gain.value = value;

  	},

  	updateMatrixWorld: ( function () {

  		var position = new Vector3$2();
  		var quaternion = new Quaternion$1();
  		var scale = new Vector3$2();

  		var orientation = new Vector3$2();

  		return function updateMatrixWorld( force ) {

  			Object3D$1.prototype.updateMatrixWorld.call( this, force );

  			var listener = this.context.listener;
  			var up = this.up;

  			this.matrixWorld.decompose( position, quaternion, scale );

  			orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

  			if ( listener.positionX ) {

  				listener.positionX.setValueAtTime( position.x, this.context.currentTime );
  				listener.positionY.setValueAtTime( position.y, this.context.currentTime );
  				listener.positionZ.setValueAtTime( position.z, this.context.currentTime );
  				listener.forwardX.setValueAtTime( orientation.x, this.context.currentTime );
  				listener.forwardY.setValueAtTime( orientation.y, this.context.currentTime );
  				listener.forwardZ.setValueAtTime( orientation.z, this.context.currentTime );
  				listener.upX.setValueAtTime( up.x, this.context.currentTime );
  				listener.upY.setValueAtTime( up.y, this.context.currentTime );
  				listener.upZ.setValueAtTime( up.z, this.context.currentTime );

  			} else {

  				listener.setPosition( position.x, position.y, position.z );
  				listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

  			}

  		};

  	} )()

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Reece Aaron Lecrivain / http://reecenotes.com/
   */

  function Audio( listener ) {

  	Object3D$1.call( this );

  	this.type = 'Audio';

  	this.context = listener.context;

  	this.gain = this.context.createGain();
  	this.gain.connect( listener.getInput() );

  	this.autoplay = false;

  	this.buffer = null;
  	this.loop = false;
  	this.startTime = 0;
  	this.playbackRate = 1;
  	this.isPlaying = false;
  	this.hasPlaybackControl = true;
  	this.sourceType = 'empty';

  	this.filters = [];

  }

  Audio.prototype = Object.assign( Object.create( Object3D$1.prototype ), {

  	constructor: Audio,

  	getOutput: function () {

  		return this.gain;

  	},

  	setNodeSource: function ( audioNode ) {

  		this.hasPlaybackControl = false;
  		this.sourceType = 'audioNode';
  		this.source = audioNode;
  		this.connect();

  		return this;

  	},

  	setBuffer: function ( audioBuffer ) {

  		this.buffer = audioBuffer;
  		this.sourceType = 'buffer';

  		if ( this.autoplay ) { this.play(); }

  		return this;

  	},

  	play: function () {

  		if ( this.isPlaying === true ) {

  			console.warn( 'THREE.Audio: Audio is already playing.' );
  			return;

  		}

  		if ( this.hasPlaybackControl === false ) {

  			console.warn( 'THREE.Audio: this Audio has no playback control.' );
  			return;

  		}

  		var source = this.context.createBufferSource();

  		source.buffer = this.buffer;
  		source.loop = this.loop;
  		source.onended = this.onEnded.bind( this );
  		source.playbackRate.setValueAtTime( this.playbackRate, this.startTime );
  		source.start( 0, this.startTime );

  		this.isPlaying = true;

  		this.source = source;

  		return this.connect();

  	},

  	pause: function () {

  		if ( this.hasPlaybackControl === false ) {

  			console.warn( 'THREE.Audio: this Audio has no playback control.' );
  			return;

  		}

  		this.source.stop();
  		this.startTime = this.context.currentTime;
  		this.isPlaying = false;

  		return this;

  	},

  	stop: function () {

  		if ( this.hasPlaybackControl === false ) {

  			console.warn( 'THREE.Audio: this Audio has no playback control.' );
  			return;

  		}

  		this.source.stop();
  		this.startTime = 0;
  		this.isPlaying = false;

  		return this;

  	},

  	connect: function () {
  		var this$1 = this;


  		if ( this.filters.length > 0 ) {

  			this.source.connect( this.filters[ 0 ] );

  			for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

  				this$1.filters[ i - 1 ].connect( this$1.filters[ i ] );

  			}

  			this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

  		} else {

  			this.source.connect( this.getOutput() );

  		}

  		return this;

  	},

  	disconnect: function () {
  		var this$1 = this;


  		if ( this.filters.length > 0 ) {

  			this.source.disconnect( this.filters[ 0 ] );

  			for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

  				this$1.filters[ i - 1 ].disconnect( this$1.filters[ i ] );

  			}

  			this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

  		} else {

  			this.source.disconnect( this.getOutput() );

  		}

  		return this;

  	},

  	getFilters: function () {

  		return this.filters;

  	},

  	setFilters: function ( value ) {

  		if ( ! value ) { value = []; }

  		if ( this.isPlaying === true ) {

  			this.disconnect();
  			this.filters = value;
  			this.connect();

  		} else {

  			this.filters = value;

  		}

  		return this;

  	},

  	getFilter: function () {

  		return this.getFilters()[ 0 ];

  	},

  	setFilter: function ( filter ) {

  		return this.setFilters( filter ? [ filter ] : [] );

  	},

  	setPlaybackRate: function ( value ) {

  		if ( this.hasPlaybackControl === false ) {

  			console.warn( 'THREE.Audio: this Audio has no playback control.' );
  			return;

  		}

  		this.playbackRate = value;

  		if ( this.isPlaying === true ) {

  			this.source.playbackRate.setValueAtTime( this.playbackRate, this.context.currentTime );

  		}

  		return this;

  	},

  	getPlaybackRate: function () {

  		return this.playbackRate;

  	},

  	onEnded: function () {

  		this.isPlaying = false;

  	},

  	getLoop: function () {

  		if ( this.hasPlaybackControl === false ) {

  			console.warn( 'THREE.Audio: this Audio has no playback control.' );
  			return false;

  		}

  		return this.loop;

  	},

  	setLoop: function ( value ) {

  		if ( this.hasPlaybackControl === false ) {

  			console.warn( 'THREE.Audio: this Audio has no playback control.' );
  			return;

  		}

  		this.loop = value;

  		if ( this.isPlaying === true ) {

  			this.source.loop = this.loop;

  		}

  		return this;

  	},

  	getVolume: function () {

  		return this.gain.gain.value;

  	},

  	setVolume: function ( value ) {

  		this.gain.gain.value = value;

  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function PositionalAudio( listener ) {

  	Audio.call( this, listener );

  	this.panner = this.context.createPanner();
  	this.panner.connect( this.gain );

  }

  PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {

  	constructor: PositionalAudio,

  	getOutput: function () {

  		return this.panner;

  	},

  	getRefDistance: function () {

  		return this.panner.refDistance;

  	},

  	setRefDistance: function ( value ) {

  		this.panner.refDistance = value;

  	},

  	getRolloffFactor: function () {

  		return this.panner.rolloffFactor;

  	},

  	setRolloffFactor: function ( value ) {

  		this.panner.rolloffFactor = value;

  	},

  	getDistanceModel: function () {

  		return this.panner.distanceModel;

  	},

  	setDistanceModel: function ( value ) {

  		this.panner.distanceModel = value;

  	},

  	getMaxDistance: function () {

  		return this.panner.maxDistance;

  	},

  	setMaxDistance: function ( value ) {

  		this.panner.maxDistance = value;

  	},

  	updateMatrixWorld: ( function () {

  		var position = new Vector3$2();

  		return function updateMatrixWorld( force ) {

  			Object3D$1.prototype.updateMatrixWorld.call( this, force );

  			position.setFromMatrixPosition( this.matrixWorld );

  			this.panner.setPosition( position.x, position.y, position.z );

  		};

  	} )()


  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function AudioAnalyser( audio, fftSize ) {

  	this.analyser = audio.context.createAnalyser();
  	this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

  	this.data = new Uint8Array( this.analyser.frequencyBinCount );

  	audio.getOutput().connect( this.analyser );

  }

  Object.assign( AudioAnalyser.prototype, {

  	getFrequencyData: function () {

  		this.analyser.getByteFrequencyData( this.data );

  		return this.data;

  	},

  	getAverageFrequency: function () {

  		var value = 0, data = this.getFrequencyData();

  		for ( var i = 0; i < data.length; i ++ ) {

  			value += data[ i ];

  		}

  		return value / data.length;

  	}

  } );

  /**
   *
   * Buffered scene graph property that allows weighted accumulation.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function PropertyMixer( binding, typeName, valueSize ) {

  	this.binding = binding;
  	this.valueSize = valueSize;

  	var bufferType = Float64Array,
  		mixFunction;

  	switch ( typeName ) {

  		case 'quaternion':
  			mixFunction = this._slerp;
  			break;

  		case 'string':
  		case 'bool':
  			bufferType = Array;
  			mixFunction = this._select;
  			break;

  		default:
  			mixFunction = this._lerp;

  	}

  	this.buffer = new bufferType( valueSize * 4 );
  	// layout: [ incoming | accu0 | accu1 | orig ]
  	//
  	// interpolators can use .buffer as their .result
  	// the data then goes to 'incoming'
  	//
  	// 'accu0' and 'accu1' are used frame-interleaved for
  	// the cumulative result and are compared to detect
  	// changes
  	//
  	// 'orig' stores the original state of the property

  	this._mixBufferRegion = mixFunction;

  	this.cumulativeWeight = 0;

  	this.useCount = 0;
  	this.referenceCount = 0;

  }

  Object.assign( PropertyMixer.prototype, {

  	// accumulate data in the 'incoming' region into 'accu<i>'
  	accumulate: function ( accuIndex, weight ) {

  		// note: happily accumulating nothing when weight = 0, the caller knows
  		// the weight and shouldn't have made the call in the first place

  		var buffer = this.buffer,
  			stride = this.valueSize,
  			offset = accuIndex * stride + stride,

  			currentWeight = this.cumulativeWeight;

  		if ( currentWeight === 0 ) {

  			// accuN := incoming * weight

  			for ( var i = 0; i !== stride; ++ i ) {

  				buffer[ offset + i ] = buffer[ i ];

  			}

  			currentWeight = weight;

  		} else {

  			// accuN := accuN + incoming * weight

  			currentWeight += weight;
  			var mix = weight / currentWeight;
  			this._mixBufferRegion( buffer, offset, 0, mix, stride );

  		}

  		this.cumulativeWeight = currentWeight;

  	},

  	// apply the state of 'accu<i>' to the binding when accus differ
  	apply: function ( accuIndex ) {

  		var stride = this.valueSize,
  			buffer = this.buffer,
  			offset = accuIndex * stride + stride,

  			weight = this.cumulativeWeight,

  			binding = this.binding;

  		this.cumulativeWeight = 0;

  		if ( weight < 1 ) {

  			// accuN := accuN + original * ( 1 - cumulativeWeight )

  			var originalValueOffset = stride * 3;

  			this._mixBufferRegion(
  				buffer, offset, originalValueOffset, 1 - weight, stride );

  		}

  		for ( var i = stride, e = stride + stride; i !== e; ++ i ) {

  			if ( buffer[ i ] !== buffer[ i + stride ] ) {

  				// value has changed -> update scene graph

  				binding.setValue( buffer, offset );
  				break;

  			}

  		}

  	},

  	// remember the state of the bound property and copy it to both accus
  	saveOriginalState: function () {

  		var binding = this.binding;

  		var buffer = this.buffer,
  			stride = this.valueSize,

  			originalValueOffset = stride * 3;

  		binding.getValue( buffer, originalValueOffset );

  		// accu[0..1] := orig -- initially detect changes against the original
  		for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {

  			buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

  		}

  		this.cumulativeWeight = 0;

  	},

  	// apply the state previously taken via 'saveOriginalState' to the binding
  	restoreOriginalState: function () {

  		var originalValueOffset = this.valueSize * 3;
  		this.binding.setValue( this.buffer, originalValueOffset );

  	},


  	// mix functions

  	_select: function ( buffer, dstOffset, srcOffset, t, stride ) {

  		if ( t >= 0.5 ) {

  			for ( var i = 0; i !== stride; ++ i ) {

  				buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

  			}

  		}

  	},

  	_slerp: function ( buffer, dstOffset, srcOffset, t ) {

  		Quaternion$1.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

  	},

  	_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {

  		var s = 1 - t;

  		for ( var i = 0; i !== stride; ++ i ) {

  			var j = dstOffset + i;

  			buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

  		}

  	}

  } );

  /**
   *
   * A reference to a real property in the scene graph.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function Composite( targetGroup, path, optionalParsedPath ) {

  	var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

  	this._targetGroup = targetGroup;
  	this._bindings = targetGroup.subscribe_( path, parsedPath );

  }

  Object.assign( Composite.prototype, {

  	getValue: function ( array, offset ) {

  		this.bind(); // bind all binding

  		var firstValidIndex = this._targetGroup.nCachedObjects_,
  			binding = this._bindings[ firstValidIndex ];

  		// and only call .getValue on the first
  		if ( binding !== undefined ) { binding.getValue( array, offset ); }

  	},

  	setValue: function ( array, offset ) {

  		var bindings = this._bindings;

  		for ( var i = this._targetGroup.nCachedObjects_,
  				  n = bindings.length; i !== n; ++ i ) {

  			bindings[ i ].setValue( array, offset );

  		}

  	},

  	bind: function () {

  		var bindings = this._bindings;

  		for ( var i = this._targetGroup.nCachedObjects_,
  				  n = bindings.length; i !== n; ++ i ) {

  			bindings[ i ].bind();

  		}

  	},

  	unbind: function () {

  		var bindings = this._bindings;

  		for ( var i = this._targetGroup.nCachedObjects_,
  				  n = bindings.length; i !== n; ++ i ) {

  			bindings[ i ].unbind();

  		}

  	}

  } );


  function PropertyBinding( rootNode, path, parsedPath ) {

  	this.path = path;
  	this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

  	this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;

  	this.rootNode = rootNode;

  }

  Object.assign( PropertyBinding, {

  	Composite: Composite,

  	create: function ( root, path, parsedPath ) {

  		if ( ! ( root && root.isAnimationObjectGroup ) ) {

  			return new PropertyBinding( root, path, parsedPath );

  		} else {

  			return new PropertyBinding.Composite( root, path, parsedPath );

  		}

  	},

  	/**
  	 * Replaces spaces with underscores and removes unsupported characters from
  	 * node names, to ensure compatibility with parseTrackName().
  	 *
  	 * @param  {string} name Node name to be sanitized.
  	 * @return {string}
  	 */
  	sanitizeNodeName: function ( name ) {

  		return name.replace( /\s/g, '_' ).replace( /[^\w-]/g, '' );

  	},

  	parseTrackName: function () {

  		// Parent directories, delimited by '/' or ':'. Currently unused, but must
  		// be matched to parse the rest of the track name.
  		var directoryRe = /((?:[\w-]+[\/:])*)/;

  		// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
  		var nodeRe = /([\w-\.]+)?/;

  		// Object on target node, and accessor. Name may contain only word
  		// characters. Accessor may contain any character except closing bracket.
  		var objectRe = /(?:\.([\w-]+)(?:\[(.+)\])?)?/;

  		// Property and accessor. May contain only word characters. Accessor may
  		// contain any non-bracket characters.
  		var propertyRe = /\.([\w-]+)(?:\[(.+)\])?/;

  		var trackRe = new RegExp( ''
  			+ '^'
  			+ directoryRe.source
  			+ nodeRe.source
  			+ objectRe.source
  			+ propertyRe.source
  			+ '$'
  		);

  		var supportedObjectNames = [ 'material', 'materials', 'bones' ];

  		return function ( trackName ) {

  			var matches = trackRe.exec( trackName );

  			if ( ! matches ) {

  				throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

  			}

  			var results = {
  				// directoryName: matches[ 1 ], // (tschw) currently unused
  				nodeName: matches[ 2 ],
  				objectName: matches[ 3 ],
  				objectIndex: matches[ 4 ],
  				propertyName: matches[ 5 ], // required
  				propertyIndex: matches[ 6 ]
  			};

  			var lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

  			if ( lastDot !== undefined && lastDot !== - 1 ) {

  				var objectName = results.nodeName.substring( lastDot + 1 );

  				// Object names must be checked against a whitelist. Otherwise, there
  				// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
  				// 'bar' could be the objectName, or part of a nodeName (which can
  				// include '.' characters).
  				if ( supportedObjectNames.indexOf( objectName ) !== - 1 ) {

  					results.nodeName = results.nodeName.substring( 0, lastDot );
  					results.objectName = objectName;

  				}

  			}

  			if ( results.propertyName === null || results.propertyName.length === 0 ) {

  				throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

  			}

  			return results;

  		};

  	}(),

  	findNode: function ( root, nodeName ) {

  		if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

  			return root;

  		}

  		// search into skeleton bones.
  		if ( root.skeleton ) {

  			var searchSkeleton = function ( skeleton ) {

  				for ( var i = 0; i < skeleton.bones.length; i ++ ) {

  					var bone = skeleton.bones[ i ];

  					if ( bone.name === nodeName ) {

  						return bone;

  					}

  				}

  				return null;

  			};

  			var bone = searchSkeleton( root.skeleton );

  			if ( bone ) {

  				return bone;

  			}

  		}

  		// search into node subtree.
  		if ( root.children ) {

  			var searchNodeSubtree = function ( children ) {

  				for ( var i = 0; i < children.length; i ++ ) {

  					var childNode = children[ i ];

  					if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

  						return childNode;

  					}

  					var result = searchNodeSubtree( childNode.children );

  					if ( result ) { return result; }

  				}

  				return null;

  			};

  			var subTreeNode = searchNodeSubtree( root.children );

  			if ( subTreeNode ) {

  				return subTreeNode;

  			}

  		}

  		return null;

  	}

  } );

  Object.assign( PropertyBinding.prototype, { // prototype, continued

  	// these are used to "bind" a nonexistent property
  	_getValue_unavailable: function () {},
  	_setValue_unavailable: function () {},

  	BindingType: {
  		Direct: 0,
  		EntireArray: 1,
  		ArrayElement: 2,
  		HasFromToArray: 3
  	},

  	Versioning: {
  		None: 0,
  		NeedsUpdate: 1,
  		MatrixWorldNeedsUpdate: 2
  	},

  	GetterByBindingType: [

  		function getValue_direct( buffer, offset ) {

  			buffer[ offset ] = this.node[ this.propertyName ];

  		},

  		function getValue_array( buffer, offset ) {

  			var source = this.resolvedProperty;

  			for ( var i = 0, n = source.length; i !== n; ++ i ) {

  				buffer[ offset ++ ] = source[ i ];

  			}

  		},

  		function getValue_arrayElement( buffer, offset ) {

  			buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

  		},

  		function getValue_toArray( buffer, offset ) {

  			this.resolvedProperty.toArray( buffer, offset );

  		}

  	],

  	SetterByBindingTypeAndVersioning: [

  		[
  			// Direct

  			function setValue_direct( buffer, offset ) {

  				this.targetObject[ this.propertyName ] = buffer[ offset ];

  			},

  			function setValue_direct_setNeedsUpdate( buffer, offset ) {

  				this.targetObject[ this.propertyName ] = buffer[ offset ];
  				this.targetObject.needsUpdate = true;

  			},

  			function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

  				this.targetObject[ this.propertyName ] = buffer[ offset ];
  				this.targetObject.matrixWorldNeedsUpdate = true;

  			}

  		], [

  			// EntireArray

  			function setValue_array( buffer, offset ) {

  				var dest = this.resolvedProperty;

  				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

  					dest[ i ] = buffer[ offset ++ ];

  				}

  			},

  			function setValue_array_setNeedsUpdate( buffer, offset ) {

  				var dest = this.resolvedProperty;

  				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

  					dest[ i ] = buffer[ offset ++ ];

  				}

  				this.targetObject.needsUpdate = true;

  			},

  			function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

  				var dest = this.resolvedProperty;

  				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

  					dest[ i ] = buffer[ offset ++ ];

  				}

  				this.targetObject.matrixWorldNeedsUpdate = true;

  			}

  		], [

  			// ArrayElement

  			function setValue_arrayElement( buffer, offset ) {

  				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

  			},

  			function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

  				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
  				this.targetObject.needsUpdate = true;

  			},

  			function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

  				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
  				this.targetObject.matrixWorldNeedsUpdate = true;

  			}

  		], [

  			// HasToFromArray

  			function setValue_fromArray( buffer, offset ) {

  				this.resolvedProperty.fromArray( buffer, offset );

  			},

  			function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

  				this.resolvedProperty.fromArray( buffer, offset );
  				this.targetObject.needsUpdate = true;

  			},

  			function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

  				this.resolvedProperty.fromArray( buffer, offset );
  				this.targetObject.matrixWorldNeedsUpdate = true;

  			}

  		]

  	],

  	getValue: function getValue_unbound( targetArray, offset ) {

  		this.bind();
  		this.getValue( targetArray, offset );

  		// Note: This class uses a State pattern on a per-method basis:
  		// 'bind' sets 'this.getValue' / 'setValue' and shadows the
  		// prototype version of these methods with one that represents
  		// the bound state. When the property is not found, the methods
  		// become no-ops.

  	},

  	setValue: function getValue_unbound( sourceArray, offset ) {

  		this.bind();
  		this.setValue( sourceArray, offset );

  	},

  	// create getter / setter pair for a property in the scene graph
  	bind: function () {

  		var targetObject = this.node,
  			parsedPath = this.parsedPath,

  			objectName = parsedPath.objectName,
  			propertyName = parsedPath.propertyName,
  			propertyIndex = parsedPath.propertyIndex;

  		if ( ! targetObject ) {

  			targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;

  			this.node = targetObject;

  		}

  		// set fail state so we can just 'return' on error
  		this.getValue = this._getValue_unavailable;
  		this.setValue = this._setValue_unavailable;

  		// ensure there is a value node
  		if ( ! targetObject ) {

  			console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
  			return;

  		}

  		if ( objectName ) {

  			var objectIndex = parsedPath.objectIndex;

  			// special cases were we need to reach deeper into the hierarchy to get the face materials....
  			switch ( objectName ) {

  				case 'materials':

  					if ( ! targetObject.material ) {

  						console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
  						return;

  					}

  					if ( ! targetObject.material.materials ) {

  						console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
  						return;

  					}

  					targetObject = targetObject.material.materials;

  					break;

  				case 'bones':

  					if ( ! targetObject.skeleton ) {

  						console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
  						return;

  					}

  					// potential future optimization: skip this if propertyIndex is already an integer
  					// and convert the integer string to a true integer.

  					targetObject = targetObject.skeleton.bones;

  					// support resolving morphTarget names into indices.
  					for ( var i = 0; i < targetObject.length; i ++ ) {

  						if ( targetObject[ i ].name === objectIndex ) {

  							objectIndex = i;
  							break;

  						}

  					}

  					break;

  				default:

  					if ( targetObject[ objectName ] === undefined ) {

  						console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
  						return;

  					}

  					targetObject = targetObject[ objectName ];

  			}


  			if ( objectIndex !== undefined ) {

  				if ( targetObject[ objectIndex ] === undefined ) {

  					console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
  					return;

  				}

  				targetObject = targetObject[ objectIndex ];

  			}

  		}

  		// resolve property
  		var nodeProperty = targetObject[ propertyName ];

  		if ( nodeProperty === undefined ) {

  			var nodeName = parsedPath.nodeName;

  			console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
  				'.' + propertyName + ' but it wasn\'t found.', targetObject );
  			return;

  		}

  		// determine versioning scheme
  		var versioning = this.Versioning.None;

  		if ( targetObject.needsUpdate !== undefined ) { // material

  			versioning = this.Versioning.NeedsUpdate;
  			this.targetObject = targetObject;

  		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

  			versioning = this.Versioning.MatrixWorldNeedsUpdate;
  			this.targetObject = targetObject;

  		}

  		// determine how the property gets bound
  		var bindingType = this.BindingType.Direct;

  		if ( propertyIndex !== undefined ) {

  			// access a sub element of the property array (only primitives are supported right now)

  			if ( propertyName === "morphTargetInfluences" ) {

  				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

  				// support resolving morphTarget names into indices.
  				if ( ! targetObject.geometry ) {

  					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
  					return;

  				}

  				if ( targetObject.geometry.isBufferGeometry ) {

  					if ( ! targetObject.geometry.morphAttributes ) {

  						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
  						return;

  					}

  					for ( var i = 0; i < this.node.geometry.morphAttributes.position.length; i ++ ) {

  						if ( targetObject.geometry.morphAttributes.position[ i ].name === propertyIndex ) {

  							propertyIndex = i;
  							break;

  						}

  					}


  				} else {

  					if ( ! targetObject.geometry.morphTargets ) {

  						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this );
  						return;

  					}

  					for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {

  						if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {

  							propertyIndex = i;
  							break;

  						}

  					}

  				}

  			}

  			bindingType = this.BindingType.ArrayElement;

  			this.resolvedProperty = nodeProperty;
  			this.propertyIndex = propertyIndex;

  		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

  			// must use copy for Object3D.Euler/Quaternion

  			bindingType = this.BindingType.HasFromToArray;

  			this.resolvedProperty = nodeProperty;

  		} else if ( Array.isArray( nodeProperty ) ) {

  			bindingType = this.BindingType.EntireArray;

  			this.resolvedProperty = nodeProperty;

  		} else {

  			this.propertyName = propertyName;

  		}

  		// select getter / setter
  		this.getValue = this.GetterByBindingType[ bindingType ];
  		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

  	},

  	unbind: function () {

  		this.node = null;

  		// back to the prototype version of getValue / setValue
  		// note: avoiding to mutate the shape of 'this' via 'delete'
  		this.getValue = this._getValue_unbound;
  		this.setValue = this._setValue_unbound;

  	}

  } );

  //!\ DECLARE ALIAS AFTER assign prototype !
  Object.assign( PropertyBinding.prototype, {

  	// initial state of these methods that calls 'bind'
  	_getValue_unbound: PropertyBinding.prototype.getValue,
  	_setValue_unbound: PropertyBinding.prototype.setValue,

  } );

  /**
   *
   * A group of objects that receives a shared animation state.
   *
   * Usage:
   *
   * 	-	Add objects you would otherwise pass as 'root' to the
   * 		constructor or the .clipAction method of AnimationMixer.
   *
   * 	-	Instead pass this object as 'root'.
   *
   * 	-	You can also add and remove objects later when the mixer
   * 		is running.
   *
   * Note:
   *
   *  	Objects of this class appear as one object to the mixer,
   *  	so cache control of the individual objects must be done
   *  	on the group.
   *
   * Limitation:
   *
   * 	- 	The animated properties must be compatible among the
   * 		all objects in the group.
   *
   *  -	A single property can either be controlled through a
   *  	target group or directly, but not both.
   *
   * @author tschw
   */

  function AnimationObjectGroup() {
  	var arguments$1 = arguments;


  	this.uuid = _Math$1.generateUUID();

  	// cached objects followed by the active ones
  	this._objects = Array.prototype.slice.call( arguments );

  	this.nCachedObjects_ = 0;			// threshold
  	// note: read by PropertyBinding.Composite

  	var indices = {};
  	this._indicesByUUID = indices;		// for bookkeeping

  	for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

  		indices[ arguments$1[ i ].uuid ] = i;

  	}

  	this._paths = [];					// inside: string
  	this._parsedPaths = [];				// inside: { we don't care, here }
  	this._bindings = []; 				// inside: Array< PropertyBinding >
  	this._bindingsIndicesByPath = {}; 	// inside: indices in these arrays

  	var scope = this;

  	this.stats = {

  		objects: {
  			get total() {

  				return scope._objects.length;

  			},
  			get inUse() {

  				return this.total - scope.nCachedObjects_;

  			}
  		},
  		get bindingsPerObject() {

  			return scope._bindings.length;

  		}

  	};

  }

  Object.assign( AnimationObjectGroup.prototype, {

  	isAnimationObjectGroup: true,

  	add: function () {
  		var arguments$1 = arguments;


  		var objects = this._objects,
  			nObjects = objects.length,
  			nCachedObjects = this.nCachedObjects_,
  			indicesByUUID = this._indicesByUUID,
  			paths = this._paths,
  			parsedPaths = this._parsedPaths,
  			bindings = this._bindings,
  			nBindings = bindings.length;

  		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

  			var object = arguments$1[ i ],
  				uuid = object.uuid,
  				index = indicesByUUID[ uuid ],
  				knownObject = undefined;

  			if ( index === undefined ) {

  				// unknown object -> add it to the ACTIVE region

  				index = nObjects ++;
  				indicesByUUID[ uuid ] = index;
  				objects.push( object );

  				// accounting is done, now do the same for all bindings

  				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

  					bindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );

  				}

  			} else if ( index < nCachedObjects ) {

  				knownObject = objects[ index ];

  				// move existing object to the ACTIVE region

  				var firstActiveIndex = -- nCachedObjects,
  					lastCachedObject = objects[ firstActiveIndex ];

  				indicesByUUID[ lastCachedObject.uuid ] = index;
  				objects[ index ] = lastCachedObject;

  				indicesByUUID[ uuid ] = firstActiveIndex;
  				objects[ firstActiveIndex ] = object;

  				// accounting is done, now do the same for all bindings

  				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

  					var bindingsForPath = bindings[ j ],
  						lastCached = bindingsForPath[ firstActiveIndex ],
  						binding = bindingsForPath[ index ];

  					bindingsForPath[ index ] = lastCached;

  					if ( binding === undefined ) {

  						// since we do not bother to create new bindings
  						// for objects that are cached, the binding may
  						// or may not exist

  						binding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );

  					}

  					bindingsForPath[ firstActiveIndex ] = binding;

  				}

  			} else if ( objects[ index ] !== knownObject ) {

  				console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +
  						'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );

  			} // else the object is already where we want it to be

  		} // for arguments

  		this.nCachedObjects_ = nCachedObjects;

  	},

  	remove: function () {
  		var arguments$1 = arguments;


  		var objects = this._objects,
  			nCachedObjects = this.nCachedObjects_,
  			indicesByUUID = this._indicesByUUID,
  			bindings = this._bindings,
  			nBindings = bindings.length;

  		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

  			var object = arguments$1[ i ],
  				uuid = object.uuid,
  				index = indicesByUUID[ uuid ];

  			if ( index !== undefined && index >= nCachedObjects ) {

  				// move existing object into the CACHED region

  				var lastCachedIndex = nCachedObjects ++,
  					firstActiveObject = objects[ lastCachedIndex ];

  				indicesByUUID[ firstActiveObject.uuid ] = index;
  				objects[ index ] = firstActiveObject;

  				indicesByUUID[ uuid ] = lastCachedIndex;
  				objects[ lastCachedIndex ] = object;

  				// accounting is done, now do the same for all bindings

  				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

  					var bindingsForPath = bindings[ j ],
  						firstActive = bindingsForPath[ lastCachedIndex ],
  						binding = bindingsForPath[ index ];

  					bindingsForPath[ index ] = firstActive;
  					bindingsForPath[ lastCachedIndex ] = binding;

  				}

  			}

  		} // for arguments

  		this.nCachedObjects_ = nCachedObjects;

  	},

  	// remove & forget
  	uncache: function () {
  		var arguments$1 = arguments;


  		var objects = this._objects,
  			nObjects = objects.length,
  			nCachedObjects = this.nCachedObjects_,
  			indicesByUUID = this._indicesByUUID,
  			bindings = this._bindings,
  			nBindings = bindings.length;

  		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

  			var object = arguments$1[ i ],
  				uuid = object.uuid,
  				index = indicesByUUID[ uuid ];

  			if ( index !== undefined ) {

  				delete indicesByUUID[ uuid ];

  				if ( index < nCachedObjects ) {

  					// object is cached, shrink the CACHED region

  					var firstActiveIndex = -- nCachedObjects,
  						lastCachedObject = objects[ firstActiveIndex ],
  						lastIndex = -- nObjects,
  						lastObject = objects[ lastIndex ];

  					// last cached object takes this object's place
  					indicesByUUID[ lastCachedObject.uuid ] = index;
  					objects[ index ] = lastCachedObject;

  					// last object goes to the activated slot and pop
  					indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
  					objects[ firstActiveIndex ] = lastObject;
  					objects.pop();

  					// accounting is done, now do the same for all bindings

  					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

  						var bindingsForPath = bindings[ j ],
  							lastCached = bindingsForPath[ firstActiveIndex ],
  							last = bindingsForPath[ lastIndex ];

  						bindingsForPath[ index ] = lastCached;
  						bindingsForPath[ firstActiveIndex ] = last;
  						bindingsForPath.pop();

  					}

  				} else {

  					// object is active, just swap with the last and pop

  					var lastIndex = -- nObjects,
  						lastObject = objects[ lastIndex ];

  					indicesByUUID[ lastObject.uuid ] = index;
  					objects[ index ] = lastObject;
  					objects.pop();

  					// accounting is done, now do the same for all bindings

  					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

  						var bindingsForPath = bindings[ j ];

  						bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
  						bindingsForPath.pop();

  					}

  				} // cached or active

  			} // if object is known

  		} // for arguments

  		this.nCachedObjects_ = nCachedObjects;

  	},

  	// Internal interface used by befriended PropertyBinding.Composite:

  	subscribe_: function ( path, parsedPath ) {

  		// returns an array of bindings for the given path that is changed
  		// according to the contained objects in the group

  		var indicesByPath = this._bindingsIndicesByPath,
  			index = indicesByPath[ path ],
  			bindings = this._bindings;

  		if ( index !== undefined ) { return bindings[ index ]; }

  		var paths = this._paths,
  			parsedPaths = this._parsedPaths,
  			objects = this._objects,
  			nObjects = objects.length,
  			nCachedObjects = this.nCachedObjects_,
  			bindingsForPath = new Array( nObjects );

  		index = bindings.length;

  		indicesByPath[ path ] = index;

  		paths.push( path );
  		parsedPaths.push( parsedPath );
  		bindings.push( bindingsForPath );

  		for ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) {

  			var object = objects[ i ];
  			bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );

  		}

  		return bindingsForPath;

  	},

  	unsubscribe_: function ( path ) {

  		// tells the group to forget about a property path and no longer
  		// update the array previously obtained with 'subscribe_'

  		var indicesByPath = this._bindingsIndicesByPath,
  			index = indicesByPath[ path ];

  		if ( index !== undefined ) {

  			var paths = this._paths,
  				parsedPaths = this._parsedPaths,
  				bindings = this._bindings,
  				lastBindingsIndex = bindings.length - 1,
  				lastBindings = bindings[ lastBindingsIndex ],
  				lastBindingsPath = path[ lastBindingsIndex ];

  			indicesByPath[ lastBindingsPath ] = index;

  			bindings[ index ] = lastBindings;
  			bindings.pop();

  			parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
  			parsedPaths.pop();

  			paths[ index ] = paths[ lastBindingsIndex ];
  			paths.pop();

  		}

  	}

  } );

  /**
   *
   * Action provided by AnimationMixer for scheduling clip playback on specific
   * objects.
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   *
   */

  function AnimationAction( mixer, clip, localRoot ) {

  	this._mixer = mixer;
  	this._clip = clip;
  	this._localRoot = localRoot || null;

  	var tracks = clip.tracks,
  		nTracks = tracks.length,
  		interpolants = new Array( nTracks );

  	var interpolantSettings = {
  		endingStart: ZeroCurvatureEnding$1,
  		endingEnd: ZeroCurvatureEnding$1
  	};

  	for ( var i = 0; i !== nTracks; ++ i ) {

  		var interpolant = tracks[ i ].createInterpolant( null );
  		interpolants[ i ] = interpolant;
  		interpolant.settings = interpolantSettings;

  	}

  	this._interpolantSettings = interpolantSettings;

  	this._interpolants = interpolants;	// bound by the mixer

  	// inside: PropertyMixer (managed by the mixer)
  	this._propertyBindings = new Array( nTracks );

  	this._cacheIndex = null;			// for the memory manager
  	this._byClipCacheIndex = null;		// for the memory manager

  	this._timeScaleInterpolant = null;
  	this._weightInterpolant = null;

  	this.loop = LoopRepeat$1;
  	this._loopCount = - 1;

  	// global mixer time when the action is to be started
  	// it's set back to 'null' upon start of the action
  	this._startTime = null;

  	// scaled local time of the action
  	// gets clamped or wrapped to 0..clip.duration according to loop
  	this.time = 0;

  	this.timeScale = 1;
  	this._effectiveTimeScale = 1;

  	this.weight = 1;
  	this._effectiveWeight = 1;

  	this.repetitions = Infinity; 		// no. of repetitions when looping

  	this.paused = false;				// true -> zero effective time scale
  	this.enabled = true;				// false -> zero effective weight

  	this.clampWhenFinished 	= false;	// keep feeding the last frame?

  	this.zeroSlopeAtStart 	= true;		// for smooth interpolation w/o separate
  	this.zeroSlopeAtEnd		= true;		// clips for start, loop and end

  }

  Object.assign( AnimationAction.prototype, {

  	// State & Scheduling

  	play: function () {

  		this._mixer._activateAction( this );

  		return this;

  	},

  	stop: function () {

  		this._mixer._deactivateAction( this );

  		return this.reset();

  	},

  	reset: function () {

  		this.paused = false;
  		this.enabled = true;

  		this.time = 0;			// restart clip
  		this._loopCount = - 1;	// forget previous loops
  		this._startTime = null;	// forget scheduling

  		return this.stopFading().stopWarping();

  	},

  	isRunning: function () {

  		return this.enabled && ! this.paused && this.timeScale !== 0 &&
  				this._startTime === null && this._mixer._isActiveAction( this );

  	},

  	// return true when play has been called
  	isScheduled: function () {

  		return this._mixer._isActiveAction( this );

  	},

  	startAt: function ( time ) {

  		this._startTime = time;

  		return this;

  	},

  	setLoop: function ( mode, repetitions ) {

  		this.loop = mode;
  		this.repetitions = repetitions;

  		return this;

  	},

  	// Weight

  	// set the weight stopping any scheduled fading
  	// although .enabled = false yields an effective weight of zero, this
  	// method does *not* change .enabled, because it would be confusing
  	setEffectiveWeight: function ( weight ) {

  		this.weight = weight;

  		// note: same logic as when updated at runtime
  		this._effectiveWeight = this.enabled ? weight : 0;

  		return this.stopFading();

  	},

  	// return the weight considering fading and .enabled
  	getEffectiveWeight: function () {

  		return this._effectiveWeight;

  	},

  	fadeIn: function ( duration ) {

  		return this._scheduleFading( duration, 0, 1 );

  	},

  	fadeOut: function ( duration ) {

  		return this._scheduleFading( duration, 1, 0 );

  	},

  	crossFadeFrom: function ( fadeOutAction, duration, warp ) {

  		fadeOutAction.fadeOut( duration );
  		this.fadeIn( duration );

  		if ( warp ) {

  			var fadeInDuration = this._clip.duration,
  				fadeOutDuration = fadeOutAction._clip.duration,

  				startEndRatio = fadeOutDuration / fadeInDuration,
  				endStartRatio = fadeInDuration / fadeOutDuration;

  			fadeOutAction.warp( 1.0, startEndRatio, duration );
  			this.warp( endStartRatio, 1.0, duration );

  		}

  		return this;

  	},

  	crossFadeTo: function ( fadeInAction, duration, warp ) {

  		return fadeInAction.crossFadeFrom( this, duration, warp );

  	},

  	stopFading: function () {

  		var weightInterpolant = this._weightInterpolant;

  		if ( weightInterpolant !== null ) {

  			this._weightInterpolant = null;
  			this._mixer._takeBackControlInterpolant( weightInterpolant );

  		}

  		return this;

  	},

  	// Time Scale Control

  	// set the time scale stopping any scheduled warping
  	// although .paused = true yields an effective time scale of zero, this
  	// method does *not* change .paused, because it would be confusing
  	setEffectiveTimeScale: function ( timeScale ) {

  		this.timeScale = timeScale;
  		this._effectiveTimeScale = this.paused ? 0 : timeScale;

  		return this.stopWarping();

  	},

  	// return the time scale considering warping and .paused
  	getEffectiveTimeScale: function () {

  		return this._effectiveTimeScale;

  	},

  	setDuration: function ( duration ) {

  		this.timeScale = this._clip.duration / duration;

  		return this.stopWarping();

  	},

  	syncWith: function ( action ) {

  		this.time = action.time;
  		this.timeScale = action.timeScale;

  		return this.stopWarping();

  	},

  	halt: function ( duration ) {

  		return this.warp( this._effectiveTimeScale, 0, duration );

  	},

  	warp: function ( startTimeScale, endTimeScale, duration ) {

  		var mixer = this._mixer, now = mixer.time,
  			interpolant = this._timeScaleInterpolant,

  			timeScale = this.timeScale;

  		if ( interpolant === null ) {

  			interpolant = mixer._lendControlInterpolant();
  			this._timeScaleInterpolant = interpolant;

  		}

  		var times = interpolant.parameterPositions,
  			values = interpolant.sampleValues;

  		times[ 0 ] = now;
  		times[ 1 ] = now + duration;

  		values[ 0 ] = startTimeScale / timeScale;
  		values[ 1 ] = endTimeScale / timeScale;

  		return this;

  	},

  	stopWarping: function () {

  		var timeScaleInterpolant = this._timeScaleInterpolant;

  		if ( timeScaleInterpolant !== null ) {

  			this._timeScaleInterpolant = null;
  			this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

  		}

  		return this;

  	},

  	// Object Accessors

  	getMixer: function () {

  		return this._mixer;

  	},

  	getClip: function () {

  		return this._clip;

  	},

  	getRoot: function () {

  		return this._localRoot || this._mixer._root;

  	},

  	// Interna

  	_update: function ( time, deltaTime, timeDirection, accuIndex ) {

  		// called by the mixer

  		if ( ! this.enabled ) {

  			// call ._updateWeight() to update ._effectiveWeight

  			this._updateWeight( time );
  			return;

  		}

  		var startTime = this._startTime;

  		if ( startTime !== null ) {

  			// check for scheduled start of action

  			var timeRunning = ( time - startTime ) * timeDirection;
  			if ( timeRunning < 0 || timeDirection === 0 ) {

  				return; // yet to come / don't decide when delta = 0

  			}

  			// start

  			this._startTime = null; // unschedule
  			deltaTime = timeDirection * timeRunning;

  		}

  		// apply time scale and advance time

  		deltaTime *= this._updateTimeScale( time );
  		var clipTime = this._updateTime( deltaTime );

  		// note: _updateTime may disable the action resulting in
  		// an effective weight of 0

  		var weight = this._updateWeight( time );

  		if ( weight > 0 ) {

  			var interpolants = this._interpolants;
  			var propertyMixers = this._propertyBindings;

  			for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {

  				interpolants[ j ].evaluate( clipTime );
  				propertyMixers[ j ].accumulate( accuIndex, weight );

  			}

  		}

  	},

  	_updateWeight: function ( time ) {

  		var weight = 0;

  		if ( this.enabled ) {

  			weight = this.weight;
  			var interpolant = this._weightInterpolant;

  			if ( interpolant !== null ) {

  				var interpolantValue = interpolant.evaluate( time )[ 0 ];

  				weight *= interpolantValue;

  				if ( time > interpolant.parameterPositions[ 1 ] ) {

  					this.stopFading();

  					if ( interpolantValue === 0 ) {

  						// faded out, disable
  						this.enabled = false;

  					}

  				}

  			}

  		}

  		this._effectiveWeight = weight;
  		return weight;

  	},

  	_updateTimeScale: function ( time ) {

  		var timeScale = 0;

  		if ( ! this.paused ) {

  			timeScale = this.timeScale;

  			var interpolant = this._timeScaleInterpolant;

  			if ( interpolant !== null ) {

  				var interpolantValue = interpolant.evaluate( time )[ 0 ];

  				timeScale *= interpolantValue;

  				if ( time > interpolant.parameterPositions[ 1 ] ) {

  					this.stopWarping();

  					if ( timeScale === 0 ) {

  						// motion has halted, pause
  						this.paused = true;

  					} else {

  						// warp done - apply final time scale
  						this.timeScale = timeScale;

  					}

  				}

  			}

  		}

  		this._effectiveTimeScale = timeScale;
  		return timeScale;

  	},

  	_updateTime: function ( deltaTime ) {

  		var time = this.time + deltaTime;

  		if ( deltaTime === 0 ) { return time; }

  		var duration = this._clip.duration,

  			loop = this.loop,
  			loopCount = this._loopCount;

  		if ( loop === LoopOnce$1 ) {

  			if ( loopCount === - 1 ) {

  				// just started

  				this._loopCount = 0;
  				this._setEndings( true, true, false );

  			}

  			handle_stop: {

  				if ( time >= duration ) {

  					time = duration;

  				} else if ( time < 0 ) {

  					time = 0;

  				} else { break handle_stop; }

  				if ( this.clampWhenFinished ) { this.paused = true; }
  				else { this.enabled = false; }

  				this._mixer.dispatchEvent( {
  					type: 'finished', action: this,
  					direction: deltaTime < 0 ? - 1 : 1
  				} );

  			}

  		} else { // repetitive Repeat or PingPong

  			var pingPong = ( loop === LoopPingPong$1 );

  			if ( loopCount === - 1 ) {

  				// just started

  				if ( deltaTime >= 0 ) {

  					loopCount = 0;

  					this._setEndings( true, this.repetitions === 0, pingPong );

  				} else {

  					// when looping in reverse direction, the initial
  					// transition through zero counts as a repetition,
  					// so leave loopCount at -1

  					this._setEndings( this.repetitions === 0, true, pingPong );

  				}

  			}

  			if ( time >= duration || time < 0 ) {

  				// wrap around

  				var loopDelta = Math.floor( time / duration ); // signed
  				time -= duration * loopDelta;

  				loopCount += Math.abs( loopDelta );

  				var pending = this.repetitions - loopCount;

  				if ( pending < 0 ) {

  					// have to stop (switch state, clamp time, fire event)

  					if ( this.clampWhenFinished ) { this.paused = true; }
  					else { this.enabled = false; }

  					time = deltaTime > 0 ? duration : 0;

  					this._mixer.dispatchEvent( {
  						type: 'finished', action: this,
  						direction: deltaTime > 0 ? 1 : - 1
  					} );

  				} else {

  					// keep running

  					if ( pending === 0 ) {

  						// entering the last round

  						var atStart = deltaTime < 0;
  						this._setEndings( atStart, ! atStart, pingPong );

  					} else {

  						this._setEndings( false, false, pingPong );

  					}

  					this._loopCount = loopCount;

  					this._mixer.dispatchEvent( {
  						type: 'loop', action: this, loopDelta: loopDelta
  					} );

  				}

  			}

  			if ( pingPong && ( loopCount & 1 ) === 1 ) {

  				// invert time for the "pong round"

  				this.time = time;
  				return duration - time;

  			}

  		}

  		this.time = time;
  		return time;

  	},

  	_setEndings: function ( atStart, atEnd, pingPong ) {

  		var settings = this._interpolantSettings;

  		if ( pingPong ) {

  			settings.endingStart 	= ZeroSlopeEnding$1;
  			settings.endingEnd		= ZeroSlopeEnding$1;

  		} else {

  			// assuming for LoopOnce atStart == atEnd == true

  			if ( atStart ) {

  				settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding$1 : ZeroCurvatureEnding$1;

  			} else {

  				settings.endingStart = WrapAroundEnding$1;

  			}

  			if ( atEnd ) {

  				settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding$1 : ZeroCurvatureEnding$1;

  			} else {

  				settings.endingEnd 	 = WrapAroundEnding$1;

  			}

  		}

  	},

  	_scheduleFading: function ( duration, weightNow, weightThen ) {

  		var mixer = this._mixer, now = mixer.time,
  			interpolant = this._weightInterpolant;

  		if ( interpolant === null ) {

  			interpolant = mixer._lendControlInterpolant();
  			this._weightInterpolant = interpolant;

  		}

  		var times = interpolant.parameterPositions,
  			values = interpolant.sampleValues;

  		times[ 0 ] = now; 				values[ 0 ] = weightNow;
  		times[ 1 ] = now + duration;	values[ 1 ] = weightThen;

  		return this;

  	}

  } );

  /**
   *
   * Player for AnimationClips.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function AnimationMixer( root ) {

  	this._root = root;
  	this._initMemoryManager();
  	this._accuIndex = 0;

  	this.time = 0;

  	this.timeScale = 1.0;

  }

  Object.assign( AnimationMixer.prototype, EventDispatcher$1.prototype, {

  	_bindAction: function ( action, prototypeAction ) {
  		var this$1 = this;


  		var root = action._localRoot || this._root,
  			tracks = action._clip.tracks,
  			nTracks = tracks.length,
  			bindings = action._propertyBindings,
  			interpolants = action._interpolants,
  			rootUuid = root.uuid,
  			bindingsByRoot = this._bindingsByRootAndName,
  			bindingsByName = bindingsByRoot[ rootUuid ];

  		if ( bindingsByName === undefined ) {

  			bindingsByName = {};
  			bindingsByRoot[ rootUuid ] = bindingsByName;

  		}

  		for ( var i = 0; i !== nTracks; ++ i ) {

  			var track = tracks[ i ],
  				trackName = track.name,
  				binding = bindingsByName[ trackName ];

  			if ( binding !== undefined ) {

  				bindings[ i ] = binding;

  			} else {

  				binding = bindings[ i ];

  				if ( binding !== undefined ) {

  					// existing binding, make sure the cache knows

  					if ( binding._cacheIndex === null ) {

  						++ binding.referenceCount;
  						this$1._addInactiveBinding( binding, rootUuid, trackName );

  					}

  					continue;

  				}

  				var path = prototypeAction && prototypeAction.
  					_propertyBindings[ i ].binding.parsedPath;

  				binding = new PropertyMixer(
  					PropertyBinding.create( root, trackName, path ),
  					track.ValueTypeName, track.getValueSize() );

  				++ binding.referenceCount;
  				this$1._addInactiveBinding( binding, rootUuid, trackName );

  				bindings[ i ] = binding;

  			}

  			interpolants[ i ].resultBuffer = binding.buffer;

  		}

  	},

  	_activateAction: function ( action ) {
  		var this$1 = this;


  		if ( ! this._isActiveAction( action ) ) {

  			if ( action._cacheIndex === null ) {

  				// this action has been forgotten by the cache, but the user
  				// appears to be still using it -> rebind

  				var rootUuid = ( action._localRoot || this._root ).uuid,
  					clipUuid = action._clip.uuid,
  					actionsForClip = this._actionsByClip[ clipUuid ];

  				this._bindAction( action,
  					actionsForClip && actionsForClip.knownActions[ 0 ] );

  				this._addInactiveAction( action, clipUuid, rootUuid );

  			}

  			var bindings = action._propertyBindings;

  			// increment reference counts / sort out state
  			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

  				var binding = bindings[ i ];

  				if ( binding.useCount ++ === 0 ) {

  					this$1._lendBinding( binding );
  					binding.saveOriginalState();

  				}

  			}

  			this._lendAction( action );

  		}

  	},

  	_deactivateAction: function ( action ) {
  		var this$1 = this;


  		if ( this._isActiveAction( action ) ) {

  			var bindings = action._propertyBindings;

  			// decrement reference counts / sort out state
  			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

  				var binding = bindings[ i ];

  				if ( -- binding.useCount === 0 ) {

  					binding.restoreOriginalState();
  					this$1._takeBackBinding( binding );

  				}

  			}

  			this._takeBackAction( action );

  		}

  	},

  	// Memory manager

  	_initMemoryManager: function () {

  		this._actions = []; // 'nActiveActions' followed by inactive ones
  		this._nActiveActions = 0;

  		this._actionsByClip = {};
  		// inside:
  		// {
  		// 		knownActions: Array< AnimationAction >	- used as prototypes
  		// 		actionByRoot: AnimationAction			- lookup
  		// }


  		this._bindings = []; // 'nActiveBindings' followed by inactive ones
  		this._nActiveBindings = 0;

  		this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


  		this._controlInterpolants = []; // same game as above
  		this._nActiveControlInterpolants = 0;

  		var scope = this;

  		this.stats = {

  			actions: {
  				get total() {

  					return scope._actions.length;

  				},
  				get inUse() {

  					return scope._nActiveActions;

  				}
  			},
  			bindings: {
  				get total() {

  					return scope._bindings.length;

  				},
  				get inUse() {

  					return scope._nActiveBindings;

  				}
  			},
  			controlInterpolants: {
  				get total() {

  					return scope._controlInterpolants.length;

  				},
  				get inUse() {

  					return scope._nActiveControlInterpolants;

  				}
  			}

  		};

  	},

  	// Memory management for AnimationAction objects

  	_isActiveAction: function ( action ) {

  		var index = action._cacheIndex;
  		return index !== null && index < this._nActiveActions;

  	},

  	_addInactiveAction: function ( action, clipUuid, rootUuid ) {

  		var actions = this._actions,
  			actionsByClip = this._actionsByClip,
  			actionsForClip = actionsByClip[ clipUuid ];

  		if ( actionsForClip === undefined ) {

  			actionsForClip = {

  				knownActions: [ action ],
  				actionByRoot: {}

  			};

  			action._byClipCacheIndex = 0;

  			actionsByClip[ clipUuid ] = actionsForClip;

  		} else {

  			var knownActions = actionsForClip.knownActions;

  			action._byClipCacheIndex = knownActions.length;
  			knownActions.push( action );

  		}

  		action._cacheIndex = actions.length;
  		actions.push( action );

  		actionsForClip.actionByRoot[ rootUuid ] = action;

  	},

  	_removeInactiveAction: function ( action ) {

  		var actions = this._actions,
  			lastInactiveAction = actions[ actions.length - 1 ],
  			cacheIndex = action._cacheIndex;

  		lastInactiveAction._cacheIndex = cacheIndex;
  		actions[ cacheIndex ] = lastInactiveAction;
  		actions.pop();

  		action._cacheIndex = null;


  		var clipUuid = action._clip.uuid,
  			actionsByClip = this._actionsByClip,
  			actionsForClip = actionsByClip[ clipUuid ],
  			knownActionsForClip = actionsForClip.knownActions,

  			lastKnownAction =
  				knownActionsForClip[ knownActionsForClip.length - 1 ],

  			byClipCacheIndex = action._byClipCacheIndex;

  		lastKnownAction._byClipCacheIndex = byClipCacheIndex;
  		knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
  		knownActionsForClip.pop();

  		action._byClipCacheIndex = null;


  		var actionByRoot = actionsForClip.actionByRoot,
  			rootUuid = ( action._localRoot || this._root ).uuid;

  		delete actionByRoot[ rootUuid ];

  		if ( knownActionsForClip.length === 0 ) {

  			delete actionsByClip[ clipUuid ];

  		}

  		this._removeInactiveBindingsForAction( action );

  	},

  	_removeInactiveBindingsForAction: function ( action ) {
  		var this$1 = this;


  		var bindings = action._propertyBindings;
  		for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

  			var binding = bindings[ i ];

  			if ( -- binding.referenceCount === 0 ) {

  				this$1._removeInactiveBinding( binding );

  			}

  		}

  	},

  	_lendAction: function ( action ) {

  		// [ active actions |  inactive actions  ]
  		// [  active actions >| inactive actions ]
  		//                 s        a
  		//                  <-swap->
  		//                 a        s

  		var actions = this._actions,
  			prevIndex = action._cacheIndex,

  			lastActiveIndex = this._nActiveActions ++,

  			firstInactiveAction = actions[ lastActiveIndex ];

  		action._cacheIndex = lastActiveIndex;
  		actions[ lastActiveIndex ] = action;

  		firstInactiveAction._cacheIndex = prevIndex;
  		actions[ prevIndex ] = firstInactiveAction;

  	},

  	_takeBackAction: function ( action ) {

  		// [  active actions  | inactive actions ]
  		// [ active actions |< inactive actions  ]
  		//        a        s
  		//         <-swap->
  		//        s        a

  		var actions = this._actions,
  			prevIndex = action._cacheIndex,

  			firstInactiveIndex = -- this._nActiveActions,

  			lastActiveAction = actions[ firstInactiveIndex ];

  		action._cacheIndex = firstInactiveIndex;
  		actions[ firstInactiveIndex ] = action;

  		lastActiveAction._cacheIndex = prevIndex;
  		actions[ prevIndex ] = lastActiveAction;

  	},

  	// Memory management for PropertyMixer objects

  	_addInactiveBinding: function ( binding, rootUuid, trackName ) {

  		var bindingsByRoot = this._bindingsByRootAndName,
  			bindingByName = bindingsByRoot[ rootUuid ],

  			bindings = this._bindings;

  		if ( bindingByName === undefined ) {

  			bindingByName = {};
  			bindingsByRoot[ rootUuid ] = bindingByName;

  		}

  		bindingByName[ trackName ] = binding;

  		binding._cacheIndex = bindings.length;
  		bindings.push( binding );

  	},

  	_removeInactiveBinding: function ( binding ) {

  		var bindings = this._bindings,
  			propBinding = binding.binding,
  			rootUuid = propBinding.rootNode.uuid,
  			trackName = propBinding.path,
  			bindingsByRoot = this._bindingsByRootAndName,
  			bindingByName = bindingsByRoot[ rootUuid ],

  			lastInactiveBinding = bindings[ bindings.length - 1 ],
  			cacheIndex = binding._cacheIndex;

  		lastInactiveBinding._cacheIndex = cacheIndex;
  		bindings[ cacheIndex ] = lastInactiveBinding;
  		bindings.pop();

  		delete bindingByName[ trackName ];

  		remove_empty_map: {

  			for ( var _ in bindingByName ) { break remove_empty_map; } // eslint-disable-line no-unused-vars

  			delete bindingsByRoot[ rootUuid ];

  		}

  	},

  	_lendBinding: function ( binding ) {

  		var bindings = this._bindings,
  			prevIndex = binding._cacheIndex,

  			lastActiveIndex = this._nActiveBindings ++,

  			firstInactiveBinding = bindings[ lastActiveIndex ];

  		binding._cacheIndex = lastActiveIndex;
  		bindings[ lastActiveIndex ] = binding;

  		firstInactiveBinding._cacheIndex = prevIndex;
  		bindings[ prevIndex ] = firstInactiveBinding;

  	},

  	_takeBackBinding: function ( binding ) {

  		var bindings = this._bindings,
  			prevIndex = binding._cacheIndex,

  			firstInactiveIndex = -- this._nActiveBindings,

  			lastActiveBinding = bindings[ firstInactiveIndex ];

  		binding._cacheIndex = firstInactiveIndex;
  		bindings[ firstInactiveIndex ] = binding;

  		lastActiveBinding._cacheIndex = prevIndex;
  		bindings[ prevIndex ] = lastActiveBinding;

  	},


  	// Memory management of Interpolants for weight and time scale

  	_lendControlInterpolant: function () {

  		var interpolants = this._controlInterpolants,
  			lastActiveIndex = this._nActiveControlInterpolants ++,
  			interpolant = interpolants[ lastActiveIndex ];

  		if ( interpolant === undefined ) {

  			interpolant = new LinearInterpolant$1(
  				new Float32Array( 2 ), new Float32Array( 2 ),
  				1, this._controlInterpolantsResultBuffer );

  			interpolant.__cacheIndex = lastActiveIndex;
  			interpolants[ lastActiveIndex ] = interpolant;

  		}

  		return interpolant;

  	},

  	_takeBackControlInterpolant: function ( interpolant ) {

  		var interpolants = this._controlInterpolants,
  			prevIndex = interpolant.__cacheIndex,

  			firstInactiveIndex = -- this._nActiveControlInterpolants,

  			lastActiveInterpolant = interpolants[ firstInactiveIndex ];

  		interpolant.__cacheIndex = firstInactiveIndex;
  		interpolants[ firstInactiveIndex ] = interpolant;

  		lastActiveInterpolant.__cacheIndex = prevIndex;
  		interpolants[ prevIndex ] = lastActiveInterpolant;

  	},

  	_controlInterpolantsResultBuffer: new Float32Array( 1 ),

  	// return an action for a clip optionally using a custom root target
  	// object (this method allocates a lot of dynamic memory in case a
  	// previously unknown clip/root combination is specified)
  	clipAction: function ( clip, optionalRoot ) {

  		var root = optionalRoot || this._root,
  			rootUuid = root.uuid,

  			clipObject = typeof clip === 'string' ?
  				AnimationClip$1.findByName( root, clip ) : clip,

  			clipUuid = clipObject !== null ? clipObject.uuid : clip,

  			actionsForClip = this._actionsByClip[ clipUuid ],
  			prototypeAction = null;

  		if ( actionsForClip !== undefined ) {

  			var existingAction =
  					actionsForClip.actionByRoot[ rootUuid ];

  			if ( existingAction !== undefined ) {

  				return existingAction;

  			}

  			// we know the clip, so we don't have to parse all
  			// the bindings again but can just copy
  			prototypeAction = actionsForClip.knownActions[ 0 ];

  			// also, take the clip from the prototype action
  			if ( clipObject === null )
  				{ clipObject = prototypeAction._clip; }

  		}

  		// clip must be known when specified via string
  		if ( clipObject === null ) { return null; }

  		// allocate all resources required to run it
  		var newAction = new AnimationAction( this, clipObject, optionalRoot );

  		this._bindAction( newAction, prototypeAction );

  		// and make the action known to the memory manager
  		this._addInactiveAction( newAction, clipUuid, rootUuid );

  		return newAction;

  	},

  	// get an existing action
  	existingAction: function ( clip, optionalRoot ) {

  		var root = optionalRoot || this._root,
  			rootUuid = root.uuid,

  			clipObject = typeof clip === 'string' ?
  				AnimationClip$1.findByName( root, clip ) : clip,

  			clipUuid = clipObject ? clipObject.uuid : clip,

  			actionsForClip = this._actionsByClip[ clipUuid ];

  		if ( actionsForClip !== undefined ) {

  			return actionsForClip.actionByRoot[ rootUuid ] || null;

  		}

  		return null;

  	},

  	// deactivates all previously scheduled actions
  	stopAllAction: function () {

  		var actions = this._actions,
  			nActions = this._nActiveActions,
  			bindings = this._bindings,
  			nBindings = this._nActiveBindings;

  		this._nActiveActions = 0;
  		this._nActiveBindings = 0;

  		for ( var i = 0; i !== nActions; ++ i ) {

  			actions[ i ].reset();

  		}

  		for ( var i = 0; i !== nBindings; ++ i ) {

  			bindings[ i ].useCount = 0;

  		}

  		return this;

  	},

  	// advance the time and update apply the animation
  	update: function ( deltaTime ) {

  		deltaTime *= this.timeScale;

  		var actions = this._actions,
  			nActions = this._nActiveActions,

  			time = this.time += deltaTime,
  			timeDirection = Math.sign( deltaTime ),

  			accuIndex = this._accuIndex ^= 1;

  		// run active actions

  		for ( var i = 0; i !== nActions; ++ i ) {

  			var action = actions[ i ];

  			action._update( time, deltaTime, timeDirection, accuIndex );

  		}

  		// update scene graph

  		var bindings = this._bindings,
  			nBindings = this._nActiveBindings;

  		for ( var i = 0; i !== nBindings; ++ i ) {

  			bindings[ i ].apply( accuIndex );

  		}

  		return this;

  	},

  	// return this mixer's root target object
  	getRoot: function () {

  		return this._root;

  	},

  	// free all resources specific to a particular clip
  	uncacheClip: function ( clip ) {
  		var this$1 = this;


  		var actions = this._actions,
  			clipUuid = clip.uuid,
  			actionsByClip = this._actionsByClip,
  			actionsForClip = actionsByClip[ clipUuid ];

  		if ( actionsForClip !== undefined ) {

  			// note: just calling _removeInactiveAction would mess up the
  			// iteration state and also require updating the state we can
  			// just throw away

  			var actionsToRemove = actionsForClip.knownActions;

  			for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

  				var action = actionsToRemove[ i ];

  				this$1._deactivateAction( action );

  				var cacheIndex = action._cacheIndex,
  					lastInactiveAction = actions[ actions.length - 1 ];

  				action._cacheIndex = null;
  				action._byClipCacheIndex = null;

  				lastInactiveAction._cacheIndex = cacheIndex;
  				actions[ cacheIndex ] = lastInactiveAction;
  				actions.pop();

  				this$1._removeInactiveBindingsForAction( action );

  			}

  			delete actionsByClip[ clipUuid ];

  		}

  	},

  	// free all resources specific to a particular root target object
  	uncacheRoot: function ( root ) {
  		var this$1 = this;


  		var rootUuid = root.uuid,
  			actionsByClip = this._actionsByClip;

  		for ( var clipUuid in actionsByClip ) {

  			var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
  				action = actionByRoot[ rootUuid ];

  			if ( action !== undefined ) {

  				this$1._deactivateAction( action );
  				this$1._removeInactiveAction( action );

  			}

  		}

  		var bindingsByRoot = this._bindingsByRootAndName,
  			bindingByName = bindingsByRoot[ rootUuid ];

  		if ( bindingByName !== undefined ) {

  			for ( var trackName in bindingByName ) {

  				var binding = bindingByName[ trackName ];
  				binding.restoreOriginalState();
  				this$1._removeInactiveBinding( binding );

  			}

  		}

  	},

  	// remove a targeted clip from the cache
  	uncacheAction: function ( clip, optionalRoot ) {

  		var action = this.existingAction( clip, optionalRoot );

  		if ( action !== null ) {

  			this._deactivateAction( action );
  			this._removeInactiveAction( action );

  		}

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function Uniform( value ) {

  	if ( typeof value === 'string' ) {

  		console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
  		value = arguments[ 1 ];

  	}

  	this.value = value;

  }

  Uniform.prototype.clone = function () {

  	return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );

  };

  /**
   * @author benaadams / https://twitter.com/ben_a_adams
   */

  function InstancedBufferGeometry() {

  	BufferGeometry$1.call( this );

  	this.type = 'InstancedBufferGeometry';
  	this.maxInstancedCount = undefined;

  }

  InstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry$1.prototype ), {

  	constructor: InstancedBufferGeometry,

  	isInstancedBufferGeometry: true,

  	copy: function ( source ) {

  		BufferGeometry$1.prototype.copy.call( this, source );

  		this.maxInstancedCount = source.maxInstancedCount;

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	}

  } );

  /**
   * @author benaadams / https://twitter.com/ben_a_adams
   */

  function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {

  	this.uuid = _Math$1.generateUUID();

  	this.data = interleavedBuffer;
  	this.itemSize = itemSize;
  	this.offset = offset;

  	this.normalized = normalized === true;

  }

  Object.defineProperties( InterleavedBufferAttribute.prototype, {

  	count: {

  		get: function () {

  			return this.data.count;

  		}

  	},

  	array: {

  		get: function () {

  			return this.data.array;

  		}

  	}

  } );

  Object.assign( InterleavedBufferAttribute.prototype, {

  	isInterleavedBufferAttribute: true,

  	setX: function ( index, x ) {

  		this.data.array[ index * this.data.stride + this.offset ] = x;

  		return this;

  	},

  	setY: function ( index, y ) {

  		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

  		return this;

  	},

  	setZ: function ( index, z ) {

  		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

  		return this;

  	},

  	setW: function ( index, w ) {

  		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

  		return this;

  	},

  	getX: function ( index ) {

  		return this.data.array[ index * this.data.stride + this.offset ];

  	},

  	getY: function ( index ) {

  		return this.data.array[ index * this.data.stride + this.offset + 1 ];

  	},

  	getZ: function ( index ) {

  		return this.data.array[ index * this.data.stride + this.offset + 2 ];

  	},

  	getW: function ( index ) {

  		return this.data.array[ index * this.data.stride + this.offset + 3 ];

  	},

  	setXY: function ( index, x, y ) {

  		index = index * this.data.stride + this.offset;

  		this.data.array[ index + 0 ] = x;
  		this.data.array[ index + 1 ] = y;

  		return this;

  	},

  	setXYZ: function ( index, x, y, z ) {

  		index = index * this.data.stride + this.offset;

  		this.data.array[ index + 0 ] = x;
  		this.data.array[ index + 1 ] = y;
  		this.data.array[ index + 2 ] = z;

  		return this;

  	},

  	setXYZW: function ( index, x, y, z, w ) {

  		index = index * this.data.stride + this.offset;

  		this.data.array[ index + 0 ] = x;
  		this.data.array[ index + 1 ] = y;
  		this.data.array[ index + 2 ] = z;
  		this.data.array[ index + 3 ] = w;

  		return this;

  	}

  } );

  /**
   * @author benaadams / https://twitter.com/ben_a_adams
   */

  function InterleavedBuffer( array, stride ) {

  	this.uuid = _Math$1.generateUUID();

  	this.array = array;
  	this.stride = stride;
  	this.count = array !== undefined ? array.length / stride : 0;

  	this.dynamic = false;
  	this.updateRange = { offset: 0, count: - 1 };

  	this.onUploadCallback = function () {};

  	this.version = 0;

  }

  Object.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {

  	set: function ( value ) {

  		if ( value === true ) { this.version ++; }

  	}

  } );

  Object.assign( InterleavedBuffer.prototype, {

  	isInterleavedBuffer: true,

  	setArray: function ( array ) {

  		if ( Array.isArray( array ) ) {

  			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

  		}

  		this.count = array !== undefined ? array.length / this.stride : 0;
  		this.array = array;

  	},

  	setDynamic: function ( value ) {

  		this.dynamic = value;

  		return this;

  	},

  	copy: function ( source ) {

  		this.array = new source.array.constructor( source.array );
  		this.count = source.count;
  		this.stride = source.stride;
  		this.dynamic = source.dynamic;

  		return this;

  	},

  	copyAt: function ( index1, attribute, index2 ) {
  		var this$1 = this;


  		index1 *= this.stride;
  		index2 *= attribute.stride;

  		for ( var i = 0, l = this.stride; i < l; i ++ ) {

  			this$1.array[ index1 + i ] = attribute.array[ index2 + i ];

  		}

  		return this;

  	},

  	set: function ( value, offset ) {

  		if ( offset === undefined ) { offset = 0; }

  		this.array.set( value, offset );

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	onUpload: function ( callback ) {

  		this.onUploadCallback = callback;

  		return this;

  	}

  } );

  /**
   * @author benaadams / https://twitter.com/ben_a_adams
   */

  function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {

  	InterleavedBuffer.call( this, array, stride );

  	this.meshPerAttribute = meshPerAttribute || 1;

  }

  InstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {

  	constructor: InstancedInterleavedBuffer,

  	isInstancedInterleavedBuffer: true,

  	copy: function ( source ) {

  		InterleavedBuffer.prototype.copy.call( this, source );

  		this.meshPerAttribute = source.meshPerAttribute;

  		return this;

  	}

  } );

  /**
   * @author benaadams / https://twitter.com/ben_a_adams
   */

  function InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {

  	BufferAttribute$1.call( this, array, itemSize );

  	this.meshPerAttribute = meshPerAttribute || 1;

  }

  InstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute$1.prototype ), {

  	constructor: InstancedBufferAttribute,

  	isInstancedBufferAttribute: true,

  	copy: function ( source ) {

  		BufferAttribute$1.prototype.copy.call( this, source );

  		this.meshPerAttribute = source.meshPerAttribute;

  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author bhouston / http://clara.io/
   * @author stephomi / http://stephaneginier.com/
   */

  function Raycaster( origin, direction, near, far ) {

  	this.ray = new Ray$1( origin, direction );
  	// direction is assumed to be normalized (for accurate distance calculations)

  	this.near = near || 0;
  	this.far = far || Infinity;

  	this.params = {
  		Mesh: {},
  		Line: {},
  		LOD: {},
  		Points: { threshold: 1 },
  		Sprite: {}
  	};

  	Object.defineProperties( this.params, {
  		PointCloud: {
  			get: function () {

  				console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
  				return this.Points;

  			}
  		}
  	} );

  }

  function ascSort( a, b ) {

  	return a.distance - b.distance;

  }

  function intersectObject( object, raycaster, intersects, recursive ) {

  	if ( object.visible === false ) { return; }

  	object.raycast( raycaster, intersects );

  	if ( recursive === true ) {

  		var children = object.children;

  		for ( var i = 0, l = children.length; i < l; i ++ ) {

  			intersectObject( children[ i ], raycaster, intersects, true );

  		}

  	}

  }

  Object.assign( Raycaster.prototype, {

  	linePrecision: 1,

  	set: function ( origin, direction ) {

  		// direction is assumed to be normalized (for accurate distance calculations)

  		this.ray.set( origin, direction );

  	},

  	setFromCamera: function ( coords, camera ) {

  		if ( ( camera && camera.isPerspectiveCamera ) ) {

  			this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
  			this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

  		} else if ( ( camera && camera.isOrthographicCamera ) ) {

  			this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
  			this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

  		} else {

  			console.error( 'THREE.Raycaster: Unsupported camera type.' );

  		}

  	},

  	intersectObject: function ( object, recursive ) {

  		var intersects = [];

  		intersectObject( object, this, intersects, recursive );

  		intersects.sort( ascSort );

  		return intersects;

  	},

  	intersectObjects: function ( objects, recursive ) {
  		var this$1 = this;


  		var intersects = [];

  		if ( Array.isArray( objects ) === false ) {

  			console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
  			return intersects;

  		}

  		for ( var i = 0, l = objects.length; i < l; i ++ ) {

  			intersectObject( objects[ i ], this$1, intersects, recursive );

  		}

  		intersects.sort( ascSort );

  		return intersects;

  	}

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function Clock( autoStart ) {

  	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

  	this.startTime = 0;
  	this.oldTime = 0;
  	this.elapsedTime = 0;

  	this.running = false;

  }

  Object.assign( Clock.prototype, {

  	start: function () {

  		this.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732

  		this.oldTime = this.startTime;
  		this.elapsedTime = 0;
  		this.running = true;

  	},

  	stop: function () {

  		this.getElapsedTime();
  		this.running = false;
  		this.autoStart = false;

  	},

  	getElapsedTime: function () {

  		this.getDelta();
  		return this.elapsedTime;

  	},

  	getDelta: function () {

  		var diff = 0;

  		if ( this.autoStart && ! this.running ) {

  			this.start();
  			return 0;

  		}

  		if ( this.running ) {

  			var newTime = ( typeof performance === 'undefined' ? Date : performance ).now();

  			diff = ( newTime - this.oldTime ) / 1000;
  			this.oldTime = newTime;

  			this.elapsedTime += diff;

  		}

  		return diff;

  	}

  } );

  /**
   * @author bhouston / http://clara.io
   * @author WestLangley / http://github.com/WestLangley
   *
   * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
   *
   * The poles (phi) are at the positive and negative y axis.
   * The equator starts at positive z.
   */

  function Spherical$1( radius, phi, theta ) {

  	this.radius = ( radius !== undefined ) ? radius : 1.0;
  	this.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole
  	this.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere

  	return this;

  }

  Object.assign( Spherical$1.prototype, {

  	set: function ( radius, phi, theta ) {

  		this.radius = radius;
  		this.phi = phi;
  		this.theta = theta;

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( other ) {

  		this.radius = other.radius;
  		this.phi = other.phi;
  		this.theta = other.theta;

  		return this;

  	},

  	// restrict phi to be betwee EPS and PI-EPS
  	makeSafe: function () {

  		var EPS = 0.000001;
  		this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

  		return this;

  	},

  	setFromVector3: function ( vec3 ) {

  		this.radius = vec3.length();

  		if ( this.radius === 0 ) {

  			this.theta = 0;
  			this.phi = 0;

  		} else {

  			this.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis
  			this.phi = Math.acos( _Math$1.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle

  		}

  		return this;

  	}

  } );

  /**
   * @author Mugen87 / https://github.com/Mugen87
   *
   * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
   *
   */

  function Cylindrical( radius, theta, y ) {

  	this.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane
  	this.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
  	this.y = ( y !== undefined ) ? y : 0; // height above the x-z plane

  	return this;

  }

  Object.assign( Cylindrical.prototype, {

  	set: function ( radius, theta, y ) {

  		this.radius = radius;
  		this.theta = theta;
  		this.y = y;

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( other ) {

  		this.radius = other.radius;
  		this.theta = other.theta;
  		this.y = other.y;

  		return this;

  	},

  	setFromVector3: function ( vec3 ) {

  		this.radius = Math.sqrt( vec3.x * vec3.x + vec3.z * vec3.z );
  		this.theta = Math.atan2( vec3.x, vec3.z );
  		this.y = vec3.y;

  		return this;

  	}

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function ImmediateRenderObject( material ) {

  	Object3D$1.call( this );

  	this.material = material;
  	this.render = function ( /* renderCallback */ ) {};

  }

  ImmediateRenderObject.prototype = Object.create( Object3D$1.prototype );
  ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

  ImmediateRenderObject.prototype.isImmediateRenderObject = true;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author WestLangley / http://github.com/WestLangley
   */

  function VertexNormalsHelper( object, size, hex, linewidth ) {

  	this.object = object;

  	this.size = ( size !== undefined ) ? size : 1;

  	var color = ( hex !== undefined ) ? hex : 0xff0000;

  	var width = ( linewidth !== undefined ) ? linewidth : 1;

  	//

  	var nNormals = 0;

  	var objGeometry = this.object.geometry;

  	if ( objGeometry && objGeometry.isGeometry ) {

  		nNormals = objGeometry.faces.length * 3;

  	} else if ( objGeometry && objGeometry.isBufferGeometry ) {

  		nNormals = objGeometry.attributes.normal.count;

  	}

  	//

  	var geometry = new BufferGeometry$1();

  	var positions = new Float32BufferAttribute$1( nNormals * 2 * 3, 3 );

  	geometry.addAttribute( 'position', positions );

  	LineSegments$1.call( this, geometry, new LineBasicMaterial$1( { color: color, linewidth: width } ) );

  	//

  	this.matrixAutoUpdate = false;

  	this.update();

  }

  VertexNormalsHelper.prototype = Object.create( LineSegments$1.prototype );
  VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;

  VertexNormalsHelper.prototype.update = ( function () {

  	var v1 = new Vector3$2();
  	var v2 = new Vector3$2();
  	var normalMatrix = new Matrix3$1();

  	return function update() {
  		var this$1 = this;


  		var keys = [ 'a', 'b', 'c' ];

  		this.object.updateMatrixWorld( true );

  		normalMatrix.getNormalMatrix( this.object.matrixWorld );

  		var matrixWorld = this.object.matrixWorld;

  		var position = this.geometry.attributes.position;

  		//

  		var objGeometry = this.object.geometry;

  		if ( objGeometry && objGeometry.isGeometry ) {

  			var vertices = objGeometry.vertices;

  			var faces = objGeometry.faces;

  			var idx = 0;

  			for ( var i = 0, l = faces.length; i < l; i ++ ) {

  				var face = faces[ i ];

  				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

  					var vertex = vertices[ face[ keys[ j ] ] ];

  					var normal = face.vertexNormals[ j ];

  					v1.copy( vertex ).applyMatrix4( matrixWorld );

  					v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this$1.size ).add( v1 );

  					position.setXYZ( idx, v1.x, v1.y, v1.z );

  					idx = idx + 1;

  					position.setXYZ( idx, v2.x, v2.y, v2.z );

  					idx = idx + 1;

  				}

  			}

  		} else if ( objGeometry && objGeometry.isBufferGeometry ) {

  			var objPos = objGeometry.attributes.position;

  			var objNorm = objGeometry.attributes.normal;

  			var idx = 0;

  			// for simplicity, ignore index and drawcalls, and render every normal

  			for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

  				v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

  				v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

  				v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this$1.size ).add( v1 );

  				position.setXYZ( idx, v1.x, v1.y, v1.z );

  				idx = idx + 1;

  				position.setXYZ( idx, v2.x, v2.y, v2.z );

  				idx = idx + 1;

  			}

  		}

  		position.needsUpdate = true;

  	};

  }() );

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   * @author WestLangley / http://github.com/WestLangley
   */

  function SpotLightHelper( light, color ) {

  	Object3D$1.call( this );

  	this.light = light;
  	this.light.updateMatrixWorld();

  	this.matrix = light.matrixWorld;
  	this.matrixAutoUpdate = false;

  	this.color = color;

  	var geometry = new BufferGeometry$1();

  	var positions = [
  		0, 0, 0, 	0, 0, 1,
  		0, 0, 0, 	1, 0, 1,
  		0, 0, 0,	- 1, 0, 1,
  		0, 0, 0, 	0, 1, 1,
  		0, 0, 0, 	0, - 1, 1
  	];

  	for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

  		var p1 = ( i / l ) * Math.PI * 2;
  		var p2 = ( j / l ) * Math.PI * 2;

  		positions.push(
  			Math.cos( p1 ), Math.sin( p1 ), 1,
  			Math.cos( p2 ), Math.sin( p2 ), 1
  		);

  	}

  	geometry.addAttribute( 'position', new Float32BufferAttribute$1( positions, 3 ) );

  	var material = new LineBasicMaterial$1( { fog: false } );

  	this.cone = new LineSegments$1( geometry, material );
  	this.add( this.cone );

  	this.update();

  }

  SpotLightHelper.prototype = Object.create( Object3D$1.prototype );
  SpotLightHelper.prototype.constructor = SpotLightHelper;

  SpotLightHelper.prototype.dispose = function () {

  	this.cone.geometry.dispose();
  	this.cone.material.dispose();

  };

  SpotLightHelper.prototype.update = function () {

  	var vector = new Vector3$2();
  	var vector2 = new Vector3$2();

  	return function update() {

  		this.light.updateMatrixWorld();

  		var coneLength = this.light.distance ? this.light.distance : 1000;
  		var coneWidth = coneLength * Math.tan( this.light.angle );

  		this.cone.scale.set( coneWidth, coneWidth, coneLength );

  		vector.setFromMatrixPosition( this.light.matrixWorld );
  		vector2.setFromMatrixPosition( this.light.target.matrixWorld );

  		this.cone.lookAt( vector2.sub( vector ) );

  		if ( this.color !== undefined ) {

  			this.cone.material.color.set( this.color );

  		} else {

  			this.cone.material.color.copy( this.light.color );

  		}

  	};

  }();

  /**
   * @author Sean Griffin / http://twitter.com/sgrif
   * @author Michael Guerrero / http://realitymeltdown.com
   * @author mrdoob / http://mrdoob.com/
   * @author ikerr / http://verold.com
   * @author Mugen87 / https://github.com/Mugen87
   */

  function getBoneList( object ) {

  	var boneList = [];

  	if ( object && object.isBone ) {

  		boneList.push( object );

  	}

  	for ( var i = 0; i < object.children.length; i ++ ) {

  		boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );

  	}

  	return boneList;

  }

  function SkeletonHelper( object ) {

  	var bones = getBoneList( object );

  	var geometry = new BufferGeometry$1();

  	var vertices = [];
  	var colors = [];

  	var color1 = new Color$1( 0, 0, 1 );
  	var color2 = new Color$1( 0, 1, 0 );

  	for ( var i = 0; i < bones.length; i ++ ) {

  		var bone = bones[ i ];

  		if ( bone.parent && bone.parent.isBone ) {

  			vertices.push( 0, 0, 0 );
  			vertices.push( 0, 0, 0 );
  			colors.push( color1.r, color1.g, color1.b );
  			colors.push( color2.r, color2.g, color2.b );

  		}

  	}

  	geometry.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	geometry.addAttribute( 'color', new Float32BufferAttribute$1( colors, 3 ) );

  	var material = new LineBasicMaterial$1( { vertexColors: VertexColors$1, depthTest: false, depthWrite: false, transparent: true } );

  	LineSegments$1.call( this, geometry, material );

  	this.root = object;
  	this.bones = bones;

  	this.matrix = object.matrixWorld;
  	this.matrixAutoUpdate = false;

  }

  SkeletonHelper.prototype = Object.create( LineSegments$1.prototype );
  SkeletonHelper.prototype.constructor = SkeletonHelper;

  SkeletonHelper.prototype.updateMatrixWorld = function () {

  	var vector = new Vector3$2();

  	var boneMatrix = new Matrix4$1();
  	var matrixWorldInv = new Matrix4$1();

  	return function updateMatrixWorld( force ) {

  		var bones = this.bones;

  		var geometry = this.geometry;
  		var position = geometry.getAttribute( 'position' );

  		matrixWorldInv.getInverse( this.root.matrixWorld );

  		for ( var i = 0, j = 0; i < bones.length; i ++ ) {

  			var bone = bones[ i ];

  			if ( bone.parent && bone.parent.isBone ) {

  				boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
  				vector.setFromMatrixPosition( boneMatrix );
  				position.setXYZ( j, vector.x, vector.y, vector.z );

  				boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
  				vector.setFromMatrixPosition( boneMatrix );
  				position.setXYZ( j + 1, vector.x, vector.y, vector.z );

  				j += 2;

  			}

  		}

  		geometry.getAttribute( 'position' ).needsUpdate = true;

  		Object3D$1.prototype.updateMatrixWorld.call( this, force );

  	};

  }();

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   */

  function PointLightHelper( light, sphereSize, color ) {

  	this.light = light;
  	this.light.updateMatrixWorld();

  	this.color = color;

  	var geometry = new SphereBufferGeometry$1( sphereSize, 4, 2 );
  	var material = new MeshBasicMaterial$1( { wireframe: true, fog: false } );

  	Mesh$1.call( this, geometry, material );

  	this.matrix = this.light.matrixWorld;
  	this.matrixAutoUpdate = false;

  	this.update();


  	/*
  	var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
  	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

  	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
  	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

  	var d = light.distance;

  	if ( d === 0.0 ) {

  		this.lightDistance.visible = false;

  	} else {

  		this.lightDistance.scale.set( d, d, d );

  	}

  	this.add( this.lightDistance );
  	*/

  }

  PointLightHelper.prototype = Object.create( Mesh$1.prototype );
  PointLightHelper.prototype.constructor = PointLightHelper;

  PointLightHelper.prototype.dispose = function () {

  	this.geometry.dispose();
  	this.material.dispose();

  };

  PointLightHelper.prototype.update = function () {

  	if ( this.color !== undefined ) {

  		this.material.color.set( this.color );

  	} else {

  		this.material.color.copy( this.light.color );

  	}

  	/*
  	var d = this.light.distance;

  	if ( d === 0.0 ) {

  		this.lightDistance.visible = false;

  	} else {

  		this.lightDistance.visible = true;
  		this.lightDistance.scale.set( d, d, d );

  	}
  	*/

  };

  /**
   * @author abelnation / http://github.com/abelnation
   * @author Mugen87 / http://github.com/Mugen87
   * @author WestLangley / http://github.com/WestLangley
   */

  function RectAreaLightHelper( light, color ) {

  	Object3D$1.call( this );

  	this.light = light;
  	this.light.updateMatrixWorld();

  	this.matrix = light.matrixWorld;
  	this.matrixAutoUpdate = false;

  	this.color = color;

  	var material = new LineBasicMaterial$1( { fog: false } );

  	var geometry = new BufferGeometry$1();

  	geometry.addAttribute( 'position', new BufferAttribute$1( new Float32Array( 5 * 3 ), 3 ) );

  	this.line = new Line$1( geometry, material );
  	this.add( this.line );


  	this.update();

  }

  RectAreaLightHelper.prototype = Object.create( Object3D$1.prototype );
  RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;

  RectAreaLightHelper.prototype.dispose = function () {

  	this.children[ 0 ].geometry.dispose();
  	this.children[ 0 ].material.dispose();

  };

  RectAreaLightHelper.prototype.update = function () {

  	// calculate new dimensions of the helper

  	var hx = this.light.width * 0.5;
  	var hy = this.light.height * 0.5;

  	var position = this.line.geometry.attributes.position;
  	var array = position.array;

  	// update vertices

  	array[ 0 ] = hx; array[ 1 ] = - hy; array[ 2 ] = 0;
  	array[ 3 ] = hx; array[ 4 ] = hy; array[ 5 ] = 0;
  	array[ 6 ] = - hx; array[ 7 ] = hy; array[ 8 ] = 0;
  	array[ 9 ] = - hx; array[ 10 ] = - hy; array[ 11 ] = 0;
  	array[ 12 ] = hx; array[ 13 ] = - hy; array[ 14 ] = 0;

  	position.needsUpdate = true;

  	if ( this.color !== undefined ) {

  		this.line.material.color.set( this.color );

  	} else {

  		this.line.material.color.copy( this.light.color );

  	}

  };

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */

  function HemisphereLightHelper( light, size, color ) {

  	Object3D$1.call( this );

  	this.light = light;
  	this.light.updateMatrixWorld();

  	this.matrix = light.matrixWorld;
  	this.matrixAutoUpdate = false;

  	this.color = color;

  	var geometry = new OctahedronBufferGeometry$1( size );
  	geometry.rotateY( Math.PI * 0.5 );

  	this.material = new MeshBasicMaterial$1( { wireframe: true, fog: false } );
  	if ( this.color === undefined ) { this.material.vertexColors = VertexColors$1; }

  	var position = geometry.getAttribute( 'position' );
  	var colors = new Float32Array( position.count * 3 );

  	geometry.addAttribute( 'color', new BufferAttribute$1( colors, 3 ) );

  	this.add( new Mesh$1( geometry, this.material ) );

  	this.update();

  }

  HemisphereLightHelper.prototype = Object.create( Object3D$1.prototype );
  HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;

  HemisphereLightHelper.prototype.dispose = function () {

  	this.children[ 0 ].geometry.dispose();
  	this.children[ 0 ].material.dispose();

  };

  HemisphereLightHelper.prototype.update = function () {

  	var vector = new Vector3$2();

  	var color1 = new Color$1();
  	var color2 = new Color$1();

  	return function update() {

  		var mesh = this.children[ 0 ];

  		if ( this.color !== undefined ) {

  			this.material.color.set( this.color );

  		} else {

  			var colors = mesh.geometry.getAttribute( 'color' );

  			color1.copy( this.light.color );
  			color2.copy( this.light.groundColor );

  			for ( var i = 0, l = colors.count; i < l; i ++ ) {

  				var color = ( i < ( l / 2 ) ) ? color1 : color2;

  				colors.setXYZ( i, color.r, color.g, color.b );

  			}

  			colors.needsUpdate = true;

  		}

  		mesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );

  	};

  }();

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function GridHelper( size, divisions, color1, color2 ) {

  	size = size || 10;
  	divisions = divisions || 10;
  	color1 = new Color$1( color1 !== undefined ? color1 : 0x444444 );
  	color2 = new Color$1( color2 !== undefined ? color2 : 0x888888 );

  	var center = divisions / 2;
  	var step = size / divisions;
  	var halfSize = size / 2;

  	var vertices = [], colors = [];

  	for ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

  		vertices.push( - halfSize, 0, k, halfSize, 0, k );
  		vertices.push( k, 0, - halfSize, k, 0, halfSize );

  		var color = i === center ? color1 : color2;

  		color.toArray( colors, j ); j += 3;
  		color.toArray( colors, j ); j += 3;
  		color.toArray( colors, j ); j += 3;
  		color.toArray( colors, j ); j += 3;

  	}

  	var geometry = new BufferGeometry$1();
  	geometry.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	geometry.addAttribute( 'color', new Float32BufferAttribute$1( colors, 3 ) );

  	var material = new LineBasicMaterial$1( { vertexColors: VertexColors$1 } );

  	LineSegments$1.call( this, geometry, material );

  }

  GridHelper.prototype = Object.create( LineSegments$1.prototype );
  GridHelper.prototype.constructor = GridHelper;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / http://github.com/Mugen87
   * @author Hectate / http://www.github.com/Hectate
   */

  function PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {

  	radius = radius || 10;
  	radials = radials || 16;
  	circles = circles || 8;
  	divisions = divisions || 64;
  	color1 = new Color$1( color1 !== undefined ? color1 : 0x444444 );
  	color2 = new Color$1( color2 !== undefined ? color2 : 0x888888 );

  	var vertices = [];
  	var colors = [];

  	var x, z;
  	var v, i, j, r, color;

  	// create the radials

  	for ( i = 0; i <= radials; i ++ ) {

  		v = ( i / radials ) * ( Math.PI * 2 );

  		x = Math.sin( v ) * radius;
  		z = Math.cos( v ) * radius;

  		vertices.push( 0, 0, 0 );
  		vertices.push( x, 0, z );

  		color = ( i & 1 ) ? color1 : color2;

  		colors.push( color.r, color.g, color.b );
  		colors.push( color.r, color.g, color.b );

  	}

  	// create the circles

  	for ( i = 0; i <= circles; i ++ ) {

  		color = ( i & 1 ) ? color1 : color2;

  		r = radius - ( radius / circles * i );

  		for ( j = 0; j < divisions; j ++ ) {

  			// first vertex

  			v = ( j / divisions ) * ( Math.PI * 2 );

  			x = Math.sin( v ) * r;
  			z = Math.cos( v ) * r;

  			vertices.push( x, 0, z );
  			colors.push( color.r, color.g, color.b );

  			// second vertex

  			v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );

  			x = Math.sin( v ) * r;
  			z = Math.cos( v ) * r;

  			vertices.push( x, 0, z );
  			colors.push( color.r, color.g, color.b );

  		}

  	}

  	var geometry = new BufferGeometry$1();
  	geometry.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	geometry.addAttribute( 'color', new Float32BufferAttribute$1( colors, 3 ) );

  	var material = new LineBasicMaterial$1( { vertexColors: VertexColors$1 } );

  	LineSegments$1.call( this, geometry, material );

  }

  PolarGridHelper.prototype = Object.create( LineSegments$1.prototype );
  PolarGridHelper.prototype.constructor = PolarGridHelper;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author WestLangley / http://github.com/WestLangley
   */

  function FaceNormalsHelper( object, size, hex, linewidth ) {

  	// FaceNormalsHelper only supports THREE.Geometry

  	this.object = object;

  	this.size = ( size !== undefined ) ? size : 1;

  	var color = ( hex !== undefined ) ? hex : 0xffff00;

  	var width = ( linewidth !== undefined ) ? linewidth : 1;

  	//

  	var nNormals = 0;

  	var objGeometry = this.object.geometry;

  	if ( objGeometry && objGeometry.isGeometry ) {

  		nNormals = objGeometry.faces.length;

  	} else {

  		console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

  	}

  	//

  	var geometry = new BufferGeometry$1();

  	var positions = new Float32BufferAttribute$1( nNormals * 2 * 3, 3 );

  	geometry.addAttribute( 'position', positions );

  	LineSegments$1.call( this, geometry, new LineBasicMaterial$1( { color: color, linewidth: width } ) );

  	//

  	this.matrixAutoUpdate = false;
  	this.update();

  }

  FaceNormalsHelper.prototype = Object.create( LineSegments$1.prototype );
  FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;

  FaceNormalsHelper.prototype.update = ( function () {

  	var v1 = new Vector3$2();
  	var v2 = new Vector3$2();
  	var normalMatrix = new Matrix3$1();

  	return function update() {
  		var this$1 = this;


  		this.object.updateMatrixWorld( true );

  		normalMatrix.getNormalMatrix( this.object.matrixWorld );

  		var matrixWorld = this.object.matrixWorld;

  		var position = this.geometry.attributes.position;

  		//

  		var objGeometry = this.object.geometry;

  		var vertices = objGeometry.vertices;

  		var faces = objGeometry.faces;

  		var idx = 0;

  		for ( var i = 0, l = faces.length; i < l; i ++ ) {

  			var face = faces[ i ];

  			var normal = face.normal;

  			v1.copy( vertices[ face.a ] )
  				.add( vertices[ face.b ] )
  				.add( vertices[ face.c ] )
  				.divideScalar( 3 )
  				.applyMatrix4( matrixWorld );

  			v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this$1.size ).add( v1 );

  			position.setXYZ( idx, v1.x, v1.y, v1.z );

  			idx = idx + 1;

  			position.setXYZ( idx, v2.x, v2.y, v2.z );

  			idx = idx + 1;

  		}

  		position.needsUpdate = true;

  	};

  }() );

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   * @author WestLangley / http://github.com/WestLangley
   */

  function DirectionalLightHelper( light, size, color ) {

  	Object3D$1.call( this );

  	this.light = light;
  	this.light.updateMatrixWorld();

  	this.matrix = light.matrixWorld;
  	this.matrixAutoUpdate = false;

  	this.color = color;

  	if ( size === undefined ) { size = 1; }

  	var geometry = new BufferGeometry$1();
  	geometry.addAttribute( 'position', new Float32BufferAttribute$1( [
  		- size, size, 0,
  		size, size, 0,
  		size, - size, 0,
  		- size, - size, 0,
  		- size, size, 0
  	], 3 ) );

  	var material = new LineBasicMaterial$1( { fog: false } );

  	this.lightPlane = new Line$1( geometry, material );
  	this.add( this.lightPlane );

  	geometry = new BufferGeometry$1();
  	geometry.addAttribute( 'position', new Float32BufferAttribute$1( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

  	this.targetLine = new Line$1( geometry, material );
  	this.add( this.targetLine );

  	this.update();

  }

  DirectionalLightHelper.prototype = Object.create( Object3D$1.prototype );
  DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;

  DirectionalLightHelper.prototype.dispose = function () {

  	this.lightPlane.geometry.dispose();
  	this.lightPlane.material.dispose();
  	this.targetLine.geometry.dispose();
  	this.targetLine.material.dispose();

  };

  DirectionalLightHelper.prototype.update = function () {

  	var v1 = new Vector3$2();
  	var v2 = new Vector3$2();
  	var v3 = new Vector3$2();

  	return function update() {

  		v1.setFromMatrixPosition( this.light.matrixWorld );
  		v2.setFromMatrixPosition( this.light.target.matrixWorld );
  		v3.subVectors( v2, v1 );

  		this.lightPlane.lookAt( v3 );

  		if ( this.color !== undefined ) {

  			this.lightPlane.material.color.set( this.color );
  			this.targetLine.material.color.set( this.color );

  		} else {

  			this.lightPlane.material.color.copy( this.light.color );
  			this.targetLine.material.color.copy( this.light.color );

  		}

  		this.targetLine.lookAt( v3 );
  		this.targetLine.scale.z = v3.length();

  	};

  }();

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author Mugen87 / https://github.com/Mugen87
   *
   *	- shows frustum, line of sight and up of the camera
   *	- suitable for fast updates
   * 	- based on frustum visualization in lightgl.js shadowmap example
   *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
   */

  function CameraHelper( camera ) {

  	var geometry = new BufferGeometry$1();
  	var material = new LineBasicMaterial$1( { color: 0xffffff, vertexColors: FaceColors$1 } );

  	var vertices = [];
  	var colors = [];

  	var pointMap = {};

  	// colors

  	var colorFrustum = new Color$1( 0xffaa00 );
  	var colorCone = new Color$1( 0xff0000 );
  	var colorUp = new Color$1( 0x00aaff );
  	var colorTarget = new Color$1( 0xffffff );
  	var colorCross = new Color$1( 0x333333 );

  	// near

  	addLine( 'n1', 'n2', colorFrustum );
  	addLine( 'n2', 'n4', colorFrustum );
  	addLine( 'n4', 'n3', colorFrustum );
  	addLine( 'n3', 'n1', colorFrustum );

  	// far

  	addLine( 'f1', 'f2', colorFrustum );
  	addLine( 'f2', 'f4', colorFrustum );
  	addLine( 'f4', 'f3', colorFrustum );
  	addLine( 'f3', 'f1', colorFrustum );

  	// sides

  	addLine( 'n1', 'f1', colorFrustum );
  	addLine( 'n2', 'f2', colorFrustum );
  	addLine( 'n3', 'f3', colorFrustum );
  	addLine( 'n4', 'f4', colorFrustum );

  	// cone

  	addLine( 'p', 'n1', colorCone );
  	addLine( 'p', 'n2', colorCone );
  	addLine( 'p', 'n3', colorCone );
  	addLine( 'p', 'n4', colorCone );

  	// up

  	addLine( 'u1', 'u2', colorUp );
  	addLine( 'u2', 'u3', colorUp );
  	addLine( 'u3', 'u1', colorUp );

  	// target

  	addLine( 'c', 't', colorTarget );
  	addLine( 'p', 'c', colorCross );

  	// cross

  	addLine( 'cn1', 'cn2', colorCross );
  	addLine( 'cn3', 'cn4', colorCross );

  	addLine( 'cf1', 'cf2', colorCross );
  	addLine( 'cf3', 'cf4', colorCross );

  	function addLine( a, b, color ) {

  		addPoint( a, color );
  		addPoint( b, color );

  	}

  	function addPoint( id, color ) {

  		vertices.push( 0, 0, 0 );
  		colors.push( color.r, color.g, color.b );

  		if ( pointMap[ id ] === undefined ) {

  			pointMap[ id ] = [];

  		}

  		pointMap[ id ].push( ( vertices.length / 3 ) - 1 );

  	}

  	geometry.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	geometry.addAttribute( 'color', new Float32BufferAttribute$1( colors, 3 ) );

  	LineSegments$1.call( this, geometry, material );

  	this.camera = camera;
  	if ( this.camera.updateProjectionMatrix ) { this.camera.updateProjectionMatrix(); }

  	this.matrix = camera.matrixWorld;
  	this.matrixAutoUpdate = false;

  	this.pointMap = pointMap;

  	this.update();

  }

  CameraHelper.prototype = Object.create( LineSegments$1.prototype );
  CameraHelper.prototype.constructor = CameraHelper;

  CameraHelper.prototype.update = function () {

  	var geometry, pointMap;

  	var vector = new Vector3$2();
  	var camera = new Camera$1();

  	function setPoint( point, x, y, z ) {

  		vector.set( x, y, z ).unproject( camera );

  		var points = pointMap[ point ];

  		if ( points !== undefined ) {

  			var position = geometry.getAttribute( 'position' );

  			for ( var i = 0, l = points.length; i < l; i ++ ) {

  				position.setXYZ( points[ i ], vector.x, vector.y, vector.z );

  			}

  		}

  	}

  	return function update() {

  		geometry = this.geometry;
  		pointMap = this.pointMap;

  		var w = 1, h = 1;

  		// we need just camera projection matrix
  		// world matrix must be identity

  		camera.projectionMatrix.copy( this.camera.projectionMatrix );

  		// center / target

  		setPoint( 'c', 0, 0, - 1 );
  		setPoint( 't', 0, 0, 1 );

  		// near

  		setPoint( 'n1', - w, - h, - 1 );
  		setPoint( 'n2', w, - h, - 1 );
  		setPoint( 'n3', - w, h, - 1 );
  		setPoint( 'n4', w, h, - 1 );

  		// far

  		setPoint( 'f1', - w, - h, 1 );
  		setPoint( 'f2', w, - h, 1 );
  		setPoint( 'f3', - w, h, 1 );
  		setPoint( 'f4', w, h, 1 );

  		// up

  		setPoint( 'u1', w * 0.7, h * 1.1, - 1 );
  		setPoint( 'u2', - w * 0.7, h * 1.1, - 1 );
  		setPoint( 'u3', 0, h * 2, - 1 );

  		// cross

  		setPoint( 'cf1', - w, 0, 1 );
  		setPoint( 'cf2', w, 0, 1 );
  		setPoint( 'cf3', 0, - h, 1 );
  		setPoint( 'cf4', 0, h, 1 );

  		setPoint( 'cn1', - w, 0, - 1 );
  		setPoint( 'cn2', w, 0, - 1 );
  		setPoint( 'cn3', 0, - h, - 1 );
  		setPoint( 'cn4', 0, h, - 1 );

  		geometry.getAttribute( 'position' ).needsUpdate = true;

  	};

  }();

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / http://github.com/Mugen87
   */

  function BoxHelper( object, color ) {

  	this.object = object;

  	if ( color === undefined ) { color = 0xffff00; }

  	var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
  	var positions = new Float32Array( 8 * 3 );

  	var geometry = new BufferGeometry$1();
  	geometry.setIndex( new BufferAttribute$1( indices, 1 ) );
  	geometry.addAttribute( 'position', new BufferAttribute$1( positions, 3 ) );

  	LineSegments$1.call( this, geometry, new LineBasicMaterial$1( { color: color } ) );

  	this.matrixAutoUpdate = false;

  	this.update();

  }

  BoxHelper.prototype = Object.create( LineSegments$1.prototype );
  BoxHelper.prototype.constructor = BoxHelper;

  BoxHelper.prototype.update = ( function () {

  	var box = new Box3$1();

  	return function update( object ) {

  		if ( object !== undefined ) {

  			console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );

  		}

  		if ( this.object !== undefined ) {

  			box.setFromObject( this.object );

  		}

  		if ( box.isEmpty() ) { return; }

  		var min = box.min;
  		var max = box.max;

  		/*
  		  5____4
  		1/___0/|
  		| 6__|_7
  		2/___3/

  		0: max.x, max.y, max.z
  		1: min.x, max.y, max.z
  		2: min.x, min.y, max.z
  		3: max.x, min.y, max.z
  		4: max.x, max.y, min.z
  		5: min.x, max.y, min.z
  		6: min.x, min.y, min.z
  		7: max.x, min.y, min.z
  		*/

  		var position = this.geometry.attributes.position;
  		var array = position.array;

  		array[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;
  		array[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;
  		array[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;
  		array[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
  		array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
  		array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
  		array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
  		array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

  		position.needsUpdate = true;

  		this.geometry.computeBoundingSphere();

  	};

  } )();

  BoxHelper.prototype.setFromObject = function ( object ) {

  	this.object = object;
  	this.update();

  	return this;

  };

  /**
   * @author WestLangley / http://github.com/WestLangley
   */

  function Box3Helper( box, hex ) {

  	this.type = 'Box3Helper';

  	this.box = box;

  	var color = ( hex !== undefined ) ? hex : 0xffff00;

  	var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );

  	var positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];

  	var geometry = new BufferGeometry$1();

  	geometry.setIndex( new BufferAttribute$1( indices, 1 ) );

  	geometry.addAttribute( 'position', new Float32BufferAttribute$1( positions, 3 ) );

  	LineSegments$1.call( this, geometry, new LineBasicMaterial$1( { color: color } ) );

  	this.geometry.computeBoundingSphere();

  }

  Box3Helper.prototype = Object.create( LineSegments$1.prototype );
  Box3Helper.prototype.constructor = Box3Helper;

  Box3Helper.prototype.updateMatrixWorld = function ( force ) {

  	var box = this.box;

  	if ( box.isEmpty() ) { return; }

  	box.getCenter( this.position );

  	box.getSize( this.scale );

  	this.scale.multiplyScalar( 0.5 );

  	Object3D$1.prototype.updateMatrixWorld.call( this, force );

  };

  /**
   * @author WestLangley / http://github.com/WestLangley
   */

  function PlaneHelper( plane, size, hex ) {

  	this.type = 'PlaneHelper';

  	this.plane = plane;

  	this.size = ( size === undefined ) ? 1 : size;

  	var color = ( hex !== undefined ) ? hex : 0xffff00;

  	var positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];

  	var geometry = new BufferGeometry$1();
  	geometry.addAttribute( 'position', new Float32BufferAttribute$1( positions, 3 ) );
  	geometry.computeBoundingSphere();

  	Line$1.call( this, geometry, new LineBasicMaterial$1( { color: color } ) );

  	//

  	var positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];

  	var geometry2 = new BufferGeometry$1();
  	geometry2.addAttribute( 'position', new Float32BufferAttribute$1( positions2, 3 ) );
  	geometry2.computeBoundingSphere();

  	this.add( new Mesh$1( geometry2, new MeshBasicMaterial$1( { color: color, opacity: 0.2, transparent: true, depthWrite: false } ) ) );

  }

  PlaneHelper.prototype = Object.create( Line$1.prototype );
  PlaneHelper.prototype.constructor = PlaneHelper;

  PlaneHelper.prototype.updateMatrixWorld = function ( force ) {

  	var scale = - this.plane.constant;

  	if ( Math.abs( scale ) < 1e-8 ) { scale = 1e-8; } // sign does not matter

  	this.scale.set( 0.5 * this.size, 0.5 * this.size, scale );

  	this.lookAt( this.plane.normal );

  	Object3D$1.prototype.updateMatrixWorld.call( this, force );

  };

  /**
   * @author WestLangley / http://github.com/WestLangley
   * @author zz85 / http://github.com/zz85
   * @author bhouston / http://clara.io
   *
   * Creates an arrow for visualizing directions
   *
   * Parameters:
   *  dir - Vector3
   *  origin - Vector3
   *  length - Number
   *  color - color in hex value
   *  headLength - Number
   *  headWidth - Number
   */

  var lineGeometry;
  var coneGeometry;

  function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

  	// dir is assumed to be normalized

  	Object3D$1.call( this );

  	if ( color === undefined ) { color = 0xffff00; }
  	if ( length === undefined ) { length = 1; }
  	if ( headLength === undefined ) { headLength = 0.2 * length; }
  	if ( headWidth === undefined ) { headWidth = 0.2 * headLength; }

  	if ( lineGeometry === undefined ) {

  		lineGeometry = new BufferGeometry$1();
  		lineGeometry.addAttribute( 'position', new Float32BufferAttribute$1( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

  		coneGeometry = new CylinderBufferGeometry$1( 0, 0.5, 1, 5, 1 );
  		coneGeometry.translate( 0, - 0.5, 0 );

  	}

  	this.position.copy( origin );

  	this.line = new Line$1( lineGeometry, new LineBasicMaterial$1( { color: color } ) );
  	this.line.matrixAutoUpdate = false;
  	this.add( this.line );

  	this.cone = new Mesh$1( coneGeometry, new MeshBasicMaterial$1( { color: color } ) );
  	this.cone.matrixAutoUpdate = false;
  	this.add( this.cone );

  	this.setDirection( dir );
  	this.setLength( length, headLength, headWidth );

  }

  ArrowHelper.prototype = Object.create( Object3D$1.prototype );
  ArrowHelper.prototype.constructor = ArrowHelper;

  ArrowHelper.prototype.setDirection = ( function () {

  	var axis = new Vector3$2();
  	var radians;

  	return function setDirection( dir ) {

  		// dir is assumed to be normalized

  		if ( dir.y > 0.99999 ) {

  			this.quaternion.set( 0, 0, 0, 1 );

  		} else if ( dir.y < - 0.99999 ) {

  			this.quaternion.set( 1, 0, 0, 0 );

  		} else {

  			axis.set( dir.z, 0, - dir.x ).normalize();

  			radians = Math.acos( dir.y );

  			this.quaternion.setFromAxisAngle( axis, radians );

  		}

  	};

  }() );

  ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

  	if ( headLength === undefined ) { headLength = 0.2 * length; }
  	if ( headWidth === undefined ) { headWidth = 0.2 * headLength; }

  	this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
  	this.line.updateMatrix();

  	this.cone.scale.set( headWidth, headLength, headWidth );
  	this.cone.position.y = length;
  	this.cone.updateMatrix();

  };

  ArrowHelper.prototype.setColor = function ( color ) {

  	this.line.material.color.copy( color );
  	this.cone.material.color.copy( color );

  };

  /**
   * @author sroucheray / http://sroucheray.org/
   * @author mrdoob / http://mrdoob.com/
   */

  function AxisHelper( size ) {

  	size = size || 1;

  	var vertices = [
  		0, 0, 0,	size, 0, 0,
  		0, 0, 0,	0, size, 0,
  		0, 0, 0,	0, 0, size
  	];

  	var colors = [
  		1, 0, 0,	1, 0.6, 0,
  		0, 1, 0,	0.6, 1, 0,
  		0, 0, 1,	0, 0.6, 1
  	];

  	var geometry = new BufferGeometry$1();
  	geometry.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	geometry.addAttribute( 'color', new Float32BufferAttribute$1( colors, 3 ) );

  	var material = new LineBasicMaterial$1( { vertexColors: VertexColors$1 } );

  	LineSegments$1.call( this, geometry, material );

  }

  AxisHelper.prototype = Object.create( LineSegments$1.prototype );
  AxisHelper.prototype.constructor = AxisHelper;

  /**
   * @author zz85 https://github.com/zz85
   *
   * Centripetal CatmullRom Curve - which is useful for avoiding
   * cusps and self-intersections in non-uniform catmull rom curves.
   * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
   *
   * curve.type accepts centripetal(default), chordal and catmullrom
   * curve.tension is used for catmullrom which defaults to 0.5
   */


  /*
  Based on an optimized c++ solution in
   - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
   - http://ideone.com/NoEbVM

  This CubicPoly class could be used for reusing some variables and calculations,
  but for three.js curve use, it could be possible inlined and flatten into a single function call
  which can be placed in CurveUtils.
  */

  function CubicPoly() {

  	var c0 = 0, c1 = 0, c2 = 0, c3 = 0;

  	/*
  	 * Compute coefficients for a cubic polynomial
  	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
  	 * such that
  	 *   p(0) = x0, p(1) = x1
  	 *  and
  	 *   p'(0) = t0, p'(1) = t1.
  	 */
  	function init( x0, x1, t0, t1 ) {

  		c0 = x0;
  		c1 = t0;
  		c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
  		c3 = 2 * x0 - 2 * x1 + t0 + t1;

  	}

  	return {

  		initCatmullRom: function ( x0, x1, x2, x3, tension ) {

  			init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

  		},

  		initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

  			// compute tangents when parameterized in [t1,t2]
  			var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
  			var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

  			// rescale tangents for parametrization in [0,1]
  			t1 *= dt1;
  			t2 *= dt1;

  			init( x1, x2, t1, t2 );

  		},

  		calc: function ( t ) {

  			var t2 = t * t;
  			var t3 = t2 * t;
  			return c0 + c1 * t + c2 * t2 + c3 * t3;

  		}

  	};

  }

  //

  var tmp = new Vector3$2();
  var px = new CubicPoly();
  var py = new CubicPoly();
  var pz = new CubicPoly();

  function CatmullRomCurve3( points ) {

  	Curve.call( this );

  	if ( points.length < 2 ) { console.warn( 'THREE.CatmullRomCurve3: Points array needs at least two entries.' ); }

  	this.points = points || [];
  	this.closed = false;

  }

  CatmullRomCurve3.prototype = Object.create( Curve.prototype );
  CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;

  CatmullRomCurve3.prototype.getPoint = function ( t ) {

  	var points = this.points;
  	var l = points.length;

  	var point = ( l - ( this.closed ? 0 : 1 ) ) * t;
  	var intPoint = Math.floor( point );
  	var weight = point - intPoint;

  	if ( this.closed ) {

  		intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

  	} else if ( weight === 0 && intPoint === l - 1 ) {

  		intPoint = l - 2;
  		weight = 1;

  	}

  	var p0, p1, p2, p3; // 4 points

  	if ( this.closed || intPoint > 0 ) {

  		p0 = points[ ( intPoint - 1 ) % l ];

  	} else {

  		// extrapolate first point
  		tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
  		p0 = tmp;

  	}

  	p1 = points[ intPoint % l ];
  	p2 = points[ ( intPoint + 1 ) % l ];

  	if ( this.closed || intPoint + 2 < l ) {

  		p3 = points[ ( intPoint + 2 ) % l ];

  	} else {

  		// extrapolate last point
  		tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
  		p3 = tmp;

  	}

  	if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {

  		// init Centripetal / Chordal Catmull-Rom
  		var pow = this.type === 'chordal' ? 0.5 : 0.25;
  		var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
  		var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
  		var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

  		// safety check for repeated points
  		if ( dt1 < 1e-4 ) { dt1 = 1.0; }
  		if ( dt0 < 1e-4 ) { dt0 = dt1; }
  		if ( dt2 < 1e-4 ) { dt2 = dt1; }

  		px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
  		py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
  		pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

  	} else if ( this.type === 'catmullrom' ) {

  		var tension = this.tension !== undefined ? this.tension : 0.5;
  		px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
  		py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
  		pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );

  	}

  	return new Vector3$2( px.calc( weight ), py.calc( weight ), pz.calc( weight ) );

  };

  function CubicBezierCurve3( v0, v1, v2, v3 ) {

  	Curve.call( this );

  	this.v0 = v0;
  	this.v1 = v1;
  	this.v2 = v2;
  	this.v3 = v3;

  }

  CubicBezierCurve3.prototype = Object.create( Curve.prototype );
  CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;

  CubicBezierCurve3.prototype.getPoint = function ( t ) {

  	var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

  	return new Vector3$2(
  		CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
  		CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
  		CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
  	);

  };

  function QuadraticBezierCurve3( v0, v1, v2 ) {

  	Curve.call( this );

  	this.v0 = v0;
  	this.v1 = v1;
  	this.v2 = v2;

  }

  QuadraticBezierCurve3.prototype = Object.create( Curve.prototype );
  QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;

  QuadraticBezierCurve3.prototype.getPoint = function ( t ) {

  	var v0 = this.v0, v1 = this.v1, v2 = this.v2;

  	return new Vector3$2(
  		QuadraticBezier( t, v0.x, v1.x, v2.x ),
  		QuadraticBezier( t, v0.y, v1.y, v2.y ),
  		QuadraticBezier( t, v0.z, v1.z, v2.z )
  	);

  };

  function LineCurve3( v1, v2 ) {

  	Curve.call( this );

  	this.v1 = v1;
  	this.v2 = v2;

  }

  LineCurve3.prototype = Object.create( Curve.prototype );
  LineCurve3.prototype.constructor = LineCurve3;

  LineCurve3.prototype.getPoint = function ( t ) {

  	if ( t === 1 ) {

  		return this.v2.clone();

  	}

  	var vector = new Vector3$2();

  	vector.subVectors( this.v2, this.v1 ); // diff
  	vector.multiplyScalar( t );
  	vector.add( this.v1 );

  	return vector;

  };

  function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

  	EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

  }

  ArcCurve.prototype = Object.create( EllipseCurve.prototype );
  ArcCurve.prototype.constructor = ArcCurve;

  //

  Curve.create = function ( construct, getPoint ) {

  	console.log( 'THREE.Curve.create() has been deprecated' );

  	construct.prototype = Object.create( Curve.prototype );
  	construct.prototype.constructor = construct;
  	construct.prototype.getPoint = getPoint;

  	return construct;

  };

  //

  function Spline( points ) {

  	console.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );

  	CatmullRomCurve3.call( this, points );
  	this.type = 'catmullrom';

  }

  Spline.prototype = Object.create( CatmullRomCurve3.prototype );

  Object.assign( Spline.prototype, {

  	initFromArray: function ( /* a */ ) {

  		console.error( 'THREE.Spline: .initFromArray() has been removed.' );

  	},
  	getControlPointsArray: function ( /* optionalTarget */ ) {

  		console.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );

  	},
  	reparametrizeByArcLength: function ( /* samplingCoef */ ) {

  		console.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );

  	}

  } );

  GridHelper.prototype.setColors = function () {

  	console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

  };

  SkeletonHelper.prototype.update = function () {

  	console.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );

  };

  //

  Object.assign( Box2.prototype, {

  	center: function ( optionalTarget ) {

  		console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
  		return this.getCenter( optionalTarget );

  	},
  	empty: function () {

  		console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
  		return this.isEmpty();

  	},
  	isIntersectionBox: function ( box ) {

  		console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
  		return this.intersectsBox( box );

  	},
  	size: function ( optionalTarget ) {

  		console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
  		return this.getSize( optionalTarget );

  	}
  } );

  Object.assign( Box3$1.prototype, {

  	center: function ( optionalTarget ) {

  		console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
  		return this.getCenter( optionalTarget );

  	},
  	empty: function () {

  		console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
  		return this.isEmpty();

  	},
  	isIntersectionBox: function ( box ) {

  		console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
  		return this.intersectsBox( box );

  	},
  	isIntersectionSphere: function ( sphere ) {

  		console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
  		return this.intersectsSphere( sphere );

  	},
  	size: function ( optionalTarget ) {

  		console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
  		return this.getSize( optionalTarget );

  	}
  } );

  Line3$1.prototype.center = function ( optionalTarget ) {

  	console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
  	return this.getCenter( optionalTarget );

  };

  Object.assign( _Math$1, {

  	random16: function () {

  		console.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' );
  		return Math.random();

  	},

  	nearestPowerOfTwo: function ( value ) {

  		console.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );
  		return _Math$1.floorPowerOfTwo( value );

  	},

  	nextPowerOfTwo: function ( value ) {

  		console.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );
  		return _Math$1.ceilPowerOfTwo( value );

  	}

  } );

  Object.assign( Matrix3$1.prototype, {

  	flattenToArrayOffset: function ( array, offset ) {

  		console.warn( "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
  		return this.toArray( array, offset );

  	},
  	multiplyVector3: function ( vector ) {

  		console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
  		return vector.applyMatrix3( this );

  	},
  	multiplyVector3Array: function ( /* a */ ) {

  		console.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );

  	},
  	applyToBuffer: function ( buffer /* offset, length */ ) {

  		console.warn( 'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
  		return this.applyToBufferAttribute( buffer );

  	},
  	applyToVector3Array: function ( /* array, offset, length */ ) {

  		console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );

  	}

  } );

  Object.assign( Matrix4$1.prototype, {

  	extractPosition: function ( m ) {

  		console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
  		return this.copyPosition( m );

  	},
  	flattenToArrayOffset: function ( array, offset ) {

  		console.warn( "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
  		return this.toArray( array, offset );

  	},
  	getPosition: function () {

  		var v1;

  		return function getPosition() {

  			if ( v1 === undefined ) { v1 = new Vector3$2(); }
  			console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
  			return v1.setFromMatrixColumn( this, 3 );

  		};

  	}(),
  	setRotationFromQuaternion: function ( q ) {

  		console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
  		return this.makeRotationFromQuaternion( q );

  	},
  	multiplyToArray: function () {

  		console.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );

  	},
  	multiplyVector3: function ( vector ) {

  		console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
  		return vector.applyMatrix4( this );

  	},
  	multiplyVector4: function ( vector ) {

  		console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
  		return vector.applyMatrix4( this );

  	},
  	multiplyVector3Array: function ( /* a */ ) {

  		console.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );

  	},
  	rotateAxis: function ( v ) {

  		console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
  		v.transformDirection( this );

  	},
  	crossVector: function ( vector ) {

  		console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
  		return vector.applyMatrix4( this );

  	},
  	translate: function () {

  		console.error( 'THREE.Matrix4: .translate() has been removed.' );

  	},
  	rotateX: function () {

  		console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

  	},
  	rotateY: function () {

  		console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

  	},
  	rotateZ: function () {

  		console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

  	},
  	rotateByAxis: function () {

  		console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

  	},
  	applyToBuffer: function ( buffer /* offset, length */ ) {

  		console.warn( 'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
  		return this.applyToBufferAttribute( buffer );

  	},
  	applyToVector3Array: function ( /* array, offset, length */ ) {

  		console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );

  	},
  	makeFrustum: function ( left, right, bottom, top, near, far ) {

  		console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
  		return this.makePerspective( left, right, top, bottom, near, far );

  	}

  } );

  Plane$1.prototype.isIntersectionLine = function ( line ) {

  	console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
  	return this.intersectsLine( line );

  };

  Quaternion$1.prototype.multiplyVector3 = function ( vector ) {

  	console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
  	return vector.applyQuaternion( this );

  };

  Object.assign( Ray$1.prototype, {

  	isIntersectionBox: function ( box ) {

  		console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
  		return this.intersectsBox( box );

  	},
  	isIntersectionPlane: function ( plane ) {

  		console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
  		return this.intersectsPlane( plane );

  	},
  	isIntersectionSphere: function ( sphere ) {

  		console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
  		return this.intersectsSphere( sphere );

  	}

  } );

  Object.assign( Shape.prototype, {

  	extrude: function ( options ) {

  		console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
  		return new ExtrudeGeometry$1( this, options );

  	},
  	makeGeometry: function ( options ) {

  		console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
  		return new ShapeGeometry$1( this, options );

  	}

  } );

  Object.assign( Vector2$1.prototype, {

  	fromAttribute: function ( attribute, index, offset ) {

  		console.error( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
  		return this.fromBufferAttribute( attribute, index, offset );

  	}

  } );

  Object.assign( Vector3$2.prototype, {

  	setEulerFromRotationMatrix: function () {

  		console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

  	},
  	setEulerFromQuaternion: function () {

  		console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

  	},
  	getPositionFromMatrix: function ( m ) {

  		console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
  		return this.setFromMatrixPosition( m );

  	},
  	getScaleFromMatrix: function ( m ) {

  		console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
  		return this.setFromMatrixScale( m );

  	},
  	getColumnFromMatrix: function ( index, matrix ) {

  		console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
  		return this.setFromMatrixColumn( matrix, index );

  	},
  	applyProjection: function ( m ) {

  		console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
  		return this.applyMatrix4( m );

  	},
  	fromAttribute: function ( attribute, index, offset ) {

  		console.error( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
  		return this.fromBufferAttribute( attribute, index, offset );

  	}

  } );

  Object.assign( Vector4$1.prototype, {

  	fromAttribute: function ( attribute, index, offset ) {

  		console.error( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
  		return this.fromBufferAttribute( attribute, index, offset );

  	}

  } );

  //

  Geometry$1.prototype.computeTangents = function () {

  	console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );

  };

  Object.assign( Object3D$1.prototype, {

  	getChildByName: function ( name ) {

  		console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
  		return this.getObjectByName( name );

  	},
  	renderDepth: function () {

  		console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

  	},
  	translate: function ( distance, axis ) {

  		console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
  		return this.translateOnAxis( axis, distance );

  	}

  } );

  Object.defineProperties( Object3D$1.prototype, {

  	eulerOrder: {
  		get: function () {

  			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
  			return this.rotation.order;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
  			this.rotation.order = value;

  		}
  	},
  	useQuaternion: {
  		get: function () {

  			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

  		},
  		set: function () {

  			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

  		}
  	}

  } );

  Object.defineProperties( LOD$1.prototype, {

  	objects: {
  		get: function () {

  			console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
  			return this.levels;

  		}
  	}

  } );

  Object.defineProperty( Skeleton$1.prototype, 'useVertexTexture', {

  	get: function () {

  		console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

  	},
  	set: function () {

  		console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

  	}

  } );

  Object.defineProperty( Curve.prototype, '__arcLengthDivisions', {

  	get: function () {

  		console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
  		return this.arcLengthDivisions;

  	},
  	set: function ( value ) {

  		console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
  		this.arcLengthDivisions = value;

  	}

  } );

  //

  PerspectiveCamera$1.prototype.setLens = function ( focalLength, filmGauge ) {

  	console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
  			"Use .setFocalLength and .filmGauge for a photographic setup." );

  	if ( filmGauge !== undefined ) { this.filmGauge = filmGauge; }
  	this.setFocalLength( focalLength );

  };

  //

  Object.defineProperties( Light$1.prototype, {
  	onlyShadow: {
  		set: function () {

  			console.warn( 'THREE.Light: .onlyShadow has been removed.' );

  		}
  	},
  	shadowCameraFov: {
  		set: function ( value ) {

  			console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
  			this.shadow.camera.fov = value;

  		}
  	},
  	shadowCameraLeft: {
  		set: function ( value ) {

  			console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
  			this.shadow.camera.left = value;

  		}
  	},
  	shadowCameraRight: {
  		set: function ( value ) {

  			console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
  			this.shadow.camera.right = value;

  		}
  	},
  	shadowCameraTop: {
  		set: function ( value ) {

  			console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
  			this.shadow.camera.top = value;

  		}
  	},
  	shadowCameraBottom: {
  		set: function ( value ) {

  			console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
  			this.shadow.camera.bottom = value;

  		}
  	},
  	shadowCameraNear: {
  		set: function ( value ) {

  			console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
  			this.shadow.camera.near = value;

  		}
  	},
  	shadowCameraFar: {
  		set: function ( value ) {

  			console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
  			this.shadow.camera.far = value;

  		}
  	},
  	shadowCameraVisible: {
  		set: function () {

  			console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );

  		}
  	},
  	shadowBias: {
  		set: function ( value ) {

  			console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
  			this.shadow.bias = value;

  		}
  	},
  	shadowDarkness: {
  		set: function () {

  			console.warn( 'THREE.Light: .shadowDarkness has been removed.' );

  		}
  	},
  	shadowMapWidth: {
  		set: function ( value ) {

  			console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
  			this.shadow.mapSize.width = value;

  		}
  	},
  	shadowMapHeight: {
  		set: function ( value ) {

  			console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
  			this.shadow.mapSize.height = value;

  		}
  	}
  } );

  //

  Object.defineProperties( BufferAttribute$1.prototype, {

  	length: {
  		get: function () {

  			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
  			return this.array.length;

  		}
  	}

  } );

  Object.assign( BufferGeometry$1.prototype, {

  	addIndex: function ( index ) {

  		console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
  		this.setIndex( index );

  	},
  	addDrawCall: function ( start, count, indexOffset ) {

  		if ( indexOffset !== undefined ) {

  			console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

  		}
  		console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
  		this.addGroup( start, count );

  	},
  	clearDrawCalls: function () {

  		console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
  		this.clearGroups();

  	},
  	computeTangents: function () {

  		console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );

  	},
  	computeOffsets: function () {

  		console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );

  	}

  } );

  Object.defineProperties( BufferGeometry$1.prototype, {

  	drawcalls: {
  		get: function () {

  			console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
  			return this.groups;

  		}
  	},
  	offsets: {
  		get: function () {

  			console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
  			return this.groups;

  		}
  	}

  } );

  //

  Object.defineProperties( Uniform.prototype, {

  	dynamic: {
  		set: function () {

  			console.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );

  		}
  	},
  	onUpdate: {
  		value: function () {

  			console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
  			return this;

  		}
  	}

  } );

  //

  Object.defineProperties( Material$1.prototype, {

  	wrapAround: {
  		get: function () {

  			console.warn( 'THREE.Material: .wrapAround has been removed.' );

  		},
  		set: function () {

  			console.warn( 'THREE.Material: .wrapAround has been removed.' );

  		}
  	},
  	wrapRGB: {
  		get: function () {

  			console.warn( 'THREE.Material: .wrapRGB has been removed.' );
  			return new Color$1();

  		}
  	},

  	shading: {
  		get: function () {

  			console.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
  			this.flatShading = ( value === FlatShading$1 );

  		}
  	}

  } );

  Object.defineProperties( MeshPhongMaterial$1.prototype, {

  	metal: {
  		get: function () {

  			console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
  			return false;

  		},
  		set: function () {

  			console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );

  		}
  	}

  } );

  Object.defineProperties( ShaderMaterial$1.prototype, {

  	derivatives: {
  		get: function () {

  			console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
  			return this.extensions.derivatives;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
  			this.extensions.derivatives = value;

  		}
  	}

  } );

  //

  Object.assign( WebGLRenderer.prototype, {

  	getCurrentRenderTarget: function () {

  		console.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );
  		return this.getRenderTarget();

  	},

  	getMaxAnisotropy: function () {

  		console.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );
  		return this.capabilities.getMaxAnisotropy();

  	},

  	getPrecision: function () {

  		console.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );
  		return this.capabilities.precision;

  	},

  	resetGLState: function () {

  		console.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );
  		return this.state.reset();

  	},

  	supportsFloatTextures: function () {

  		console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
  		return this.extensions.get( 'OES_texture_float' );

  	},
  	supportsHalfFloatTextures: function () {

  		console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
  		return this.extensions.get( 'OES_texture_half_float' );

  	},
  	supportsStandardDerivatives: function () {

  		console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
  		return this.extensions.get( 'OES_standard_derivatives' );

  	},
  	supportsCompressedTextureS3TC: function () {

  		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
  		return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );

  	},
  	supportsCompressedTexturePVRTC: function () {

  		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
  		return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );

  	},
  	supportsBlendMinMax: function () {

  		console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
  		return this.extensions.get( 'EXT_blend_minmax' );

  	},
  	supportsVertexTextures: function () {

  		console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
  		return this.capabilities.vertexTextures;

  	},
  	supportsInstancedArrays: function () {

  		console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
  		return this.extensions.get( 'ANGLE_instanced_arrays' );

  	},
  	enableScissorTest: function ( boolean ) {

  		console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
  		this.setScissorTest( boolean );

  	},
  	initMaterial: function () {

  		console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

  	},
  	addPrePlugin: function () {

  		console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

  	},
  	addPostPlugin: function () {

  		console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

  	},
  	updateShadowMap: function () {

  		console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

  	}

  } );

  Object.defineProperties( WebGLRenderer.prototype, {

  	shadowMapEnabled: {
  		get: function () {

  			return this.shadowMap.enabled;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
  			this.shadowMap.enabled = value;

  		}
  	},
  	shadowMapType: {
  		get: function () {

  			return this.shadowMap.type;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
  			this.shadowMap.type = value;

  		}
  	},
  	shadowMapCullFace: {
  		get: function () {

  			return this.shadowMap.cullFace;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
  			this.shadowMap.cullFace = value;

  		}
  	}
  } );

  Object.defineProperties( WebGLShadowMap.prototype, {

  	cullFace: {
  		get: function () {

  			return this.renderReverseSided ? CullFaceFront$1 : CullFaceBack$1;

  		},
  		set: function ( cullFace ) {

  			var value = ( cullFace !== CullFaceBack$1 );
  			console.warn( "WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + "." );
  			this.renderReverseSided = value;

  		}
  	}

  } );

  //

  Object.defineProperties( WebGLRenderTarget.prototype, {

  	wrapS: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
  			return this.texture.wrapS;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
  			this.texture.wrapS = value;

  		}
  	},
  	wrapT: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
  			return this.texture.wrapT;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
  			this.texture.wrapT = value;

  		}
  	},
  	magFilter: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
  			return this.texture.magFilter;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
  			this.texture.magFilter = value;

  		}
  	},
  	minFilter: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
  			return this.texture.minFilter;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
  			this.texture.minFilter = value;

  		}
  	},
  	anisotropy: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
  			return this.texture.anisotropy;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
  			this.texture.anisotropy = value;

  		}
  	},
  	offset: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
  			return this.texture.offset;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
  			this.texture.offset = value;

  		}
  	},
  	repeat: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
  			return this.texture.repeat;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
  			this.texture.repeat = value;

  		}
  	},
  	format: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
  			return this.texture.format;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
  			this.texture.format = value;

  		}
  	},
  	type: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
  			return this.texture.type;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
  			this.texture.type = value;

  		}
  	},
  	generateMipmaps: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
  			return this.texture.generateMipmaps;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
  			this.texture.generateMipmaps = value;

  		}
  	}

  } );

  //

  Audio.prototype.load = function ( file ) {

  	console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
  	var scope = this;
  	var audioLoader = new AudioLoader();
  	audioLoader.load( file, function ( buffer ) {

  		scope.setBuffer( buffer );

  	} );
  	return this;

  };

  AudioAnalyser.prototype.getData = function () {

  	console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
  	return this.getFrequencyData();

  };

  //

  CubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {

  	console.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );
  	return this.update( renderer, scene );

  };

  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};





  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var stats_min = createCommonjsModule(function (module, exports) {
  // stats.js - http://github.com/mrdoob/stats.js
  (function(f,e){module.exports=e();})(commonjsGlobal,function(){var f=function(){function e(a){c.appendChild(a.dom);return a}function u(a){for(var d=0;d<c.children.length;d++){ c.children[d].style.display=d===a?"block":"none"; }l=a;}var l=0,c=document.createElement("div");c.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000";c.addEventListener("click",function(a){a.preventDefault();
  u(++l%c.children.length);},!1);var k=(performance||Date).now(),g=k,a=0,r=e(new f.Panel("FPS","#0ff","#002")),h=e(new f.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory){ var t=e(new f.Panel("MB","#f08","#201")); }u(0);return{REVISION:16,dom:c,addPanel:e,showPanel:u,begin:function(){k=(performance||Date).now();},end:function(){a++;var c=(performance||Date).now();h.update(c-k,200);if(c>g+1E3&&(r.update(1E3*a/(c-g),100), g=c, a=0, t)){var d=performance.memory;t.update(d.usedJSHeapSize/
  1048576,d.jsHeapSizeLimit/1048576);}return c},update:function(){k=this.end();},domElement:c,setMode:u}};f.Panel=function(e,f,l){var c=Infinity,k=0,g=Math.round,a=g(window.devicePixelRatio||1),r=80*a,h=48*a,t=3*a,v=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement("canvas");q.width=r;q.height=h;q.style.cssText="width:80px;height:48px";var b=q.getContext("2d");b.font="bold "+9*a+"px Helvetica,Arial,sans-serif";b.textBaseline="top";b.fillStyle=l;b.fillRect(0,0,r,h);b.fillStyle=f;b.fillText(e,t,v);
  b.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(h,w){c=Math.min(c,h);k=Math.max(k,h);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=f;b.fillText(g(h)+" "+e+" ("+g(c)+"-"+g(k)+")",t,v);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,g((1-h/w)*p));}}};return f});
  });

  /**
   * @author szimek / https://github.com/szimek/
   * @author alteredq / http://alteredqualia.com/
   * @author Marius Kintel / https://github.com/kintel
   */

  /*
   In options, we can specify:
   * Texture parameters for an auto-generated target texture
   * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
  */
  function WebGLRenderTarget$1( width, height, options ) {

  	this.uuid = _Math.generateUUID();

  	this.width = width;
  	this.height = height;

  	this.scissor = new Vector4( 0, 0, width, height );
  	this.scissorTest = false;

  	this.viewport = new Vector4( 0, 0, width, height );

  	options = options || {};

  	if ( options.minFilter === undefined ) { options.minFilter = LinearFilter; }

  	this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

  	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
  	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
  	this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

  }

  Object.assign( WebGLRenderTarget$1.prototype, EventDispatcher.prototype, {

  	isWebGLRenderTarget: true,

  	setSize: function ( width, height ) {

  		if ( this.width !== width || this.height !== height ) {

  			this.width = width;
  			this.height = height;

  			this.dispose();

  		}

  		this.viewport.set( 0, 0, width, height );
  		this.scissor.set( 0, 0, width, height );

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( source ) {

  		this.width = source.width;
  		this.height = source.height;

  		this.viewport.copy( source.viewport );

  		this.texture = source.texture.clone();

  		this.depthBuffer = source.depthBuffer;
  		this.stencilBuffer = source.stencilBuffer;
  		this.depthTexture = source.depthTexture;

  		return this;

  	},

  	dispose: function () {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function StereoCamera$1() {

  	this.type = 'StereoCamera';

  	this.aspect = 1;

  	this.eyeSep = 0.064;

  	this.cameraL = new PerspectiveCamera();
  	this.cameraL.layers.enable( 1 );
  	this.cameraL.matrixAutoUpdate = false;

  	this.cameraR = new PerspectiveCamera();
  	this.cameraR.layers.enable( 2 );
  	this.cameraR.matrixAutoUpdate = false;

  }

  Object.assign( StereoCamera$1.prototype, {

  	update: ( function () {

  		var instance, focus, fov, aspect, near, far, zoom, eyeSep;

  		var eyeRight = new Matrix4();
  		var eyeLeft = new Matrix4();

  		return function update( camera ) {

  			var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
  												aspect !== camera.aspect * this.aspect || near !== camera.near ||
  												far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;

  			if ( needsUpdate ) {

  				instance = this;
  				focus = camera.focus;
  				fov = camera.fov;
  				aspect = camera.aspect * this.aspect;
  				near = camera.near;
  				far = camera.far;
  				zoom = camera.zoom;

  				// Off-axis stereoscopic effect based on
  				// http://paulbourke.net/stereographics/stereorender/

  				var projectionMatrix = camera.projectionMatrix.clone();
  				eyeSep = this.eyeSep / 2;
  				var eyeSepOnProjection = eyeSep * near / focus;
  				var ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;
  				var xmin, xmax;

  				// translate xOffset

  				eyeLeft.elements[ 12 ] = - eyeSep;
  				eyeRight.elements[ 12 ] = eyeSep;

  				// for left eye

  				xmin = - ymax * aspect + eyeSepOnProjection;
  				xmax = ymax * aspect + eyeSepOnProjection;

  				projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
  				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

  				this.cameraL.projectionMatrix.copy( projectionMatrix );

  				// for right eye

  				xmin = - ymax * aspect - eyeSepOnProjection;
  				xmax = ymax * aspect - eyeSepOnProjection;

  				projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
  				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

  				this.cameraR.projectionMatrix.copy( projectionMatrix );

  			}

  			this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
  			this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );

  		};

  	} )()

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author marklundin / http://mark-lundin.com/
   * @author alteredq / http://alteredqualia.com/
   * @author tschw
   */

  var AnaglyphEffect = function ( renderer, width, height ) {

  	// Matrices generated with angler.js https://github.com/tschw/angler.js/
  	// (in column-major element order, as accepted by WebGL)

  	this.colorMatrixLeft = new Matrix3().fromArray( [

  			1.0671679973602295, 	-0.0016435992438346148,		 0.0001777536963345483, // r out
  			-0.028107794001698494,	-0.00019593400065787137,	-0.0002875397040043026, // g out
  			-0.04279090091586113,	 0.000015809757314855233,	-0.00024287120322696865 // b out

  	] );

  	//		red						green 						blue  						in

  	this.colorMatrixRight = new Matrix3().fromArray( [

  			-0.0355340838432312,	-0.06440307199954987,		 0.018319187685847282,	// r out
  			-0.10269022732973099,	 0.8079727292060852,		-0.04835830628871918,	// g out
  			0.0001224992738571018,	-0.009558862075209618,		 0.567823588848114		// b out

  	] );

  	var _camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

  	var _scene = new Scene();

  	var _stereo = new StereoCamera$1();

  	var _params = { minFilter: LinearFilter, magFilter: NearestFilter, format: RGBAFormat };

  	if ( width === undefined ) { width = 512; }
  	if ( height === undefined ) { height = 512; }

  	var _renderTargetL = new WebGLRenderTarget$1( width, height, _params );
  	var _renderTargetR = new WebGLRenderTarget$1( width, height, _params );

  	var _material = new ShaderMaterial( {

  		uniforms: {

  			"mapLeft": { value: _renderTargetL.texture },
  			"mapRight": { value: _renderTargetR.texture },

  			"colorMatrixLeft": { value: this.colorMatrixLeft },
  			"colorMatrixRight": { value: this.colorMatrixRight }

  		},

  		vertexShader: [

  			"varying vec2 vUv;",

  			"void main() {",

  			"	vUv = vec2( uv.x, uv.y );",
  			"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

  			"}"

  		].join( "\n" ),

  		fragmentShader: [

  			"uniform sampler2D mapLeft;",
  			"uniform sampler2D mapRight;",
  			"varying vec2 vUv;",

  			"uniform mat3 colorMatrixLeft;",
  			"uniform mat3 colorMatrixRight;",

  			// These functions implement sRGB linearization and gamma correction

  			"float lin( float c ) {",
  			"	return c <= 0.04045 ? c * 0.0773993808 :",
  			"			pow( c * 0.9478672986 + 0.0521327014, 2.4 );",
  			"}",

  			"vec4 lin( vec4 c ) {",
  			"	return vec4( lin( c.r ), lin( c.g ), lin( c.b ), c.a );",
  			"}",

  			"float dev( float c ) {",
  			"	return c <= 0.0031308 ? c * 12.92",
  			"			: pow( c, 0.41666 ) * 1.055 - 0.055;",
  			"}",


  			"void main() {",

  			"	vec2 uv = vUv;",

  			"	vec4 colorL = lin( texture2D( mapLeft, uv ) );",
  			"	vec4 colorR = lin( texture2D( mapRight, uv ) );",

  			"	vec3 color = clamp(",
  			"			colorMatrixLeft * colorL.rgb +",
  			"			colorMatrixRight * colorR.rgb, 0., 1. );",

  			"	gl_FragColor = vec4(",
  			"			dev( color.r ), dev( color.g ), dev( color.b ),",
  			"			max( colorL.a, colorR.a ) );",

  			"}"

  		].join( "\n" )

  	} );

  	var mesh = new Mesh( new PlaneBufferGeometry( 2, 2 ), _material );
  	_scene.add( mesh );

  	this.setSize = function ( width, height ) {

  		renderer.setSize( width, height );

  		var pixelRatio = renderer.getPixelRatio();

  		_renderTargetL.setSize( width * pixelRatio, height * pixelRatio );
  		_renderTargetR.setSize( width * pixelRatio, height * pixelRatio );

  	};

  	this.render = function ( scene, camera ) {

  		scene.updateMatrixWorld();

  		if ( camera.parent === null ) { camera.updateMatrixWorld(); }

  		_stereo.update( camera );

  		renderer.render( scene, _stereo.cameraL, _renderTargetL, true );
  		renderer.render( scene, _stereo.cameraR, _renderTargetR, true );
  		renderer.render( _scene, _camera );

  	};

  	this.dispose = function() {

  		if ( _renderTargetL ) { _renderTargetL.dispose(); }
  		if ( _renderTargetR ) { _renderTargetR.dispose(); }

  	};

  };

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   * @author arodic / http://aleksandarrodic.com/
   * @author fonserbc / http://fonserbc.github.io/
  */

  var StereoEffect = function ( renderer ) {

  	var _stereo = new StereoCamera$1();
  	_stereo.aspect = 0.5;

  	this.setEyeSeparation = function ( eyeSep ) {

  		_stereo.eyeSep = eyeSep;

  	};

  	this.setSize = function ( width, height ) {

  		renderer.setSize( width, height );

  	};

  	this.render = function ( scene, camera ) {

  		scene.updateMatrixWorld();

  		if ( camera.parent === null ) { camera.updateMatrixWorld(); }

  		_stereo.update( camera );

  		var size = renderer.getSize();

  		if ( renderer.autoClear ) { renderer.clear(); }
  		renderer.setScissorTest( true );

  		renderer.setScissor( 0, 0, size.width / 2, size.height );
  		renderer.setViewport( 0, 0, size.width / 2, size.height );
  		renderer.render( scene, _stereo.cameraL );

  		renderer.setScissor( size.width / 2, 0, size.width / 2, size.height );
  		renderer.setViewport( size.width / 2, 0, size.width / 2, size.height );
  		renderer.render( scene, _stereo.cameraR );

  		renderer.setScissorTest( false );

  	};

  };

  /**
   * @author [Tristan Valcke]{@link https://github.com/Itee}
   * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
   *
   * @class TOrbitControlsHelper
   * @classdesc Todo...
   * @example Todo...
   *
   */

  function TOrbitControlsHelper ( orbitControls ) {

      if ( !orbitControls ) { throw new Error( 'Unable to create TOrbitControlsHelper for null or undefined controller !' ) }
      if ( !orbitControls instanceof OrbitControls ) { throw new Error( 'Parameter need to be an OrbitControls !' ) }

      var RADIUS    = 2;
      var RADIALS   = 16;
      var CIRCLES   = 2;
      var DIVISIONS = 64;
      var color1    = new Color( 0x444444 );
      var color2    = new Color( 0x888888 );

      var vertices = [];
      var colors   = [];

      var x, z;
      var v, i, j, r, color;

      // create the radials
      for ( i = 0 ; i <= RADIALS ; i++ ) {

          v = ( i / RADIALS ) * ( Math.PI * 2 );

          x = Math.sin( v ) * RADIUS;
          z = Math.cos( v ) * RADIUS;

          vertices.push( 0, 0, 0 );
          vertices.push( x, 0, z );

          color = ( i & 1 ) ? color1 : color2;

          colors.push( color.r, color.g, color.b );
          colors.push( color.r, color.g, color.b );

      }

      // create the circles
      for ( i = 0 ; i <= CIRCLES ; i++ ) {

          color = ( i & 1 ) ? color1 : color2;

          r = RADIUS - ( RADIUS / CIRCLES * i );

          for ( j = 0 ; j < DIVISIONS ; j++ ) {

              // first vertex
              v = ( j / DIVISIONS ) * ( Math.PI * 2 );

              x = Math.sin( v ) * r;
              z = Math.cos( v ) * r;

              vertices.push( x, 0, z );
              colors.push( color.r, color.g, color.b );

              // second vertex
              v = ( ( j + 1 ) / DIVISIONS ) * ( Math.PI * 2 );

              x = Math.sin( v ) * r;
              z = Math.cos( v ) * r;

              vertices.push( x, 0, z );
              colors.push( color.r, color.g, color.b );

          }

          // create axis
          vertices.push(
              -1, 0, 0, 1, 0, 0,
              0, -1, 0, 0, 1, 0,
              0, 0, -1, 0, 0, 1
          );
          colors.push(
              1, 0, 0, 1, 0.6, 0,
              0, 1, 0, 0.6, 1, 0,
              0, 0, 1, 0, 0.6, 1
          );

      }

      var geometry = new BufferGeometry();
      geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
      geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

      var material         = new LineBasicMaterial( { vertexColors: VertexColors } );
      material.transparent = true;
      material.opacity     = 0.0;

      LineSegments.call( this, geometry, material );

      this.control = orbitControls;
      this.control.addEventListener( 'start', this.startOpacityAnimation.bind( this ) );
      this.control.addEventListener( 'change', this.updateHelperPosition.bind( this ) );
      this.control.addEventListener( 'end', this.endOpacityAnimation.bind( this ) );

      this.intervalId = undefined;

  }

  TOrbitControlsHelper.prototype = Object.assign( Object.create( LineSegments.prototype ), {

      constructor: TOrbitControlsHelper,

      updateHelperPosition: function updateHelperPosition () {

          var target = this.control.target;

          this.position.x = target.x;
          this.position.y = target.y;
          this.position.z = target.z;

      },

      startOpacityAnimation: function startOpacityAnimation () {

          // In case fade off is running, kill it an restore opacity to 1
          if ( this.intervalId !== undefined ) {

              clearInterval( this.intervalId );
              this.intervalId = undefined;

          }

          this.material.opacity = 1.0;

      },

      endOpacityAnimation: function endOpacityAnimation () {

          // Manage transparency interval
          this.intervalId = setInterval( function () {

              if ( this.material.opacity <= 0.0 ) {

                  this.material.opacity = 0.0;
                  clearInterval( this.intervalId );
                  this.intervalId = undefined;

              } else {

                  this.material.opacity -= 0.1;

              }

          }.bind( this ), 100 );

      }

  } );

  /**
   * @author [Tristan Valcke]{@link https://github.com/Itee}
   * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
   *
   * @class TViewport
   * @classdesc The TViewport allow to manage in an easier way a webgl TViewport containing by default:<br>
   * scene, camera, camera controllers, camera effects, lights, renderder, and some helper
   *
   * @requires three.PCFSoftShadowMap
   * @requires three.Scene
   * @requires three.PerspectiveCamera
   * @requires three.WebGLRenderer
   * @requires three.FogExp2
   * @requires three.DirectionalLight
   * @requires three.Raycaster
   * @requires three.Vector2
   * @requires three.Color
   * @requires three.MeshPhongMaterial
   * @requires three.ArrowHelper
   * @requires three.OrbitControls(modularized)
   * @requires three.AnaglyphEffect(modularized)
   * @requires three.StereoEffect(modularized)
   * @requires stats.Stats
   * @requires objects3d.TOrbitControlsHelper
   *
   * @example Todo
   *
   */

  /* eslint-env browser */
  /* global $ */

  // extended three
  /**
   *
   * @param container
   * @constructor
   */
  function TViewport ( container ) {

      // First check if the given container exist, else throw an error
      if ( container === null || typeof container === 'undefined' || container.length === 0 ) {
          throw new Error( 'Required an container or a template to be create !' )
      }

      this.container       = container;
      this.containerWidth  = this.container.clientWidth; //outerWidth(true)
      this.containerHeight = this.container.clientHeight; //height()

      this.view = $( TViewport.getTemplate() );

      this.scene = new Scene$1();

      //    this.scene.add( new GridHelper(100, 100) )

      this.camera                   = new PerspectiveCamera$1();
      this.orbitControl             = new OrbitControls( this.camera, this.view.get( 0 ) );
      this.orbitControl.maxDistance = 2000;
      this.orbitControlHelper       = new TOrbitControlsHelper( this.orbitControl );
      this.scene.add( this.orbitControlHelper );

      this.cameraControl         = this.orbitControl;
      this.cameraControlType     = 'orbital';
      this.cameraControl.enabled = true;

      this.cameraEffect = 'normal';

      // Base renderer
      this.webGLRenderer = new WebGLRenderer( { antialias: true } );

      // Anaglyph effect
      this.anaglyphEffectRenderer = new AnaglyphEffect( this.webGLRenderer, this.containerWidth, this.containerHeight );

      // Creates the Stereo Effect for the VR experience.
      this.stereoEffectRenderer = new StereoEffect( this.webGLRenderer );

      // Current renderer
      this.renderer = this.webGLRenderer;

      $( this.webGLRenderer.domElement ).appendTo( this.view );

      this.measuring     = false;
      this.mouse         = new Vector2$1();
      this.isRaycastable = false;
      this.raycaster     = new Raycaster();
      this.raycastables  = [];
      this.intersection  = undefined;

      //    this.baseColor       = new Color( 0.7, 0.5, 0.1 )
      //    this.intersectColor  = new Color( 0.1, 0.5, 0.7 )

      this.backupIntersectedMaterial = undefined;
      this.backupSelectedMaterial    = undefined;
      this.intersectMaterial         = new MeshPhongMaterial$1( { color: new Color$1( 0.1, 0.5, 0.7 ) } );

      this.selected = undefined;
      //    this.selectedOutline = undefined

      this.settings = {
          camera:   {
              fov:      50,
              aspect:   (this.containerWidth / this.containerHeight),
              near:     0.01,
              far:      10000,
              position: {
                  x: 5.0,
                  y: 2.0,
                  z: -5.0
              },
              target:   {
                  x: 0.0,
                  y: 0.0,
                  z: 0.0
              }
          },
          showStat: true
      };

      //    this.clock = new Clock()

      this.view.appendTo( this.container );
      init.call( this );

      if ( this.settings.showStat ) {

          this.stats                           = new stats_min();
          this.stats.domElement.style.position = 'absolute';
          this.stats.domElement.style.top      = null;
          this.stats.domElement.style.left     = null;
          this.stats.domElement.style.right    = '0px';
          this.stats.domElement.style.bottom   = '0px';
          this.container.appendChild( this.stats.domElement );

      }

      this.autorun   = true;
      this.toggleCam = true;
      this.updateSizes();
      this.update();

      function init () {

          initCamera.call( this );
          initLight.call( this );
          initRender.call( this );
          initEvent.call( this );

      }

      function initCamera () {

          this.camera.fov        = this.settings.camera.fov;
          this.camera.aspect     = this.settings.camera.aspect;
          this.camera.near       = this.settings.camera.near;
          this.camera.far        = this.settings.camera.far;
          this.camera.position.x = this.settings.camera.position.x;
          this.camera.position.y = this.settings.camera.position.y;
          this.camera.position.z = this.settings.camera.position.z;

      }

      function initLight () {

          //        this.scene.add( new AmbientLight( 0xffffff ) );

          //        this.light = new SpotLight( 0x777777 )
          //        this.light.position.set( -700.0, 1800.0, 2000.0 )
          //        this.light.castShadow            = true
          //        this.light.shadow.mapSize.width  = 2048
          //        this.light.shadow.mapSize.height = 2048

          this.light = new DirectionalLight$1( 0xFFFFFF );
          this.light.position.set( -70.0, 180.0, 200.0 );
          this.light.castShadow            = true;
          this.light.shadow.mapSize.width  = 2048;
          this.light.shadow.mapSize.height = 2048;

          //        var lightHelper = new DirectionalLightHelper( this.light, 200, new Color(0.3, 0.5, 0.7) )
          //        this.scene.add( lightHelper )

          this.scene.add( this.light );

          //        this.scene.add( this.light )

      }

      function initRender () {

          this.webGLRenderer.setClearColor( 0x777777 );
          this.webGLRenderer.autoClear         = true;
          this.webGLRenderer.shadowMap.enabled = true;
          this.webGLRenderer.shadowMap.yype    = PCFSoftShadowMap$1;
      }

      function initEvent () {

          var self = this;

          window.addEventListener( 'resize', self.updateSizes.bind( self ), true );

          self.view[ 0 ].addEventListener( 'mousemove', this.updateRaycasting.bind( this ), false );
          self.view[ 0 ].addEventListener( 'mousedown', this.selectObject.bind( this ), false );

          self.orbitControl.addEventListener( 'rotate', self.decimateVisibleMeshes.bind( self ), true );
          self.orbitControl.addEventListener( 'pan', self.decimateVisibleMeshes.bind( self ), true );
          self.orbitControl.addEventListener( 'zoom', self.decimateVisibleMeshes.bind( self ), true );
          self.orbitControl.addEventListener( 'end', self.populateVisibleMeshes.bind( self ), true );

      }

  }

  // Static methods
  Object.assign( TViewport, {

      getTemplate: function getTemplate () {
          return '' +
              '<div class="webglViewport">' +
              '	<div id="tablet-controls-panel">' +
              '       <div id="progressBar" class="progress">' +
              '           <div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" style="width:0%">' +
              '               <span class="sr-only">0%</span>' +
              '           </div>' +
              '       </div>' +
              //            '		<div class="control">' +
              //            '			<a id="move-forward" data-toggle="tooltip" title="Avancer">' +
              //            '				<i class="fa fa-arrow-circle-up fa-4x"></i>' +
              //            '			</a>' +
              //            '		</div>' +
              //            '		<div class="control">' +
              //            '			<a id="move-backward" data-toggle="tooltip" title="Reculer">' +
              //            '				<i class="fa fa-arrow-circle-down fa-4x"></i>' +
              //            '			</a>' +
              //            '		</div>' +
              '	</div>' +
              '	<div id="camera-coordinates" style="color: white; position: absolute; top: 0px; margin-left: 10px;"></div>' +
              '</div>'
      }

  } );

  // Public methods
  Object.assign( TViewport.prototype, EventDispatcher$1.prototype, {

      toggleAutorun: function toggleAutorun () {

          // Toggle running state
          this.autorun = !this.autorun;
          // Restart loop if wanted
          if ( this.autorun ) {
              this.update();
          }

      },

      toggleCamera: function toggleCamera () {

          this.toggleCam = !this.toggleCam;
      },

      update: function update ( forceUpdate ) {

          if ( this.stats ) {
              this.stats.begin();
          }

          // Break loop if wanted
          if ( this.autorun || forceUpdate ) {

              requestAnimationFrame( this.update.bind( this ) );

              if ( this.cameraControl instanceof OrbitControls ) {
                  this.camera.updateProjectionMatrix();
              }

              //            var avatar = this.scene.getObjectByName( 'Avatar' )
              //            if ( avatar && avatar.mixer ) {
              //
              //                avatar.mixer.update( this.clock.getDelta() )
              //
              //            }

              this.renderer.render( this.scene, this.camera );

              //            if ( this.cameraEffect === 'normal' ) {
              //                this.webGLRenderer.render( this.scene, this.camera )
              //            } else if ( this.cameraEffect === 'anaglyph' ) {
              //                this.anaglyphEffectRenderer.render( this.scene, this.camera )
              //            } else if ( this.cameraEffect === 'vr' ) {
              //                this.stereoEffectRenderer.render( this.scene, this.camera )
              //            } else {
              //                console.error( 'Unknown camera effect: ' + this.cameraEffect )
              //                this.webGLRenderer.render( this.scene, this.camera )
              //            }

          }

          if ( this.stats ) {
              this.stats.end();
          }

      },

      updateSizes: function updateSizes () {

          this.containerWidth  = this.container.clientWidth;
          this.containerHeight = this.container.clientHeight;

          this.webGLRenderer.setSize( this.containerWidth, this.containerHeight );

          // required for correct camera position at init...
          this.camera.aspect = this.containerWidth / this.containerHeight;
          this.camera.updateProjectionMatrix();
      },

      addRaycastables: function addRaycastables ( objects ) {
          var this$1 = this;


          for ( var intersectableIndex = 0, numberOfIntersectables = objects.length ; intersectableIndex < numberOfIntersectables ; intersectableIndex++ ) {

              this$1.raycastables.push( objects[ intersectableIndex ] );

          }

      },

      updateRaycasting: function updateRaycasting ( event ) {

          if ( !this.isRaycastable ) {

              if ( this.intersection ) {

                  //                this.intersection.object.material.color.copy( this.baseColor )
                  this.intersection          = null;
                  document.body.style.cursor = 'auto';

              }

              return

          }

          event.preventDefault();

          var xMouseOnContainer = event.layerX || event.offsetX || 0;
          var yMouseOnContainer = event.layerY || event.offsetY || 0;
          this.mouse.x          = ( xMouseOnContainer / this.container.clientWidth ) * 2 - 1;
          this.mouse.y          = -( yMouseOnContainer / this.container.clientHeight ) * 2 + 1;
          this.raycaster.setFromCamera( this.mouse, this.camera );

          var showRay = false;
          if ( showRay ) {

              var ray = this.raycaster.ray;

              if ( this.ray ) {
                  this.scene.remove( this.ray );
              }

              this.ray = new ArrowHelper( ray.direction, ray.origin, 10, 0x115577 );
              this.scene.add( this.ray );

          }

          var intersections = undefined;
          if ( this.measuring ) {

              var meshesGroup = this.scene.getObjectByName( 'MeshesGroup' );
              var meshes      = ( meshesGroup ) ? meshesGroup.children : [];

              //			var pointcloudGroup = this.scene.getObjectByName( 'PointClouds' )
              //			var pointcloud      = ( pointcloudGroup ) ? pointcloudGroup.children : []
              //
              //			var objectToIntersect = meshes.concat( pointcloud )

              intersections = this.raycaster.intersectObjects( meshes, true );
              //			intersections = this.raycaster.intersectObjects( objectToIntersect, true )
              if ( intersections.length > 0 ) {

                  this.intersection = intersections[ 0 ]; // Keep only closest intersected object
                  this.dispatchEvent( { type: 'intersectPoint' } );

              } else if ( this.intersection ) {

                  this.intersection = null;

              }

          } else {

              intersections = this.raycaster.intersectObjects( this.raycastables );
              if ( intersections.length > 0 ) {

                  if ( !this.intersection ) {

                      this.intersection = intersections[ 0 ];

                      this.backupIntersectedMaterial    = this.intersection.object.material;
                      this.intersection.object.material = this.intersectMaterial;

                  } else if ( this.intersection.object.uuid !== intersections[ 0 ].object.uuid ) {

                      this.intersection.object.material = this.backupIntersectedMaterial;

                      this.intersection                 = intersections[ 0 ];
                      this.backupIntersectedMaterial    = this.intersection.object.material;
                      this.intersection.object.material = this.intersectMaterial;

                  }

                  document.body.style.cursor = 'pointer';

              } else if ( this.intersection ) {

                  this.intersection.object.material = this.backupIntersectedMaterial;
                  this.intersection                 = null;
                  document.body.style.cursor        = 'auto';

              }

          }

      },

      selectObject: function selectObject ( clickEvent ) {

          if ( this.measuring ) {

              if ( this.intersection ) {

                  if ( clickEvent.button === 0 ) {

                      this.dispatchEvent( { type: 'newClickedPoint' } );

                  } else if ( clickEvent.button === 2 ) {

                      this.intersection = null;
                      this.dispatchEvent( { type: 'measureEnd' } );

                  } else {

                  }

              } else {

                  console.warn( 'Unable to get hit position for undefined intersection objects !!!' );

              }

          } else {

              if ( clickEvent.button === 0 ) {

                  if ( this.intersection ) {

                      clickEvent.preventDefault();

                      if ( this.selected !== this.intersection.object ) {

                          if ( this.selected ) {

                              this.selected.material      = this.backupSelectedMaterial;
                              this.selected               = null;
                              this.backupSelectedMaterial = null;
                              //                            this.scene.remove( this.selectedOutline )

                          }

                          this.selected                  = this.intersection.object;
                          this.backupSelectedMaterial    = this.backupIntersectedMaterial;
                          this.backupIntersectedMaterial = this.intersectMaterial;
                          //                        this.selected.material = this.intersectMaterial

                          //                        var selectedGeometry = this.selected.geometry
                          //
                          //                        var outlineMaterial = new MeshBasicMaterial( {
                          //                            color: 0x115577,
                          //                            side:  BackSide
                          //                        } )
                          //
                          //                        this.selectedOutline = new Mesh( selectedGeometry, outlineMaterial )
                          //                        //                    this.selectedOutline.matrix.copy( this.selected.matrix )
                          //                        this.selectedOutline.position.copy( this.selected.position )
                          //                        this.selectedOutline.quaternion.copy( this.selected.quaternion )
                          //                        this.selectedOutline.scale.set( 1.1, 1.0, 1.1 )
                          //
                          //                        this.scene.add( this.selectedOutline )

                          this.dispatchEvent( { type: 'objectSelected' } );

                      }

                  } else if ( this.selected ) {

                      this.selected.material      = this.backupSelectedMaterial;
                      this.selected               = null;
                      this.backupSelectedMaterial = null;

                      //                    this.scene.remove( this.selectedOutline )
                      //                    this.selected = null

                  }

              }

          }

      },

      setCameraPosition: function setCameraPosition ( position ) {

          var cameraControllerType = this.cameraControlType;
          if ( cameraControllerType === 'orbital' ) {

              this.camera.position.x = position.x;
              this.camera.position.y = position.y;
              this.camera.position.z = position.z;

              this.cameraControl.target.x = position.x;
              this.cameraControl.target.y = 0;
              this.cameraControl.target.z = position.z;

              this.cameraControl.update();

          } else if ( cameraControllerType === 'path' ) {

              this.cameraControl.goTo( position );

          } else {

              console.error( "Unable to change camera position, unknown camera controller type !" );

          }

      },

      setCameraEffect: function setCameraEffect ( cameraEffect ) {

          var trimmedEffectName = cameraEffect.trim( ' ' );

          // In case we were in vr, reset renderer size
          if ( this.cameraEffect === trimmedEffectName ) {

              return;

          } else if ( trimmedEffectName === 'normal' ) {

              this.renderer = this.webGLRenderer;

          } else if ( trimmedEffectName === 'vr' ) {

              this.renderer = this.stereoEffectRenderer;

          } else if ( trimmedEffectName === 'anaglyph' ) {

              this.renderer = this.anaglyphEffectRenderer;

          } else {

              this.renderer = this.webGLRenderer;

          }

          this.renderer.setSize( this.containerWidth, this.containerHeight );

          this.cameraEffect = trimmedEffectName;

      },

      setCameraControls: function setCameraControls ( cameraControlType ) {

          var currentCameraPosition = this.camera.position;

          if ( cameraControlType === "orbital" ) {

              this.cameraControlType = cameraControlType;

              this.cameraControl.enabled = false;
              this.scene.fog             = null;
              this.cameraControl         = this.orbitControl;
              this.cameraControl.enabled = true;

              this.camera.far = 60;
              this.camera.updateProjectionMatrix();

              // Set target to previous camera position
              this.cameraControl.target.x = currentCameraPosition.x;
              this.cameraControl.target.y = currentCameraPosition.y;
              this.cameraControl.target.z = currentCameraPosition.z;

              this.cameraControl.object.position.x += 10;
              this.cameraControl.object.position.y += 5;
              this.cameraControl.object.position.z += 10;

              this.scene.add( this.orbitControlHelper );

              this.cameraControl.update();

          } else if ( mode === "avatar" ) {

              // Set target to previous camera position
              this.cameraControl.object.position.x = this.cameraControl.target.x;
              this.cameraControl.object.position.y = this.cameraControl.target.y;
              this.cameraControl.object.position.z = this.cameraControl.target.z;

              this.cameraControl.target.x = currentCameraPosition.x;
              this.cameraControl.target.y = currentCameraPosition.y;
              this.cameraControl.target.z = currentCameraPosition.z;

              this.scene.remove( this.orbitControlHelper );

              this.cameraControl.update();

          } else if ( cameraControlType === "path" ) {

              this.cameraControlType = cameraControlType;

              this.cameraControl.enabled = false;
              this.scene.fog             = new FogExp2$1( 0x000000, 0.2 );
              this.camera.far            = 10;
              this.camera.updateProjectionMatrix();

          } else {

              console.error( "Invalid camera controller: " + cameraControlType );

          }

      },

      setGroupVisibility: function setGroupVisibility ( groupName, visibility ) {

          var group = this.scene.getObjectByName( groupName );
          if ( group ) {
              group.visible = visibility;
              for ( var childIndex = 0, numberOfChilds = group.children.length ; childIndex < numberOfChilds ; childIndex++ ) {
                  group.children[ childIndex ].visible = visibility;
              }
          }

      },

      decimateVisibleMeshes: function decimateVisibleMeshes () {

          //todo: recursive search against currently visible group and cache hide mesh for repopulate later !!!

          var decimateValue = 0.9;
          var groups        = this.scene.children.filter( function (child) { return child.type === 'Group'; } );
          if ( !groups || groups.length === 0 ) { return }

          var subGroup = groups[ 0 ].children.filter( function (child) { return child.type === 'Group'; } );
          if ( !subGroup || subGroup.length === 0 ) { return }

          var subSubGroup = subGroup[ 0 ].children.filter( function (child) { return child.type === 'Group'; } );
          if ( !subSubGroup || subSubGroup.length === 0 ) { return }

          var meshes = subSubGroup[ 0 ].children.filter( function (child) { return child.isMesh; } );
          if ( !meshes || meshes.length === 0 ) { return }

          var numberOfMeshesToHide = Math.round( meshes.length * decimateValue );

          for ( var meshIndex = 0 ; meshIndex < numberOfMeshesToHide ; meshIndex++ ) {

              meshes[ meshIndex ].visible = false;

          }

      },

      populateVisibleMeshes: function populateVisibleMeshes () {

          var groups = this.scene.children.filter( function (child) { return child.type === 'Group'; } );
          if ( !groups || groups.length === 0 ) { return }

          var subGroup = groups[ 0 ].children.filter( function (child) { return child.type === 'Group'; } );
          if ( !subGroup || subGroup.length === 0 ) { return }

          var subSubGroup = subGroup[ 0 ].children.filter( function (child) { return child.type === 'Group'; } );
          if ( !subSubGroup || subSubGroup.length === 0 ) { return }

          var meshes = subSubGroup[ 0 ].children.filter( function (child) { return child.isMesh; } );
          if ( !meshes || meshes.length === 0 ) { return }

          var numberOfMeshes = meshes.length;

          for ( var meshIndex = 0 ; meshIndex < numberOfMeshes ; meshIndex++ ) {

              meshes[ meshIndex ].visible = true;

          }

      }

  } );

  /**
   *
   * Action provided by AnimationMixer for scheduling clip playback on specific
   * objects.
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   *
   */

  function AnimationAction$1( mixer, clip, localRoot ) {

  	this._mixer = mixer;
  	this._clip = clip;
  	this._localRoot = localRoot || null;

  	var tracks = clip.tracks,
  		nTracks = tracks.length,
  		interpolants = new Array( nTracks );

  	var interpolantSettings = {
  		endingStart: ZeroCurvatureEnding,
  		endingEnd: ZeroCurvatureEnding
  	};

  	for ( var i = 0; i !== nTracks; ++ i ) {

  		var interpolant = tracks[ i ].createInterpolant( null );
  		interpolants[ i ] = interpolant;
  		interpolant.settings = interpolantSettings;

  	}

  	this._interpolantSettings = interpolantSettings;

  	this._interpolants = interpolants;	// bound by the mixer

  	// inside: PropertyMixer (managed by the mixer)
  	this._propertyBindings = new Array( nTracks );

  	this._cacheIndex = null;			// for the memory manager
  	this._byClipCacheIndex = null;		// for the memory manager

  	this._timeScaleInterpolant = null;
  	this._weightInterpolant = null;

  	this.loop = LoopRepeat;
  	this._loopCount = - 1;

  	// global mixer time when the action is to be started
  	// it's set back to 'null' upon start of the action
  	this._startTime = null;

  	// scaled local time of the action
  	// gets clamped or wrapped to 0..clip.duration according to loop
  	this.time = 0;

  	this.timeScale = 1;
  	this._effectiveTimeScale = 1;

  	this.weight = 1;
  	this._effectiveWeight = 1;

  	this.repetitions = Infinity; 		// no. of repetitions when looping

  	this.paused = false;				// true -> zero effective time scale
  	this.enabled = true;				// false -> zero effective weight

  	this.clampWhenFinished 	= false;	// keep feeding the last frame?

  	this.zeroSlopeAtStart 	= true;		// for smooth interpolation w/o separate
  	this.zeroSlopeAtEnd		= true;		// clips for start, loop and end

  }

  Object.assign( AnimationAction$1.prototype, {

  	// State & Scheduling

  	play: function () {

  		this._mixer._activateAction( this );

  		return this;

  	},

  	stop: function () {

  		this._mixer._deactivateAction( this );

  		return this.reset();

  	},

  	reset: function () {

  		this.paused = false;
  		this.enabled = true;

  		this.time = 0;			// restart clip
  		this._loopCount = - 1;	// forget previous loops
  		this._startTime = null;	// forget scheduling

  		return this.stopFading().stopWarping();

  	},

  	isRunning: function () {

  		return this.enabled && ! this.paused && this.timeScale !== 0 &&
  				this._startTime === null && this._mixer._isActiveAction( this );

  	},

  	// return true when play has been called
  	isScheduled: function () {

  		return this._mixer._isActiveAction( this );

  	},

  	startAt: function ( time ) {

  		this._startTime = time;

  		return this;

  	},

  	setLoop: function ( mode, repetitions ) {

  		this.loop = mode;
  		this.repetitions = repetitions;

  		return this;

  	},

  	// Weight

  	// set the weight stopping any scheduled fading
  	// although .enabled = false yields an effective weight of zero, this
  	// method does *not* change .enabled, because it would be confusing
  	setEffectiveWeight: function ( weight ) {

  		this.weight = weight;

  		// note: same logic as when updated at runtime
  		this._effectiveWeight = this.enabled ? weight : 0;

  		return this.stopFading();

  	},

  	// return the weight considering fading and .enabled
  	getEffectiveWeight: function () {

  		return this._effectiveWeight;

  	},

  	fadeIn: function ( duration ) {

  		return this._scheduleFading( duration, 0, 1 );

  	},

  	fadeOut: function ( duration ) {

  		return this._scheduleFading( duration, 1, 0 );

  	},

  	crossFadeFrom: function ( fadeOutAction, duration, warp ) {

  		fadeOutAction.fadeOut( duration );
  		this.fadeIn( duration );

  		if ( warp ) {

  			var fadeInDuration = this._clip.duration,
  				fadeOutDuration = fadeOutAction._clip.duration,

  				startEndRatio = fadeOutDuration / fadeInDuration,
  				endStartRatio = fadeInDuration / fadeOutDuration;

  			fadeOutAction.warp( 1.0, startEndRatio, duration );
  			this.warp( endStartRatio, 1.0, duration );

  		}

  		return this;

  	},

  	crossFadeTo: function ( fadeInAction, duration, warp ) {

  		return fadeInAction.crossFadeFrom( this, duration, warp );

  	},

  	stopFading: function () {

  		var weightInterpolant = this._weightInterpolant;

  		if ( weightInterpolant !== null ) {

  			this._weightInterpolant = null;
  			this._mixer._takeBackControlInterpolant( weightInterpolant );

  		}

  		return this;

  	},

  	// Time Scale Control

  	// set the time scale stopping any scheduled warping
  	// although .paused = true yields an effective time scale of zero, this
  	// method does *not* change .paused, because it would be confusing
  	setEffectiveTimeScale: function ( timeScale ) {

  		this.timeScale = timeScale;
  		this._effectiveTimeScale = this.paused ? 0 : timeScale;

  		return this.stopWarping();

  	},

  	// return the time scale considering warping and .paused
  	getEffectiveTimeScale: function () {

  		return this._effectiveTimeScale;

  	},

  	setDuration: function ( duration ) {

  		this.timeScale = this._clip.duration / duration;

  		return this.stopWarping();

  	},

  	syncWith: function ( action ) {

  		this.time = action.time;
  		this.timeScale = action.timeScale;

  		return this.stopWarping();

  	},

  	halt: function ( duration ) {

  		return this.warp( this._effectiveTimeScale, 0, duration );

  	},

  	warp: function ( startTimeScale, endTimeScale, duration ) {

  		var mixer = this._mixer, now = mixer.time,
  			interpolant = this._timeScaleInterpolant,

  			timeScale = this.timeScale;

  		if ( interpolant === null ) {

  			interpolant = mixer._lendControlInterpolant();
  			this._timeScaleInterpolant = interpolant;

  		}

  		var times = interpolant.parameterPositions,
  			values = interpolant.sampleValues;

  		times[ 0 ] = now;
  		times[ 1 ] = now + duration;

  		values[ 0 ] = startTimeScale / timeScale;
  		values[ 1 ] = endTimeScale / timeScale;

  		return this;

  	},

  	stopWarping: function () {

  		var timeScaleInterpolant = this._timeScaleInterpolant;

  		if ( timeScaleInterpolant !== null ) {

  			this._timeScaleInterpolant = null;
  			this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

  		}

  		return this;

  	},

  	// Object Accessors

  	getMixer: function () {

  		return this._mixer;

  	},

  	getClip: function () {

  		return this._clip;

  	},

  	getRoot: function () {

  		return this._localRoot || this._mixer._root;

  	},

  	// Interna

  	_update: function ( time, deltaTime, timeDirection, accuIndex ) {

  		// called by the mixer

  		if ( ! this.enabled ) {

  			// call ._updateWeight() to update ._effectiveWeight

  			this._updateWeight( time );
  			return;

  		}

  		var startTime = this._startTime;

  		if ( startTime !== null ) {

  			// check for scheduled start of action

  			var timeRunning = ( time - startTime ) * timeDirection;
  			if ( timeRunning < 0 || timeDirection === 0 ) {

  				return; // yet to come / don't decide when delta = 0

  			}

  			// start

  			this._startTime = null; // unschedule
  			deltaTime = timeDirection * timeRunning;

  		}

  		// apply time scale and advance time

  		deltaTime *= this._updateTimeScale( time );
  		var clipTime = this._updateTime( deltaTime );

  		// note: _updateTime may disable the action resulting in
  		// an effective weight of 0

  		var weight = this._updateWeight( time );

  		if ( weight > 0 ) {

  			var interpolants = this._interpolants;
  			var propertyMixers = this._propertyBindings;

  			for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {

  				interpolants[ j ].evaluate( clipTime );
  				propertyMixers[ j ].accumulate( accuIndex, weight );

  			}

  		}

  	},

  	_updateWeight: function ( time ) {

  		var weight = 0;

  		if ( this.enabled ) {

  			weight = this.weight;
  			var interpolant = this._weightInterpolant;

  			if ( interpolant !== null ) {

  				var interpolantValue = interpolant.evaluate( time )[ 0 ];

  				weight *= interpolantValue;

  				if ( time > interpolant.parameterPositions[ 1 ] ) {

  					this.stopFading();

  					if ( interpolantValue === 0 ) {

  						// faded out, disable
  						this.enabled = false;

  					}

  				}

  			}

  		}

  		this._effectiveWeight = weight;
  		return weight;

  	},

  	_updateTimeScale: function ( time ) {

  		var timeScale = 0;

  		if ( ! this.paused ) {

  			timeScale = this.timeScale;

  			var interpolant = this._timeScaleInterpolant;

  			if ( interpolant !== null ) {

  				var interpolantValue = interpolant.evaluate( time )[ 0 ];

  				timeScale *= interpolantValue;

  				if ( time > interpolant.parameterPositions[ 1 ] ) {

  					this.stopWarping();

  					if ( timeScale === 0 ) {

  						// motion has halted, pause
  						this.paused = true;

  					} else {

  						// warp done - apply final time scale
  						this.timeScale = timeScale;

  					}

  				}

  			}

  		}

  		this._effectiveTimeScale = timeScale;
  		return timeScale;

  	},

  	_updateTime: function ( deltaTime ) {

  		var time = this.time + deltaTime;

  		if ( deltaTime === 0 ) { return time; }

  		var duration = this._clip.duration,

  			loop = this.loop,
  			loopCount = this._loopCount;

  		if ( loop === LoopOnce ) {

  			if ( loopCount === - 1 ) {

  				// just started

  				this._loopCount = 0;
  				this._setEndings( true, true, false );

  			}

  			handle_stop: {

  				if ( time >= duration ) {

  					time = duration;

  				} else if ( time < 0 ) {

  					time = 0;

  				} else { break handle_stop; }

  				if ( this.clampWhenFinished ) { this.paused = true; }
  				else { this.enabled = false; }

  				this._mixer.dispatchEvent( {
  					type: 'finished', action: this,
  					direction: deltaTime < 0 ? - 1 : 1
  				} );

  			}

  		} else { // repetitive Repeat or PingPong

  			var pingPong = ( loop === LoopPingPong );

  			if ( loopCount === - 1 ) {

  				// just started

  				if ( deltaTime >= 0 ) {

  					loopCount = 0;

  					this._setEndings( true, this.repetitions === 0, pingPong );

  				} else {

  					// when looping in reverse direction, the initial
  					// transition through zero counts as a repetition,
  					// so leave loopCount at -1

  					this._setEndings( this.repetitions === 0, true, pingPong );

  				}

  			}

  			if ( time >= duration || time < 0 ) {

  				// wrap around

  				var loopDelta = Math.floor( time / duration ); // signed
  				time -= duration * loopDelta;

  				loopCount += Math.abs( loopDelta );

  				var pending = this.repetitions - loopCount;

  				if ( pending < 0 ) {

  					// have to stop (switch state, clamp time, fire event)

  					if ( this.clampWhenFinished ) { this.paused = true; }
  					else { this.enabled = false; }

  					time = deltaTime > 0 ? duration : 0;

  					this._mixer.dispatchEvent( {
  						type: 'finished', action: this,
  						direction: deltaTime > 0 ? 1 : - 1
  					} );

  				} else {

  					// keep running

  					if ( pending === 0 ) {

  						// entering the last round

  						var atStart = deltaTime < 0;
  						this._setEndings( atStart, ! atStart, pingPong );

  					} else {

  						this._setEndings( false, false, pingPong );

  					}

  					this._loopCount = loopCount;

  					this._mixer.dispatchEvent( {
  						type: 'loop', action: this, loopDelta: loopDelta
  					} );

  				}

  			}

  			if ( pingPong && ( loopCount & 1 ) === 1 ) {

  				// invert time for the "pong round"

  				this.time = time;
  				return duration - time;

  			}

  		}

  		this.time = time;
  		return time;

  	},

  	_setEndings: function ( atStart, atEnd, pingPong ) {

  		var settings = this._interpolantSettings;

  		if ( pingPong ) {

  			settings.endingStart 	= ZeroSlopeEnding;
  			settings.endingEnd		= ZeroSlopeEnding;

  		} else {

  			// assuming for LoopOnce atStart == atEnd == true

  			if ( atStart ) {

  				settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;

  			} else {

  				settings.endingStart = WrapAroundEnding;

  			}

  			if ( atEnd ) {

  				settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;

  			} else {

  				settings.endingEnd 	 = WrapAroundEnding;

  			}

  		}

  	},

  	_scheduleFading: function ( duration, weightNow, weightThen ) {

  		var mixer = this._mixer, now = mixer.time,
  			interpolant = this._weightInterpolant;

  		if ( interpolant === null ) {

  			interpolant = mixer._lendControlInterpolant();
  			this._weightInterpolant = interpolant;

  		}

  		var times = interpolant.parameterPositions,
  			values = interpolant.sampleValues;

  		times[ 0 ] = now; 				values[ 0 ] = weightNow;
  		times[ 1 ] = now + duration;	values[ 1 ] = weightThen;

  		return this;

  	}

  } );

  /**
   *
   * A reference to a real property in the scene graph.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function Composite$1( targetGroup, path, optionalParsedPath ) {

  	var parsedPath = optionalParsedPath || PropertyBinding$1.parseTrackName( path );

  	this._targetGroup = targetGroup;
  	this._bindings = targetGroup.subscribe_( path, parsedPath );

  }

  Object.assign( Composite$1.prototype, {

  	getValue: function ( array, offset ) {

  		this.bind(); // bind all binding

  		var firstValidIndex = this._targetGroup.nCachedObjects_,
  			binding = this._bindings[ firstValidIndex ];

  		// and only call .getValue on the first
  		if ( binding !== undefined ) { binding.getValue( array, offset ); }

  	},

  	setValue: function ( array, offset ) {

  		var bindings = this._bindings;

  		for ( var i = this._targetGroup.nCachedObjects_,
  				  n = bindings.length; i !== n; ++ i ) {

  			bindings[ i ].setValue( array, offset );

  		}

  	},

  	bind: function () {

  		var bindings = this._bindings;

  		for ( var i = this._targetGroup.nCachedObjects_,
  				  n = bindings.length; i !== n; ++ i ) {

  			bindings[ i ].bind();

  		}

  	},

  	unbind: function () {

  		var bindings = this._bindings;

  		for ( var i = this._targetGroup.nCachedObjects_,
  				  n = bindings.length; i !== n; ++ i ) {

  			bindings[ i ].unbind();

  		}

  	}

  } );


  function PropertyBinding$1( rootNode, path, parsedPath ) {

  	this.path = path;
  	this.parsedPath = parsedPath || PropertyBinding$1.parseTrackName( path );

  	this.node = PropertyBinding$1.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;

  	this.rootNode = rootNode;

  }

  Object.assign( PropertyBinding$1, {

  	Composite: Composite$1,

  	create: function ( root, path, parsedPath ) {

  		if ( ! ( root && root.isAnimationObjectGroup ) ) {

  			return new PropertyBinding$1( root, path, parsedPath );

  		} else {

  			return new PropertyBinding$1.Composite( root, path, parsedPath );

  		}

  	},

  	/**
  	 * Replaces spaces with underscores and removes unsupported characters from
  	 * node names, to ensure compatibility with parseTrackName().
  	 *
  	 * @param  {string} name Node name to be sanitized.
  	 * @return {string}
  	 */
  	sanitizeNodeName: function ( name ) {

  		return name.replace( /\s/g, '_' ).replace( /[^\w-]/g, '' );

  	},

  	parseTrackName: function () {

  		// Parent directories, delimited by '/' or ':'. Currently unused, but must
  		// be matched to parse the rest of the track name.
  		var directoryRe = /((?:[\w-]+[\/:])*)/;

  		// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
  		var nodeRe = /([\w-\.]+)?/;

  		// Object on target node, and accessor. Name may contain only word
  		// characters. Accessor may contain any character except closing bracket.
  		var objectRe = /(?:\.([\w-]+)(?:\[(.+)\])?)?/;

  		// Property and accessor. May contain only word characters. Accessor may
  		// contain any non-bracket characters.
  		var propertyRe = /\.([\w-]+)(?:\[(.+)\])?/;

  		var trackRe = new RegExp( ''
  			+ '^'
  			+ directoryRe.source
  			+ nodeRe.source
  			+ objectRe.source
  			+ propertyRe.source
  			+ '$'
  		);

  		var supportedObjectNames = [ 'material', 'materials', 'bones' ];

  		return function ( trackName ) {

  			var matches = trackRe.exec( trackName );

  			if ( ! matches ) {

  				throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

  			}

  			var results = {
  				// directoryName: matches[ 1 ], // (tschw) currently unused
  				nodeName: matches[ 2 ],
  				objectName: matches[ 3 ],
  				objectIndex: matches[ 4 ],
  				propertyName: matches[ 5 ], // required
  				propertyIndex: matches[ 6 ]
  			};

  			var lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

  			if ( lastDot !== undefined && lastDot !== - 1 ) {

  				var objectName = results.nodeName.substring( lastDot + 1 );

  				// Object names must be checked against a whitelist. Otherwise, there
  				// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
  				// 'bar' could be the objectName, or part of a nodeName (which can
  				// include '.' characters).
  				if ( supportedObjectNames.indexOf( objectName ) !== - 1 ) {

  					results.nodeName = results.nodeName.substring( 0, lastDot );
  					results.objectName = objectName;

  				}

  			}

  			if ( results.propertyName === null || results.propertyName.length === 0 ) {

  				throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

  			}

  			return results;

  		};

  	}(),

  	findNode: function ( root, nodeName ) {

  		if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

  			return root;

  		}

  		// search into skeleton bones.
  		if ( root.skeleton ) {

  			var searchSkeleton = function ( skeleton ) {

  				for ( var i = 0; i < skeleton.bones.length; i ++ ) {

  					var bone = skeleton.bones[ i ];

  					if ( bone.name === nodeName ) {

  						return bone;

  					}

  				}

  				return null;

  			};

  			var bone = searchSkeleton( root.skeleton );

  			if ( bone ) {

  				return bone;

  			}

  		}

  		// search into node subtree.
  		if ( root.children ) {

  			var searchNodeSubtree = function ( children ) {

  				for ( var i = 0; i < children.length; i ++ ) {

  					var childNode = children[ i ];

  					if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

  						return childNode;

  					}

  					var result = searchNodeSubtree( childNode.children );

  					if ( result ) { return result; }

  				}

  				return null;

  			};

  			var subTreeNode = searchNodeSubtree( root.children );

  			if ( subTreeNode ) {

  				return subTreeNode;

  			}

  		}

  		return null;

  	}

  } );

  Object.assign( PropertyBinding$1.prototype, { // prototype, continued

  	// these are used to "bind" a nonexistent property
  	_getValue_unavailable: function () {},
  	_setValue_unavailable: function () {},

  	BindingType: {
  		Direct: 0,
  		EntireArray: 1,
  		ArrayElement: 2,
  		HasFromToArray: 3
  	},

  	Versioning: {
  		None: 0,
  		NeedsUpdate: 1,
  		MatrixWorldNeedsUpdate: 2
  	},

  	GetterByBindingType: [

  		function getValue_direct( buffer, offset ) {

  			buffer[ offset ] = this.node[ this.propertyName ];

  		},

  		function getValue_array( buffer, offset ) {

  			var source = this.resolvedProperty;

  			for ( var i = 0, n = source.length; i !== n; ++ i ) {

  				buffer[ offset ++ ] = source[ i ];

  			}

  		},

  		function getValue_arrayElement( buffer, offset ) {

  			buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

  		},

  		function getValue_toArray( buffer, offset ) {

  			this.resolvedProperty.toArray( buffer, offset );

  		}

  	],

  	SetterByBindingTypeAndVersioning: [

  		[
  			// Direct

  			function setValue_direct( buffer, offset ) {

  				this.targetObject[ this.propertyName ] = buffer[ offset ];

  			},

  			function setValue_direct_setNeedsUpdate( buffer, offset ) {

  				this.targetObject[ this.propertyName ] = buffer[ offset ];
  				this.targetObject.needsUpdate = true;

  			},

  			function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

  				this.targetObject[ this.propertyName ] = buffer[ offset ];
  				this.targetObject.matrixWorldNeedsUpdate = true;

  			}

  		], [

  			// EntireArray

  			function setValue_array( buffer, offset ) {

  				var dest = this.resolvedProperty;

  				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

  					dest[ i ] = buffer[ offset ++ ];

  				}

  			},

  			function setValue_array_setNeedsUpdate( buffer, offset ) {

  				var dest = this.resolvedProperty;

  				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

  					dest[ i ] = buffer[ offset ++ ];

  				}

  				this.targetObject.needsUpdate = true;

  			},

  			function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

  				var dest = this.resolvedProperty;

  				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

  					dest[ i ] = buffer[ offset ++ ];

  				}

  				this.targetObject.matrixWorldNeedsUpdate = true;

  			}

  		], [

  			// ArrayElement

  			function setValue_arrayElement( buffer, offset ) {

  				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

  			},

  			function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

  				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
  				this.targetObject.needsUpdate = true;

  			},

  			function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

  				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
  				this.targetObject.matrixWorldNeedsUpdate = true;

  			}

  		], [

  			// HasToFromArray

  			function setValue_fromArray( buffer, offset ) {

  				this.resolvedProperty.fromArray( buffer, offset );

  			},

  			function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

  				this.resolvedProperty.fromArray( buffer, offset );
  				this.targetObject.needsUpdate = true;

  			},

  			function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

  				this.resolvedProperty.fromArray( buffer, offset );
  				this.targetObject.matrixWorldNeedsUpdate = true;

  			}

  		]

  	],

  	getValue: function getValue_unbound( targetArray, offset ) {

  		this.bind();
  		this.getValue( targetArray, offset );

  		// Note: This class uses a State pattern on a per-method basis:
  		// 'bind' sets 'this.getValue' / 'setValue' and shadows the
  		// prototype version of these methods with one that represents
  		// the bound state. When the property is not found, the methods
  		// become no-ops.

  	},

  	setValue: function getValue_unbound( sourceArray, offset ) {

  		this.bind();
  		this.setValue( sourceArray, offset );

  	},

  	// create getter / setter pair for a property in the scene graph
  	bind: function () {

  		var targetObject = this.node,
  			parsedPath = this.parsedPath,

  			objectName = parsedPath.objectName,
  			propertyName = parsedPath.propertyName,
  			propertyIndex = parsedPath.propertyIndex;

  		if ( ! targetObject ) {

  			targetObject = PropertyBinding$1.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;

  			this.node = targetObject;

  		}

  		// set fail state so we can just 'return' on error
  		this.getValue = this._getValue_unavailable;
  		this.setValue = this._setValue_unavailable;

  		// ensure there is a value node
  		if ( ! targetObject ) {

  			console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
  			return;

  		}

  		if ( objectName ) {

  			var objectIndex = parsedPath.objectIndex;

  			// special cases were we need to reach deeper into the hierarchy to get the face materials....
  			switch ( objectName ) {

  				case 'materials':

  					if ( ! targetObject.material ) {

  						console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
  						return;

  					}

  					if ( ! targetObject.material.materials ) {

  						console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
  						return;

  					}

  					targetObject = targetObject.material.materials;

  					break;

  				case 'bones':

  					if ( ! targetObject.skeleton ) {

  						console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
  						return;

  					}

  					// potential future optimization: skip this if propertyIndex is already an integer
  					// and convert the integer string to a true integer.

  					targetObject = targetObject.skeleton.bones;

  					// support resolving morphTarget names into indices.
  					for ( var i = 0; i < targetObject.length; i ++ ) {

  						if ( targetObject[ i ].name === objectIndex ) {

  							objectIndex = i;
  							break;

  						}

  					}

  					break;

  				default:

  					if ( targetObject[ objectName ] === undefined ) {

  						console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
  						return;

  					}

  					targetObject = targetObject[ objectName ];

  			}


  			if ( objectIndex !== undefined ) {

  				if ( targetObject[ objectIndex ] === undefined ) {

  					console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
  					return;

  				}

  				targetObject = targetObject[ objectIndex ];

  			}

  		}

  		// resolve property
  		var nodeProperty = targetObject[ propertyName ];

  		if ( nodeProperty === undefined ) {

  			var nodeName = parsedPath.nodeName;

  			console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
  				'.' + propertyName + ' but it wasn\'t found.', targetObject );
  			return;

  		}

  		// determine versioning scheme
  		var versioning = this.Versioning.None;

  		if ( targetObject.needsUpdate !== undefined ) { // material

  			versioning = this.Versioning.NeedsUpdate;
  			this.targetObject = targetObject;

  		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

  			versioning = this.Versioning.MatrixWorldNeedsUpdate;
  			this.targetObject = targetObject;

  		}

  		// determine how the property gets bound
  		var bindingType = this.BindingType.Direct;

  		if ( propertyIndex !== undefined ) {

  			// access a sub element of the property array (only primitives are supported right now)

  			if ( propertyName === "morphTargetInfluences" ) {

  				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

  				// support resolving morphTarget names into indices.
  				if ( ! targetObject.geometry ) {

  					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
  					return;

  				}

  				if ( targetObject.geometry.isBufferGeometry ) {

  					if ( ! targetObject.geometry.morphAttributes ) {

  						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
  						return;

  					}

  					for ( var i = 0; i < this.node.geometry.morphAttributes.position.length; i ++ ) {

  						if ( targetObject.geometry.morphAttributes.position[ i ].name === propertyIndex ) {

  							propertyIndex = i;
  							break;

  						}

  					}


  				} else {

  					if ( ! targetObject.geometry.morphTargets ) {

  						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this );
  						return;

  					}

  					for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {

  						if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {

  							propertyIndex = i;
  							break;

  						}

  					}

  				}

  			}

  			bindingType = this.BindingType.ArrayElement;

  			this.resolvedProperty = nodeProperty;
  			this.propertyIndex = propertyIndex;

  		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

  			// must use copy for Object3D.Euler/Quaternion

  			bindingType = this.BindingType.HasFromToArray;

  			this.resolvedProperty = nodeProperty;

  		} else if ( Array.isArray( nodeProperty ) ) {

  			bindingType = this.BindingType.EntireArray;

  			this.resolvedProperty = nodeProperty;

  		} else {

  			this.propertyName = propertyName;

  		}

  		// select getter / setter
  		this.getValue = this.GetterByBindingType[ bindingType ];
  		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

  	},

  	unbind: function () {

  		this.node = null;

  		// back to the prototype version of getValue / setValue
  		// note: avoiding to mutate the shape of 'this' via 'delete'
  		this.getValue = this._getValue_unbound;
  		this.setValue = this._setValue_unbound;

  	}

  } );

  //!\ DECLARE ALIAS AFTER assign prototype !
  Object.assign( PropertyBinding$1.prototype, {

  	// initial state of these methods that calls 'bind'
  	_getValue_unbound: PropertyBinding$1.prototype.getValue,
  	_setValue_unbound: PropertyBinding$1.prototype.setValue,

  } );

  /**
   *
   * Buffered scene graph property that allows weighted accumulation.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function PropertyMixer$1( binding, typeName, valueSize ) {

  	this.binding = binding;
  	this.valueSize = valueSize;

  	var bufferType = Float64Array,
  		mixFunction;

  	switch ( typeName ) {

  		case 'quaternion':
  			mixFunction = this._slerp;
  			break;

  		case 'string':
  		case 'bool':
  			bufferType = Array;
  			mixFunction = this._select;
  			break;

  		default:
  			mixFunction = this._lerp;

  	}

  	this.buffer = new bufferType( valueSize * 4 );
  	// layout: [ incoming | accu0 | accu1 | orig ]
  	//
  	// interpolators can use .buffer as their .result
  	// the data then goes to 'incoming'
  	//
  	// 'accu0' and 'accu1' are used frame-interleaved for
  	// the cumulative result and are compared to detect
  	// changes
  	//
  	// 'orig' stores the original state of the property

  	this._mixBufferRegion = mixFunction;

  	this.cumulativeWeight = 0;

  	this.useCount = 0;
  	this.referenceCount = 0;

  }

  Object.assign( PropertyMixer$1.prototype, {

  	// accumulate data in the 'incoming' region into 'accu<i>'
  	accumulate: function ( accuIndex, weight ) {

  		// note: happily accumulating nothing when weight = 0, the caller knows
  		// the weight and shouldn't have made the call in the first place

  		var buffer = this.buffer,
  			stride = this.valueSize,
  			offset = accuIndex * stride + stride,

  			currentWeight = this.cumulativeWeight;

  		if ( currentWeight === 0 ) {

  			// accuN := incoming * weight

  			for ( var i = 0; i !== stride; ++ i ) {

  				buffer[ offset + i ] = buffer[ i ];

  			}

  			currentWeight = weight;

  		} else {

  			// accuN := accuN + incoming * weight

  			currentWeight += weight;
  			var mix = weight / currentWeight;
  			this._mixBufferRegion( buffer, offset, 0, mix, stride );

  		}

  		this.cumulativeWeight = currentWeight;

  	},

  	// apply the state of 'accu<i>' to the binding when accus differ
  	apply: function ( accuIndex ) {

  		var stride = this.valueSize,
  			buffer = this.buffer,
  			offset = accuIndex * stride + stride,

  			weight = this.cumulativeWeight,

  			binding = this.binding;

  		this.cumulativeWeight = 0;

  		if ( weight < 1 ) {

  			// accuN := accuN + original * ( 1 - cumulativeWeight )

  			var originalValueOffset = stride * 3;

  			this._mixBufferRegion(
  				buffer, offset, originalValueOffset, 1 - weight, stride );

  		}

  		for ( var i = stride, e = stride + stride; i !== e; ++ i ) {

  			if ( buffer[ i ] !== buffer[ i + stride ] ) {

  				// value has changed -> update scene graph

  				binding.setValue( buffer, offset );
  				break;

  			}

  		}

  	},

  	// remember the state of the bound property and copy it to both accus
  	saveOriginalState: function () {

  		var binding = this.binding;

  		var buffer = this.buffer,
  			stride = this.valueSize,

  			originalValueOffset = stride * 3;

  		binding.getValue( buffer, originalValueOffset );

  		// accu[0..1] := orig -- initially detect changes against the original
  		for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {

  			buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

  		}

  		this.cumulativeWeight = 0;

  	},

  	// apply the state previously taken via 'saveOriginalState' to the binding
  	restoreOriginalState: function () {

  		var originalValueOffset = this.valueSize * 3;
  		this.binding.setValue( this.buffer, originalValueOffset );

  	},


  	// mix functions

  	_select: function ( buffer, dstOffset, srcOffset, t, stride ) {

  		if ( t >= 0.5 ) {

  			for ( var i = 0; i !== stride; ++ i ) {

  				buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

  			}

  		}

  	},

  	_slerp: function ( buffer, dstOffset, srcOffset, t ) {

  		Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

  	},

  	_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {

  		var s = 1 - t;

  		for ( var i = 0; i !== stride; ++ i ) {

  			var j = dstOffset + i;

  			buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

  		}

  	}

  } );

  /**
   *
   * Player for AnimationClips.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function AnimationMixer$1( root ) {

  	this._root = root;
  	this._initMemoryManager();
  	this._accuIndex = 0;

  	this.time = 0;

  	this.timeScale = 1.0;

  }

  Object.assign( AnimationMixer$1.prototype, EventDispatcher.prototype, {

  	_bindAction: function ( action, prototypeAction ) {
  		var this$1 = this;


  		var root = action._localRoot || this._root,
  			tracks = action._clip.tracks,
  			nTracks = tracks.length,
  			bindings = action._propertyBindings,
  			interpolants = action._interpolants,
  			rootUuid = root.uuid,
  			bindingsByRoot = this._bindingsByRootAndName,
  			bindingsByName = bindingsByRoot[ rootUuid ];

  		if ( bindingsByName === undefined ) {

  			bindingsByName = {};
  			bindingsByRoot[ rootUuid ] = bindingsByName;

  		}

  		for ( var i = 0; i !== nTracks; ++ i ) {

  			var track = tracks[ i ],
  				trackName = track.name,
  				binding = bindingsByName[ trackName ];

  			if ( binding !== undefined ) {

  				bindings[ i ] = binding;

  			} else {

  				binding = bindings[ i ];

  				if ( binding !== undefined ) {

  					// existing binding, make sure the cache knows

  					if ( binding._cacheIndex === null ) {

  						++ binding.referenceCount;
  						this$1._addInactiveBinding( binding, rootUuid, trackName );

  					}

  					continue;

  				}

  				var path = prototypeAction && prototypeAction.
  					_propertyBindings[ i ].binding.parsedPath;

  				binding = new PropertyMixer$1(
  					PropertyBinding$1.create( root, trackName, path ),
  					track.ValueTypeName, track.getValueSize() );

  				++ binding.referenceCount;
  				this$1._addInactiveBinding( binding, rootUuid, trackName );

  				bindings[ i ] = binding;

  			}

  			interpolants[ i ].resultBuffer = binding.buffer;

  		}

  	},

  	_activateAction: function ( action ) {
  		var this$1 = this;


  		if ( ! this._isActiveAction( action ) ) {

  			if ( action._cacheIndex === null ) {

  				// this action has been forgotten by the cache, but the user
  				// appears to be still using it -> rebind

  				var rootUuid = ( action._localRoot || this._root ).uuid,
  					clipUuid = action._clip.uuid,
  					actionsForClip = this._actionsByClip[ clipUuid ];

  				this._bindAction( action,
  					actionsForClip && actionsForClip.knownActions[ 0 ] );

  				this._addInactiveAction( action, clipUuid, rootUuid );

  			}

  			var bindings = action._propertyBindings;

  			// increment reference counts / sort out state
  			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

  				var binding = bindings[ i ];

  				if ( binding.useCount ++ === 0 ) {

  					this$1._lendBinding( binding );
  					binding.saveOriginalState();

  				}

  			}

  			this._lendAction( action );

  		}

  	},

  	_deactivateAction: function ( action ) {
  		var this$1 = this;


  		if ( this._isActiveAction( action ) ) {

  			var bindings = action._propertyBindings;

  			// decrement reference counts / sort out state
  			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

  				var binding = bindings[ i ];

  				if ( -- binding.useCount === 0 ) {

  					binding.restoreOriginalState();
  					this$1._takeBackBinding( binding );

  				}

  			}

  			this._takeBackAction( action );

  		}

  	},

  	// Memory manager

  	_initMemoryManager: function () {

  		this._actions = []; // 'nActiveActions' followed by inactive ones
  		this._nActiveActions = 0;

  		this._actionsByClip = {};
  		// inside:
  		// {
  		// 		knownActions: Array< AnimationAction >	- used as prototypes
  		// 		actionByRoot: AnimationAction			- lookup
  		// }


  		this._bindings = []; // 'nActiveBindings' followed by inactive ones
  		this._nActiveBindings = 0;

  		this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


  		this._controlInterpolants = []; // same game as above
  		this._nActiveControlInterpolants = 0;

  		var scope = this;

  		this.stats = {

  			actions: {
  				get total() {

  					return scope._actions.length;

  				},
  				get inUse() {

  					return scope._nActiveActions;

  				}
  			},
  			bindings: {
  				get total() {

  					return scope._bindings.length;

  				},
  				get inUse() {

  					return scope._nActiveBindings;

  				}
  			},
  			controlInterpolants: {
  				get total() {

  					return scope._controlInterpolants.length;

  				},
  				get inUse() {

  					return scope._nActiveControlInterpolants;

  				}
  			}

  		};

  	},

  	// Memory management for AnimationAction objects

  	_isActiveAction: function ( action ) {

  		var index = action._cacheIndex;
  		return index !== null && index < this._nActiveActions;

  	},

  	_addInactiveAction: function ( action, clipUuid, rootUuid ) {

  		var actions = this._actions,
  			actionsByClip = this._actionsByClip,
  			actionsForClip = actionsByClip[ clipUuid ];

  		if ( actionsForClip === undefined ) {

  			actionsForClip = {

  				knownActions: [ action ],
  				actionByRoot: {}

  			};

  			action._byClipCacheIndex = 0;

  			actionsByClip[ clipUuid ] = actionsForClip;

  		} else {

  			var knownActions = actionsForClip.knownActions;

  			action._byClipCacheIndex = knownActions.length;
  			knownActions.push( action );

  		}

  		action._cacheIndex = actions.length;
  		actions.push( action );

  		actionsForClip.actionByRoot[ rootUuid ] = action;

  	},

  	_removeInactiveAction: function ( action ) {

  		var actions = this._actions,
  			lastInactiveAction = actions[ actions.length - 1 ],
  			cacheIndex = action._cacheIndex;

  		lastInactiveAction._cacheIndex = cacheIndex;
  		actions[ cacheIndex ] = lastInactiveAction;
  		actions.pop();

  		action._cacheIndex = null;


  		var clipUuid = action._clip.uuid,
  			actionsByClip = this._actionsByClip,
  			actionsForClip = actionsByClip[ clipUuid ],
  			knownActionsForClip = actionsForClip.knownActions,

  			lastKnownAction =
  				knownActionsForClip[ knownActionsForClip.length - 1 ],

  			byClipCacheIndex = action._byClipCacheIndex;

  		lastKnownAction._byClipCacheIndex = byClipCacheIndex;
  		knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
  		knownActionsForClip.pop();

  		action._byClipCacheIndex = null;


  		var actionByRoot = actionsForClip.actionByRoot,
  			rootUuid = ( action._localRoot || this._root ).uuid;

  		delete actionByRoot[ rootUuid ];

  		if ( knownActionsForClip.length === 0 ) {

  			delete actionsByClip[ clipUuid ];

  		}

  		this._removeInactiveBindingsForAction( action );

  	},

  	_removeInactiveBindingsForAction: function ( action ) {
  		var this$1 = this;


  		var bindings = action._propertyBindings;
  		for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

  			var binding = bindings[ i ];

  			if ( -- binding.referenceCount === 0 ) {

  				this$1._removeInactiveBinding( binding );

  			}

  		}

  	},

  	_lendAction: function ( action ) {

  		// [ active actions |  inactive actions  ]
  		// [  active actions >| inactive actions ]
  		//                 s        a
  		//                  <-swap->
  		//                 a        s

  		var actions = this._actions,
  			prevIndex = action._cacheIndex,

  			lastActiveIndex = this._nActiveActions ++,

  			firstInactiveAction = actions[ lastActiveIndex ];

  		action._cacheIndex = lastActiveIndex;
  		actions[ lastActiveIndex ] = action;

  		firstInactiveAction._cacheIndex = prevIndex;
  		actions[ prevIndex ] = firstInactiveAction;

  	},

  	_takeBackAction: function ( action ) {

  		// [  active actions  | inactive actions ]
  		// [ active actions |< inactive actions  ]
  		//        a        s
  		//         <-swap->
  		//        s        a

  		var actions = this._actions,
  			prevIndex = action._cacheIndex,

  			firstInactiveIndex = -- this._nActiveActions,

  			lastActiveAction = actions[ firstInactiveIndex ];

  		action._cacheIndex = firstInactiveIndex;
  		actions[ firstInactiveIndex ] = action;

  		lastActiveAction._cacheIndex = prevIndex;
  		actions[ prevIndex ] = lastActiveAction;

  	},

  	// Memory management for PropertyMixer objects

  	_addInactiveBinding: function ( binding, rootUuid, trackName ) {

  		var bindingsByRoot = this._bindingsByRootAndName,
  			bindingByName = bindingsByRoot[ rootUuid ],

  			bindings = this._bindings;

  		if ( bindingByName === undefined ) {

  			bindingByName = {};
  			bindingsByRoot[ rootUuid ] = bindingByName;

  		}

  		bindingByName[ trackName ] = binding;

  		binding._cacheIndex = bindings.length;
  		bindings.push( binding );

  	},

  	_removeInactiveBinding: function ( binding ) {

  		var bindings = this._bindings,
  			propBinding = binding.binding,
  			rootUuid = propBinding.rootNode.uuid,
  			trackName = propBinding.path,
  			bindingsByRoot = this._bindingsByRootAndName,
  			bindingByName = bindingsByRoot[ rootUuid ],

  			lastInactiveBinding = bindings[ bindings.length - 1 ],
  			cacheIndex = binding._cacheIndex;

  		lastInactiveBinding._cacheIndex = cacheIndex;
  		bindings[ cacheIndex ] = lastInactiveBinding;
  		bindings.pop();

  		delete bindingByName[ trackName ];

  		remove_empty_map: {

  			for ( var _ in bindingByName ) { break remove_empty_map; } // eslint-disable-line no-unused-vars

  			delete bindingsByRoot[ rootUuid ];

  		}

  	},

  	_lendBinding: function ( binding ) {

  		var bindings = this._bindings,
  			prevIndex = binding._cacheIndex,

  			lastActiveIndex = this._nActiveBindings ++,

  			firstInactiveBinding = bindings[ lastActiveIndex ];

  		binding._cacheIndex = lastActiveIndex;
  		bindings[ lastActiveIndex ] = binding;

  		firstInactiveBinding._cacheIndex = prevIndex;
  		bindings[ prevIndex ] = firstInactiveBinding;

  	},

  	_takeBackBinding: function ( binding ) {

  		var bindings = this._bindings,
  			prevIndex = binding._cacheIndex,

  			firstInactiveIndex = -- this._nActiveBindings,

  			lastActiveBinding = bindings[ firstInactiveIndex ];

  		binding._cacheIndex = firstInactiveIndex;
  		bindings[ firstInactiveIndex ] = binding;

  		lastActiveBinding._cacheIndex = prevIndex;
  		bindings[ prevIndex ] = lastActiveBinding;

  	},


  	// Memory management of Interpolants for weight and time scale

  	_lendControlInterpolant: function () {

  		var interpolants = this._controlInterpolants,
  			lastActiveIndex = this._nActiveControlInterpolants ++,
  			interpolant = interpolants[ lastActiveIndex ];

  		if ( interpolant === undefined ) {

  			interpolant = new LinearInterpolant(
  				new Float32Array( 2 ), new Float32Array( 2 ),
  				1, this._controlInterpolantsResultBuffer );

  			interpolant.__cacheIndex = lastActiveIndex;
  			interpolants[ lastActiveIndex ] = interpolant;

  		}

  		return interpolant;

  	},

  	_takeBackControlInterpolant: function ( interpolant ) {

  		var interpolants = this._controlInterpolants,
  			prevIndex = interpolant.__cacheIndex,

  			firstInactiveIndex = -- this._nActiveControlInterpolants,

  			lastActiveInterpolant = interpolants[ firstInactiveIndex ];

  		interpolant.__cacheIndex = firstInactiveIndex;
  		interpolants[ firstInactiveIndex ] = interpolant;

  		lastActiveInterpolant.__cacheIndex = prevIndex;
  		interpolants[ prevIndex ] = lastActiveInterpolant;

  	},

  	_controlInterpolantsResultBuffer: new Float32Array( 1 ),

  	// return an action for a clip optionally using a custom root target
  	// object (this method allocates a lot of dynamic memory in case a
  	// previously unknown clip/root combination is specified)
  	clipAction: function ( clip, optionalRoot ) {

  		var root = optionalRoot || this._root,
  			rootUuid = root.uuid,

  			clipObject = typeof clip === 'string' ?
  				AnimationClip.findByName( root, clip ) : clip,

  			clipUuid = clipObject !== null ? clipObject.uuid : clip,

  			actionsForClip = this._actionsByClip[ clipUuid ],
  			prototypeAction = null;

  		if ( actionsForClip !== undefined ) {

  			var existingAction =
  					actionsForClip.actionByRoot[ rootUuid ];

  			if ( existingAction !== undefined ) {

  				return existingAction;

  			}

  			// we know the clip, so we don't have to parse all
  			// the bindings again but can just copy
  			prototypeAction = actionsForClip.knownActions[ 0 ];

  			// also, take the clip from the prototype action
  			if ( clipObject === null )
  				{ clipObject = prototypeAction._clip; }

  		}

  		// clip must be known when specified via string
  		if ( clipObject === null ) { return null; }

  		// allocate all resources required to run it
  		var newAction = new AnimationAction$1( this, clipObject, optionalRoot );

  		this._bindAction( newAction, prototypeAction );

  		// and make the action known to the memory manager
  		this._addInactiveAction( newAction, clipUuid, rootUuid );

  		return newAction;

  	},

  	// get an existing action
  	existingAction: function ( clip, optionalRoot ) {

  		var root = optionalRoot || this._root,
  			rootUuid = root.uuid,

  			clipObject = typeof clip === 'string' ?
  				AnimationClip.findByName( root, clip ) : clip,

  			clipUuid = clipObject ? clipObject.uuid : clip,

  			actionsForClip = this._actionsByClip[ clipUuid ];

  		if ( actionsForClip !== undefined ) {

  			return actionsForClip.actionByRoot[ rootUuid ] || null;

  		}

  		return null;

  	},

  	// deactivates all previously scheduled actions
  	stopAllAction: function () {

  		var actions = this._actions,
  			nActions = this._nActiveActions,
  			bindings = this._bindings,
  			nBindings = this._nActiveBindings;

  		this._nActiveActions = 0;
  		this._nActiveBindings = 0;

  		for ( var i = 0; i !== nActions; ++ i ) {

  			actions[ i ].reset();

  		}

  		for ( var i = 0; i !== nBindings; ++ i ) {

  			bindings[ i ].useCount = 0;

  		}

  		return this;

  	},

  	// advance the time and update apply the animation
  	update: function ( deltaTime ) {

  		deltaTime *= this.timeScale;

  		var actions = this._actions,
  			nActions = this._nActiveActions,

  			time = this.time += deltaTime,
  			timeDirection = Math.sign( deltaTime ),

  			accuIndex = this._accuIndex ^= 1;

  		// run active actions

  		for ( var i = 0; i !== nActions; ++ i ) {

  			var action = actions[ i ];

  			action._update( time, deltaTime, timeDirection, accuIndex );

  		}

  		// update scene graph

  		var bindings = this._bindings,
  			nBindings = this._nActiveBindings;

  		for ( var i = 0; i !== nBindings; ++ i ) {

  			bindings[ i ].apply( accuIndex );

  		}

  		return this;

  	},

  	// return this mixer's root target object
  	getRoot: function () {

  		return this._root;

  	},

  	// free all resources specific to a particular clip
  	uncacheClip: function ( clip ) {
  		var this$1 = this;


  		var actions = this._actions,
  			clipUuid = clip.uuid,
  			actionsByClip = this._actionsByClip,
  			actionsForClip = actionsByClip[ clipUuid ];

  		if ( actionsForClip !== undefined ) {

  			// note: just calling _removeInactiveAction would mess up the
  			// iteration state and also require updating the state we can
  			// just throw away

  			var actionsToRemove = actionsForClip.knownActions;

  			for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

  				var action = actionsToRemove[ i ];

  				this$1._deactivateAction( action );

  				var cacheIndex = action._cacheIndex,
  					lastInactiveAction = actions[ actions.length - 1 ];

  				action._cacheIndex = null;
  				action._byClipCacheIndex = null;

  				lastInactiveAction._cacheIndex = cacheIndex;
  				actions[ cacheIndex ] = lastInactiveAction;
  				actions.pop();

  				this$1._removeInactiveBindingsForAction( action );

  			}

  			delete actionsByClip[ clipUuid ];

  		}

  	},

  	// free all resources specific to a particular root target object
  	uncacheRoot: function ( root ) {
  		var this$1 = this;


  		var rootUuid = root.uuid,
  			actionsByClip = this._actionsByClip;

  		for ( var clipUuid in actionsByClip ) {

  			var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
  				action = actionByRoot[ rootUuid ];

  			if ( action !== undefined ) {

  				this$1._deactivateAction( action );
  				this$1._removeInactiveAction( action );

  			}

  		}

  		var bindingsByRoot = this._bindingsByRootAndName,
  			bindingByName = bindingsByRoot[ rootUuid ];

  		if ( bindingByName !== undefined ) {

  			for ( var trackName in bindingByName ) {

  				var binding = bindingByName[ trackName ];
  				binding.restoreOriginalState();
  				this$1._removeInactiveBinding( binding );

  			}

  		}

  	},

  	// remove a targeted clip from the cache
  	uncacheAction: function ( clip, optionalRoot ) {

  		var action = this.existingAction( clip, optionalRoot );

  		if ( action !== null ) {

  			this._deactivateAction( action );
  			this._removeInactiveAction( action );

  		}

  	}

  } );

  /**
   * @author sroucheray / http://sroucheray.org/
   * @author mrdoob / http://mrdoob.com/
   */

  function AxisHelper$1( size ) {

  	size = size || 1;

  	var vertices = [
  		0, 0, 0,	size, 0, 0,
  		0, 0, 0,	0, size, 0,
  		0, 0, 0,	0, 0, size
  	];

  	var colors = [
  		1, 0, 0,	1, 0.6, 0,
  		0, 1, 0,	0.6, 1, 0,
  		0, 0, 1,	0, 0.6, 1
  	];

  	var geometry = new BufferGeometry();
  	geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  	geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

  	var material = new LineBasicMaterial( { vertexColors: VertexColors } );

  	LineSegments.call( this, geometry, material );

  }

  AxisHelper$1.prototype = Object.create( LineSegments.prototype );
  AxisHelper$1.prototype.constructor = AxisHelper$1;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / http://github.com/Mugen87
   */

  function BoxHelper$1( object, color ) {

  	this.object = object;

  	if ( color === undefined ) { color = 0xffff00; }

  	var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
  	var positions = new Float32Array( 8 * 3 );

  	var geometry = new BufferGeometry();
  	geometry.setIndex( new BufferAttribute( indices, 1 ) );
  	geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );

  	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );

  	this.matrixAutoUpdate = false;

  	this.update();

  }

  BoxHelper$1.prototype = Object.create( LineSegments.prototype );
  BoxHelper$1.prototype.constructor = BoxHelper$1;

  BoxHelper$1.prototype.update = ( function () {

  	var box = new Box3();

  	return function update( object ) {

  		if ( object !== undefined ) {

  			console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );

  		}

  		if ( this.object !== undefined ) {

  			box.setFromObject( this.object );

  		}

  		if ( box.isEmpty() ) { return; }

  		var min = box.min;
  		var max = box.max;

  		/*
  		  5____4
  		1/___0/|
  		| 6__|_7
  		2/___3/

  		0: max.x, max.y, max.z
  		1: min.x, max.y, max.z
  		2: min.x, min.y, max.z
  		3: max.x, min.y, max.z
  		4: max.x, max.y, min.z
  		5: min.x, max.y, min.z
  		6: min.x, min.y, min.z
  		7: max.x, min.y, min.z
  		*/

  		var position = this.geometry.attributes.position;
  		var array = position.array;

  		array[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;
  		array[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;
  		array[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;
  		array[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
  		array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
  		array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
  		array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
  		array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

  		position.needsUpdate = true;

  		this.geometry.computeBoundingSphere();

  	};

  } )();

  BoxHelper$1.prototype.setFromObject = function ( object ) {

  	this.object = object;
  	this.update();

  	return this;

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   * @author bhouston / http://clara.io
   */

  function Frustum$1( p0, p1, p2, p3, p4, p5 ) {

  	this.planes = [

  		( p0 !== undefined ) ? p0 : new Plane(),
  		( p1 !== undefined ) ? p1 : new Plane(),
  		( p2 !== undefined ) ? p2 : new Plane(),
  		( p3 !== undefined ) ? p3 : new Plane(),
  		( p4 !== undefined ) ? p4 : new Plane(),
  		( p5 !== undefined ) ? p5 : new Plane()

  	];

  }

  Object.assign( Frustum$1.prototype, {

  	set: function ( p0, p1, p2, p3, p4, p5 ) {

  		var planes = this.planes;

  		planes[ 0 ].copy( p0 );
  		planes[ 1 ].copy( p1 );
  		planes[ 2 ].copy( p2 );
  		planes[ 3 ].copy( p3 );
  		planes[ 4 ].copy( p4 );
  		planes[ 5 ].copy( p5 );

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( frustum ) {

  		var planes = this.planes;

  		for ( var i = 0; i < 6; i ++ ) {

  			planes[ i ].copy( frustum.planes[ i ] );

  		}

  		return this;

  	},

  	setFromMatrix: function ( m ) {

  		var planes = this.planes;
  		var me = m.elements;
  		var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
  		var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
  		var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
  		var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

  		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
  		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
  		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
  		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
  		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
  		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

  		return this;

  	},

  	intersectsObject: function () {

  		var sphere = new Sphere();

  		return function intersectsObject( object ) {

  			var geometry = object.geometry;

  			if ( geometry.boundingSphere === null )
  				{ geometry.computeBoundingSphere(); }

  			sphere.copy( geometry.boundingSphere )
  				.applyMatrix4( object.matrixWorld );

  			return this.intersectsSphere( sphere );

  		};

  	}(),

  	intersectsSprite: function () {

  		var sphere = new Sphere();

  		return function intersectsSprite( sprite ) {

  			sphere.center.set( 0, 0, 0 );
  			sphere.radius = 0.7071067811865476;
  			sphere.applyMatrix4( sprite.matrixWorld );

  			return this.intersectsSphere( sphere );

  		};

  	}(),

  	intersectsSphere: function ( sphere ) {

  		var planes = this.planes;
  		var center = sphere.center;
  		var negRadius = - sphere.radius;

  		for ( var i = 0; i < 6; i ++ ) {

  			var distance = planes[ i ].distanceToPoint( center );

  			if ( distance < negRadius ) {

  				return false;

  			}

  		}

  		return true;

  	},

  	intersectsBox: function () {

  		var p1 = new Vector3$1(),
  			p2 = new Vector3$1();

  		return function intersectsBox( box ) {

  			var planes = this.planes;

  			for ( var i = 0; i < 6; i ++ ) {

  				var plane = planes[ i ];

  				p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
  				p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
  				p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
  				p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
  				p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
  				p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

  				var d1 = plane.distanceToPoint( p1 );
  				var d2 = plane.distanceToPoint( p2 );

  				// if both outside plane, no intersection

  				if ( d1 < 0 && d2 < 0 ) {

  					return false;

  				}

  			}

  			return true;

  		};

  	}(),

  	containsPoint: function ( point ) {

  		var planes = this.planes;

  		for ( var i = 0; i < 6; i ++ ) {

  			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

  				return false;

  			}

  		}

  		return true;

  	}

  } );

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * Extensible curve object
   *
   * Some common of curve methods:
   * .getPoint(t), getTangent(t)
   * .getPointAt(u), getTangentAt(u)
   * .getPoints(), .getSpacedPoints()
   * .getLength()
   * .updateArcLengths()
   *
   * This following curves inherit from THREE.Curve:
   *
   * -- 2D curves --
   * THREE.ArcCurve
   * THREE.CubicBezierCurve
   * THREE.EllipseCurve
   * THREE.LineCurve
   * THREE.QuadraticBezierCurve
   * THREE.SplineCurve
   *
   * -- 3D curves --
   * THREE.CatmullRomCurve3
   * THREE.CubicBezierCurve3
   * THREE.LineCurve3
   * THREE.QuadraticBezierCurve3
   *
   * A series of curves can be represented as a THREE.CurvePath.
   *
   **/

  /**************************************************************
   *	Abstract Curve base class
   **************************************************************/

  function Curve$1() {

  	this.arcLengthDivisions = 200;

  }

  Object.assign( Curve$1.prototype, {

  	// Virtual base class method to overwrite and implement in subclasses
  	//	- t [0 .. 1]

  	getPoint: function () {

  		console.warn( 'THREE.Curve: .getPoint() not implemented.' );
  		return null;

  	},

  	// Get point at relative position in curve according to arc length
  	// - u [0 .. 1]

  	getPointAt: function ( u ) {

  		var t = this.getUtoTmapping( u );
  		return this.getPoint( t );

  	},

  	// Get sequence of points using getPoint( t )

  	getPoints: function ( divisions ) {
  		var this$1 = this;


  		if ( divisions === undefined ) { divisions = 5; }

  		var points = [];

  		for ( var d = 0; d <= divisions; d ++ ) {

  			points.push( this$1.getPoint( d / divisions ) );

  		}

  		return points;

  	},

  	// Get sequence of points using getPointAt( u )

  	getSpacedPoints: function ( divisions ) {
  		var this$1 = this;


  		if ( divisions === undefined ) { divisions = 5; }

  		var points = [];

  		for ( var d = 0; d <= divisions; d ++ ) {

  			points.push( this$1.getPointAt( d / divisions ) );

  		}

  		return points;

  	},

  	// Get total curve arc length

  	getLength: function () {

  		var lengths = this.getLengths();
  		return lengths[ lengths.length - 1 ];

  	},

  	// Get list of cumulative segment lengths

  	getLengths: function ( divisions ) {
  		var this$1 = this;


  		if ( divisions === undefined ) { divisions = this.arcLengthDivisions; }

  		if ( this.cacheArcLengths &&
  			( this.cacheArcLengths.length === divisions + 1 ) &&
  			! this.needsUpdate ) {

  			return this.cacheArcLengths;

  		}

  		this.needsUpdate = false;

  		var cache = [];
  		var current, last = this.getPoint( 0 );
  		var p, sum = 0;

  		cache.push( 0 );

  		for ( p = 1; p <= divisions; p ++ ) {

  			current = this$1.getPoint( p / divisions );
  			sum += current.distanceTo( last );
  			cache.push( sum );
  			last = current;

  		}

  		this.cacheArcLengths = cache;

  		return cache; // { sums: cache, sum: sum }; Sum is in the last element.

  	},

  	updateArcLengths: function () {

  		this.needsUpdate = true;
  		this.getLengths();

  	},

  	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

  	getUtoTmapping: function ( u, distance ) {

  		var arcLengths = this.getLengths();

  		var i = 0, il = arcLengths.length;

  		var targetArcLength; // The targeted u distance value to get

  		if ( distance ) {

  			targetArcLength = distance;

  		} else {

  			targetArcLength = u * arcLengths[ il - 1 ];

  		}

  		// binary search for the index with largest value smaller than target u distance

  		var low = 0, high = il - 1, comparison;

  		while ( low <= high ) {

  			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

  			comparison = arcLengths[ i ] - targetArcLength;

  			if ( comparison < 0 ) {

  				low = i + 1;

  			} else if ( comparison > 0 ) {

  				high = i - 1;

  			} else {

  				high = i;
  				break;

  				// DONE

  			}

  		}

  		i = high;

  		if ( arcLengths[ i ] === targetArcLength ) {

  			return i / ( il - 1 );

  		}

  		// we could get finer grain at lengths, or use simple interpolation between two points

  		var lengthBefore = arcLengths[ i ];
  		var lengthAfter = arcLengths[ i + 1 ];

  		var segmentLength = lengthAfter - lengthBefore;

  		// determine where we are between the 'before' and 'after' points

  		var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

  		// add that fractional amount to t

  		var t = ( i + segmentFraction ) / ( il - 1 );

  		return t;

  	},

  	// Returns a unit vector tangent at t
  	// In case any sub curve does not implement its tangent derivation,
  	// 2 points a small delta apart will be used to find its gradient
  	// which seems to give a reasonable approximation

  	getTangent: function ( t ) {

  		var delta = 0.0001;
  		var t1 = t - delta;
  		var t2 = t + delta;

  		// Capping in case of danger

  		if ( t1 < 0 ) { t1 = 0; }
  		if ( t2 > 1 ) { t2 = 1; }

  		var pt1 = this.getPoint( t1 );
  		var pt2 = this.getPoint( t2 );

  		var vec = pt2.clone().sub( pt1 );
  		return vec.normalize();

  	},

  	getTangentAt: function ( u ) {

  		var t = this.getUtoTmapping( u );
  		return this.getTangent( t );

  	},

  	computeFrenetFrames: function ( segments, closed ) {
  		var this$1 = this;


  		// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

  		var normal = new Vector3$1();

  		var tangents = [];
  		var normals = [];
  		var binormals = [];

  		var vec = new Vector3$1();
  		var mat = new Matrix4();

  		var i, u, theta;

  		// compute the tangent vectors for each segment on the curve

  		for ( i = 0; i <= segments; i ++ ) {

  			u = i / segments;

  			tangents[ i ] = this$1.getTangentAt( u );
  			tangents[ i ].normalize();

  		}

  		// select an initial normal vector perpendicular to the first tangent vector,
  		// and in the direction of the minimum tangent xyz component

  		normals[ 0 ] = new Vector3$1();
  		binormals[ 0 ] = new Vector3$1();
  		var min = Number.MAX_VALUE;
  		var tx = Math.abs( tangents[ 0 ].x );
  		var ty = Math.abs( tangents[ 0 ].y );
  		var tz = Math.abs( tangents[ 0 ].z );

  		if ( tx <= min ) {

  			min = tx;
  			normal.set( 1, 0, 0 );

  		}

  		if ( ty <= min ) {

  			min = ty;
  			normal.set( 0, 1, 0 );

  		}

  		if ( tz <= min ) {

  			normal.set( 0, 0, 1 );

  		}

  		vec.crossVectors( tangents[ 0 ], normal ).normalize();

  		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
  		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


  		// compute the slowly-varying normal and binormal vectors for each segment on the curve

  		for ( i = 1; i <= segments; i ++ ) {

  			normals[ i ] = normals[ i - 1 ].clone();

  			binormals[ i ] = binormals[ i - 1 ].clone();

  			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

  			if ( vec.length() > Number.EPSILON ) {

  				vec.normalize();

  				theta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

  				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

  			}

  			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

  		}

  		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

  		if ( closed === true ) {

  			theta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
  			theta /= segments;

  			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

  				theta = - theta;

  			}

  			for ( i = 1; i <= segments; i ++ ) {

  				// twist a little...
  				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
  				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

  			}

  		}

  		return {
  			tangents: tangents,
  			normals: normals,
  			binormals: binormals
  		};

  	}

  } );

  function LineCurve$1( v1, v2 ) {

  	Curve$1.call( this );

  	this.v1 = v1;
  	this.v2 = v2;

  }

  LineCurve$1.prototype = Object.create( Curve$1.prototype );
  LineCurve$1.prototype.constructor = LineCurve$1;

  LineCurve$1.prototype.isLineCurve = true;

  LineCurve$1.prototype.getPoint = function ( t ) {

  	if ( t === 1 ) {

  		return this.v2.clone();

  	}

  	var point = this.v2.clone().sub( this.v1 );
  	point.multiplyScalar( t ).add( this.v1 );

  	return point;

  };

  // Line curve is linear, so we can overwrite default getPointAt

  LineCurve$1.prototype.getPointAt = function ( u ) {

  	return this.getPoint( u );

  };

  LineCurve$1.prototype.getTangent = function ( /* t */ ) {

  	var tangent = this.v2.clone().sub( this.v1 );

  	return tangent.normalize();

  };

  /**
   * @author Sean Griffin / http://twitter.com/sgrif
   * @author Michael Guerrero / http://realitymeltdown.com
   * @author mrdoob / http://mrdoob.com/
   * @author ikerr / http://verold.com
   * @author Mugen87 / https://github.com/Mugen87
   */

  function getBoneList$1( object ) {

  	var boneList = [];

  	if ( object && object.isBone ) {

  		boneList.push( object );

  	}

  	for ( var i = 0; i < object.children.length; i ++ ) {

  		boneList.push.apply( boneList, getBoneList$1( object.children[ i ] ) );

  	}

  	return boneList;

  }

  function SkeletonHelper$1( object ) {

  	var bones = getBoneList$1( object );

  	var geometry = new BufferGeometry();

  	var vertices = [];
  	var colors = [];

  	var color1 = new Color( 0, 0, 1 );
  	var color2 = new Color( 0, 1, 0 );

  	for ( var i = 0; i < bones.length; i ++ ) {

  		var bone = bones[ i ];

  		if ( bone.parent && bone.parent.isBone ) {

  			vertices.push( 0, 0, 0 );
  			vertices.push( 0, 0, 0 );
  			colors.push( color1.r, color1.g, color1.b );
  			colors.push( color2.r, color2.g, color2.b );

  		}

  	}

  	geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  	geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

  	var material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );

  	LineSegments.call( this, geometry, material );

  	this.root = object;
  	this.bones = bones;

  	this.matrix = object.matrixWorld;
  	this.matrixAutoUpdate = false;

  }

  SkeletonHelper$1.prototype = Object.create( LineSegments.prototype );
  SkeletonHelper$1.prototype.constructor = SkeletonHelper$1;

  SkeletonHelper$1.prototype.updateMatrixWorld = function () {

  	var vector = new Vector3$1();

  	var boneMatrix = new Matrix4();
  	var matrixWorldInv = new Matrix4();

  	return function updateMatrixWorld( force ) {

  		var bones = this.bones;

  		var geometry = this.geometry;
  		var position = geometry.getAttribute( 'position' );

  		matrixWorldInv.getInverse( this.root.matrixWorld );

  		for ( var i = 0, j = 0; i < bones.length; i ++ ) {

  			var bone = bones[ i ];

  			if ( bone.parent && bone.parent.isBone ) {

  				boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
  				vector.setFromMatrixPosition( boneMatrix );
  				position.setXYZ( j, vector.x, vector.y, vector.z );

  				boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
  				vector.setFromMatrixPosition( boneMatrix );
  				position.setXYZ( j + 1, vector.x, vector.y, vector.z );

  				j += 2;

  			}

  		}

  		geometry.getAttribute( 'position' ).needsUpdate = true;

  		Object3D.prototype.updateMatrixWorld.call( this, force );

  	};

  }();

  /**
   * @author [Tristan Valcke]{@link https://github.com/Itee}
   * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
   *
   * @class TErrorManager
   * @classdesc TCache is a simple javascript object whose purpose is to store some ket/value data to future usage. It could be enable/disable.
   *
   * @example
   * var cache = new TCache()
   * cache.add( 'foo', 'bar' )
   * console.log( cache.get('foo') ) // 'bar'
   */

  /**
   * @class Super class cache!
   */
  var TCache = function TCache () {
      this._cache = {};
  };

  /**
   * Allow to add new key value pair, the key cannot be null, undefined, or an empty string.
   * In case the key already exist, the value will be overwritten.
   *
   * @param key
   * @param file
   */
  TCache.prototype.add = function add ( key, file ) {

      this._cache[ key ] = file;

  };

  /**
   * Return the value associated to the key.
   *
   * @param key
   * @returns {*}
   */
  TCache.prototype.get = function get ( key ) {

      return this._cache[ key ]

  };

  /**
   * Remove to value from the cache. Does nothing if the key does not exist.
   *
   * @param key
   */
  TCache.prototype.remove = function remove ( key ) {

      delete this._cache[ key ];

  };

  /**
   * Clear the cache and reset it to an empty object.
   */
  TCache.prototype.clear = function clear () {

      this._cache = {};

  };

  /**
   * @author [Tristan Valcke]{@link https://github.com/Itee}
   * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
   *
   * @class TDataBaseManager
   * @classdesc The base class of database managers. Give the basic interface about database call.
   *
   * @requires {@link HttpVerb}
   * @requires {@link ResponseType}
   * @requires {@link HttpStatusCode}
   * @requires {@link TOrchestrator}
   * @requires {@link TCache}
   *
   * @example Todo
   *
   */

  function TDataBaseManager () {

      var _basePath     = '/';
      var _responseType = ResponseType.Json;

      // Todo: progress and error manager
      this.progressManager = null;
      this.errorManager    = null;

      Object.defineProperties( this, {

          basePath: {
              enumerable: true,
              get: function get () {
                  return _basePath
              },
              set: function set ( basePath ) {

                  if ( !basePath ) {
                      throw new Error( 'TDataBaseManager: basePath cannot be null or undefined !' )
                  }

                  if ( typeof basePath !== 'string' ) {
                      throw new Error( 'TDataBaseManager: basePath is expected to be a string !' )
                  }

                  if ( basePath.length === 0 ) {
                      throw new Error( 'TDataBaseManager: basePath cannot be an empty string !' )
                  }

                  if ( !/\S/.test( basePath ) ) {
                      throw new Error( 'TDataBaseManager: basePath cannot contain only whithspace !' )
                  }

                  _basePath = basePath;
              }
          },

          responseType: {
              enumerable: true,
              get: function get () {
                  return _responseType
              },
              set: function set ( responseType ) {

                  if ( !responseType ) {
                      throw new Error( 'TDataBaseManager: basePath cannot be null or undefined !' )
                  }

                  if ( typeof responseType !== 'string' ) {
                      throw new Error( 'TDataBaseManager: basePath is expected to be a string !' )
                  }

                  _responseType = responseType;
              }
          },

          _cache: {
              value: new TCache()
          }

      } );

  }

  // Static Private properties
  Object.defineProperties( TDataBaseManager, {

      /**
       * @static
       * @private
       * @memberOf TDataBaseManager
       * @description The orchestrator singleton instance that will manage and perform database request from all managers.
       */
      _orchestrator: {
          value: singletonInstance
      },

      /**
       * @static
       * @private
       * @function
       * @memberOf TDataBaseManager
       * @description This static private method will check the server response status code, and perform the associated action.
       * @param {number} status - The server response status code to check.
       */
      _statusOk: {
          value: function (status) {

              var statusOk = false;

              if ( status === HttpStatusCode.NoContent ) {

                  console.warn( 'Unable to retrieve data...' );

              } else if ( status !== HttpStatusCode.Ok ) {

                  console.error( 'An error occurs when retrieve data from database !!!' );

              } else {

                  statusOk = true;

              }

              return statusOk

          }
      }

  } );

  // Static Public methods
  Object.assign( TDataBaseManager, {

      /**
       * @static
       * @function
       * @memberOf TDataBaseManager
       * @description Will queue an XMLHttpRequest to the orchestrator binding the callbacks to the server response.
       *
       * @param {HttpVerb} method - The method to use for this request.
       * @param {string} url - The URL to call.
       * @param {object} data - The data to sent to the server.
       * @param {function} onLoad - The onLoad callback, which is call when server respond with success to the request.
       * @param {function} onProgress - The onProgress callback, which is call during the response incoming.
       * @param {function} onError - The onError callback, which is call when server respond with an error to the request.
       * @param {ResponseType} responseType - Allow to set the expected response type.
       */
      requestServer: function requestServer ( method, url, data, onLoad, onProgress, onError, responseType ) {

          TDataBaseManager._orchestrator.queue( {
              method: method,
              url: url,
              data: data,
              onLoad: onLoad,
              onProgress: onProgress,
              onError: onError,
              responseType: responseType
          } );

      }

  } );

  /// Instance
  // private properties
  Object.defineProperties( TDataBaseManager.prototype, {

      //// Events

      /**
       * @private
       * @function
       * @memberOf TDataBaseManager.prototype
       * @description The private _onLoad method allow to process the server response in an abstract way to check against error and wrong status code.
       * It will bind user callback on each type of returns, and dispatch in sub methods in function of the response type.
       *
       * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
       * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
       * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
       * @param {object} loadEvent - The server response object to parse.
       */
      _onLoad: {
          value: function _onLoad ( onLoadCallback, onProgressCallback, onErrorCallback, loadEvent ) {

              var target       = loadEvent.target;
              var status       = target.status;
              var response     = target.response;
              var responseType = target.responseType;

              if ( !TDataBaseManager._statusOk( status ) ) { return }

              if ( !response ) {
                  console.error( 'TDataBaseManager.onLoad: No data receive !' );
                  return
              }

              switch ( responseType ) {

                  case ResponseType.ArrayBuffer:
                      this._onArrayBuffer(
                          response,
                          onLoadCallback,
                          this._onProgress.bind( this, onProgressCallback ),
                          this._onError.bind( this, onErrorCallback )
                      );
                      break;

                  case ResponseType.Blob:
                      this._onBlob(
                          response,
                          onLoadCallback,
                          this._onProgress.bind( this, onProgressCallback ),
                          this._onError.bind( this, onErrorCallback )
                      );
                      break;

                  case ResponseType.Json:
                      this._onJson(
                          response,
                          onLoadCallback,
                          this._onProgress.bind( this, onProgressCallback ),
                          this._onError.bind( this, onErrorCallback )
                      );
                      break;

                  case ResponseType.DOMString:
                  case ResponseType.Default:
                      this._onText(
                          response,
                          onLoadCallback,
                          this._onProgress.bind( this, onProgressCallback ),
                          this._onError.bind( this, onErrorCallback )
                      );
                      break;

                  default:
                      throw new Error( ("Unknown response type: " + responseType) )
                      break;

              }

          }
      },

      /**
       * @private
       * @function
       * @memberOf TDataBaseManager.prototype
       * @description The private _onProgress method will handle all progress event from server and submit them to the progressManager if exist else to the user onProgressCallback
       *
       * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
       * @param {object} progressEvent - The server progress event.
       */
      _onProgress: {
          value: function _onProgress ( onProgressCallback, progressEvent ) {

              if ( this.progressManager ) {

                  this.progressManager.update( onProgressCallback, progressEvent );

              } else if ( onProgressCallback ) {

                  onProgressCallback( progressEvent );

              } else {

                  //console.log( progressEvent )

              }

          }
      },

      /**
       * @private
       * @function
       * @memberOf TDataBaseManager.prototype
       * @description The private _onError method will handle all error event from server and submit them to the errorManager if exist else to the user onErrorCallback
       *
       * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
       * @param {object} errorEvent - A server error event
       */
      _onError: {
          value: function _onError ( onErrorCallback, errorEvent ) {

              if ( this.errorManager ) {

                  this.errorManager.update( onErrorCallback, errorEvent );

              } else if ( onErrorCallback ) {

                  onErrorCallback( errorEvent );

              } else {

                  console.error( errorEvent );

              }

          }
      },

      //// Data parsing
      // Expect that methods were reimplemented when TDataBaseManager is inherited

      /**
       * @private
       * @abstract
       * @function
       * @memberOf TDataBaseManager.prototype
       * @description The abstract private _onArrayBuffer method must be overridden in case the parser expect an array buffer as input data.
       *
       * @param {ArrayBuffer} data - The retrieved data to parse.
       * @param {function} onSuccess - The onLoad callback, which is call when parser parse with success the data.
       * @param {function} onProgress - The onProgress callback, which is call during the parsing.
       * @param {function} onError - The onError callback, which is call when parser throw an error during parsing.
       */
      _onArrayBuffer: {
          value: function _onArrayBufferDefault ( data, onSuccess, onProgress, onError ) {
              throw new Error( 'TDataBaseManager: _onArrayBuffer methods must be reimplemented !' )
          }
      },

      /**
       * @private
       * @abstract
       * @function
       * @memberOf TDataBaseManager.prototype
       * @description The abstract private _onBlob method must be overridden in case the parser expect a blob as input data.
       *
       * @param {Blob} data - The retrieved data to parse.
       * @param {function} onSuccess - The onLoad callback, which is call when parser parse with success the data.
       * @param {function} onProgress - The onProgress callback, which is call during the parsing.
       * @param {function} onError - The onError callback, which is call when parser throw an error during parsing.
       */
      _onBlob: {
          value: function _onBlobDefault ( data, onSuccess, onProgress, onError ) {
              throw new Error( 'TDataBaseManager: _onBlob methods must be reimplemented !' )
          }
      },

      /**
       * @private
       * @abstract
       * @function
       * @memberOf TDataBaseManager.prototype
       * @description The abstract private _onJson method must be overridden in case the parser expect json as input data.
       *
       * @param {json} data - The retrieved data to parse.
       * @param {function} onSuccess - The onLoad callback, which is call when parser parse with success the data.
       * @param {function} onProgress - The onProgress callback, which is call during the parsing.
       * @param {function} onError - The onError callback, which is call when parser throw an error during parsing.
       */
      _onJson: {
          value: function _onJsonDefault ( data, onSuccess, onProgress, onError ) {
              throw new Error( 'TDataBaseManager: _onJson methods must be reimplemented !' )
          }
      },

      /**
       * @private
       * @abstract
       * @function
       * @memberOf TDataBaseManager.prototype
       * @description The abstract private _onText method must be overridden in case the parser expect a string/text as input data.
       *
       * @param {string} data - The retrieved data to parse.
       * @param {function} onSuccess - The onLoad callback, which is call when parser parse with success the data.
       * @param {function} onProgress - The onProgress callback, which is call during the parsing.
       * @param {function} onError - The onError callback, which is call when parser throw an error during parsing.
       */
      _onText: {
          value: function _onTextDefault ( data, onSuccess, onProgress, onError ) {
              throw new Error( 'TDataBaseManager: _onText methods must be reimplemented !' )
          }
      },

      // REST Api calls
      /**
       * @private
       * @function
       * @memberOf TDataBaseManager.prototype
       * @description The private _create method allow to format a server request to create objects with the given data and get creation result with given callbacks.
       *
       * @param {object} data - The data to send.
       * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
       * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
       * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
       */
      _create: {
          value: function _create ( data, onLoadCallback, onProgressCallback, onErrorCallback ) {

              TDataBaseManager.requestServer(
                  HttpVerb.Create,
                  this.basePath,
                  data,
                  this._onLoad.bind( this, onLoadCallback, onProgressCallback, onErrorCallback ),
                  this._onProgress.bind( this, onProgressCallback ),
                  this._onError.bind( this, onErrorCallback ),
                  this.responseType
              );

          }
      },

      /**
       * @private
       * @function
       * @memberOf TDataBaseManager.prototype
       * @description The private _readSome method will format a server request to get objects with id in the ids array.
       *
       * @param {array.<string>} ids - The ids of objects to retrieve.
       * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
       * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
       * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
       */
      _readSome: {
          value: function _readSome ( ids, onLoadCallback, onProgressCallback, onErrorCallback ) {
              var this$1 = this;


              var self = this;
              var results = [];

              var cachedResult = undefined;
              var id = undefined;
              for ( var idIndex = 0, numberOfIds = ids.length ; idIndex < numberOfIds ; idIndex++ ) {
                  id = ids[ idIndex ];

                  cachedResult = this$1._cache.get( id );
                  if ( !cachedResult ) { break }

                  results.push(cachedResult);
              }

              if(results.length === ids.length ) {

                  onLoadCallback(results);

              } else {

                  function cacheOnLoadResult( results ) {

                      var result = undefined;
                      for ( var resultIndex = 0, numberOfResults = results.length ; resultIndex < numberOfResults ; resultIndex++ ) {
                          result = results[ resultIndex ];
                          self._cache.add(ids[resultIndex], result);
                      }
                      onLoadCallback(results);

                  }

                  TDataBaseManager.requestServer(
                      HttpVerb.Read,
                      this.basePath,
                      ids,
                      this._onLoad.bind( this, cacheOnLoadResult, onProgressCallback, onErrorCallback ),
                      this._onProgress.bind( this, onProgressCallback ),
                      this._onError.bind( this, onErrorCallback ),
                      this.responseType
                  );

              }


          }
      },

      /**
       * @private
       * @function
       * @memberOf TDataBaseManager.prototype
       * @description The private _updateOne method will format a server request to get a single object with the given id.
       *
       * @param {string} id - The object's id of the object to retrieve.
       * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
       * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
       * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
       */
      _readOne: {
          value: function _readOne ( id, onLoadCallback, onProgressCallback, onErrorCallback ) {

              var self = this;
              var cachedValue = this._cache.get( id );

              if ( cachedValue ) {

                  onLoadCallback( cachedValue );

              } else {

                  function cacheOnLoadResult( result ) {

                      self._cache.add(id, result[0]);
                      onLoadCallback(result);

                  }

                  TDataBaseManager.requestServer(
                      HttpVerb.Read,
                      ((this.basePath) + "/" + id),
                      null,
                      this._onLoad.bind( this, cacheOnLoadResult, onProgressCallback, onErrorCallback ),
                      this._onProgress.bind( this, onProgressCallback ),
                      this._onError.bind( this, onErrorCallback ),
                      this.responseType
                  );

              }

          }
      },

      //Todo: where are update datas ?
      /**
       * @private
       * @function
       * @memberOf TDataBaseManager.prototype
       * @description The private _updateSome method will format a server request to update objects with id in the ids array.
       *
       * @param {array.<string>} ids - The ids of objects to update.
       * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
       * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
       * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
       */
      _updateSome: {
          value: function _updateSome ( ids, onLoadCallback, onProgressCallback, onErrorCallback ) {

              TDataBaseManager.requestServer(
                  HttpVerb.Update,
                  this.basePath,
                  ids,
                  this._onLoad.bind( this, onLoadCallback, onProgressCallback, onErrorCallback ),
                  this._onProgress.bind( this, onProgressCallback ),
                  this._onError.bind( this, onErrorCallback ),
                  this.responseType
              );

          }
      },

      //Todo: where are update datas ?
      /**
       * @private
       * @function
       * @memberOf TDataBaseManager.prototype
       * @description The private _updateOne method will format a server request to update a single object with the given id.
       *
       * @param {string} id - The object's id of the object to update.
       * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
       * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
       * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
       */
      _updateOne: {
          value: function _updateOne ( id, onLoadCallback, onProgressCallback, onErrorCallback ) {

              TDataBaseManager.requestServer(
                  HttpVerb.Update,
                  ((this.basePath) + "/" + id),
                  null,
                  this._onLoad.bind( this, onLoadCallback, onProgressCallback, onErrorCallback ),
                  this._onProgress.bind( this, onProgressCallback ),
                  this._onError.bind( this, onErrorCallback ),
                  this.responseType
              );

          }
      },

      /**
       * @private
       * @function
       * @memberOf TDataBaseManager.prototype
       * @description The private _deleteSome method will format a server request to delete objects with id in the ids array.
       *
       * @param {array.<string>} ids - The ids of objects to delete.
       * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
       * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
       * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
       */
      _deleteSome: {
          value: function _deleteSome ( ids, onLoadCallback, onProgressCallback, onErrorCallback ) {

              TDataBaseManager.requestServer(
                  HttpVerb.Delete,
                  this.basePath,
                  ids,
                  this._onLoad.bind( this, onLoadCallback, onProgressCallback, onErrorCallback ),
                  this._onProgress.bind( this, onProgressCallback ),
                  this._onError.bind( this, onErrorCallback ),
                  this.responseType
              );

          }
      },

      /**
       * @private
       * @function
       * @memberOf TDataBaseManager.prototype
       * @description The private _deleteOne method will format a server request to delete a single object with the given id.
       *
       * @param {string} id - The object's id of the object to delete.
       * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
       * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
       * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
       */
      _deleteOne: {
          value: function _deleteOne ( id, onLoadCallback, onProgressCallback, onErrorCallback ) {

              TDataBaseManager.requestServer(
                  HttpVerb.Delete,
                  ((this.basePath) + "/" + id),
                  null,
                  this._onLoad.bind( this, onLoadCallback, onProgressCallback, onErrorCallback ),
                  this._onProgress.bind( this, onProgressCallback ),
                  this._onError.bind( this, onErrorCallback ),
                  this.responseType
              );

          }
      }

  } );

  // Public interface
  Object.assign( TDataBaseManager.prototype, {

      /**
       * @function
       * @memberOf TDataBaseManager.prototype
       * @description The create method allow to create a new ressource on the server. Providing a single object that match a database schema, or an array of them.
       *
       * @param {object|array.<object>} data - The data to send for create new objects.
       * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
       * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
       * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
       */
      create: function create ( data, onLoadCallback, onProgressCallback, onErrorCallback ) {

          var dataArray = [];
          var onError = onErrorCallback || function ( error ) { console.error( error ); };

          if ( !data ) { onError( 'TDataBaseManager.create: Data cannot be null or undefined !' ); }

          if ( Array.isArray( data ) ) {

              if ( data.length === 0 ) { onError( 'TDataBaseManager.create: Array of data cannot be empty !' ); }

              dataArray = data;

          } else {

              dataArray.push( data );

          }

          this._create( dataArray, onLoadCallback, onProgressCallback, onError );

      },

      /**
       * @function
       * @memberOf TDataBaseManager.prototype
       * @description The read method allow to retrieve data from the server, using a single id or an array of them.
       *
       * @param {string|array.<string>} ids - The ids of objects to retrieve.
       * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
       * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
       * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
       */
      read: function read ( ids, onLoadCallback, onProgressCallback, onErrorCallback ) {

          var onError = onErrorCallback || function ( error ) { console.error( error ); };

          if ( !ids ) { onError( 'TDataBaseManager.read: Ids cannot be null or undefined !' ); }

          if ( Array.isArray( ids ) ) {

              if ( ids.length === 0 ) { onError( 'TDataBaseManager.read: Array of data cannot be empty !' ); }

              if ( ids.length === 1 ) {
                  this._readOne( ids[0], onLoadCallback, onProgressCallback, onError );
              } else {
                  this._readSome( ids, onLoadCallback, onProgressCallback, onError );
              }

          } else if ( typeof ids === 'string' ) {

              this._readOne( ids, onLoadCallback, onProgressCallback, onError );

          } else {

              onError( 'TDataBaseManager.read: Expected string id or array of string id !' );

          }

      },

      /**
       * @function
       * @memberOf TDataBaseManager.prototype
       * @description The update method allow to update data on the server, using a single id or an array of them, and a corresponding object about the data to update.
       *
       * @param {string|array.<string>} ids - The ids of objects to update.
       * @param {object} data - The update data ( need to match the related database schema ! ). In case of multiple ids they will be updated with the same given data.
       * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
       * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
       * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
       */
      update: function update ( ids, data, onLoadCallback, onProgressCallback, onErrorCallback ) {

          var onError = onErrorCallback || function ( error ) { console.error( error ); };

          if ( !ids ) { onError( 'TDataBaseManager.update: Ids cannot be null or undefined !' ); }
          if ( !data ) { onError( 'TDataBaseManager.update: Data cannot be null or undefined !' ); }

          if ( Array.isArray( ids ) ) {

              this._updateSome( ids, onLoadCallback, onProgressCallback, onError );

          } else if ( typeof ids === 'string' ) {

              this._updateOne( ids, onLoadCallback, onProgressCallback, onError );

          } else {

              onError( 'TDataBaseManager.update: Expected string id or array of string id !' );

          }

      },

      /**
       * @function
       * @memberOf TDataBaseManager.prototype
       * @description The delete method allow to remove data from the server, using a single id or an array of them.
       *
       * @param {string|array.<string>} ids - The ids of objects to delete.
       * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
       * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
       * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
       */
      delete: function delete$1 ( ids, onLoadCallback, onProgressCallback, onErrorCallback ) {

          var onError = onErrorCallback || function ( error ) { console.error( error ); };

          if ( !ids ) { onError( 'TDataBaseManager.delete: Ids data cannot be null or undefined !' ); }

          if ( Array.isArray( ids ) ) {

              this._deleteSome( ids, onLoadCallback, onProgressCallback, onError );

          } else if ( typeof ids === 'string' ) {

              this._deleteOne( ids, onLoadCallback, onProgressCallback, onError );

          } else {

              onError( 'TDataBaseManager.delete: Expected string id or array of string id !' );

          }

      },

  } );

  /**
   * @author [Tristan Valcke]{@link https://github.com/Itee}
   * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
   *
   * @class TScenesManager
   * @classdesc Todo...
   * @example Todo...
   *
   */

  /**
   *
   * @constructor
   */
  function TObjectsManager () {

      TDataBaseManager.call( this );
      this.basePath = '/objects';

  }

  TObjectsManager.prototype = Object.assign( Object.create( TDataBaseManager.prototype ), {

      constructor: TObjectsManager,

      convertJsonToObject3D: function convertJsonToObject3D ( jsonData, onError ) {

          // Todo factory
          var data       = jsonData;
          var objectType = data.type;

          if ( objectType === 'Object3D' ) {

              var object3d            = new Object3D$1();
              object3d.uuid           = data.uuid;
              object3d.name           = data.name;
              object3d.type           = data.type;
              object3d.parent         = data.parent;
              object3d.children       = [];
              object3d.up.x           = data.up.x;
              object3d.up.y           = data.up.y;
              object3d.up.z           = data.up.z;
              object3d.position.x     = data.position.x;
              object3d.position.y     = data.position.y;
              object3d.position.z     = data.position.z;
              object3d.rotation.x     = data.rotation.x;
              object3d.rotation.y     = data.rotation.y;
              object3d.rotation.z     = data.rotation.z;
              object3d.rotation.order = data.rotation.order;
              object3d.quaternion.x   = data.quaternion.x;
              object3d.quaternion.y   = data.quaternion.y;
              object3d.quaternion.z   = data.quaternion.z;
              object3d.quaternion.w   = data.quaternion.w;
              object3d.scale.x        = data.scale.x;
              object3d.scale.y        = data.scale.y;
              object3d.scale.z        = data.scale.z;
              object3d.modelViewMatrix.fromArray( data.modelViewMatrix );
              object3d.normalMatrix.fromArray( data.normalMatrix );
              object3d.matrix.fromArray( data.matrix );
              object3d.matrixWorld.fromArray( data.matrixWorld );
              object3d.matrixAutoUpdate       = data.matrixAutoUpdate;
              object3d.matrixWorldNeedsUpdate = data.matrixWorldNeedsUpdate;
              object3d.layers.mask            = data.layers;
              object3d.visible                = data.visible;
              object3d.castShadow             = data.castShadow;
              object3d.receiveShadow          = data.receiveShadow;
              object3d.frustumCulled          = data.frustumCulled;
              object3d.renderOrder            = data.renderOrder;
              object3d.userData               = data.userData;

              return object3d

          } else if ( objectType === 'LineSegments' ) {

              var segment = new LineSegments$1();
              segment.uuid           = data.uuid;
              segment.name           = data.name;
              segment.type           = data.type;
              segment.parent         = null;//data.parent
              segment.children       = data.children;
              segment.up.x           = data.up.x;
              segment.up.y           = data.up.y;
              segment.up.z           = data.up.z;
              segment.position.x     = data.position.x;
              segment.position.y     = data.position.y;
              segment.position.z     = data.position.z;
              segment.rotation.x     = data.rotation.x;
              segment.rotation.y     = data.rotation.y;
              segment.rotation.z     = data.rotation.z;
              segment.rotation.order = data.rotation.order;
              segment.quaternion.x   = data.quaternion.x;
              segment.quaternion.y   = data.quaternion.y;
              segment.quaternion.z   = data.quaternion.z;
              segment.quaternion.w   = data.quaternion.w;
              segment.scale.x        = data.scale.x;
              segment.scale.y        = data.scale.y;
              segment.scale.z        = data.scale.z;
              segment.modelViewMatrix.fromArray( data.modelViewMatrix );
              segment.normalMatrix.fromArray( data.normalMatrix );
              segment.matrix.fromArray( data.matrix );
              segment.matrixWorld.fromArray( data.matrixWorld );
              segment.matrixAutoUpdate       = data.matrixAutoUpdate;
              segment.matrixWorldNeedsUpdate = data.matrixWorldNeedsUpdate;
              segment.layers.mask            = data.layers;
              segment.visible                = data.visible;
              segment.castShadow             = data.castShadow;
              segment.receiveShadow          = data.receiveShadow;
              segment.frustumCulled          = data.frustumCulled;
              segment.renderOrder            = data.renderOrder;
              segment.userData               = data.userData || {};
              segment.geometry               = data.geometry;
              segment.material               = data.material;

              // Required for carl source
              segment.userData['id'] = data._id;

              return mesh

          } else if ( objectType === 'Mesh' ) {

              var mesh            = new Mesh$1();
              mesh.uuid           = data.uuid;
              mesh.name           = data.name;
              mesh.type           = data.type;
              mesh.parent         = null;//data.parent
              mesh.children       = data.children;
              mesh.up.x           = data.up.x;
              mesh.up.y           = data.up.y;
              mesh.up.z           = data.up.z;
              mesh.position.x     = data.position.x;
              mesh.position.y     = data.position.y;
              mesh.position.z     = data.position.z;
              mesh.rotation.x     = data.rotation.x;
              mesh.rotation.y     = data.rotation.y;
              mesh.rotation.z     = data.rotation.z;
              mesh.rotation.order = data.rotation.order;
              mesh.quaternion.x   = data.quaternion.x;
              mesh.quaternion.y   = data.quaternion.y;
              mesh.quaternion.z   = data.quaternion.z;
              mesh.quaternion.w   = data.quaternion.w;
              mesh.scale.x        = data.scale.x;
              mesh.scale.y        = data.scale.y;
              mesh.scale.z        = data.scale.z;
              mesh.modelViewMatrix.fromArray( data.modelViewMatrix );
              mesh.normalMatrix.fromArray( data.normalMatrix );
              mesh.matrix.fromArray( data.matrix );
              mesh.matrixWorld.fromArray( data.matrixWorld );
              mesh.matrixAutoUpdate       = data.matrixAutoUpdate;
              mesh.matrixWorldNeedsUpdate = data.matrixWorldNeedsUpdate;
              mesh.layers.mask            = data.layers;
              mesh.visible                = data.visible;
              mesh.castShadow             = data.castShadow;
              mesh.receiveShadow          = data.receiveShadow;
              mesh.frustumCulled          = data.frustumCulled;
              mesh.renderOrder            = data.renderOrder;
              mesh.userData               = data.userData || {};
              mesh.geometry               = data.geometry;
              mesh.material               = data.material;

              // Required for carl source
              mesh.userData['id'] = jsonData._id;

              return mesh
              //            //            mesh.geometry = self.convertJsonToGeometry( data.geometry )
              //            //            mesh.material = self.convertJsonToMaterial( data.material )
              //
              //            var haveGeometry = false
              //            self.retrieveGeometryFor( mesh, data.geometry, function ( geometry ) {
              //
              //                mesh.geometry = geometry
              //                haveGeometry  = true
              //
              //                if ( !haveGeometry || !haveMaterial ) { return }
              //
              //                callback( mesh )
              //
              //            } )
              //
              //            var haveMaterial = false
              //            self.retrieveMaterialFor( mesh, data.material, function ( materials ) {
              //
              //                mesh.material = materials
              //                haveMaterial  = true
              //
              //                if ( !haveGeometry || !haveMaterial ) { return }
              //
              //                callback( mesh )
              //
              //            } )

          } else {

              onError( "Non managed object type: " + objectType );
          }

      }

  } );

  Object.defineProperties( TObjectsManager.prototype, {

      _onJson: {
          value: function _onJson ( jsonData, onSuccess, onProgress, onError ) {
              var this$1 = this;


              if ( Array.isArray( jsonData ) ) {

                  var objects = [];
                  var object  = undefined;
                  var data    = undefined;
                  for ( var dataIndex = 0, numberOfDatas = jsonData.length ; dataIndex < numberOfDatas ; dataIndex++ ) {

                      data   = jsonData[ dataIndex ];
                      object = this$1.convertJsonToObject3D( data, onError );

                      if ( object ) { objects.push( object ); }

                      onProgress( dataIndex / numberOfDatas );

                  }

                  onSuccess( objects );

              } else {

                  var object$1 = this.convertJsonToObject3D( jsonData, onError );
                  onProgress( 1.0 );

                  onSuccess( object$1 );

              }

          }
      }

  } );

  /**
   * @author [Tristan Valcke]{@link https://github.com/Itee}
   * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
   *
   * @class TGeometriesManager
   * @classdesc Todo...
   * @example Todo...
   *
   * @requires {@link TDataBaseManager}
   * @requires '../../../node_modules/three/src/core/Geometry'
   * @requires { BufferGeometry } from 'three'
   * @requires '../../../node_modules/three/src/core/BufferAttribute'
   *
   */

  /**
   *
   * @constructor
   */
  function TGeometriesManager () {

      TDataBaseManager.call( this );
      this.basePath = '/geometries';

  }

  TGeometriesManager.prototype = Object.assign( Object.create( TDataBaseManager.prototype ), {

      constructor: TGeometriesManager,

      /**
       * @public
       * @memberOf TGeometriesManager.prototype
       *
       * @param jsonGeometry
       * @param onError
       * @returns {*}
       */
      convertJsonToGeometry: function convertJsonToGeometry ( jsonGeometry, onError ) {

          var geometry = null;

          if ( jsonGeometry.isGeometry ) {

              geometry = new Geometry();

              geometry.uuid = jsonGeometry.uuid;
              geometry.name = jsonGeometry.name;
              geometry.type = jsonGeometry.type;

              var vertices = [];
              var vertex   = undefined;
              for ( var index = 0, numberOfVertices = jsonGeometry.vertices.length ; index < numberOfVertices ; ++index ) {

                  vertex = jsonGeometry.vertices[ index ];
                  vertices.push( new Vector3( vertex.x / 100, vertex.y / 100, vertex.z / 100 ) );

              }
              geometry.vertices = vertices;
              //                geometry.colors                  = jsonGeometry.colors

              var faces = [];
              var face  = undefined;
              for ( var faceIndex = 0, numberOfFaces = jsonGeometry.faces.length ; faceIndex < numberOfFaces ; faceIndex++ ) {
                  face = jsonGeometry.faces[ faceIndex ];
                  faces.push( new Face3( face.a, face.b, face.c, face.normal, face.color, face.materialIndex ) );
              }
              geometry.faces         = faces;
              //                geometry.faceVertexUvs           = [ [ Number ] ]
              geometry.morphTargets  = [];
              geometry.morphNormals  = [];
              geometry.skinWeights   = [];
              geometry.skinIndices   = [];
              geometry.lineDistances = [];

              //                geometry.computeBoundingBox()
              //                geometry.boundingBox.min.x       = jsonGeometry.boundingBox.min.x
              //                geometry.boundingBox.min.y       = jsonGeometry.boundingBox.min.y
              //                geometry.boundingBox.min.z       = jsonGeometry.boundingBox.min.z
              //                geometry.boundingBox.max.x       = jsonGeometry.boundingBox.max.x
              //                geometry.boundingBox.max.y       = jsonGeometry.boundingBox.max.y
              //                geometry.boundingBox.max.z       = jsonGeometry.boundingBox.max.z
              //
              //                geometry.computeBoundingSphere()
              //                geometry.boundingSphere.center.x = jsonGeometry.boundingSphere.center.x
              //                geometry.boundingSphere.center.y = jsonGeometry.boundingSphere.center.y
              //                geometry.boundingSphere.center.z = jsonGeometry.boundingSphere.center.z
              //                geometry.boundingSphere.radius                  = jsonGeometry.boundingSphere.radius

              geometry.elementsNeedUpdate      = true; //jsonGeometry.elementsNeedUpdate
              geometry.verticesNeedUpdate      = true; //jsonGeometry.verticesNeedUpdate
              geometry.uvsNeedUpdate           = true; //jsonGeometry.uvsNeedUpdate
              geometry.normalsNeedUpdate       = true; //jsonGeometry.normalsNeedUpdate
              geometry.colorsNeedUpdate        = true; //jsonGeometry.colorsNeedUpdate
              geometry.lineDistancesNeedUpdate = true; //jsonGeometry.lineDistancesNeedUpdate
              geometry.groupsNeedUpdate        = true; //jsonGeometry.groupsNeedUpdate

          } else if ( jsonGeometry.isBufferGeometry ) {

              geometry = new BufferGeometry();

              geometry.uuid   = jsonGeometry.uuid;
              geometry.name   = jsonGeometry.name;
              geometry.type   = jsonGeometry.type;
              //            geometry.drawRange = jsonGeometry.drawRange
              geometry.groups = jsonGeometry.groups;

              // Extract attributes
              var jsonGeometryAttributes = jsonGeometry.attributes;
              if ( jsonGeometryAttributes ) {

                  var attributes = {};

                  // TODO: make the other attribs or using loop over them !!
                  var positionAttributes = jsonGeometryAttributes.position;
                  if ( positionAttributes ) {
                      attributes[ 'position' ] = new BufferAttribute( new Float32Array( positionAttributes.array ), positionAttributes.itemSize, positionAttributes.normalized );
                  }

                  geometry.attributes = attributes;

              }

              // Extract index
              var jsonGeometryIndexes = jsonGeometry.index;
              if ( jsonGeometryIndexes ) {
                  geometry.index = new BufferAttribute( new Uint32Array( jsonGeometryIndexes.array ), jsonGeometryIndexes.itemSize, jsonGeometryIndexes.normalized );
              }

          } else {

              onError( 'Unable to retrieve geometry type !!!' );

          }

          geometry.computeFaceNormals();
          geometry.computeVertexNormals();

          // TCache geometry for future use
  //        this._cache.add( jsonGeometry._id, geometry )

          return geometry

      },

  } );

  Object.defineProperties( TGeometriesManager.prototype, {

      _onJson: {
          value: function _onJson ( jsonData, onSuccess, onProgress, onError ) {
              var this$1 = this;


              var geometries = {};

              if ( Array.isArray( jsonData ) ) {

                  var data       = undefined;
                  var geometry   = undefined;
                  for ( var dataIndex = 0, numberOfDatas = jsonData.length ; dataIndex < numberOfDatas ; dataIndex++ ) {

                      data     = jsonData[ dataIndex ];
                      geometry = this$1.convertJsonToGeometry( data, onError );

                      if ( geometry ) { geometries[data._id] = geometry; }

                      onProgress( dataIndex / numberOfDatas );

                  }


              } else {

                  geometries[jsonData._id] = this.convertJsonToGeometry( jsonData, onError );
                  onProgress( 1.0 );

              }

              onSuccess( geometries );

          }
      }

  } );

  /**
   * @author [Tristan Valcke]{@link https://github.com/Itee}
   * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
   *
   * @class TScenesManager
   * @classdesc Todo...
   * @example Todo...
   * @requires TDataBaseManager
   *
   */

  /**
   *
   * @constructor
   */
  function TMaterialsManager () {

      TDataBaseManager.call( this );
      this.basePath = '/materials';

  }

  TMaterialsManager.prototype = Object.assign( Object.create( TDataBaseManager.prototype ), {

      constructor: TMaterialsManager,

      convertJsonToMaterial: function convertJsonToMaterial ( jsonMaterial ) {

          var materialType = jsonMaterial.type;
          var material       = undefined;

          switch ( materialType ) {

              case 'MeshPhongMaterial': {
                  material                     = new MeshPhongMaterial$1();
                  material.uuid                = jsonMaterial.uuid;
                  material.name                = jsonMaterial.name;
                  material.type                = jsonMaterial.type;
                  material.fog                 = jsonMaterial.fog;
                  material.lights              = jsonMaterial.lights;
                  material.blending            = jsonMaterial.blending;
                  material.side                = jsonMaterial.side;
                  material.flatShading         = jsonMaterial.flatShading;
                  material.vertexColors        = jsonMaterial.vertexColors;
                  material.opacity             = jsonMaterial.opacity;
                  material.transparent         = jsonMaterial.transparent;
                  material.blendSrc            = jsonMaterial.blendSrc;
                  material.blendDst            = jsonMaterial.blendDst;
                  material.blendEquation       = jsonMaterial.blendEquation;
                  material.blendSrcAlpha       = jsonMaterial.blendSrcAlpha;
                  material.blendDstAlpha       = jsonMaterial.blendDstAlpha;
                  material.blendEquationAlpha  = jsonMaterial.blendEquationAlpha;
                  material.depthFunc           = jsonMaterial.depthFunc;
                  material.depthTest           = jsonMaterial.depthTest;
                  material.depthWrite          = jsonMaterial.depthWrite;
                  material.clippingPlanes      = jsonMaterial.clippingPlanes;
                  material.clipIntersection    = jsonMaterial.clipIntersection;
                  material.clipShadows         = jsonMaterial.clipShadows;
                  material.colorWrite          = jsonMaterial.colorWrite;
                  material.precision           = jsonMaterial.precision;
                  material.polygonOffset       = jsonMaterial.polygonOffset;
                  material.polygonOffsetFactor = jsonMaterial.polygonOffsetFactor;
                  material.polygonOffsetUnits  = jsonMaterial.polygonOffsetUnits;
                  material.dithering           = jsonMaterial.dithering;
                  material.alphaTest           = jsonMaterial.alphaTest;
                  material.premultipliedAlpha  = jsonMaterial.premultipliedAlpha;
                  material.overdraw            = jsonMaterial.overdraw;
                  material.visible             = jsonMaterial.visible;
                  material.userData            = jsonMaterial.userData;
                  material.needsUpdate         = jsonMaterial.needsUpdate;
                  material.color               = new Color$1( jsonMaterial.color.r, jsonMaterial.color.g, jsonMaterial.color.b );
                  material.specular            = new Color$1( jsonMaterial.specular.r, jsonMaterial.specular.g, jsonMaterial.specular.b );
                  material.shininess           = jsonMaterial.shininess;
                  material.map                 = jsonMaterial.map;
                  material.lightMap            = jsonMaterial.lightMap;
                  material.lightMapIntensity   = jsonMaterial.lightMapIntensity;
                  material.aoMap               = jsonMaterial.aoMap;
                  material.aoMapIntensity      = jsonMaterial.aoMapIntensity;
                  material.emissive            = new Color$1( jsonMaterial.emissive.r, jsonMaterial.emissive.g, jsonMaterial.emissive.b );
                  material.emissiveIntensity   = jsonMaterial.emissiveIntensity;
                  material.emissiveMap         = jsonMaterial.emissiveMap;
                  material.bumpMap             = jsonMaterial.bumpMap;
                  material.bumpScale           = jsonMaterial.bumpScale;
                  material.normalMap           = jsonMaterial.normalMap;
                  material.normalScale         = jsonMaterial.normalScale;
                  material.displacementMap     = jsonMaterial.displacementMap;
                  material.displacementScale   = jsonMaterial.displacementScale;
                  material.displacementBias    = jsonMaterial.displacementBias;
                  material.specularMap         = jsonMaterial.specularMap;
                  material.alphaMap            = jsonMaterial.alphaMap;
                  material.envMap              = jsonMaterial.alphaMap;
                  material.combine             = jsonMaterial.combine;
                  material.reflectivity        = jsonMaterial.reflectivity;
                  material.refractionRatio     = jsonMaterial.refractionRatio;
                  material.wireframe           = jsonMaterial.wireframe;
                  material.wireframeLinewidth  = jsonMaterial.wireframeLinewidth;
                  material.wireframeLinecap    = jsonMaterial.wireframeLinecap;
                  material.wireframeLinejoin   = jsonMaterial.wireframeLinejoin;
                  material.skinning            = jsonMaterial.skinning;
                  material.morphTargets        = jsonMaterial.morphTargets;
                  material.morphNormals        = jsonMaterial.morphNormals;
              }
                  break;

              case 'LineBasicMaterial': {
                  material       = new LineBasicMaterial$1();
                  material.uuid  = jsonMaterial.uuid;
                  material.name  = jsonMaterial.name;
                  material.type  = jsonMaterial.type;
                  material.color = new Color$1( jsonMaterial.color.r, jsonMaterial.color.g, jsonMaterial.color.b );
              }
                  break;

              default:
                  console.error( 'Unknown material type !' );
                  break;

          }

          return material

      }

  } );

  Object.defineProperties( TMaterialsManager.prototype, {

      _onJson: {
          value: function _onJson ( jsonData, onSuccess, onProgress, onError ) {
              var this$1 = this;


              var materials = {};

              if ( Array.isArray( jsonData ) ) {

                  var data     = undefined;
                  var material = undefined;
                  for ( var dataIndex = 0, numberOfDatas = jsonData.length ; dataIndex < numberOfDatas ; dataIndex++ ) {

                      data     = jsonData[ dataIndex ];
                      material = this$1.convertJsonToMaterial( data, onError );

                      if ( material ) { materials[ data._id ] = material; }

                      onProgress( dataIndex / numberOfDatas );

                  }

              } else {

                  materials[ jsonData._id ] = this.convertJsonToMaterial( jsonData, onError );
                  onProgress( 1.0 );

              }

              onSuccess( materials );

          }
      }

  } );

  /**
   * @author [Tristan Valcke]{@link https://github.com/Itee}
   * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
   *
   *
   * @class TScenesManager
   * @classdesc Todo...
   * @example Todo...
   *
   * @requires TDataBaseManager
   *
   */

  /**
   *
   * @constructor
   */
  function TScenesManager () {

      TDataBaseManager.call( this );
      this.basePath = '/scenes';

  }

  TScenesManager.prototype = Object.assign( Object.create( TDataBaseManager.prototype ), {

      constructor: TScenesManager

  } );

  Object.defineProperties( TScenesManager.prototype, {

      _onJson: {
          value: function _onJson ( jsonData, onSuccess, onProgress, onError ) {

              onSuccess( jsonData );

          }
      }

  } );

  /**
   * @author [Tristan Valcke]{@link https://github.com/Itee}
   * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
   *
   * @class TApplication
   * @classdesc The TApplication is the base Itee application, it will load the required environement and start the dialog with the Itee server.
   * @example Todo...
   *
   */

  /* eslint-env browser */
  /* global $, H, URL */

  //import { SplitModifier } from '../../build/tmp/SplitModifier'

  //TMP

  var imageLoader   = new ImageLoader();
  var RAD_TO_DEG_PI = 180 / Math.PI;

  // Usefull for shot updates
  var frustum                    = new Frustum$1();
  var cameraViewProjectionMatrix = new Matrix4();

  var OFFSET_CORRECTOR = {
      x: 0.48,
      y: 0.31
  };

  var LAMBERT_NORD_OFFSET = {
      x: 600200,
      y: 131400,
      z: 60
  };
  // Camera position =>
  // x: -0.0007484443485736847
  // y: 10.24522892416233
  // z: -0.000806964111538799
  // 651543.533,6864982.935
  var LAMBERT_NINETY_THREE_OFFSET = {
      x: 651543.533,
      y: 6864982.935
  };

  function convertWebglVectorToTopologicVector ( vector ) {

      return new Vector3$1( vector.x, -vector.z, vector.y )

  }

  function convertWebGLCoordinatesToLambert93Coordinates ( coordinates ) {

      return new Vector3$1(
          coordinates.x + LAMBERT_NINETY_THREE_OFFSET.x + OFFSET_CORRECTOR.x,
          -coordinates.z + LAMBERT_NINETY_THREE_OFFSET.y + OFFSET_CORRECTOR.y,
          coordinates.y
      )

  }

  function convertLambert93CoordinatesToWebGLCoordinates ( coordinates ) {

      return new Vector3$1(
          coordinates.x - LAMBERT_NINETY_THREE_OFFSET.x - OFFSET_CORRECTOR.x,
          0,
          -(coordinates.y - LAMBERT_NINETY_THREE_OFFSET.y - OFFSET_CORRECTOR.y)
      )

  }

  //
  function convertWebGLRotationToTopologicalYawPitch ( vectorDir ) {

      function getYaw ( vector ) {
          return Math.atan2( vector.y, vector.x )
      }

      function getPitch ( vector ) {
          return Math.asin( vector.z )
      }

      function radiansToDegrees ( radians ) {
          return radians * RAD_TO_DEG_PI
      }

      var topoVectorDir = convertWebglVectorToTopologicVector( vectorDir );

      return {
          yaw:   -( radiansToDegrees( getYaw( topoVectorDir ) ) - 90 ),
          pitch: radiansToDegrees( getPitch( topoVectorDir ) )
      }

  }

  /**
   *
   * @param container
   * @param parameters
   * @param onReady
   * @constructor
   */
  function TApplication ( container, parameters, onReady ) {

      if ( !container ) {
          console.error( "Undefined or null container:" + container );
          return
      }
      if ( !parameters ) {
          console.error( "Undefined or null parameters:" + parameters );
          return
      }
      if ( !onReady ) {
          console.error( "Undefined or null onReady:" + onReady );
          return
      }

      console.time( "TApplication" );
      console.log( "Starting TApplication..." );

      var self      = this;
      var _parameters = {
          gui: {
              orientation: 'vertical',
              limit:       100,
              position:    '50%' // if there is no percentage it interpret it as pixels
          },

          webGLEnable: true,
          webGL:       {

              camera: null,

              modelEnable: true,
              model:       {
                  files:             [],
                  textureResolution: '',
                  allowGround:       true
              },

              tigerEnable: false,
              tiger:       {},

              caimanEnable: false,
              caiman:       {},

              cloudPointEnable: false,
              cloudPoint:       {},

              pathEnable: false,
              path:       {},

              shotsEnable: false,
              shots:       {},

              avatarEnable: false,
              avatarParams: {}

          }
      };

      // Recursive merging parameter
      $.extend( true, _parameters, parameters );

      this.viewer            = '';
      this.previousImageShot = undefined;
      this.thumbnailPanel    = document.getElementById( 'thumbnailPanel' );
      this.dataPanel         = document.getElementById( 'dataPanel' );
      this.universalLoader   = new TUniversalLoader();

      this.meshManager                     = undefined;
      this.meshManagerPathResolutionMap    = [
          {
              min:   15,
              max:   Infinity,
              value: 0
          }, {
              min:   5,
              max:   15,
              value: 256
          }, {
              min:   0,
              max:   5,
              value: 4096
          }
      ];
      this.meshManagerOrbitalResolutionMap = [
          {
              min:   30,
              max:   Infinity,
              value: 0
          },
          {
              min:   20,
              max:   30,
              value: 256
          },
          {
              min:   10,
              max:   20,
              value: 1024
          },
          {
              min:   5,
              max:   10,
              value: 2048
          },
          {
              min:   0,
              max:   5,
              value: 4096
          }
      ];

      this.updateMeshTimeout       = undefined;
      this.pointCloudManager       = undefined;
      this.updatePointCloudTimeout = undefined;

      function _initGUI ( parameters ) {

          parameters = parameters || {};

          // Init docks and panels
          var navBar = document.getElementById( 'mainNavBar' );

          // Compute available screen height without navBar
          var navBarHeight  = (navBar) ? navBar.clientHeight : 0;
          var contentHeight = $( window ).height() - navBarHeight;

          // Init navbar
          var importInput = $( "#importInput" );
          $( '#importBtn' ).on( "click", function ( event ) {
              self.popupImportFilesModal.call( self );
          } );

          this.toggleXRay = false;
          var xRayBtn     = $( "#xRayBtn" );
          xRayBtn.on( "click", function ( event ) {

              self.toggleXRay = !self.toggleXRay;
              self.changeMaterialSide.call( self, self.webglViewport.scene.children, self.toggleXRay );

          } );

          this.toggleSelection = false;
          var selectBtn        = $( "#selectBtn" );
          selectBtn.on( "click", function ( event ) {

              self.toggleSelection             = !self.toggleSelection;
              self.webglViewport.isRaycastable = self.toggleSelection;

              //            var cursor = ( self.toggleSelection ) ? 'pointer' : 'default';
              //            $('html').css('cursor', 'wait');

          } );

          var cameraModeDropDown = $( '#cameraMode' ).find( 'li' );
          cameraModeDropDown.on( 'click', function ( event ) {
              var cameraMode = $( this ).find( 'a' ).attr( 'data-value' );
              self.setCameraMode.call( self, cameraMode );
          } );

          var switchRenderEffectDropDown = $( '#renderEffectDropDown' ).find( 'li' );
          switchRenderEffectDropDown.on( 'click', function ( event ) {
              var renderEffect = $( this ).find( 'a' ).attr( 'data-value' );
              self.setRendersEffect.call( self, renderEffect );
          } );

          // Docking view
          // Convert a div to a dock manager.  Panels can then be docked on to it
          this.mainContainer = new dockspawn.DockManager( container );
          this.mainContainer.initialize();
          window.addEventListener( 'resize', function () { self.mainContainer.invalidate(); }, true );

          this.detailBtn = $( "#detailBtn" );
          this.detailBtn.on( "click", function (event) {

              var carlId = event.currentTarget.value.slice( 0, -4 ).toUpperCase();
              parent.postMessage( ("GISDetailAction#-#" + carlId + ";com.carl.xnet.equipment.backend.bean.BoxBean#+#"), '*' );

          } );

          this.historyBtn = $( "#historyBtn" );
          this.historyBtn.on( "click", function (event) {

              var carlId = event.currentTarget.value.slice( 0, -4 ).toUpperCase();
              parent.postMessage( ("WOViewAction#-#" + carlId + ";com.carl.xnet.equipment.backend.bean.BoxBean#+#"), '*' );

          } );

          this.createBtn = $( "#createBtn" );
          this.createBtn.on( "click", function (event) {

              var carlId = event.currentTarget.value.slice( 0, -4 ).toUpperCase();
              parent.postMessage( ("CREATE_WO#-#" + carlId + ";com.carl.xnet.equipment.backend.bean.BoxBean#+#"), '*' );

          } );

          //        this.mainContainer = (container) ? container : document.getElementById( 'mainContainer' );
          //        this.mainContainer.height( contentHeight );

          // Convert existing elements on the page into "Panels".
          // They can then be docked on to the dock manager
          // Panels get a titlebar and a close button, and can also be
          // converted to a floating dialog box which can be dragged / resized
          var treeViewContainer = document.getElementById( "treeViewContainer" );
          if ( !parameters.carlEnable ) {
              this.treeView = new dockspawn.PanelContainer( treeViewContainer, this.mainContainer, 'Projet' );
          } else {
              treeViewContainer.style.display = 'none';
          }
          this.webglViewportContainer = new dockspawn.PanelContainer( document.getElementById( "webglViewportContainer" ), this.mainContainer, 'Maquette' );

          // Dock the panels on the dock manager
          var documentNode = this.mainContainer.context.model.documentManagerNode;
          if ( !parameters.carlEnable ) { var solutionNode = this.mainContainer.dockLeft( documentNode, this.treeView, 0.20 ); }
          var outlineNode = this.mainContainer.dockFill( documentNode, this.webglViewportContainer );

          // Measure Tool
          this.measureTools = $( '#measureTools' ).find( 'li' );
          this.measureTools.on( 'click', function ( event ) {
              var selectedTool = $( this ).find( 'a' ).attr( 'data-value' );
              self.startMeasure( selectedTool );
          } );
          this.measureMode         = undefined;
          this.measureCounter      = 0;
          this.currentMeasureGroup = undefined;

          // Split Tool
          //        this.globalPlane = new SplitModifier( 100 );
          this.globalPlane     = new Plane( new Vector3$1( 0, -1, 0 ), 0.8 );
          this.splitToolButton = document.getElementById( 'splitBtn' );
          if ( this.splitToolButton !== null && this.splitToolButton !== undefined ) {

              this.splitToolToggle      = false;
              this.spliterSliderControl = new Slider( "#spliterSliderControl", {
                  reversed:         true,
                  min:              -50,
                  max:              85,
                  value:            0,
                  orientation:      'vertical',
                  tooltip_position: 'left',
                  precision:        2
              } );
              this.spliterSliderControl.on( "slide", function ( sliderValue ) {

                  //                self.globalPlane.position.y = sliderValue / 10;
                  self.globalPlane.constant = sliderValue;

              } );

              self.spliterSliderControl.$sliderElem[ 0 ].style.display = 'none';

              this.splitToolButton.onclick = function ( event ) {

                  self.splitToolToggle = !self.splitToolToggle;

                  self.spliterSliderControl.$sliderElem[ 0 ].style.display = ( self.splitToolToggle ) ? 'block' : 'none';
                  self.globalPlane.visible                                 = self.splitToolToggle;

                  self.webglViewport.renderer.clippingPlanes = ( self.splitToolToggle ) ? [ self.globalPlane ] : [];
                  //OR
                  //                if( self.splitToolToggle ) {
                  //
                  //                    var group = self.webglViewport.scene.getObjectByName( 'MeshesGroup' )
                  //                    if ( ! group ) return;
                  //
                  //                    self.webglViewport.scene.remove( group );
                  //
                  //                    var splittedGroup = self.globalPlane.add( group )
                  //                    self.webglViewport.scene.add( splittedGroup )
                  //
                  //                } else {
                  //
                  //
                  //
                  //                }

                  event.preventDefault();

              };

          } else {

              console.error( 'split button does not exist !' );

          }
          // Init modals
          this.importFilesModalView = $( '#importFilesModal' );
          this.importFilesModalView.modal( {
              keyboard: false,
              show:     false
          } );

          var validateImportFilesModal = $( '#validateImportFilesModal' );
          validateImportFilesModal.on( "click", function () {

              var importInput   = $( "#importInput" );
              var files         = importInput[ 0 ].files;
              var numberOfFiles = files.length;
              console.log( "numberOfFiles: " + numberOfFiles );

              var filesUrls = [];
              var fileUrl   = '';
              var fileIndex;
              var fileObject;

              for ( fileIndex = 0 ; fileIndex < numberOfFiles ; ++fileIndex ) {
                  fileObject = files[ fileIndex ];
                  fileUrl    = URL.createObjectURL( fileObject ) + '/' + fileObject.name;

                  filesUrls.push( fileUrl );
              }

              self.loadObjectFromURL( filesUrls );

          } );

          this.imageShotModalView = $( '#imageShotModal' );
          this.imageShotModalView.modal( {
              keyboard: false,
              show:     false
          } );

          this.selectedObjectModalView = $( '#selectedObjectModal' );
          this.selectedObjectModalView.modal( {
              keyboard: false,
              show:     false
          } );
      }

      function _initWebGLViewport ( parameters ) {

          parameters = parameters || {};

          this.webglViewportContainer = document.getElementById( 'webglViewportContainer' );
          this.webglViewport          = new TViewport( this.webglViewportContainer );
          //        this.webglViewport.toggleAutorun()

          var camera = parameters.camera;
          if ( camera ) {

              var cameraPosition = camera.position;
              if ( cameraPosition ) {
                  this.webglViewport.camera.position.set( cameraPosition.x, cameraPosition.y, cameraPosition.z );
              }

              var cameraTarget = camera.target;
              if ( cameraTarget ) {
                  var target = new Vector3$1( cameraTarget.x, cameraTarget.y, cameraTarget.z );
                  this.webglViewport.camera.lookAt( target );
                  this.webglViewport.cameraControl.target = target;
              }

          }

          this.webglViewport.scene.add( new AmbientLight( 0x999999, 0.8 ) );

          this.progressBar = $( '#progressBar .progress-bar' );
          this.progressBar.parent().css( "display", "none" );

          if ( parameters.modelEnable ) { _initModelData.call( self, parameters.model ); }
          if ( parameters.pointCloudEnable ) { _initPointCloudData.call( self, parameters.pointCloud ); }
          if ( parameters.avatarEnable ) { _initAvatarData.call( self, parameters.avatarParams ); }

      }

      var _modelReady = false;

      function _initModelData ( parameters ) {

          self.companiesManager  = new TDataBaseManager();
          self.sitesManager      = new TDataBaseManager();
          self.buildingsManager  = new TDataBaseManager();
          self.scenesManager     = new TScenesManager();
          self.objectsManager    = new TObjectsManager();
          self.geometriesManager = new TGeometriesManager();
          self.materialsManager  = new TMaterialsManager();

          var companiesIds = parameters.companiesIds;
          if ( companiesIds ) { _initCompanies( companiesIds ); }

          var sitesIds = parameters.sitesIds;
          if ( sitesIds ) { _initSitesOf( sitesIds ); }

          var buildingsIds = parameters.buildingsIds;
          if ( buildingsIds ) {
              // Update carl batiment button value
              self.detailBtn.val( buildingsIds );
              self.historyBtn.val( buildingsIds );
              self.createBtn.val( buildingsIds );

              _initBuildingsOf( buildingsIds, null, true );
          }

          var scenesIds = parameters.scenesIds;
          if ( scenesIds ) { _initScenesOf( scenesIds, null, true ); }

          var objectsIds = parameters.objectsIds;
          if ( objectsIds ) { _initObjectsOf( objectsIds, null, true ); }

          function _initCompanies ( companiesIds ) {

              if ( !companiesIds ) { return }

              self.companiesManager.read( companiesIds, function ( companies ) {

                  var company = undefined;
                  for ( var companyIndex = 0, numberOfCompanies = companies.length ; companyIndex < numberOfCompanies ; companyIndex++ ) {
                      company = companies[ companyIndex ];
                      _initSitesOf( company.sites );
                  }

              } );

          }

          function _initSitesOf ( sitesIds ) {

              if ( !sitesIds ) { return }

              self.sitesManager.read( sitesIds, function ( sites ) {

                  var site = undefined;
                  for ( var siteIndex = 0, numberOfSites = sites.length ; siteIndex < numberOfSites ; siteIndex++ ) {
                      site = sites[ siteIndex ];

                      var siteGroup      = new Group();
                      siteGroup[ '_id' ] = site._id;
                      siteGroup.name     = site.name;
                      siteGroup.visible  = (siteIndex === 0);

                      // These are the main group for the webgl view
                      self.webglViewport.scene.add( siteGroup );

                      // Create new base tree item
                      var objectTreeViewItem = self.insertTreeViewItem( siteGroup._id, siteGroup.name, null, siteGroup.visible );
                      objectTreeViewItem.find( '#' + siteGroup._id + 'VisibilityCheckbox' ).on( 'change', function ( event ) {

                          siteGroup.visible = this.checked;

                      } );

                      _initBuildingsOf( site.buildings, siteGroup, siteGroup.visible );

                  }

              } );

          }

          function _initBuildingsOf ( buildingsIds, site, visible ) {

              if ( !buildingsIds ) { return }

              self.buildingsManager.read( buildingsIds, function ( buildings ) {

                  var building = undefined;
                  for ( var buildingIndex = 0, numberOfBuildings = buildings.length ; buildingIndex < numberOfBuildings ; buildingIndex++ ) {
                      building = buildings[ buildingIndex ];

                      var buildingGroup      = new Group();
                      buildingGroup[ '_id' ] = building._id;
                      buildingGroup.name     = building.name;
                      buildingGroup.visible  = (visible && buildingIndex === 0 );

                      var parentId = undefined;
                      if ( site ) {

                          site.add( buildingGroup );
                          parentId = site._id;

                      } else {

                          self.webglViewport.scene.add( buildingGroup );

                      }

                      // Create new base tree item
                      var objectTreeViewItem = self.insertTreeViewItem( buildingGroup._id, buildingGroup.name, parentId, buildingGroup.visible );
                      objectTreeViewItem.find( ("#" + (buildingGroup._id) + "VisibilityCheckbox") ).on( 'change', toggleObjectVisibility( buildingGroup ) );

                      _initScenesOf( building.scenes, buildingGroup, buildingGroup.visible );

                  }

              } );

          }

          function _initScenesOf ( scenesIds, building, visible ) {

              if ( !scenesIds ) { return }

              self.scenesManager.read( scenesIds, function ( scenes ) {

                  var scene = undefined;
                  for ( var sceneIndex = 0, numberOfScenes = scenes.length ; sceneIndex < numberOfScenes ; sceneIndex++ ) {
                      scene = scenes[ sceneIndex ];

                      var sceneGroup      = new Group();
                      sceneGroup[ '_id' ] = scene._id;
                      sceneGroup.name     = scene.name;
                      sceneGroup.visible  = (visible && scene.layers === 1 );

                      var parentId = undefined;
                      if ( building ) {

                          building.add( sceneGroup );
                          parentId = building._id;

                      } else {

                          self.webglViewport.scene.add( sceneGroup );

                      }

                      // Create new base tree item
                      var objectTreeViewItem = self.insertTreeViewItem( sceneGroup._id, sceneGroup.name, parentId, sceneGroup.visible );
                      objectTreeViewItem.find( ("#" + (sceneGroup._id) + "VisibilityCheckbox") ).on( 'change', toggleObjectVisibility( sceneGroup ) );

                      _initObjectsOf( scene.children, sceneGroup, true );
                      // set children visible by default due to non recursive visible settings
                      //                    _initObjectsOf( scene.children, sceneGroup, sceneIsVisible )

                  }

              } );

          }

          function _initObjectsOf ( objectsIds, scene, visible ) {

              var _BUNCH_SIZE = 500;

              if ( !objectsIds ) { return }

              var idBunch  = [];
              var objectId = undefined;
              for ( var objectIdIndex = 0, numberOfIds = objectsIds.length ; objectIdIndex < numberOfIds ; objectIdIndex++ ) {
                  objectId = objectsIds[ objectIdIndex ];

                  idBunch.push( objectId );

                  if ( idBunch.length === _BUNCH_SIZE || objectIdIndex === numberOfIds - 1 ) {
                      downloadObjects( idBunch );
                      idBunch = [];
                  }

              }

              function downloadObjects ( objectsIds ) {

                  self.objectsManager.read( objectsIds, function ( objects ) {

                      // Create geometries and materials list
                      var geometriesIds = [];
                      var materialsIds  = [];

                      var object = undefined;
                      for ( var objectIndex = 0, numberOfObjects = objects.length ; objectIndex < numberOfObjects ; objectIndex++ ) {
                          object         = objects[ objectIndex ];
                          object.visible = visible;

                          if ( object.children.length > 0 ) {
                              _initObjectsOf( object.children, object, visible );
                              object.children = [];
                          }

                          geometriesIds.push( object.geometry );
                          Array.prototype.push.apply( materialsIds, object.material );
                      }

                      geometriesIds = uniq( geometriesIds );
                      materialsIds  = uniq( materialsIds );

                      self.geometriesManager.read( geometriesIds, function ( geometries ) {

                          var object = undefined;
                          for ( var objectIndex = 0, numberOfObjects = objects.length ; objectIndex < numberOfObjects ; objectIndex++ ) {
                              object          = objects[ objectIndex ];
                              object.geometry = geometries[ object.geometry ];

                              objectReady( object );
                          }

                      } );

                      self.materialsManager.read( materialsIds, function ( materials ) {

                          var object         = undefined;
                          var objectMaterial = undefined;
                          for ( var objectIndex = 0, numberOfObjects = objects.length ; objectIndex < numberOfObjects ; objectIndex++ ) {
                              object = objects[ objectIndex ];

                              objectMaterial = object.material;
                              if ( Array.isArray( objectMaterial ) ) {

                                  // Take care about the multi material order
                                  object.material = [];
                                  var materialId  = undefined;
                                  for ( var materialIndex = 0, numberOfMaterials = objectMaterial.length ; materialIndex < numberOfMaterials ; materialIndex++ ) {
                                      materialId = objectMaterial[ materialIndex ];

                                      object.material.push( materials[ materialId ] );
                                  }

                              } else {

                                  object.material = materials[ object.material ];

                              }

                              objectReady( object );

                          }

                      } );

                      function objectReady ( object ) {

                          if ( typeof object.geometry !== 'string' && typeof object.material !== 'string' ) {
                              scene.add( object );
                              self.webglViewport.addRaycastables( [ object ] );
                          }

                      }

                  } );

              }

              function uniq ( a ) {
                  var seen = {};
                  return a.filter( function ( item ) {
                      return seen.hasOwnProperty( item ) ? false : (seen[ item ] = true);
                  } );
              }

          }

          function toggleObjectVisibility ( building ) {

              return function ( event ) {

                  building.visible = this.checked;

              }

          }

      }

      function _initPointCloudData ( parameters ) {

          parameters = parameters || {};

          if ( parameters.fromDatabase ) {

              self.pointCloudManager = new TPointsManager( this.webglViewport );
              self.pointCloudManager.setGlobalOffset( LAMBERT_NORD_OFFSET );
              if ( parameters.samplingMin ) { self.pointCloudManager.setMinimumSamplingLimit( parameters.samplingMin ); }

              self.pointCloudManager.getPointClouds( function () {
                  _checkReady();
              } );

          }

          var additionalFiles = parameters.files;
          if ( additionalFiles && additionalFiles.length > 0 ) {

              self.universalLoader.load(
                  additionalFiles,
                  function ( clouds ) {

                      //convert obj [y forward / z up] as [-z forward / y up]
                      for ( var i = 0, numberOfChildren = clouds.children.length ; i < numberOfChildren ; ++i ) {
                          clouds.children[ i ].rotation.x -= Math.PI / 2;
                      }
                      this.webglViewport.scene.add( clouds );

                  }.bind( this ),
                  false,
                  parameters.sampling
              );

          }

      }

      var _avatarReady = false;

      function _initAvatarData ( parameters ) {

          parameters = parameters || {};

          //        self.universalLoader.load( [
          //            'resources/models/fbx/ethan/ascii/Ethan.fbx'
          //            //            'resources/models/fbx/Xsi/Xsi.fbx'
          //        ], function ( ethan ) {
          //            //convert obj [y forward / z up] as [-z forward / y up]
          //            //            shots.rotation.x -= Math.PI / 2;
          //            this.webglViewport.scene.add( ethan )
          //
          //        }.bind( this ), false )

          var jsonLoader = new JSONLoader();
          //        jsonLoader.load( 'resources/models/json/oko/Oko_textured.json', function ( geometry, materials ) {
          //        jsonLoader.load( 'resources/models/json/oko/Oko_join.json', function ( geometry, materials ) {
          jsonLoader.load( 'resources/models/json/John/John.json', function ( geometry, materials ) {
              //        jsonLoader.load( 'resources/models/json/Ethan/Ethan_idle.json', function ( geometry, materials ) {
              //        jsonLoader.load( 'resources/models/json/Ethan/Ethan_idle_centered.json', function ( geometry, materials ) {

              materials.visible = true;

              var mesh = undefined;
              if ( geometry.bones && geometry.bones.length > 0 ) {

                  mesh = new SkinnedMesh(
                      geometry,
                      materials
                  );

              } else {

                  mesh = new Mesh( geometry, materials );

              }

              mesh.name = 'Avatar';

              var rad = 115 * Math.PI / 180;
              mesh.rotateY( rad );

              onLoad( mesh );

          } );

          //        var objectLoader = new ObjectLoader()
          //        objectLoader.load( 'resources/models/json/materials.json', function ( object ) {
          //
          //            self.webglViewport.scene.add( object )
          //
          //        } )

          var _recenter           = true;
          var _setDoubleSide      = false;
          var _displayCenter      = false;
          var _displayBoundingBox = false;
          var _displayWire        = false;
          var _displaySkeleton    = false;
          var _manageAnimation    = true;

          var currentActionIndex = undefined;
          var skeletonHelper     = undefined;

          var mixers  = [];
          var actions = [];

          function onLoad ( object ) {

              if ( !object ) {

                  console.error( 'Something when wrong... Object is null or undefined !' );
                  return

              } else if ( object instanceof Group || object instanceof Scene ) {

                  var child = undefined;
                  while ( object.children.length > 0 ) {

                      child = object.children[ object.children.length - 1 ];

                      _processObject( child );

                  }

              } else if ( object instanceof Object3D ) {

                  _processObject( object );

              } else if ( object.skeleton && object.clip ) {

                  skeletonHelper          = new SkeletonHelper$1( object.skeleton.bones[ 0 ] );
                  skeletonHelper.skeleton = object.skeleton; // allow animation mixer to bind to SkeletonHelper directly
                  skeletonHelper.update();

                  self.webglViewport.scene.add( skeletonHelper );

                  // play animation
                  var mixer = new AnimationMixer$1( skeletonHelper );
                  mixer.clipAction( object.clip ).setEffectiveWeight( 1.0 ).play();
                  mixers.push( mixer );

              } else {

                  console.warn( 'Unknown object type !!!' );

              }

              function _processObject ( object ) {

                  if ( _recenter ) { _recenterGeometry( object ); }
                  if ( _setDoubleSide ) { _setDoubleSidedMaterial( object ); }
                  if ( _displayCenter ) { _addCenterHelper( object ); }
                  if ( _displayBoundingBox ) { _addBoundingBoxHelper( object ); }
                  if ( _displayWire ) { _addWire( object ); }
                  if ( _displaySkeleton ) { _addSkeletonHelper( object ); }
                  if ( _manageAnimation ) { _addAnimations( object ); }

                  //					var position = getNextPosition()
                  //					object.position.copy( position )

                  self.webglViewport.scene.add( object );
                  _avatarReady = true;
                  _checkReady();

              }

              function _recenterGeometry ( object ) {

                  //						if( ! object.geometry.boundingBox ) { object.geometry.computeBoundingBox() }
                  //
                  //						var center = object.geometry.boundingBox.getCenter()
                  //						var negCenter = center.negate()

                  var offset = object.geometry.center();

                  var bb    = object.geometry.boundingBox;
                  var bbMin = bb.min.negate();
                  object.geometry.translate( 0, bbMin.y, 0 );

              }

              function _setDoubleSidedMaterial ( object ) {

                  if ( 'material' in object ) {

                      object.material.side    = DoubleSide;
                      object.material.opacity = 1;

                  } else {

                      console.warn( 'No material found !' );

                  }

              }

              function _addWire ( object ) {

                  var wireframe = new LineSegments(
                      new WireframeGeometry( object.geometry ),
                      new LineBasicMaterial( {
                          color:     0xffffff,
                          linewidth: 1
                      } ) );

                  self.webglViewport.scene.add( wireframe );

              }

              function _addCenterHelper ( object ) {

                  if ( !object.geometry.boundingBox ) { object.geometry.computeBoundingBox(); }

                  var center = object.geometry.boundingBox.getCenter();

                  var axisHelper = new AxisHelper$1( 5 );
                  axisHelper.position.copy( center );

                  self.webglViewport.scene.add( axisHelper );

              }

              function _addBoundingBoxHelper ( object ) {

                  var boundingBoxHelper = new BoxHelper$1( object );

                  self.webglViewport.scene.add( boundingBoxHelper );

              }

              function _addSkeletonHelper ( object ) {

                  if ( object.skeleton && object.skeleton.bones && object.skeleton.bones.length > 0 ) {

                      skeletonHelper                    = new SkeletonHelper$1( object );
                      skeletonHelper.material.linewidth = 3;
                      skeletonHelper.update();
                      self.webglViewport.scene.add( skeletonHelper );

                      var helper2                = new SkeletonHelper$1( object.skeleton.bones[ 0 ] );
                      helper2.material.linewidth = 3;
                      helper2.update();
                      self.webglViewport.scene.add( helper2 );

                  } else if ( object.geometry && object.geometry.bones && object.geometry.bones.length > 0 ) {

                      // Create Skeleton from geometry bones
                      //							object.skeleton = new THREE.Skeleton( object.geometry.bones )

                      //							var helper = new THREE.SkeletonHelper( object.geometry.bones[ 0 ] )
                      //							helper.material.linewidth = 3
                      //							helper.update()
                      //
                      //							scene.add( helper )

                      console.warn( 'Unable to process skeleton from geometry !' );

                  } else {

                      console.warn( 'No skeleton founds !' );

                  }

              }

              function _addAnimations ( object ) {

                  if ( object.animations && object.animations.length > 0 ) {

                      object.mixer = new AnimationMixer$1( object );
                      //                    mixers.push( object.mixer )

                      var action = object.mixer.clipAction( object.animations[ 1 ] );
                      action.setEffectiveWeight( 1.0 );
                      action.play();

                  } else if ( object.geometry.animations && object.geometry.animations.length > 0 ) {

                      object.mixer = new AnimationMixer$1( object );
                      //                    mixers.push( object.mixer )

                      var anim   = undefined;
                      var action = undefined;
                      for ( var animIndex = 0, numberOfAnims = object.geometry.animations.length ; animIndex < numberOfAnims ; animIndex++ ) {

                          anim   = object.geometry.animations[ animIndex ];
                          action = object.mixer.clipAction( anim );

                          actions.push( action );

                      }

                      currentActionIndex = 0;
                      actions[ currentActionIndex ].play();

                  } else {

                      console.warn( 'No animations founds !' );

                      //							var url = 'models/bvh/01/01_01.bvh'
                      //
                      //							var bvhLoader = new THREE.BVHLoader( manager )
                      //							bvhLoader.load(
                      //									url,
                      //									onLoad,
                      ////									function( animation ) {
                      ////
                      ////										object.mixer = new THREE.AnimationMixer( object )
                      ////										mixers.push( object.mixer )
                      ////
                      ////										var action = object.mixer.clipAction( animation.clip )
                      ////										action.setEffectiveWeight( 1.0 )
                      ////										action.play()
                      ////
                      ////									},
                      //									onProgress,
                      //									onError
                      //							)

                  }

              }

          }

      }

      function _initListener () {

          window.addEventListener( 'message', function ( event ) {

              console.log( event.data );

              // IMPORTANT: Check the origin of the data!
              if ( ~event.origin.indexOf( 'http://yoursite.com' ) ) {
                  // The data has been sent from your site

                  // The data sent with postMessage is stored in event.data
                  console.log( event.data );
              } else {
                  // The data hasn't been sent from your site!
                  // Be careful! Do not use it.
                  return;
              }

          } );

          // Update meshes
          //        self.webglViewport.orbitControl.addEventListener( 'end', self.updateMeshResolution.bind( self ) )

          // Update point cloud
          //        self.webglViewport.orbitControl.addEventListener( 'end', self.updatePointCloudDensity.bind( self ) )

          //
          self.webglViewport.addEventListener( 'objectSelected', self.popupSelectedObjectModal.bind( self ) );
          self.webglViewport.addEventListener( 'newClickedPoint', self.updateMeasure.bind( self ) );
          self.webglViewport.addEventListener( 'intersectPoint', self.updateTemporaryMeasure.bind( self ) );
          self.webglViewport.addEventListener( 'measureEnd', self.endMeasure.bind( self ) );

          window.addEventListener( "keydown", function ( event ) {
              if ( event.defaultPrevented ) {
                  return; // Should do nothing if the key event was already consumed.
              }

              switch ( event.key ) {

                  case "2":
                      self.webglViewport.camera.position.x = 160 + 0;
                      self.webglViewport.camera.position.y = 15 + 0;
                      self.webglViewport.camera.position.z = 70 + 250;

                      self.webglViewport.orbitControl.target.x = 160;
                      self.webglViewport.orbitControl.target.y = 15;
                      self.webglViewport.orbitControl.target.z = 70;
                      break;

                  case "4":
                      self.webglViewport.camera.position.x = 160 - 250;
                      self.webglViewport.camera.position.y = 15 + 0;
                      self.webglViewport.camera.position.z = 70 + 0;

                      self.webglViewport.orbitControl.target.x = 160;
                      self.webglViewport.orbitControl.target.y = 15;
                      self.webglViewport.orbitControl.target.z = 70;
                      break;

                  case "5":
                      self.webglViewport.camera.position.x = 160 + 0;
                      self.webglViewport.camera.position.y = 15 + 250;
                      self.webglViewport.camera.position.z = 70 + 0;

                      self.webglViewport.orbitControl.target.x = 160;
                      self.webglViewport.orbitControl.target.y = 15;
                      self.webglViewport.orbitControl.target.z = 70;
                      break;

                  case "6":
                      self.webglViewport.camera.position.x = 160 + 250;
                      self.webglViewport.camera.position.y = 15 + 0;
                      self.webglViewport.camera.position.z = 70 + 0;

                      self.webglViewport.orbitControl.target.x = 160;
                      self.webglViewport.orbitControl.target.y = 15;
                      self.webglViewport.orbitControl.target.z = 70;
                      break;

                  case "8":
                      self.webglViewport.camera.position.x = 160 + 0;
                      self.webglViewport.camera.position.y = 15 + 0;
                      self.webglViewport.camera.position.z = 70 - 250;

                      self.webglViewport.orbitControl.target.x = 160;
                      self.webglViewport.orbitControl.target.y = 15;
                      self.webglViewport.orbitControl.target.z = 70;
                      break;

                  default:
                      return; // Quit when this doesn't handle the key event.
              }

              self.webglViewport.orbitControl.update();

              // Consume the event for suppressing "double action".
              event.preventDefault();
          }, true );

      }

      (function _init () {

          _initGUI.call( self, _parameters.gui );

          if ( _parameters.webGLEnable ) { _initWebGLViewport.call( self, _parameters.webGL ); }

          _initListener.call( self );

      })();

      function _checkReady () {

          if ( parameters.webGL.modelEnable ) {

              if ( !_modelReady ) { return }

          }

          if ( parameters.webGL.avatarEnable ) {

              if ( !_avatarReady ) { return }

          }

          console.timeEnd( "TApplication" );
          //        self.webglViewport.toggleAutorun()

          onReady();

      }

  }

  /**
   * Static methods
   */
  Object.assign( TApplication, {

      // Todo: String helper

      /**
       * @static
       * @public
       * @memberOf TApplication
       */
      diacriticsMap: (function () {

          /*
           Licensed under the Apache License, Version 2.0 (the "License");
           you may not use this file except in compliance with the License.
           You may obtain a copy of the License at

           http://www.apache.org/licenses/LICENSE-2.0

           Unless required by applicable law or agreed to in writing, software
           distributed under the License is distributed on an "AS IS" BASIS,
           WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
           See the License for the specific language governing permissions and
           limitations under the License.
           */

          var defaultDiacriticsRemovalMap = [
              {
                  'base':    'A',
                  'letters': '\u0041\u24B6\uFF21\u00C0\u00C1\u00C2\u1EA6\u1EA4\u1EAA\u1EA8\u00C3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\u00C4\u01DE\u1EA2\u00C5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F'
              },
              {
                  'base':    'AA',
                  'letters': '\uA732'
              },
              {
                  'base':    'AE',
                  'letters': '\u00C6\u01FC\u01E2'
              },
              {
                  'base':    'AO',
                  'letters': '\uA734'
              },
              {
                  'base':    'AU',
                  'letters': '\uA736'
              },
              {
                  'base':    'AV',
                  'letters': '\uA738\uA73A'
              },
              {
                  'base':    'AY',
                  'letters': '\uA73C'
              },
              {
                  'base':    'B',
                  'letters': '\u0042\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181'
              },
              {
                  'base':    'C',
                  'letters': '\u0043\u24B8\uFF23\u0106\u0108\u010A\u010C\u00C7\u1E08\u0187\u023B\uA73E'
              },
              {
                  'base':    'D',
                  'letters': '\u0044\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779\u00D0'
              },
              {
                  'base':    'DZ',
                  'letters': '\u01F1\u01C4'
              },
              {
                  'base':    'Dz',
                  'letters': '\u01F2\u01C5'
              },
              {
                  'base':    'E',
                  'letters': '\u0045\u24BA\uFF25\u00C8\u00C9\u00CA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\u00CB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E'
              },
              {
                  'base':    'F',
                  'letters': '\u0046\u24BB\uFF26\u1E1E\u0191\uA77B'
              },
              {
                  'base':    'G',
                  'letters': '\u0047\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E'
              },
              {
                  'base':    'H',
                  'letters': '\u0048\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D'
              },
              {
                  'base':    'I',
                  'letters': '\u0049\u24BE\uFF29\u00CC\u00CD\u00CE\u0128\u012A\u012C\u0130\u00CF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197'
              },
              {
                  'base':    'J',
                  'letters': '\u004A\u24BF\uFF2A\u0134\u0248'
              },
              {
                  'base':    'K',
                  'letters': '\u004B\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2'
              },
              {
                  'base':    'L',
                  'letters': '\u004C\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780'
              },
              {
                  'base':    'LJ',
                  'letters': '\u01C7'
              },
              {
                  'base':    'Lj',
                  'letters': '\u01C8'
              },
              {
                  'base':    'M',
                  'letters': '\u004D\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C'
              },
              {
                  'base':    'N',
                  'letters': '\u004E\u24C3\uFF2E\u01F8\u0143\u00D1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4'
              },
              {
                  'base':    'NJ',
                  'letters': '\u01CA'
              },
              {
                  'base':    'Nj',
                  'letters': '\u01CB'
              },
              {
                  'base':    'O',
                  'letters': '\u004F\u24C4\uFF2F\u00D2\u00D3\u00D4\u1ED2\u1ED0\u1ED6\u1ED4\u00D5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\u00D6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\u00D8\u01FE\u0186\u019F\uA74A\uA74C'
              },
              {
                  'base':    'OI',
                  'letters': '\u01A2'
              },
              {
                  'base':    'OO',
                  'letters': '\uA74E'
              },
              {
                  'base':    'OU',
                  'letters': '\u0222'
              },
              {
                  'base':    'OE',
                  'letters': '\u008C\u0152'
              },
              {
                  'base':    'oe',
                  'letters': '\u009C\u0153'
              },
              {
                  'base':    'P',
                  'letters': '\u0050\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754'
              },
              {
                  'base':    'Q',
                  'letters': '\u0051\u24C6\uFF31\uA756\uA758\u024A'
              },
              {
                  'base':    'R',
                  'letters': '\u0052\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782'
              },
              {
                  'base':    'S',
                  'letters': '\u0053\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784'
              },
              {
                  'base':    'T',
                  'letters': '\u0054\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786'
              },
              {
                  'base':    'TZ',
                  'letters': '\uA728'
              },
              {
                  'base':    'U',
                  'letters': '\u0055\u24CA\uFF35\u00D9\u00DA\u00DB\u0168\u1E78\u016A\u1E7A\u016C\u00DC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244'
              },
              {
                  'base':    'V',
                  'letters': '\u0056\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245'
              },
              {
                  'base':    'VY',
                  'letters': '\uA760'
              },
              {
                  'base':    'W',
                  'letters': '\u0057\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72'
              },
              {
                  'base':    'X',
                  'letters': '\u0058\u24CD\uFF38\u1E8A\u1E8C'
              },
              {
                  'base':    'Y',
                  'letters': '\u0059\u24CE\uFF39\u1EF2\u00DD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE'
              },
              {
                  'base':    'Z',
                  'letters': '\u005A\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762'
              },
              {
                  'base':    'a',
                  'letters': '\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u00E4\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250'
              },
              {
                  'base':    'aa',
                  'letters': '\uA733'
              },
              {
                  'base':    'ae',
                  'letters': '\u00E6\u01FD\u01E3'
              },
              {
                  'base':    'ao',
                  'letters': '\uA735'
              },
              {
                  'base':    'au',
                  'letters': '\uA737'
              },
              {
                  'base':    'av',
                  'letters': '\uA739\uA73B'
              },
              {
                  'base':    'ay',
                  'letters': '\uA73D'
              },
              {
                  'base':    'b',
                  'letters': '\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253'
              },
              {
                  'base':    'c',
                  'letters': '\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184'
              },
              {
                  'base':    'd',
                  'letters': '\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A'
              },
              {
                  'base':    'dz',
                  'letters': '\u01F3\u01C6'
              },
              {
                  'base':    'e',
                  'letters': '\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD'
              },
              {
                  'base':    'f',
                  'letters': '\u0066\u24D5\uFF46\u1E1F\u0192\uA77C'
              },
              {
                  'base':    'g',
                  'letters': '\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F'
              },
              {
                  'base':    'h',
                  'letters': '\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265'
              },
              {
                  'base':    'hv',
                  'letters': '\u0195'
              },
              {
                  'base':    'i',
                  'letters': '\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131'
              },
              {
                  'base':    'j',
                  'letters': '\u006A\u24D9\uFF4A\u0135\u01F0\u0249'
              },
              {
                  'base':    'k',
                  'letters': '\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3'
              },
              {
                  'base':    'l',
                  'letters': '\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747'
              },
              {
                  'base':    'lj',
                  'letters': '\u01C9'
              },
              {
                  'base':    'm',
                  'letters': '\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F'
              },
              {
                  'base':    'n',
                  'letters': '\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5'
              },
              {
                  'base':    'nj',
                  'letters': '\u01CC'
              },
              {
                  'base':    'o',
                  'letters': '\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u00F6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275'
              },
              {
                  'base':    'oi',
                  'letters': '\u01A3'
              },
              {
                  'base':    'ou',
                  'letters': '\u0223'
              },
              {
                  'base':    'oo',
                  'letters': '\uA74F'
              },
              {
                  'base':    'p',
                  'letters': '\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755'
              },
              {
                  'base':    'q',
                  'letters': '\u0071\u24E0\uFF51\u024B\uA757\uA759'
              },
              {
                  'base':    'r',
                  'letters': '\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783'
              },
              {
                  'base':    's',
                  'letters': '\u0073\u24E2\uFF53\u00DF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B'
              },
              {
                  'base':    't',
                  'letters': '\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787'
              },
              {
                  'base':    'tz',
                  'letters': '\uA729'
              },
              {
                  'base':    'u',
                  'letters': '\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u00FC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289'
              },
              {
                  'base':    'v',
                  'letters': '\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C'
              },
              {
                  'base':    'vy',
                  'letters': '\uA761'
              },
              {
                  'base':    'w',
                  'letters': '\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73'
              },
              {
                  'base':    'x',
                  'letters': '\u0078\u24E7\uFF58\u1E8B\u1E8D'
              },
              {
                  'base':    'y',
                  'letters': '\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF'
              },
              {
                  'base':    'z',
                  'letters': '\u007A\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763'
              }
          ];

          var diacriticsMap = {};
          for ( var i = 0 ; i < defaultDiacriticsRemovalMap.length ; i++ ) {
              var letters = defaultDiacriticsRemovalMap [ i ].letters;
              for ( var j = 0 ; j < letters.length ; j++ ) {
                  diacriticsMap[ letters[ j ] ] = defaultDiacriticsRemovalMap[ i ].base;
              }
          }

          return diacriticsMap;

      })(),

      /**
       * @static
       * @public
       * @memberOf TApplication
       *
       * @param string
       */
      removeDiacritics: function removeDiacritics ( string ) {

          return string.replace( /[^\u0000-\u007E]/g, function ( a ) {
              return TApplication.diacriticsMap[ a ] || a;
          } );

      }

  } );

  /**
   * Public methods
   */
  Object.assign( TApplication.prototype, {

      /**
       * @memberOf TApplication.prototype
       */
      initRequest: function initRequest () {

          var request = new XMLHttpRequest();

          request.onreadystatechange = function onReadyStateChange () {

              if ( request.readyState === 4 ) {

                  if ( request.status === 200 ) {

                      var response = JSON.parse( request.response );
                      console.log( response );

                  } else {

                      var response = JSON.parse( request.response );
                      console.error( response );

                  }

              }

          };

          request.onprogress = function onProgress ( progressEvent ) {

              console.log( progressEvent );

          };

          request.onload = function onLoad ( loadEvent ) {

              console.log( loadEvent );

          };

          request.onerror = function onError ( error ) {

              console.error( error );

          };

          request.open( 'GET', 'turlututu' );

      },

      // Public methods

      // TreeView
      /**
       * @memberOf TApplication.prototype
       */
      insertTreeViewItem: function insertTreeViewItem ( itemId, itemName, parentId, isCheckedByDefault ) {

          var concatedName   = itemName.replace( /\s/g, '' );
          var undottedName   = concatedName.replace( /\./g, '' );
          var unslashedName  = undottedName.replace( /\//g, '' );
          var unsquaredName  = unslashedName.replace( /[\[\]@]+/g, '' );
          var selectableName = unsquaredName.replace( /[<{(')}>]/g, '' );
          var cleanName      = TApplication.removeDiacritics( selectableName );

          parentId                 = parentId || 'treeViewContainer';
          var concatedParentName   = parentId.replace( /\s/g, '' );
          var undottedParentName   = concatedParentName.replace( /\./g, '' );
          var unslashedParentName  = undottedParentName.replace( /\//g, '' );
          var unsquaredParentName  = unslashedParentName.replace( /[\[\]@]+/g, '' );
          var selectableParentName = unsquaredParentName.replace( /[<{(')}>]/g, '' );
          var cleanParentName      = TApplication.removeDiacritics( selectableParentName );

          var checked = (isCheckedByDefault) ? 'checked="checked"' : '';

          var domElement = "" + ('' +
          '<li id="' + itemId + '">' +
          '   <input type="checkbox" id="' + itemId + 'ExpandCheckbox" />' +
          '   <label>' +
          '       <input type="checkbox" id="' + itemId + 'VisibilityCheckbox" ' + checked + ' /><span></span>' +
          '   </label>' +
          '   <label for="' + itemId + 'ExpandCheckbox">' + itemName + '</label>' +
          '   <ul class="children"></ul>' +
          '</li>');

          var item = $( domElement );

          $( '#' + cleanParentName ).children( '.children' ).append( item );

          return item;

      },

      /**
       * @memberOf TApplication.prototype
       */
      changeMaterialSide: function changeMaterialSide ( objects, xRayActive ) {
          var this$1 = this;


          var object = undefined;

          for ( var objectIndex = 0, numberOfObjects = objects.length ; objectIndex < numberOfObjects ; ++objectIndex ) {

              object = objects[ objectIndex ];

              if ( object.type === 'Mesh' ) {

                  object.material.side = ( xRayActive ) ? BackSide : FrontSide;

              } else if ( object.type === 'Group' ) {

                  this$1.changeMaterialSide.call( this$1, object.children, xRayActive );

              }

          }

      },

      // Layers
      /**
       * @memberOf TApplication.prototype
       */
      setLayerGroupVisibility: function setLayerGroupVisibility ( groupName, visibility ) {

          if ( groupName === 'tigre' ) {

              this.geomapViewer.layerGroupSetVisible( 'Tigre', visibility, function () {
                  this.geomapViewer.mapRefresh();
              }, this );

              this.webglViewport.setGroupVisibility( 'TigerParticularEmbranchments', visibility );
              this.webglViewport.setGroupVisibility( 'TigerNodes', visibility );
              this.webglViewport.setGroupVisibility( 'TigerSections', visibility );

          } else if ( groupName === 'caiman' ) {

              this.geomapViewer.layerGroupSetVisible( 'Caiman', visibility, function () {
                  this.geomapViewer.mapRefresh();
              }, this );

              this.webglViewport.setGroupVisibility( 'CaimanParticularEmbranchments', visibility );
              this.webglViewport.setGroupVisibility( 'CaimanNodes', visibility );
              this.webglViewport.setGroupVisibility( 'CaimanSections', visibility );

          } else if ( groupName === 'radier' ) {

              this.webglViewport.setGroupVisibility( 'radierGroup', visibility );

          } else if ( groupName === 'surface' ) {

              this.webglViewport.setGroupVisibility( 'GroundLayer', visibility );
              this.updateMeshResolution( 0 );

          } else if ( groupName === 'maonnerie' ) {

              this.webglViewport.setGroupVisibility( 'UndergroundLayer', visibility );
              this.updateMeshResolution( 0 );

          } else if ( groupName === 'nuage' ) {

              this.webglViewport.setGroupVisibility( 'PointClouds', visibility );

          } else if ( groupName === 'flow' ) {

              this.webglViewport.setGroupVisibility( 'flowParticles', visibility );

          } else {

              this.webglViewport.setGroupVisibility( groupName, visibility );

          }

      },

      /**
       * @memberOf TApplication.prototype
       */
      loadObjectFromURL: function loadObjectFromURL ( filesUrls ) {

          this.universalLoader.load( filesUrls, function ( objects ) {

              //convert obj [y forward / z up] as [-z forward / y up]
              // objects.rotation.x -= Math.PI / 2;

              // Set double side (or maybe not...)
              var numberOfChildren = objects.children.length;
              var i;
              for ( i = 0 ; i < numberOfChildren ; ++i ) {
                  objects.children[ i ].rotation.x -= Math.PI / 2;
                  objects.children[ i ].material.side = 2;
              }

              //    console.log(objects);

              this.webglViewport.scene.add( objects );

          }.bind( this ), true );

      },

      /**
       * @memberOf TApplication.prototype
       */
      updateViewportSizes: function updateViewportSizes () {

          if ( this.webglViewport ) {
              this.webglViewport.updateSizes();
          }

      },

      /**
       * @memberOf TApplication.prototype
       */
      updateDataPanel: function updateDataPanel () {

          // Todo make it efficient !!!

          // Get curve distance from start of path to current camera position
          var distanceFromStart = this.webglViewport.pathControl.getDistanceFromStart();

          // Get closest section and get his data to display
          var sections = this.webglViewport.scene.getObjectByName( 'CaimanSections' );
          if ( !sections ) {
              console.error( "Unable to update data panel with null sections !" );
              return
          }

          var cameraPosition          = this.webglViewport.pathControl.camera.position;
          var tinyestDistanceToCamera = Infinity;
          var distanceToCamera        = undefined;
          var section                 = undefined;
          var closestSectionId        = undefined;
          var vertice                 = undefined;
          for ( var sectionIndex = 0, numberOfSections = sections.children.length ; sectionIndex < numberOfSections ; sectionIndex++ ) {

              section = sections.children[ sectionIndex ];

              for ( var i = 0, numberOfVertices = section.geometry.vertices.length ; i < numberOfVertices ; i++ ) {

                  vertice          = section.geometry.vertices[ i ];
                  distanceToCamera = cameraPosition.distanceTo( vertice );

                  if ( distanceToCamera < tinyestDistanceToCamera ) {
                      tinyestDistanceToCamera = distanceToCamera;
                      closestSectionId        = sectionIndex;

                      // Arrow helpers
                      //                    var direction = new Vector3().subVectors( vertice, cameraPosition ).normalize()
                      //                    var arrow = new ArrowHelper( direction, cameraPosition, distanceToCamera )
                      //                    this.webglViewport.scene.add( arrow )

                  }

              }

          }

          var sectionData = sections.children[ closestSectionId ].userData;

          // Clear dataPanel content
          this.resetDataPanel();

          // Fill content
          var paragraph = null;

          paragraph             = document.createElement( 'p' );
          paragraph.textContent = "Distance: " + distanceFromStart.toFixed( 2 ) + " m";
          this.dataPanel.appendChild( paragraph );

          paragraph             = document.createElement( 'p' );
          paragraph.textContent = "Arrondissement: " + sectionData.borough;
          this.dataPanel.appendChild( paragraph );

          paragraph             = document.createElement( 'p' );
          paragraph.textContent = "Circonscription: " + sectionData.district;
          this.dataPanel.appendChild( paragraph );

          paragraph             = document.createElement( 'p' );
          paragraph.textContent = "Nom de voie: " + sectionData.streetName;
          this.dataPanel.appendChild( paragraph );

          paragraph             = document.createElement( 'p' );
          paragraph.textContent = "Type: " + sectionData.type;
          this.dataPanel.appendChild( paragraph );

          paragraph             = document.createElement( 'p' );
          paragraph.textContent = "Type d'effluent: " + sectionData.effluentsType;
          this.dataPanel.appendChild( paragraph );

          paragraph             = document.createElement( 'p' );
          paragraph.textContent = "Longueur: " + sectionData.length.toFixed( 2 ) + " m";
          this.dataPanel.appendChild( paragraph );

          paragraph             = document.createElement( 'p' );
          paragraph.textContent = "Dernire visite: " + sectionData.lastVisit;
          this.dataPanel.appendChild( paragraph );

          paragraph                = document.createElement( 'p' );
          var regulatedStringState = (sectionData.regulated == 0) ? 'Non' : 'Oui';
          paragraph.textContent    = "Regul: " + regulatedStringState;
          this.dataPanel.appendChild( paragraph );

      },

      /**
       * @memberOf TApplication.prototype
       */
      resetDataPanel: function resetDataPanel () {

          this.dataPanel.innerHTML = "";

      },

      /**
       * @memberOf TApplication.prototype
       */
      startMeasure: function startMeasure ( measureMode ) {

          this.webglViewport.view[ 0 ].className = "crosshair";

          var measureGroup = this.webglViewport.scene.getObjectByName( 'MeasureGroup' );
          if ( !measureGroup ) {

              measureGroup      = new Group();
              measureGroup.name = 'MeasureGroup';

              this.webglViewport.scene.add( measureGroup );

          }

          this.measureMode = measureMode;

          this.webglViewport.measuring = true;
          if ( this.measureMode === 'segment' ) {

              this.currentMeasureGroup      = new Group();
              this.currentMeasureGroup.name = 'Segment.' + this.measureCounter;

          } else if ( this.measureMode === 'polyline' ) {

              this.currentMeasureGroup      = new Group();
              this.currentMeasureGroup.name = 'PolyLigne.' + this.measureCounter;

          } else if ( this.measureMode === 'polysegment' ) {

              this.currentMeasureGroup      = new Group();
              this.currentMeasureGroup.name = 'PolySegment.' + this.measureCounter;

          } else if ( this.measureMode === 'clear' ) {

              this.endMeasure();
              this.removeMeasure();

          } else {

              //TODO: check other measure tools !!!

          }

          //Todo: in function of measure type change subGroup
          measureGroup.add( this.currentMeasureGroup );

      },

      /**
       * @memberOf TApplication.prototype
       */
      updateTemporaryMeasure: function updateTemporaryMeasure ( event ) {

          var self = this;

          var intersectionPoint    = this.webglViewport.intersection.point;
          var measureGroupChildren = this.currentMeasureGroup.children;

          if ( this.measureMode === 'segment' ) {

              var lastMeasurePoint = measureGroupChildren[ measureGroupChildren.length - 1 ];
              if ( lastMeasurePoint ) {

                  //update temp line
                  var temporaryMeasureLine = this.webglViewport.scene.getObjectByName( 'TemporaryMeasureLine' );
                  if ( !temporaryMeasureLine ) { temporaryMeasureLine = createTemporaryMeasureLine(); }
                  updateTemporaryMeasureLine();

                  // update temp distance label
                  updateTemporaryMeasureDistanceLabel( temporaryMeasureLine );

              }

              var temporaryMeasurePoint = this.webglViewport.scene.getObjectByName( 'TemporaryMeasurePoint' );
              if ( !temporaryMeasurePoint ) { temporaryMeasurePoint = createTemporaryMeasurePoint(); }
              updateTemporaryMeasurePoint( intersectionPoint );

          } else if ( this.measureMode === 'polyline' ) {

              var lastMeasurePoint = measureGroupChildren[ measureGroupChildren.length - 1 ];
              if ( lastMeasurePoint ) {

                  //update temp line
                  var temporaryMeasureLine = this.webglViewport.scene.getObjectByName( 'TemporaryMeasureLine' );
                  if ( !temporaryMeasureLine ) { temporaryMeasureLine = createTemporaryMeasureLine(); }
                  updateTemporaryMeasureLine();

                  // update temp distance label
                  updateTemporaryMeasureDistanceLabel( temporaryMeasureLine );

              }

              var temporaryMeasurePoint = this.webglViewport.scene.getObjectByName( 'TemporaryMeasurePoint' );
              if ( !temporaryMeasurePoint ) { temporaryMeasurePoint = createTemporaryMeasurePoint(); }
              updateTemporaryMeasurePoint( intersectionPoint );

          } else if ( this.measureMode === 'polysegment' ) {

              var lastMeasurePoint = measureGroupChildren[ 0 ];
              if ( lastMeasurePoint ) {

                  //update temp line
                  var temporaryMeasureLine = this.webglViewport.scene.getObjectByName( 'TemporaryMeasureLine' );
                  if ( !temporaryMeasureLine ) { temporaryMeasureLine = createTemporaryMeasureLine(); }
                  updateTemporaryMeasureLine();

                  // update temp distance label
                  updateTemporaryMeasureDistanceLabel( temporaryMeasureLine );

              }

              var temporaryMeasurePoint = this.webglViewport.scene.getObjectByName( 'TemporaryMeasurePoint' );
              if ( !temporaryMeasurePoint ) { temporaryMeasurePoint = createTemporaryMeasurePoint(); }
              updateTemporaryMeasurePoint( intersectionPoint );

          } else {

              //TODO: check other measure tools !!!

          }

          function createTemporaryMeasureLine () {

              var geometry = new Geometry();
              geometry.vertices.push( new Vector3$1() );
              geometry.vertices.push( new Vector3$1() );

              var material = new LineBasicMaterial( {
                  color: 0x4286f4
              } );

              var temporaryMeasureLine  = new Line( geometry, material );
              temporaryMeasureLine.name = 'TemporaryMeasureLine';

              self.webglViewport.scene.add( temporaryMeasureLine );

              return temporaryMeasureLine

          }

          function updateTemporaryMeasureLine () {

              temporaryMeasureLine.geometry.vertices[ 0 ]      = lastMeasurePoint.position.clone();
              temporaryMeasureLine.geometry.vertices[ 1 ]      = intersectionPoint.clone();
              temporaryMeasureLine.geometry.verticesNeedUpdate = true;

          }

          function updateTemporaryMeasureDistanceLabel ( temporaryMeasureLine ) {

              var temporaryMeasureDistanceLabel = self.webglViewport.scene.getObjectByName( 'TemporaryMeasureDistanceLabel' );
              if ( temporaryMeasureDistanceLabel ) {

                  temporaryMeasureLine.remove( temporaryMeasureDistanceLabel );

              }

              var lastMeasurePointPosition = lastMeasurePoint.position;
              var distance                 = lastMeasurePointPosition.distanceTo( intersectionPoint );

              var sprit        = TApplication.createSprite( distance.toFixed( 3 ) + 'm' );
              sprit.name       = 'TemporaryMeasureDistanceLabel';
              sprit.position.x = (lastMeasurePointPosition.x + intersectionPoint.x) / 2;
              sprit.position.y = ((lastMeasurePointPosition.y + intersectionPoint.y) / 2) + 0.2;
              sprit.position.z = (lastMeasurePointPosition.z + intersectionPoint.z) / 2;

              temporaryMeasureLine.add( sprit );

          }

          function createTemporaryMeasurePoint () {

              var geometry = new SphereBufferGeometry( 0.01, 3, 3 );

              var material = new MeshLambertMaterial( {
                  color: 0x4286f4,
                  side:  FrontSide
              } );

              var temporaryMeasurePoint  = new Mesh( geometry, material );
              temporaryMeasurePoint.name = 'TemporaryMeasurePoint';

              self.webglViewport.scene.add( temporaryMeasurePoint );

              return temporaryMeasurePoint

          }

          function updateTemporaryMeasurePoint ( newPosition ) {
              temporaryMeasurePoint.position.copy( newPosition );
          }

      },

      /**
       * @memberOf TApplication.prototype
       */
      removeTemporaryMeasure: function removeTemporaryMeasure () {

          this.webglViewport.scene.remove( this.webglViewport.scene.getObjectByName( 'TemporaryMeasurePoint' ) );
          this.webglViewport.scene.remove( this.webglViewport.scene.getObjectByName( 'TemporaryMeasureLine' ) );
          this.webglViewport.scene.remove( this.webglViewport.scene.getObjectByName( 'TemporaryMeasureDistanceLabel' ) );

      },

      /**
       * @memberOf TApplication.prototype
       */
      updateMeasure: function updateMeasure ( event ) {

          var intersectionPoint    = this.webglViewport.intersection.point;
          var measureGroupChildren = this.currentMeasureGroup.children;

          if ( this.measureMode === 'segment' ) {

              var lastMeasurePoint = measureGroupChildren[ measureGroupChildren.length - 1 ];
              if ( lastMeasurePoint ) {

                  //update line
                  var newMeasureLine = createMeasureLine();
                  this.currentMeasureGroup.add( newMeasureLine );

                  // update distance label
                  createMeasureDistanceLabel( newMeasureLine );

              }

              var measurePoint = createMeasurePoint();
              this.currentMeasureGroup.add( measurePoint );

              if ( measureGroupChildren.length === 3 ) {
                  this.removeTemporaryMeasure();
                  this.startMeasure( this.measureMode );
              }

          } else if ( this.measureMode === 'polyline' ) {

              var lastMeasurePoint = measureGroupChildren[ measureGroupChildren.length - 1 ];
              if ( lastMeasurePoint ) {

                  //update line
                  var newMeasureLine = createMeasureLine();
                  this.currentMeasureGroup.add( newMeasureLine );

                  // update distance label
                  createMeasureDistanceLabel( newMeasureLine );

              }

              var measurePoint = createMeasurePoint();
              this.currentMeasureGroup.add( measurePoint );

          } else if ( this.measureMode === 'polysegment' ) {

              var lastMeasurePoint = measureGroupChildren[ 0 ];
              if ( lastMeasurePoint ) {

                  //update line
                  var newMeasureLine = createMeasureLine();
                  this.currentMeasureGroup.add( newMeasureLine );

                  // update distance label
                  createMeasureDistanceLabel( newMeasureLine );

              }

              var measurePoint = createMeasurePoint();
              this.currentMeasureGroup.add( measurePoint );

          } else {

              //TODO: check other measure tools !!!

          }

          function createMeasureLine () {

              var geometry = new Geometry();
              geometry.vertices.push( lastMeasurePoint.position.clone() );
              geometry.vertices.push( intersectionPoint.clone() );

              var material = new LineBasicMaterial( {
                  color: 0x4286f4
              } );

              return new Line( geometry, material )

          }

          function createMeasureDistanceLabel ( measureLine ) {

              var lastMeasurePointPosition = lastMeasurePoint.position;
              var distance                 = lastMeasurePointPosition.distanceTo( intersectionPoint );

              var sprit        = TApplication.createSprite( distance.toFixed( 3 ) + 'm' );
              sprit.position.x = (lastMeasurePointPosition.x + intersectionPoint.x) / 2;
              sprit.position.y = ((lastMeasurePointPosition.y + intersectionPoint.y) / 2) + 0.2;
              sprit.position.z = (lastMeasurePointPosition.z + intersectionPoint.z) / 2;

              measureLine.add( sprit );

          }

          function createMeasurePoint () {

              var geometry = new SphereBufferGeometry( 0.01, 3, 3 );

              var material = new MeshLambertMaterial( {
                  color: 0x4286f4,
                  side:  FrontSide
              } );

              var point = new Mesh( geometry, material );
              point.position.copy( intersectionPoint );

              return point

          }

      },

      /**
       * @memberOf TApplication.prototype
       */
      endMeasure: function endMeasure () {

          this.webglViewport.view[ 0 ].className = "";

          this.webglViewport.measuring = false;

          // Remove temp measure
          this.removeTemporaryMeasure();

          // Increment measure group counter
          this.measureCounter++;

      },

      /**
       * @memberOf TApplication.prototype
       */
      removeMeasure: function removeMeasure () {
          var this$1 = this;


          while ( this.measureCounter >= 0 ) {

              var measureGroup = this$1.webglViewport.scene.getObjectByName( 'MeasureGroup' );
              this$1.webglViewport.scene.remove( measureGroup );

              this$1.measureCounter = -1;

              //            var segmentToRemove = this.webglViewport.scene.getObjectByName( 'Segment.' + this.measureCounter )
              //            this.webglViewport.scene.remove( segmentToRemove )
              //
              //            var polylineToRemove = this.webglViewport.scene.getObjectByName( 'PolyLigne.' + this.measureCounter )
              //            this.webglViewport.scene.remove( polylineToRemove )
              //
              //            var polysegmentToRemove = this.webglViewport.scene.getObjectByName( 'PolySegment.' + this.measureCounter )
              //            this.webglViewport.scene.remove( polysegmentToRemove )
              //
              //            this.measureCounter--

          }

      },

      /**
       * @memberOf TApplication.prototype
       */
      updateImageShot: function updateImageShot () {

          //Todo: Think of the fact that the shots are low compared to the camera position

          var shotGroup = this.webglViewport.scene.getObjectByName( 'shotGroup' );
          if ( !shotGroup ) {
              console.error( "Unable to update images shot with null shots !" );
              return
          }

          var camera = this.webglViewport.camera;

          // every time the camera or objects change position (or every frame)
          camera.updateMatrixWorld(); // make sure the camera matrix is updated
          camera.matrixWorldInverse.getInverse( camera.matrixWorld );
          cameraViewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
          frustum.setFromMatrix( cameraViewProjectionMatrix );

          var MAXIMUM_DISTANCE_TO = 4; //m use SQUARED distance for perf
          var cameraPosition      = camera.getWorldPosition();
          var cameraDirection     = camera.getWorldDirection();
          var shots               = shotGroup.children;
          var shot                = undefined;
          var bestShot            = undefined;
          var distanceToCamera    = undefined;
          var shotPosition        = undefined;
          var shotOrientation     = undefined;
          var dotProduct          = undefined;
          var result              = undefined;
          var bestResult          = Infinity;
          for ( var shotIndex = 0, numberOfShots = shots.length ; shotIndex < numberOfShots ; shotIndex++ ) {

              shot = shots[ shotIndex ];
              if ( !frustum.intersectsObject( shot ) ) {
                  continue
              }

              shotPosition     = shot.getWorldPosition();
              distanceToCamera = shotPosition.distanceToSquared( cameraPosition );
              if ( distanceToCamera > MAXIMUM_DISTANCE_TO ) {
                  continue
              }

              shotOrientation = shot.getWorldDirection();
              dotProduct      = shotOrientation.dot( cameraDirection );
              if ( dotProduct > 0 ) {
                  continue
              }

              result = dotProduct / distanceToCamera;
              if ( result < bestResult ) {
                  bestResult = result;
                  bestShot   = shot;
              }

          }

          if ( bestShot && this.previousImageShot !== bestShot ) {

              this.previousImageShot = bestShot;

              //			shot.visible   = true
              //			var shotDirAxe = new ArrowHelper( bestShot.getWorldDirection(), bestShot.getWorldPosition(), 1, 0x00ffff )
              //			this.webglViewport.scene.add( shotDirAxe )
              //			shot.material.map        = imageLoader.load( "resources/images/none_image.png" )
              //			shot.material.needUpdate = true

              this.thumbnailPanel.innerHTML = "";
              var thumbnails                = imageLoader.load( bestShot.userData.filePath + "LD/" + bestShot.name );

              var link = document.createElement( 'a' );
              link.appendChild( thumbnails );
              link.onclick = function () {
                  this.popupImageShotModal();
              }.bind( this );
              this.thumbnailPanel.appendChild( link );

          }

      },

      /**
       * @memberOf TApplication.prototype
       */
      popupImportFilesModal: function popupImportFilesModal () {

          var self = this;
          self.importFilesModalView.modal( 'show' );
      },

      /**
       * @memberOf TApplication.prototype
       */
      popupImageShotModal: function popupImageShotModal () {

          var self = this;
          imageLoader.load( this.previousImageShot.userData.filePath + "HD/" + this.previousImageShot.name, function onLoad ( imageHD ) {

              if ( !imageHD ) {
                  console.error( "Unable to display empty or null hd image !" );
                  return
              }

              var link = document.createElement( 'a' );
              link.setAttribute( 'href', self.previousImageShot.userData.filePath + "HD/" + self.previousImageShot.name );
              link.setAttribute( 'target', "_blank" );

              link.appendChild( imageHD );

              $( '#imageShotModalContent' )
                  .empty()
                  .append( link );

              self.imageShotModalView.modal( 'show' );

          } );

      },

      /**
       * @memberOf TApplication.prototype
       */
      popupSelectedObjectModal: function popupSelectedObjectModal () {

          var selectedObject = this.webglViewport.selected;
          var userData       = selectedObject.userData || selectedObject.parent.userData;

          var ul = document.createElement( 'ul' );
          processDataObject( userData, ul );

          //        li
          //        a#detailBtn.btn(data-toggle='button', title='Dtails quipement')
          //        i.fa.fa-pencil
          //        li
          //        a#historyBtn.btn(data-toggle='button', title='Historique d\'intervention')
          //        i.fa.fa-history
          //        li
          //        a#createBtn.btn(data-toggle='button', title='Cration d\'intervention')
          //        i.fa.fa-flash

          //        $( '#selectedObjectContent' )
          //            .empty()
          //            .append( ul )
          //            .append( aDetail )

          var carlId = userData.id.slice( 0, -4 ).toUpperCase();

          var modalHeader       = document.getElementById( 'selectedObjectHeader' );
          modalHeader.innerHTML = "";
          modalHeader.appendChild( createHeaderTitle( selectedObject.name ) );
          modalHeader.appendChild( createHeaderButtons( carlId ) );

          var selectedObjectContent       = document.getElementById( 'selectedObjectContent' );
          selectedObjectContent.innerHTML = "";
          selectedObjectContent.appendChild( ul );

          this.selectedObjectModalView.modal( 'show' );

          function processDataObject ( dataObject, container ) {

              for ( var dataName in dataObject ) {

                  if ( dataName === 'revit_id' ) {
                      continue
                  }

                  var data = dataObject[ dataName ];

                  var liElement = document.createElement( 'li' );

                  var titleElement       = document.createElement( 'b' );
                  titleElement.innerText = dataName + ': ';

                  if ( typeof (data) === 'object' ) {

                      liElement.appendChild( titleElement );

                      var ulElement = document.createElement( 'ul' );
                      processDataObject( data, ulElement );

                      liElement.appendChild( ulElement );

                  } else {

                      liElement.appendChild( titleElement );

                      var dataElement       = document.createElement( 'span' );
                      dataElement.innerText = data;

                      liElement.appendChild( dataElement );

                  }

                  container.appendChild( liElement );

              }

          }

          function createHeaderTitle ( title ) {

              var headerTitle = document.createElement( 'h4' );
              headerTitle.classList.add( 'modal-title' );
              headerTitle.innerHTML     = title || 'Selection';
              headerTitle.style.display = 'inline-block';
              headerTitle.style.width   = '20%';

              return headerTitle
          }

          function createHeaderButtons ( carlId ) {

              var buttonsContainer             = document.createElement( 'div' );
              buttonsContainer.style.display   = 'inline-block';
              buttonsContainer.style.width     = '80%';
              buttonsContainer.style.textAlign = 'right';

              var editButton     = createButton( carlId, 'pencil', 'Dtails quipement' );
              editButton.onclick = function ( event ) {

                  var carlId = event.currentTarget.value;
                  parent.postMessage( ("GISDetailAction#-#" + carlId + ";com.carl.xnet.equipment.backend.bean.MaterialBean#+#"), '*' );

              };
              buttonsContainer.appendChild( editButton );

              var historyButton     = createButton( carlId, 'history', 'Historique d\'intervention' );
              historyButton.onclick = function ( event ) {

                  var carlId = event.currentTarget.value;
                  parent.postMessage( ("WOViewAction#-#" + carlId + ";com.carl.xnet.equipment.backend.bean.MaterialBean#+#"), '*' );

              };
              buttonsContainer.appendChild( historyButton );

              var createInterButton     = createButton( carlId, 'flash', 'Cration d\'intervention' );
              createInterButton.onclick = function ( event ) {

                  var carlId = event.currentTarget.value;
                  parent.postMessage( ("CREATE_WO#-#" + carlId + ";com.carl.xnet.equipment.backend.bean.MaterialBean#+#"), '*' );

              };
              buttonsContainer.appendChild( createInterButton );

              return buttonsContainer

          }

          function createButton ( idValue, iconName, toolTip ) {

              var button = document.createElement( 'button' );
              button.classList.add( 'btn' );
              button.setAttribute( 'title', toolTip );
              button.setAttribute( 'value', idValue );
              button.style.marginLeft = '5px';

              var icon = document.createElement( 'i' );
              icon.classList.add( 'fa' );
              icon.classList.add( ("fa-" + iconName) );

              button.appendChild( icon );

              return button

          }

      },

      /**
       * @memberOf TApplication.prototype
       */
      updatePointCloudDensity: function updatePointCloudDensity ( /*delay*/ ) {

          var cameraPosition = this.webglViewport.camera.getWorldPosition();

          var delay = 500;
          if ( this.pointCloudManager ) {

              clearTimeout( this.updatePointCloudTimeout );
              this.updatePointCloudTimeout = setTimeout( this.pointCloudManager.updatePointClouds.bind( this.pointCloudManager ), delay, cameraPosition );

          }

      },

      /**
       * @memberOf TApplication.prototype
       */
      updateMeshResolution: function updateMeshResolution ( /*delay*/ ) {

          var delay = 500;
          if ( this.meshManager ) {

              clearTimeout( this.updateMeshTimeout );
              this.updateMeshTimeout = setTimeout( this.meshManager.updateMeshes.bind( this.meshManager ), delay );

          }

      },

      /**
       * @memberOf TApplication.prototype
       */
      updateAvatar: function updateAvatar () {

          var avatar = this.webglViewport.scene.getObjectByName( "Avatar" );
          if ( !avatar ) { return }

          var cameraControllerType = this.webglViewport.cameraControlType;
          if ( cameraControllerType === 'orbital' ) {

              avatar.visible = true;

          } else if ( cameraControllerType === 'path' ) {

              avatar.visible = false;

              // CAMERA PART
              var cameraPosition  = this.webglViewport.camera.getWorldPosition();
              var cameraDirection = this.webglViewport.camera.getWorldDirection();

              // CameraHelper
              //            var cameraDirectionHelper = new ArrowHelper( cameraDirection, cameraPosition, 1 )
              //            cameraDirectionHelper.name = 'cameraDirectionHelper'
              //            this.webglViewport.scene.remove( this.webglViewport.scene.getObjectByName('cameraDirectionHelper') )
              //            this.webglViewport.scene.add( cameraDirectionHelper )

              // PATH PART
              var currentPathPosition = this.webglViewport.pathControl.getCurrentPathPosition();
              var nextPathPosition    = this.webglViewport.pathControl.getNextPathPosition();

              var pathDirection = new Vector3$1();
              pathDirection.subVectors( nextPathPosition, currentPathPosition );
              pathDirection.normalize();

              // Path Helper
              //            var pathDirectionHelper = new ArrowHelper( pathDirection, currentPathPosition, 1 )
              //            pathDirectionHelper.name = 'pathDirectionHelper'
              //            this.webglViewport.scene.remove( this.webglViewport.scene.getObjectByName('pathDirectionHelper') )
              //            this.webglViewport.scene.add( pathDirectionHelper )

              avatar.position.copy( currentPathPosition );

              if ( cameraDirection.dot( pathDirection ) > 0 ) {

                  avatar.lookAt( nextPathPosition );

              } else {

                  avatar.lookAt( nextPathPosition.negate() );

              }

              var rad = 115 * Math.PI / 180;
              avatar.rotateY( rad );

          }

      },

      /**
       * @memberOf TApplication.prototype
       */
      setCameraMode: function setCameraMode ( mode ) {

          this.webglViewport.setCameraControls( mode );

          if ( mode === "avatar" ) {

          } else {

              //            this.meshManager.setResolutionMap( this.meshManagerOrbitalResolutionMap )
              //            this.updateMeshResolution()

              //            this.updatePointCloudDensity()
              this.resetDataPanel();
              //            this.updateAvatar()

          }

      },

      /**
       * @memberOf TApplication.prototype
       */
      setRendersEffect: function setRendersEffect ( effect ) {

          this.webglViewport.setCameraEffect( effect );

      },

      /**
       * @memberOf TApplication.prototype
       */
      askUserForPosition: function askUserForPosition () {

          var self = this;
          this.geomapViewer.digitizePoint( "Cliquer sur la carte", true, function ( event ) {

              //Do something with the geometry
              var geometry = event.geometry;
              if ( !geometry ) {
                  console.warn( "Unable to find geometry in tiger event !" );
                  return
              }

              var coordinates = geometry.coordinate;
              if ( !coordinates ) {
                  console.warn( "Unable to find coordinates in tiger geometry !" );
                  return
              }

              var scale = 100;
              // convert Lambert 93 coords to local webgl coords
              // WebGl is Y up and -Z forward !
              var webglCoordinates = convertLambert93CoordinatesToWebGLCoordinates( coordinates );
              webglCoordinates.y   = scale / 3;

              this.geomapViewer.zoomToView( coordinates.x, coordinates.y, scale, function ( event ) {}, this );

              self.webglViewport.setCameraPosition( webglCoordinates );

          }, self );

      },

      /**
       * @memberOf TApplication.prototype
       */
      setMapViewer: function setMapViewer ( viewer ) {

          this.viewer = viewer;
          this.updateMapViewer();

      },

      /**
       * Update camera viewers
       *
       * @memberOf TApplication.prototype
       */
      updateMapViewer: function updateMapViewer () {

          this.updateMapViewerPosition();
          this.updateMapViewerOrientation();
          this.updateMapViewerDisplay();

      },

      /**
       * Update camera position
       *
       * @memberOf TApplication.prototype
       */
      updateMapViewerPosition: function updateMapViewerPosition () {

          var cameraPosition = this.webglViewport.camera.position;
          if ( !cameraPosition ) {
              console.warn( "Unable to find coordinates of webgl camera !" );
              return
          }

          var viewer = this.viewer;
          if ( viewer === '2d' ) {

              if ( !this.geomapViewer ) {
                  return
              }

              // convert local webgl coords to Lambert 93 coords
              var lambertCoordinates = convertWebGLCoordinatesToLambert93Coordinates( cameraPosition );

              var scale    = 150;
              var mySymbol = {
                  "x":      lambertCoordinates.x,
                  "y":      lambertCoordinates.y,
                  "color":  "00FF00",
                  "size":   "25pt",
                  "symbol": "f1eb"
              };

              this.geomapViewer.zoomToView( lambertCoordinates.x, lambertCoordinates.y, scale, function ( event ) {}, this );
              this.geomapViewer.symbolDraw( "mySymbolLayer", mySymbol, true );

          } else if ( viewer === '3d' ) {

              var currentLocation = this.rlensViewer.getLocation();
              if ( !currentLocation || this.previousLocation.id !== currentLocation.id ) {

                  this.rlensViewer
                      .setLocation( '2 Boulevard Saint Michel, Paris' )
                      .then( function ( location ) {

                          this.previousLocation = location;

                      }.bind( this ) )
                      .catch( function ( e ) {

                          console.error( e );

                      } );

              }

          } else {

              console.error( "Unable to set rotation, unknown viewer: " + this.viewer );

          }

      },

      /**
       * Update camera orientation
       * @memberOf TApplication.prototype
       */
      updateMapViewerOrientation: function updateMapViewerOrientation () {

          var cameraWorldDirection = this.webglViewport.camera.getWorldDirection();
          if ( !cameraWorldDirection ) {
              console.error( 'Invalid direction vector !!!' );
              return
          }

          var viewer = this.viewer;
          if ( this.viewer === '2d' ) {

              if ( !this.geomapViewer ) {
                  return
              }

              var position = convertWebGLCoordinatesToLambert93Coordinates( this.webglViewport.camera.position );
              var rotation = convertWebGLRotationToTopologicalYawPitch( cameraWorldDirection );

              var cameraSymbol = {
                  "x":        position.x,
                  "y":        position.y,
                  "rotation": rotation.yaw,
                  "color":    "00FF00",
                  "size":     "25pt",
                  "symbol":   "f1eb"
              };

              if ( this.webglViewport.cameraControlType === 'path' ) {

                  this.geomapViewer.zoomToView( position.x, position.y, 150, function ( event ) {}, this );

              } else if ( this.webglViewport.cameraControlType === 'orbital' ) {

                  //Todo: Center on target and set correct scale in function of camera to target distance

              }

              this.geomapViewer.symbolDraw( "mySymbolLayer", cameraSymbol, true );

          } else if ( this.viewer === '3d' ) {

              if ( this.previousLocation ) {

                  var rotation = convertWebGLRotationToTopologicalYawPitch( cameraWorldDirection );
                  var yawPitch = new H.realitylens.YawPitch( rotation );

                  this.rlensViewer.setViewDirection( yawPitch, 0 );

              }

          } else {

              console.error( "Unable to set rotation, unknown viewer: " + this.viewer );

          }

      },

      updateMapViewerDisplay: function updateMapViewerDisplay () {

          if ( !this.geomapViewer && !this.rlensPanel ) {

              return

          } else if ( this.geomapViewer && !this.rlensPanel ) {

              this.geomapPanel.style.display = 'block';
              return

          } else if ( !this.geomapViewer && this.rlensPanel ) {

              this.rlensPanel.style.display = 'block';
              return

          }

          var viewer = this.viewer;
          if ( viewer === '2d' ) {

              this.rlensPanel.style.display  = 'none';
              this.geomapPanel.style.display = 'block';

          } else if ( viewer === '3d' ) {

              this.geomapPanel.style.display = 'none';
              this.rlensPanel.style.display  = 'block';

          } else {

              this.rlensPanel.style.display  = 'none';
              this.geomapPanel.style.display = 'none';

              console.error( 'Invalid map viewer options !!! Available options are: 2d or 3d.' );

          }

      }

  } );

  /**
   * @author [Tristan Valcke]{@link https://github.com/Itee}
   * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
   *
   * @class TFactory
   * @classdesc Todo...
   * @example Todo...
   *
   */
   
  function TFactory () {

  }

  /**
   * @author [Tristan Valcke]{@link https://github.com/Itee}
   * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
   *
   * @class TErrorManager
   * @classdesc Todo...
   * @example Todo...
   *
   */


  function TErrorManager () {

  }

  /**
   * @author [Tristan Valcke]{@link https://github.com/Itee}
   * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
   *
   * @class TProgressManager
   * @classdesc Todo...
   * @example Todo...
   *
   */

  function TProgressManager () {

  }

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mr.doob / http://mrdoob.com/
   */

  var Detector = {

  	canvas: !! window.CanvasRenderingContext2D,
  	webgl: ( function () {

  		try {

  			var canvas = document.createElement( 'canvas' ); return !! ( window.WebGLRenderingContext && ( canvas.getContext( 'webgl' ) || canvas.getContext( 'experimental-webgl' ) ) );

  		} catch ( e ) {

  			return false;

  		}

  	} )(),
  	workers: !! window.Worker,
  	fileapi: window.File && window.FileReader && window.FileList && window.Blob,

  	getWebGLErrorMessage: function () {

  		var element = document.createElement( 'div' );
  		element.id = 'webgl-error-message';
  		element.style.fontFamily = 'monospace';
  		element.style.fontSize = '13px';
  		element.style.fontWeight = 'normal';
  		element.style.textAlign = 'center';
  		element.style.background = '#fff';
  		element.style.color = '#000';
  		element.style.padding = '1.5em';
  		element.style.width = '400px';
  		element.style.margin = '5em auto 0';

  		if ( ! this.webgl ) {

  			element.innerHTML = window.WebGLRenderingContext ? [
  				'Your graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br />',
  				'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.'
  			].join( '\n' ) : [
  				'Your browser does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br/>',
  				'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.'
  			].join( '\n' );

  		}

  		return element;

  	},

  	addGetWebGLMessage: function ( parameters ) {

  		var parent, id, element;

  		parameters = parameters || {};

  		parent = parameters.parent !== undefined ? parameters.parent : document.body;
  		id = parameters.id !== undefined ? parameters.id : 'oldie';

  		element = Detector.getWebGLErrorMessage();
  		element.id = id;

  		parent.appendChild( element );

  	}

  };

  // browserify support
  if ( typeof module === 'object' ) {

  	module.exports = Detector;

  }

  /**
   * @author [Tristan Valcke]{@link https://github.com/Itee}
   * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
   *
   * @file The main entry point for Itee-Client, it contains all exports of the library
   *
   */

  exports.HttpStatusCode = HttpStatusCode;
  exports.HttpVerb = HttpVerb;
  exports.ResponseType = ResponseType;
  exports.TApplication = TApplication;
  exports.TCache = TCache;
  exports.TOrchestrator = singletonInstance;
  exports.TViewport = TViewport;
  exports.TFactory = TFactory;
  exports.TUniversalLoader = TUniversalLoader;
  exports.TOrbitControlsHelper = TOrbitControlsHelper;
  exports.TErrorManager = TErrorManager;
  exports.TProgressManager = TProgressManager;
  exports.TDataBaseManager = TDataBaseManager;
  exports.TScenesManager = TScenesManager;
  exports.TObjectsManager = TObjectsManager;
  exports.TGeometriesManager = TGeometriesManager;
  exports.TMaterialsManager = TMaterialsManager;
  exports.TPointsManager = TPointsManager;
  exports.AnaglyphEffect = AnaglyphEffect;
  exports.WebGLDetector = Detector;
  exports.OrbitControls = OrbitControls;
  exports.StereoEffect = StereoEffect;

  Object.defineProperty(exports, '__esModule', { value: true });

});
