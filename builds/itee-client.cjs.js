console.log('Itee.Client v7.0.0 - CommonJs')
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var iteeUtils = require('itee-utils');
var iteeValidators = require('itee-validators');

/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @class ClassName
 * @classdesc Todo...
 * @example Todo...
 *
 */

/**
 * The FileFormat Enum give some commonly used file format in 3d context
 * @type {Enum}
 */
const FileFormat = iteeUtils.toEnum( {
    Asc:  { value: 'asc' },
    Dae:  { value: 'dae' },
    Dbf:  { value: 'dbf' },
    Fbx:  { value: 'fbx' },
    Mtl:  { value: 'mtl' },
    Json: { value: 'json' },
    Obj:  { value: 'obj' },
    Shp:  { value: 'shp' },
    Stl:  { value: 'stl' }
} );

/**
 * @typedef {Enum} HttpStatusCode
 * @property {number} Continue=100 - Waiting for the continuation of the request.
 * @property {number} SwitchingProtocols=101 - The requester has asked the server to switch protocols and the server has agreed to do so.
 * @property {number} Processing=102 - WebDAV: Processing in progress (prevents the client from exceeding the limited waiting time).
 * @property {number} Ok=200 - Query successfully processed.
 * @property {number} Created=201 - Query successfully processed and a document was created.
 * @property {number} Accepted=202 - Query processed, but without guarantee of result.
 * @property {number} NonAuthoritativeInformation=203 - Information returned, but generated by an uncertified source.
 * @property {number} NoContent=204 - Query successfully processed but no information returned.
 * @property {number} ResetContent=205 - Query successfully processed, the current page can be cleared.
 * @property {number} PartialContent=206 - Only part of the resource has been transmitted.
 * @property {number} MultiStatus=207 - WebDAV: Multiple Response.
 * @property {number} AlreadyReported=208 - WebDAV: The document was previously sent to this collection.
 * @property {number} ContentDifferent=210 - WebDAV: The copy of the client-side resource differs from that of the server (content or properties).
 * @property {number} IMUsed=226 - The server has completed the request for the resource, and the response is a representation of the result of one or more instance manipulations applied to the
 *     current instance.
 * @property {number} MultipleChoices=300 - The requested URI refers to multiple resources.
 * @property {number} MovedPermanently=301 - Document moved permanently.
 * @property {number} Found=302 - Document moved temporarily.
 * @property {number} SeeOther=303 - The answer to this query is elsewhere.
 * @property {number} NotModified=304 - Document not modified since the last request.
 * @property {number} UseProxy=305 - The request must be re-addressed to the proxy.
 * @property {number} Unused=306 - Code used by an older version of RFC 2616, now reserved.
 * @property {number} TemporaryRedirect=307 - The request must be temporarily redirected to the specified URI.
 * @property {number} PermanentRedirect=308 - The request must be redirected permanently to the specified URI.
 * @property {number} TooManyRedirects=310 - The request must be redirected too many times, or is the victim of a redirection loop.
 * @property {number} BadRequest=400 - The syntax of the query is wrong.
 * @property {number} Unauthorized=401 - Authentication is required to access the resource.
 * @property {number} PaymentRequired=402 - Payment required to access the resource.
 * @property {number} Forbidden=403 - The server understood the request, but refuses to execute it. Unlike error 401, authenticating will not make any difference. On servers where authentication is
 *     required, this usually means that authentication has been accepted but access rights do not allow the client to access the resource.
 * @property {number} NotFound=404 - Resource not found.
 * @property {number} MethodNotAllowed=405 - Unauthorized request method.
 * @property {number} NotAcceptable=406 - The requested resource is not available in a format that would respect the "Accept" headers of the request.
 * @property {number} ProxyAuthenticationRequired=407 - Access to the authorized resource by identification with the proxy.
 * @property {number} RequestTimeOut=408 - Waiting time for an elapsed client request.
 * @property {number} Conflict=409 - The request can not be processed in the current state.
 * @property {number} Gone=410 - The resource is no longer available and no redirection address is known.
 * @property {number} LengthRequired=411 - The length of the request has not been specified.
 * @property {number} PreconditionFailed=412 - Preconditions sent by the query unverified.
 * @property {number} RequestEntityTooLarge=413 - Abandoned processing due to excessive request
 * @property {number} RequestURITooLong=414 - URI too long
 * @property {number} UnsupportedMediaType=415 - Unsupported query format for a given method and resource.
 * @property {number} RequestRangeUnsatisfiable=416 - Invalid "range" request header fields.
 * @property {number} ExpectationFailed=417 - Expected behavior and defined in the header of the unsatisfactory request.
 * @property {number} ImATeapot=418 - "I am a teapot". This code is defined in RFC 2324 dated April 1, 1998, Hyper Text Coffee Pot Control Protocol.
 * @property {number} BadMapping=421 - The request was sent to a server that is not able to produce a response (for example, because a connection has been reused).
 * @property {number} UnprocessableEntity=422 - WebDAV: The entity provided with the request is incomprehensible or incomplete.
 * @property {number} Locked=423 - WebDAV: The operation can not take place because the resource is locked.
 * @property {number} MethodFailure=424 - WebDAV: A method of the transaction failed.
 * @property {number} UnorderedCollection=425 - WebDAV RFC 3648. This code is defined in the WebDAV Advanced Collections Protocol draft , but is absent from the Web Distributed Authoring and
 *     Versioning (WebDAV) Ordered Collections Protocol.
 * @property {number} UpgradeRequired=426 - RFC 2817 The client should change protocol, for example to TLS / 1.0 .
 * @property {number} PreconditionRequired=428 - RFC 6585 The request must be conditional.
 * @property {number} TooManyRequests=429 - RFC 6585 The client has issued too many requests within a given time.
 * @property {number} RequestHeaderFieldsTooLarge=431 - RFC 6585 HTTP headers issued exceed the maximum size allowed by the server.
 * @property {number} NoResponse=444 - Indicates that the server did not return any information to the client and closed the connection.
 * @property {number} RetryWith=449 - Code defined by Microsoft . The request should be returned after performing an action.
 * @property {number} BlockedByWindowsParentalControls=450 - Code defined by Microsoft. This error is generated when Windows Parental Control tools are enabled and block access to the page.
 * @property {number} UnavailableForLegalReasons=451 - This error code indicates that the requested resource is inaccessible for legal reasons
 * @property {number} UnrecoverableError=456 - WebDAV: Fatal error.
 * @property {number} SSLCertificateError=495 - An extension of the 400 Bad Request error, used when the client provided an invalid certificate.
 * @property {number} SSLCertificateRequired=496 - An extension of the 400 Bad Request error, used when a required client certificate is not provided.
 * @property {number} HTTPRequestSentToHTTPSPort=497 - An extension of the 400 Bad Request error, used when the client sends an HTTP request to port 443 normally intended for HTTPS requests.
 * @property {number} ClientClosedRequest=499 - The client closed the connection before receiving the response. This error occurs when the processing is too long on the server side.
 * @property {number} InternalServerError=500 - Internal server error.
 * @property {number} NotImplemented=501 - Functionality claimed not supported by the server.
 * @property {number} BadGateway=502 - Wrong response sent to an intermediate server by another server.
 * @property {number} ServiceUnavailable=503 - Service temporarily unavailable or under maintenance.
 * @property {number} GatewayTimeOut=504 - Waiting time for a response from a server to an intermediate server that has elapsed.
 * @property {number} HTTPVersionNotSupported=505 - HTTP version not managed by the server.
 * @property {number} VariantAlsoNegotiates=506 - RFC 2295: Negotiation Error. Transparent content negociation.
 * @property {number} InsufficientStorage=507 - WebDAV: Insufficient space to modify properties or build the collection.
 * @property {number} LoopDetected=508 - WebDAV: Loop in a Resource Match
 * @property {number} BandwidthLimitExceeded=509 - Used by many servers to indicate a quota overrun.
 * @property {number} NotExtended=510 - RFC 2774: The request does not respect the policy for accessing extended HTTP resources.
 * @property {number} NetworkAuthenticationRequired=511 - RFC 6585: The client must authenticate to access the network. Used by captive portals to redirect clients to the authentication page.
 * @property {number} UnknownError=520 - Error 520 is used as a wildcard response when the origin server returns an unexpected result.
 * @property {number} WebServerIsDown=521 - The server has refused the connection from Cloudflare.
 * @property {number} ConnectionTimedOut=522 - Cloudflare could not negotiate a TCP handshake with the origin server.
 * @property {number} OriginIsUnreachable=523 - Cloudflare failed to reach the origin server. This can occur if DNS server name resolution fails.
 * @property {number} ATimeoutOccured=524 - Cloudflare established a TCP connection with the origin server but did not receive an HTTP response before the login timeout.
 * @property {number} SSLHandshakeFailed=525 - Cloudflare could not negotiate SSL / TLS handshake with the origin server.
 * @property {number} InvalidSSLCertificate=526 - Cloudflare could not validate the SSL certificate presented by the origin server.
 * @property {number} RailgunError=527 - Error 527 indicates that the request has timed out or failed after the WAN connection was established.
 *
 * @constant
 * @type {HttpStatusCode}
 * @description HttpStatusCode contains all http status code available to check and process correctly server response.
 * @see {@link https://en.wikipedia.org/wiki/List_of_HTTP_status_codes} for further information.
 */
const HttpStatusCode = iteeUtils.toEnum( {

    // 100
    Continue:           { value: 100 },
    SwitchingProtocols: { value: 101 },
    Processing:         { value: 102 },

    // 200
    Ok:                          { value: 200 },
    Created:                     { value: 201 },
    Accepted:                    { value: 202 },
    NonAuthoritativeInformation: { value: 203 },
    NoContent:                   { value: 204 },
    ResetContent:                { value: 205 },
    PartialContent:              { value: 206 },
    MultiStatus:                 { value: 207 },
    AlreadyReported:             { value: 208 },
    ContentDifferent:            { value: 210 },
    IMUsed:                      { value: 226 },

    // 300
    MultipleChoices:   { value: 300 },
    MovedPermanently:  { value: 301 },
    Found:             { value: 302 },
    SeeOther:          { value: 303 },
    NotModified:       { value: 304 },
    UseProxy:          { value: 305 },
    Unused:            { value: 306 },
    TemporaryRedirect: { value: 307 },
    PermanentRedirect: { value: 308 },
    TooManyRedirects:  { value: 310 },

    // 400
    BadRequest:                       { value: 400 },
    Unauthorized:                     { value: 401 },
    PaymentRequired:                  { value: 402 },
    Forbidden:                        { value: 403 },
    NotFound:                         { value: 404 },
    MethodNotAllowed:                 { value: 405 },
    NotAcceptable:                    { value: 406 },
    ProxyAuthenticationRequired:      { value: 407 },
    RequestTimeOut:                   { value: 408 },
    Conflict:                         { value: 409 },
    Gone:                             { value: 410 },
    LengthRequired:                   { value: 411 },
    PreconditionFailed:               { value: 412 },
    RequestEntityTooLarge:            { value: 413 },
    RequestRangeUnsatisfiable:        { value: 416 },
    ExpectationFailed:                { value: 417 },
    ImATeapot:                        { value: 418 },
    BadMapping:                       { value: 421 },
    UnprocessableEntity:              { value: 422 },
    Locked:                           { value: 423 },
    MethodFailure:                    { value: 424 },
    UnorderedCollection:              { value: 425 },
    UpgradeRequired:                  { value: 426 },
    PreconditionRequired:             { value: 428 },
    TooManyRequests:                  { value: 429 },
    RequestHeaderFieldsTooLarge:      { value: 431 },
    NoResponse:                       { value: 444 },
    RetryWith:                        { value: 449 },
    BlockedByWindowsParentalControls: { value: 450 },
    UnavailableForLegalReasons:       { value: 451 },
    UnrecoverableError:               { value: 456 },
    SSLCertificateError:              { value: 495 },
    SSLCertificateRequired:           { value: 496 },
    HTTPRequestSentToHTTPSPort:       { value: 497 },
    ClientClosedRequest:              { value: 499 },

    // 500
    InternalServerError:           { value: 500 },
    NotImplemented:                { value: 501 },
    BadGateway:                    { value: 502 },
    ServiceUnavailable:            { value: 503 },
    GatewayTimeOut:                { value: 504 },
    HTTPVersionNotSupported:       { value: 505 },
    VariantAlsoNegotiates:         { value: 506 },
    InsufficientStorage:           { value: 507 },
    LoopDetected:                  { value: 508 },
    BandwidthLimitExceeded:        { value: 509 },
    NotExtended:                   { value: 510 },
    NetworkAuthenticationRequired: { value: 511 },
    UnknownError:                  { value: 520 },
    WebServerIsDown:               { value: 521 },
    ConnectionTimedOut:            { value: 522 },
    OriginIsUnreachable:           { value: 523 },
    ATimeoutOccured:               { value: 524 },
    SSLHandshakeFailed:            { value: 525 },
    InvalidSSLCertificate:         { value: 526 },
    RailgunError:                  { value: 527 }

} );

/**
 * @typedef {Enum} HttpVerb
 * @property {string} Create="PUT" - Corresponding to the create http verb for an itee server, namely "PUT".
 * @property {string} Read="POST" - Corresponding to the read http verb for an itee server, namely "POST".
 * @property {string} Update="PATCH" - Corresponding to the update http verb for an itee server, namely "PATCH".
 * @property {string} Delete="DELETE" - Corresponding to the delete http verb for an itee server, namely "DELETE".
 *
 * @constant
 * @type {HttpVerb}
 * @description HttpVerb contains the CRUD actions with corresponding http verb to request an itee server.
 * @see {@link https://en.wikipedia.org/wiki/Create,_read,_update_and_delete} for further information.
 */
const HttpVerb = iteeUtils.toEnum( {
    Create: { value: 'PUT' },
    Read:   { value: 'POST' },
    Update: { value: 'PATCH' },
    Delete: { value: 'DELETE' }
} );

/**
 * The Keys Enum give the associated key_code
 * @type {Enum}
 */
const Keys = iteeUtils.toEnum( {
    BACKSPACE:            { value: 8 },
    TAB:                  { value: 9 },
    ENTER:                { value: 13 },
    SHIFT:                { value: 16 },
    CTRL:                 { value: 17 },
    ALT:                  { value: 18 },
    PAUSE:                { value: 19 },
    CAPS_LOCK:            { value: 20 },
    ESCAPE:               { value: 27 },
    SPACE:                { value: 32 },
    PAGE_UP:              { value: 33 },
    PAGE_DOWN:            { value: 34 },
    END:                  { value: 35 },
    HOME:                 { value: 36 },
    LEFT_ARROW:           { value: 37 },
    UP_ARROW:             { value: 38 },
    RIGHT_ARROW:          { value: 39 },
    DOWN_ARROW:           { value: 40 },
    INSERT:               { value: 45 },
    DELETE:               { value: 46 },
    ZERO:                 { value: 48 },
    ONE:                  { value: 49 },
    TWO:                  { value: 50 },
    THREE:                { value: 51 },
    FOUR:                 { value: 52 },
    FIVE:                 { value: 53 },
    SIX:                  { value: 54 },
    SEVEN:                { value: 55 },
    HEIGHT:               { value: 56 },
    NINE:                 { value: 57 },
    A:                    { value: 65 },
    B:                    { value: 66 },
    C:                    { value: 67 },
    D:                    { value: 68 },
    E:                    { value: 69 },
    F:                    { value: 70 },
    G:                    { value: 71 },
    H:                    { value: 72 },
    I:                    { value: 73 },
    J:                    { value: 74 },
    K:                    { value: 75 },
    L:                    { value: 76 },
    M:                    { value: 77 },
    N:                    { value: 78 },
    O:                    { value: 79 },
    P:                    { value: 80 },
    Q:                    { value: 81 },
    R:                    { value: 82 },
    S:                    { value: 83 },
    T:                    { value: 84 },
    U:                    { value: 85 },
    V:                    { value: 86 },
    W:                    { value: 87 },
    X:                    { value: 88 },
    Y:                    { value: 89 },
    Z:                    { value: 90 },
    LEFT_WINDOW_KEY:      { value: 91 },
    RIGHT_WINDOW_KEY:     { value: 92 },
    SELECT_KEY:           { value: 93 },
    NUMPAD_0:             { value: 96 },
    NUMPAD_1:             { value: 97 },
    NUMPAD_2:             { value: 98 },
    NUMPAD_3:             { value: 99 },
    NUMPAD_4:             { value: 100 },
    NUMPAD_5:             { value: 101 },
    NUMPAD_6:             { value: 102 },
    NUMPAD_7:             { value: 103 },
    NUMPAD_8:             { value: 104 },
    NUMPAD_9:             { value: 105 },
    MULTIPLY:             { value: 106 },
    ADD:                  { value: 107 },
    SUBSTRACT:            { value: 109 },
    DECIMAL_POINT:        { value: 110 },
    DIVIDE:               { value: 111 },
    F1:                   { value: 112 },
    F2:                   { value: 113 },
    F3:                   { value: 114 },
    F4:                   { value: 115 },
    F5:                   { value: 116 },
    F6:                   { value: 117 },
    F7:                   { value: 118 },
    F8:                   { value: 119 },
    F9:                   { value: 120 },
    F10:                  { value: 121 },
    F11:                  { value: 122 },
    F12:                  { value: 123 },
    NUM_LOCK:             { value: 144 },
    SCROLL_LOCK:          { value: 145 },
    SEMICOLON:            { value: 186 },
    EQUAL:                { value: 187 },
    COMMA:                { value: 188 },
    DASH:                 { value: 189 },
    PERIODE:              { value: 190 },
    SLASH:                { value: 191 },
    GRAVE_ACCENT:         { value: 192 },
    OPEN_SQUARE_BRACKET:  { value: 219 },
    BACKSLASH:            { value: 220 },
    CLOSE_SQUARE_BRACKET: { value: 221 },
    SINGLE_QUOTE:         { value: 222 }
} );

// Todo
const MimeType = iteeUtils.toEnum( {} );

/**
 * This Enum expose 4 common state of mouse button.
 * Wheel, Left, Middle and Right
 * @type {Enum}
 */
const Mouse = iteeUtils.toEnum( {
    WHEEL:  { value: -1 },
    LEFT:   { value: 0 },
    MIDDLE: { value: 1 },
    RIGHT:  { value: 2 }
} );

/**
 * @typedef {Enum} ResponseType
 * @property {string} ArrayBuffer="arraybuffer" - The "arraybuffer" server response type.
 * @property {string} Blob="blob" - The "blob" server response type.
 * @property {string} Document="document" - The "document" server response type.
 * @property {string} Json="json" - The "json" server response type.
 * @property {string} DOMString="text" - The "text" server response type.
 * @property {string} Default="text" - The "" server response type ( equivalent to DOMString ).
 *
 * @constant
 * @type {ResponseType}
 * @description ResponseType allow to filter wich type of response is recieved from the server.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType} for further information.
 */
const ResponseType = iteeUtils.toEnum( {
    ArrayBuffer: { value: 'arraybuffer' },
    Blob:        { value: 'blob' },
    Document:    { value: 'document' },
    Json:        { value: 'json' },
    DOMString:   { value: 'text' },
    Default:     { value: '' }
} );

/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @class TCache
 * @classdesc TCache is a simple javascript object whose purpose is to store some ket/value data to future usage. It could be enable/disable.
 *
 * @example
 * var cache = new TCache()
 * cache.add( 'foo', 'bar' )
 * TLogger.log( cache.get('foo') ) // 'bar'
 */

/**
 * @class Super class cache!
 */
class TStore {

    static _validate ( value, validators ) {

        for ( let validatorIndex = 0, numberOfValidators = validators.length ; validatorIndex < numberOfValidators ; validatorIndex++ ) {

            let validator = validators[ validatorIndex ];

            if ( !validator.validator( value ) ) {

                const error = validator.error;
                if ( iteeValidators.isString( error ) ) {
                    throw new TypeError( error )
                } else if ( iteeValidators.isFunction( error ) ) {
                    throw new TypeError( error( value ) )
                } else {
                    throw new TypeError( `${value} is invalid.` )
                }

            }

        }

    }

    /**
     * @constructor
     */
    constructor ( parameters = {} ) {

        const _parameters = {
            ...{
                collection:      {},
                allowOverride:   false,
                keyValidators:   [],
                valueValidators: []
            }, ...parameters
        };

        this.collection      = _parameters.collection;
        this.allowOverride   = _parameters.allowOverride;
        this.keyValidators   = _parameters.keyValidators;
        this.valueValidators = _parameters.valueValidators;

    }

    get collection () {

        return this._collection

    }

    set collection ( value ) {

        const memberName = 'Collection';
        const expect     = 'Expect an object.';

        if ( iteeValidators.isNull( value ) ) { throw new TypeError( `${memberName} cannot be null ! ${expect}` ) }
        if ( iteeValidators.isUndefined( value ) ) { throw new TypeError( `${memberName} cannot be undefined ! ${expect}` ) }
        if ( iteeValidators.isNotObject( value ) ) { throw new TypeError( `${memberName} cannot be an instance of ${value.constructor.name} ! ${expect}` ) }

        this._collection = value;

    }

    get allowOverride () {

        return this._allowOverride

    }

    set allowOverride ( value ) {

        const memberName = 'Allow override';
        const expect     = 'Expect a boolean.';

        if ( iteeValidators.isNull( value ) ) { throw new TypeError( `${memberName} cannot be null ! ${expect}` ) }
        if ( iteeValidators.isUndefined( value ) ) { throw new TypeError( `${memberName} cannot be undefined ! ${expect}` ) }
        if ( iteeValidators.isNotBoolean( value ) ) { throw new TypeError( `${memberName} cannot be an instance of ${value.constructor.name} ! ${expect}` ) }

        this._allowOverride = value;

    }

    get keyValidators () {

        return this._keyValidators

    }

    set keyValidators ( value ) {

        const memberName = 'Keys validators';
        const expect     = 'Expect an array of TValidator or an empty array.';

        if ( iteeValidators.isNull( value ) ) { throw new TypeError( `${memberName} cannot be null ! ${expect}` ) }
        if ( iteeValidators.isUndefined( value ) ) { throw new TypeError( `${memberName} cannot be undefined ! ${expect}` ) }
        if ( iteeValidators.isNotArray( value ) ) { throw new TypeError( `${memberName} cannot be an instance of ${value.constructor.name} ! ${expect}` ) }

        this._keyValidators = value;

    }

    get valueValidators () {
        return this._valueValidators
    }

    set valueValidators ( value ) {

        const memberName = 'Values validators';
        const expect     = 'Expect an array of TValidator or an empty array.';

        if ( iteeValidators.isNull( value ) ) { throw new TypeError( `${memberName} cannot be null ! ${expect}` ) }
        if ( iteeValidators.isUndefined( value ) ) { throw new TypeError( `${memberName} cannot be undefined ! ${expect}` ) }
        if ( iteeValidators.isNotArray( value ) ) { throw new TypeError( `${memberName} cannot be an instance of ${value.constructor.name} ! ${expect}` ) }

        this._valueValidators = value;

    }

    get keys () {

        return Object.keys( this._collection )

    }

    get values () {

        return Object.values( this._collection )

    }

    setCollection ( value ) {

        this.collection = value;
        return this

    }

    setAllowOverride ( value ) {

        this.allowOverride = value;
        return this

    }

    setKeyValidators ( value ) {

        this.keyValidators( value );
        return this

    }

    setValueValidators ( value ) {

        this.valueValidators( value );
        return this

    }

    /**
     * Allow to add new key value pair, the key cannot be null, undefined, or an empty string.
     * In case the key already exist, the value will be overwritten if force params is true or this
     * allow overriding else it throw an TypeError.
     *
     * @param key
     * @param value
     * @param force
     */
    add ( key, value, force = false ) {

        if ( this.contain( key ) && ( !this._allowOverride && !force ) ) {
            throw new TypeError( `Item with key (${key}) already exist in collection !` )
        }

        TStore._validate( key, this._keyValidators );
        TStore._validate( value, this._valueValidators );

        this._collection[ key ] = value;

        return this

    }

    contain ( key ) {

        return iteeValidators.isNotUndefined( this._collection[ key ] )

    }

    /**
     * Return the value associated to the key.
     *
     * @param key
     * @returns {*}
     */
    get ( key ) {

        return this._collection[ key ]

    }

    /**
     * Remove to value from the cache. Does nothing if the key does not exist.
     *
     * @param key
     */
    remove ( key ) {

        delete this._collection[ key ];

        return this

    }

    /**
     * Clear the cache and reset collection to an empty object.
     */
    clear () {

        this._collection = {};

        return this

    }

}

/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */

class TAbstractFactory extends TStore {

    constructor ( parameters = {} ) {

        const _parameters = { ...{}, ...parameters };

        super( _parameters );

    }

    // eslint-disable-next-line no-unused-vars
    create ( key, ...parameters ) {

        // Need to be reimplemented

    }

}

/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */

class TCloningFactory extends TAbstractFactory {

    constructor ( parameters = {} ) {

        const _parameters = { ...{}, ...parameters };

        super( _parameters );

    }

    create ( key, ...parameters ) {
        super.create( key, ...parameters );

        return this.get( key ).clone( ...parameters )

    }
}

/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */

class TInstancingFactory extends TAbstractFactory {

    constructor ( parameters = {} ) {

        const _parameters = { ...{}, ...parameters };

        super( _parameters );

    }

    create ( key, ...parameters ) {
        super.create( key, ...parameters );

        return new this.get( key )( ...parameters )

    }

}

/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @class Todo...
 * @classdesc Todo...
 * @example Todo...
 *
 */

/**
 *
 * @type {Object}
 */
const LogOutput = iteeUtils.toEnum( {
    Console:  1,
    Html:     2,
    Toast:    4,
    File:     8,
    Database: 16,
    All:      255
} );

const LogType = iteeUtils.toEnum( {
    Message:  0,
    Progress: 1,
    Time:     2
} );

/**
 *
 * @type {Object}
 */
const LogLevel = iteeUtils.toEnum( {
    None:    0,
    Debug:   1,
    Info:    2,
    Warning: 4,
    Error:   8,
    All:     255
} );

/*
 *  Allow to toast an message or error to user
 *  @level String who represent the gravity level of message between "error | warn (for warning) | other (will display like info message)"
 *  @message String message to display
 */
/**
 *
 * @param outputs
 * @constructor
 */
class TLogger {

    /**
     *
     * @param level
     * @return {string}
     * @private
     */
    static _levelToString ( level ) {

        let levelString = '';

        switch ( level ) {

            case LogLevel.Info:
                levelString = 'info';
                break

            case LogLevel.Warning:
                levelString = 'warning';
                break

            case LogLevel.Error:
                levelString = 'error';
                break

            default:
                levelString = 'unknownLogLevel';
                break

        }

        return levelString

    }

    constructor ( parameters = {} ) {

        const _parameters = {
            ...{
                outputLevel: LogLevel.Error,
                outputs:     LogOutput.Console
            }, ...parameters
        };

        this.outputLevel = _parameters.outputLevel;
        this.outputs     = _parameters.outputs;

        this._logsArray    = [];
        this._timers       = {};
        this._counterTrace = 0;

    }

    get outputLevel () {
        return this._outputLevel
    }

    set outputLevel ( value ) {

        const memberName = 'OutputLevel';
        const expect     = 'Expect a value from LogLevel enum.';

        if ( iteeValidators.isNull( value ) ) { throw new Error( `${memberName} cannot be null ! ${expect}` ) }
        if ( iteeValidators.isUndefined( value ) ) { throw new Error( `${memberName} cannot be undefined ! ${expect}` ) }
        //        if ( !Object.keys( LogLevel ).includes( value ) ) { throw new Error( `${memberName} cannot be an instance of ${value.constructor.name}. ${expect}` ) }

        this._outputLevel = value;

    }

    get outputs () {
        return this._outputs
    }

    set outputs ( value ) {

        const memberName = 'Output';
        const expect     = 'Expect a value from LogOutput enum.';

        if ( iteeValidators.isNull( value ) ) { throw new Error( `${memberName} cannot be null ! ${expect}` ) }
        if ( iteeValidators.isUndefined( value ) ) { throw new Error( `${memberName} cannot be undefined ! ${expect}` ) }
        //        if ( !Object.keys( LogOutput ).includes( value ) ) { throw new Error( `${memberName} cannot be an instance of ${value.constructor.name}. ${expect}` ) }

        this._outputs = value;

    }

    /**
     *
     * @param level
     * @param datas
     * @return {*}
     * @private
     */
    _formatTrace ( level, datas ) {

        const levelString = TLogger._levelToString( level );
        const tmpLevel    = `${levelString}_${this._counterTrace}`;

        if ( iteeValidators.isString( datas ) ) {

            this._logsArray[ tmpLevel ] = datas;

        } else if ( iteeValidators.isObject( datas ) ) {

            this._logsArray[ tmpLevel ] = TLogger._formatObjectError( datas );

        } else if ( iteeValidators.isArrayOfString( datas ) ) {

            this._logsArray[ tmpLevel ] = datas.toString();

        } else if ( iteeValidators.isArrayOfObject( datas ) ) {

            this._logsArray[ tmpLevel ] = '';

            for ( let dataIndex = 0, numberOfDatas = datas.length ; dataIndex < numberOfDatas ; dataIndex++ ) {
                this._formatTrace( level, datas[ dataIndex ] );
            }

        } else {

            this._logsArray[ tmpLevel ] = ( datas ) ? datas.toString() : 'Empty log data !';

        }

        this._counterTrace++;
        return this._logsArray[ tmpLevel ]

    }

    // Todo: Use listener models
    /**
     *
     * @param message
     */
    dispatch ( message ) {

        const type = message.type;
        switch ( type ) {

            case LogType.Message:
                this._dispatchMessage( message );
                break

            case LogType.Progress:
                this._dispatchProgress( message );
                break

            case LogType.Time:
                this._dispatchTime( message );
                break

            default:
                throw new RangeError( `Invalid switch parameter: ${type}` )

        }

    }

    _dispatchMessage ( message ) {

        const level = message.level;
        const data  = message.message;

        // Root message in function of gravity
        switch ( level ) {

            case LogLevel.Error:
                if ( this.outputLevel & LogLevel.Error ) {
                    this._dispatchErrorMessage( data );
                }
                break

            case LogLevel.Warning:
                if ( this.outputLevel & LogLevel.Warning ) {
                    this._dispatchWarningMessage( data );
                }
                break

            case LogLevel.Info:
                if ( this.outputLevel & LogLevel.Info ) {
                    this._dispatchInfoMessage( data );
                }
                break

            case LogLevel.Debug:
                if ( this.outputLevel & LogLevel.Debug ) {
                    this._dispatchDebugMessage( data );
                }
                break

            // For "Debug" output, don't store trace like this !
            default:
                throw new RangeError( `Invalid switch parameter: ${level}` )

        }

    }

    _dispatchErrorMessage ( errorMessage ) {

        if ( this.outputs & LogOutput.Console ) {

            console.error( errorMessage );

        }

        if ( this.outputs & LogOutput.Html ) {

            const span = document.createElement( 'span' );
            span.classList.add( 'log-error' );
            span.innerText = errorMessage;
            document.body.appendChild( span );

        }

        if ( this.outputs & LogOutput.Toast ) ;

        if ( this.outputs & LogOutput.File ) ;

        if ( this.outputs & LogOutput.Database ) ;

    }

    _dispatchWarningMessage ( warnMessage ) {

        if ( this.outputs & LogOutput.Console ) {

            console.warn( warnMessage );

        }

        if ( this.outputs & LogOutput.Html ) {

            const span = document.createElement( 'span' );
            span.classList.add( 'log-warning' );
            span.innerText = warnMessage;
            document.body.appendChild( span );

        }

        if ( this.outputs & LogOutput.Toast ) ;

        if ( this.outputs & LogOutput.File ) ;

        if ( this.outputs & LogOutput.Database ) ;

    }

    _dispatchInfoMessage ( infoMessage ) {

        if ( this.outputs & LogOutput.Console ) {

            console.log( infoMessage );

        }

        if ( this.outputs & LogOutput.Html ) {

            const span = document.createElement( 'span' );
            span.classList.add( 'log-info' );
            span.innerText = infoMessage;
            document.body.appendChild( span );

        }

        if ( this.outputs & LogOutput.Toast ) ;

        if ( this.outputs & LogOutput.File ) ;

        if ( this.outputs & LogOutput.Database ) ;

    }

    _dispatchDebugMessage ( debugMessage ) {

        if ( this.outputs & LogOutput.Console ) {

            console.log( debugMessage );

        }

        if ( this.outputs & LogOutput.Html ) {

            const span = document.createElement( 'span' );
            span.classList.add( 'log-info' );
            span.innerText = debugMessage;
            document.body.appendChild( span );

        }

        if ( this.outputs & LogOutput.Toast ) ;

        if ( this.outputs & LogOutput.File ) ;

        if ( this.outputs & LogOutput.Database ) ;

    }

    _dispatchProgress ( progress ) {

        const level          = progress.level;
        let formattedMessage = progress.message;

        // Root message in function of gravity
        switch ( level ) {

            case LogLevel.Info:
                if ( this.outputLevel & LogLevel.Info ) {
                    this._dispatchInfoProgress( formattedMessage );
                }
                break

            case LogLevel.Debug:
                if ( this.outputLevel & LogLevel.Debug ) {
                    this._dispatchDebugProgress( formattedMessage );
                }
                break

            // For "Debug" output, don't store trace like this !
            default:
                throw new RangeError( `Invalid switch parameter: ${level}` )

        }

    }

    _dispatchInfoProgress ( infoProgress ) {

        if ( this.outputs & LogOutput.Console ) {

            console.log( infoProgress );

        }

        if ( this.outputs & LogOutput.Html ) {

            const span = document.createElement( 'span' );
            span.classList.add( 'log-info' );
            span.innerText = infoProgress;
            document.body.appendChild( span );

        }

        if ( this.outputs & LogOutput.Toast ) ;

        if ( this.outputs & LogOutput.File ) ;

        if ( this.outputs & LogOutput.Database ) ;

    }

    _dispatchDebugProgress ( debugProgress ) {

        if ( this.outputs & LogOutput.Console ) {

            console.log( debugProgress );

        }

        if ( this.outputs & LogOutput.Html ) {

            const span = document.createElement( 'span' );
            span.classList.add( 'log-info' );
            span.innerText = debugProgress;
            document.body.appendChild( span );

        }

        if ( this.outputs & LogOutput.Toast ) ;

        if ( this.outputs & LogOutput.File ) ;

        if ( this.outputs & LogOutput.Database ) ;

    }

    _dispatchTime ( time ) {

        console.log( time.message );

    }

    debug ( debug ) {

        this.dispatch( {
            type:    LogType.Message,
            level:   LogLevel.Debug,
            message: debug
        } );

    }

    /**
     *
     * @param info
     */
    log ( info ) {

        this.dispatch( {
            type:    LogType.Message,
            level:   LogLevel.Info,
            message: info
        } );

    }

    /**
     *
     * @param warning
     */
    warn ( warning ) {

        this.dispatch( {
            type:    LogType.Message,
            level:   LogLevel.Warning,
            message: warning
        } );

    }

    /**
     *
     * @param error
     */
    error ( error ) {

        this.dispatch( {
            type:    LogType.Message,
            level:   LogLevel.Error,
            message: error
        } );

    }

    progress ( progress ) {

        progress.preventDefault();
        if ( progress.cancelable ) {
            progress.stopImmediatePropagation();
        }

        if ( progress.lengthComputable ) {

            const type        = progress.type;
            const loaded      = progress.loaded;
            const total       = progress.total;
            const advancement = Math.round( ( loaded / total ) * 10000 ) / 100;
            const message     = `${type}: ${advancement}% [${loaded}/${total}]`;

            this.dispatch( {
                type:    LogType.Progress,
                level:   LogLevel.Info,
                message: message
            } );

        }

    }

    startChronoFor ( key ) {

        this._timers[ key ] = new Date().getTime();

    }

    stopChronoFor ( key ) {

        const deltaTime = ( new Date().getTime() - this._timers[ key ] );
        const message   = `${key} take ${deltaTime}ms.`;

        this.dispatch( {
            type:    LogType.Time,
            level:   LogLevel.Debug,
            message: message
        } );

    }

    setOutputLevel ( value ) {

        this.outputLevel = value;
        return this

    }

    setOutput ( value ) {

        this.outputs = value;
        return this

    }

}

const DefaultLogger = new TLogger();

/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * based on Lee Stemkoski work
 *
 * @class TFactory
 * @classdesc Todo...
 * @example Todo...
 * (1) create a global variable:
 *      var keyboard = new TKeyboardController();
 * (2) during main loop:
 *       keyboard.update();
 * (3) check state of keys:
 *       keyboard.down("A")    -- true for one update cycle after key is pressed
 *       keyboard.pressed("A") -- true as long as key is being pressed
 *       keyboard.up("A")      -- true for one update cycle after key is released
 *
 *  See TKeyboardController.k object data below for names of keys whose state can be polled
 *
 */

class TKeyboardController {

    /**
     *
     * @param keyCode
     * @return {string}
     */
    static keyName ( keyCode ) {
        return ( TKeyboardController.k[ keyCode ] !== null ) ?
            TKeyboardController.k[ keyCode ] :
            String.fromCharCode( keyCode )
    }

    /**
     *
     * @param event
     */
    static onKeyUp ( event ) {
        var key = TKeyboardController.keyName( event.keyCode );
        if ( TKeyboardController.status[ key ] ) {
            TKeyboardController.status[ key ].pressed = false;
        }
    }

    /**
     *
     * @param event
     */
    static onKeyDown ( event ) {
        var key = TKeyboardController.keyName( event.keyCode );
        if ( !TKeyboardController.status[ key ] ) {
            TKeyboardController.status[ key ] = {
                down:              false,
                pressed:           false,
                up:                false,
                updatedPreviously: false
            };
        }
    }

    constructor ( /*parameters = {}*/ ) {

        /*
         const _parameters = {
         ...{}, ...parameters
         }
         */

        // bind keyEvents
        document.addEventListener( 'keydown', TKeyboardController.onKeyDown, false );
        document.addEventListener( 'keyup', TKeyboardController.onKeyUp, false );

    }

    /**
     *
     */
    update () {
        for ( var key in TKeyboardController.status ) {
            // insure that every keypress has "down" status exactly once
            if ( !TKeyboardController.status[ key ].updatedPreviously ) {
                TKeyboardController.status[ key ].down              = true;
                TKeyboardController.status[ key ].pressed           = true;
                TKeyboardController.status[ key ].updatedPreviously = true;
            } else { // updated previously
                TKeyboardController.status[ key ].down = false;
            }

            // key has been flagged as "up" since last update
            if ( TKeyboardController.status[ key ].up ) {
                delete TKeyboardController.status[ key ];
                continue // move on to next key
            }

            if ( !TKeyboardController.status[ key ].pressed ) // key released
            {
                TKeyboardController.status[ key ].up = true;
            }
        }
    }

    /**
     *
     * @param keyName
     * @return {*}
     */
    down ( keyName ) {
        return ( TKeyboardController.status[ keyName ] && TKeyboardController.status[ keyName ].down )
    }

    /**
     *
     * @param keyName
     * @return {*|pressed|boolean}
     */
    pressed ( keyName ) {
        return ( TKeyboardController.status[ keyName ] && TKeyboardController.status[ keyName ].pressed )
    }

    /**
     *
     * @param keyName
     * @return {*}
     */
    up ( keyName ) {
        return ( TKeyboardController.status[ keyName ] && TKeyboardController.status[ keyName ].up )
    }

    /**
     *
     */
    debug () {
        var list = 'Keys active: ';
        for ( var arg in TKeyboardController.status ) {
            list += ' ' + arg;
        }
        DefaultLogger.log( list );
    }

}

TKeyboardController.k      = Keys;
TKeyboardController.status = {};

/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @class Todo...
 * @classdesc Todo...
 * @example Todo...
 *
 */

/* eslint-env browser */

class TMouseController {

    constructor ( /*parameters = {}*/ ) {

    }

}

/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @class Todo...
 * @classdesc Todo...
 * @example Todo...
 *
 */

/* eslint-env browser */

/**
 *
 * @type {Object}
 */
const Endianness = iteeUtils.toEnum( {
    Little: true,
    Big:    false
} );

/**
 *
 * @type {Object}
 */
const Byte = iteeUtils.toEnum( {
    One:    1,
    Two:    2,
    Four:   4,
    Height: 8
} );

/**
 *
 * @param buffer
 * @param offset
 * @param length
 * @param endianness
 * @constructor
 */

class TBinaryReader {

    constructor ( parameters = {} ) {

        const _parameters = {
            ...{
                buffer:     new ArrayBuffer( 0 ),
                offset:     0,
                length:     0,
                endianness: Endianness.Little
            }, ...parameters
        };

        this.buffer     = _parameters.buffer;
        this.offset     = _parameters.offset;
        this.length     = _parameters.length;
        this.endianness = _parameters.endianness;

        this._updateDataView();

    }

    get buffer () {
        return this._buffer
    }

    set buffer ( value ) {

        const memberName = 'Buffer';
        const expect     = 'Expect an instance of ArrayBuffer.';

        if ( iteeValidators.isNull( value ) ) { throw new TypeError( `${memberName} cannot be null ! ${expect}` ) }
        if ( iteeValidators.isUndefined( value ) ) { throw new TypeError( `${memberName} cannot be undefined ! ${expect}` ) }
        if ( iteeValidators.isNotArrayBuffer ) { throw new TypeError( `${memberName} cannot be an instance of ${value.constructor.name} ! ${expect}` ) }

        this._buffer = value;
        this._offset = 0;
        this._length = value.byteLength;

        this._updateDataView();

    }

    get offset () {
        return this._offset
    }

    set offset ( value ) {

        const memberName = 'Offset';
        const expect     = 'Expect a number.';

        if ( iteeValidators.isNull( value ) ) { throw new TypeError( `${memberName} cannot be null ! ${expect}` ) }
        if ( iteeValidators.isUndefined( value ) ) { throw new TypeError( `${memberName} cannot be undefined ! ${expect}` ) }
        if ( iteeValidators.isNotNumber( value ) ) { throw new TypeError( `${memberName} cannot be an instance of ${value.constructor.name} ! ${expect}` ) }

        this._offset = value;

        this._updateDataView();

    }

    get length () {
        return this._length
    }

    set length ( value ) {

        const memberName = 'Length';
        const expect     = 'Expect a number.';

        if ( iteeValidators.isNull( value ) ) { throw new TypeError( `${memberName} cannot be null ! ${expect}` ) }
        if ( iteeValidators.isUndefined( value ) ) { throw new TypeError( `${memberName} cannot be undefined ! ${expect}` ) }
        if ( iteeValidators.isNotNumber( value ) ) { throw new TypeError( `${memberName} cannot be an instance of ${value.constructor.name} ! ${expect}` ) }

        this._length = value;

        this._updateDataView();

    }

    get endianness () {
        return this._endianness
    }

    set endianness ( value ) {

        const memberName = 'Endianness';
        const expect     = 'Expect a boolean.';

        if ( iteeValidators.isNull( value ) ) { throw new TypeError( `${memberName} cannot be null ! ${expect}` ) }
        if ( iteeValidators.isUndefined( value ) ) { throw new TypeError( `${memberName} cannot be undefined ! ${expect}` ) }
        if ( iteeValidators.isNotBoolean( value ) ) { throw new TypeError( `${memberName} cannot be an instance of ${value.constructor.name} ! ${expect}` ) }

        this._endianness = value;
    }

    /**
     *
     * @param buffer
     * @param offset
     * @param length
     * @return {this}
     */
    setBuffer ( buffer, offset, length ) {

        this.buffer = buffer;
        this.offset = offset || 0;
        this.length = length || buffer.byteLength;

        return this

    }

    setOffset ( value ) {

        this.offset = value;
        return this

    }

    setLength ( value ) {

        this.length = value;
        return this

    }

    /**
     *
     * @param endianess
     * @return {this}
     */
    setEndianess ( endianess ) {

        this.endianness = endianess;
        return this

    }

    /**
     *
     * @param increment
     * @return {*}
     * @private
     */
    _getAndUpdateOffsetBy ( increment ) {

        const currentOffset = this._offset;
        this._offset += increment;
        return currentOffset

    }

    /**
     *
     * @private
     */
    _updateDataView () {

        this._dataView = new DataView( this._buffer, this._offset, this._length );

    }

    /**
     *
     * @return {boolean}
     */
    isEndOfFile () {

        return ( this._offset === this._length )

    }

    /**
     *
     * @param offset
     * @return {this}
     */
    skipOffsetTo ( offset ) {

        this._offset = offset;

        return this

    }

    /**
     *
     * @param nBytes
     * @return {this}
     */
    skipOffsetOf ( nBytes ) {

        this._offset += nBytes;

        return this

    }

    getBoolean () {

        return ( ( this.getUint8() & 1 ) === 1 )

    }

    getBooleanArray ( length ) {

        const array = [];

        for ( let i = 0 ; i < length ; i++ ) {

            array.push( this.getBoolean() );

        }

        return array

    }

    /**
     *
     * @return {number}
     */
    getInt8 () {

        return this._dataView.getInt8( this._getAndUpdateOffsetBy( Byte.One ) )

    }

    getInt8Array ( length ) {

        const array = [];

        for ( let i = 0 ; i < length ; i++ ) {

            array.push( this.getInt8() );

        }

        return array

    }

    /**
     *
     * @return {number}
     */
    getUint8 () {

        return this._dataView.getUint8( this._getAndUpdateOffsetBy( Byte.One ) )

    }

    getUint8Array ( length ) {

        const array = [];

        for ( let i = 0 ; i < length ; i++ ) {

            array.push( this.getUint8() );

        }

        return array

    }

    /**
     *
     * @return {number}
     */
    getInt16 () {

        return this._dataView.getInt16( this._getAndUpdateOffsetBy( Byte.Two ), this._endianness )

    }

    getInt16Array ( length ) {

        const array = [];

        for ( let i = 0 ; i < length ; i++ ) {

            array.push( this.getInt16() );

        }

        return array

    }

    /**
     *
     * @return {number}
     */
    getUint16 () {

        return this._dataView.getUint16( this._getAndUpdateOffsetBy( Byte.Two ), this._endianness )

    }

    getUint16Array ( length ) {

        const array = [];

        for ( let i = 0 ; i < length ; i++ ) {

            array.push( this.getUint16() );

        }

        return array

    }

    /**
     *
     * @return {number}
     */
    getInt32 () {

        return this._dataView.getInt32( this._getAndUpdateOffsetBy( Byte.Four ), this._endianness )

    }

    getInt32Array ( length ) {

        const array = [];

        for ( let i = 0 ; i < length ; i++ ) {

            array.push( this.getInt32() );

        }

        return array

    }

    /**
     *
     * @return {number}
     */
    getUint32 () {

        return this._dataView.getUint32( this._getAndUpdateOffsetBy( Byte.Four ), this._endianness )

    }

    getUint32Array ( length ) {

        const array = [];

        for ( let i = 0 ; i < length ; i++ ) {

            array.push( this.getUint32() );

        }

        return array

    }

    // From THREE.FBXLoader
    // JavaScript doesn't support 64-bit integer so attempting to calculate by ourselves.
    // 1 << 32 will return 1 so using multiply operation instead here.
    // There'd be a possibility that this method returns wrong value if the value
    // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
    // TODO: safely handle 64-bit integer
    getInt64 () {

        let low  = null;
        let high = null;

        if ( this._endianness === Endianness.Little ) {

            low  = this.getUint32();
            high = this.getUint32();

        } else {

            high = this.getUint32();
            low  = this.getUint32();

        }

        // calculate negative value
        if ( high & 0x80000000 ) {

            high = ~high & 0xFFFFFFFF;
            low  = ~low & 0xFFFFFFFF;

            if ( low === 0xFFFFFFFF ) {
                high = ( high + 1 ) & 0xFFFFFFFF;
            }

            low = ( low + 1 ) & 0xFFFFFFFF;

            return -( high * 0x100000000 + low )

        }

        return high * 0x100000000 + low

    }

    getInt64Array ( length ) {

        const array = [];

        for ( let i = 0 ; i < length ; i++ ) {

            array.push( this.getInt64() );

        }

        return array

    }

    // Note: see getInt64() comment
    getUint64 () {

        let low  = null;
        let high = null;

        if ( this._endianness === Endianness.Little ) {

            low  = this.getUint32();
            high = this.getUint32();

        } else {

            high = this.getUint32();
            low  = this.getUint32();

        }

        return high * 0x100000000 + low

    }

    getUint64Array ( length ) {

        const array = [];

        for ( let i = 0 ; i < length ; i++ ) {

            array.push( this.getUint64() );

        }

        return array

    }

    /**
     *
     * @return {number}
     */
    getFloat32 () {

        return this._dataView.getFloat32( this._getAndUpdateOffsetBy( Byte.Four ), this._endianness )

    }

    getFloat32Array ( length ) {

        const array = [];

        for ( let i = 0 ; i < length ; i++ ) {

            array.push( this.getFloat32() );

        }

        return array

    }

    /**
     *
     * @return {number}
     */
    getFloat64 () {

        return this._dataView.getFloat64( this._getAndUpdateOffsetBy( Byte.Height ), this._endianness )

    }

    getFloat64Array ( length ) {

        const array = [];

        for ( let i = 0 ; i < length ; i++ ) {

            array.push( this.getFloat64() );

        }

        return array

    }

    /**
     *
     * @return {string}
     */
    getChar () {

        return String.fromCharCode( this.getUint8() )

    }

    /**
     *
     * @param length
     * @param trim
     * @return {string}
     */
    getString ( length, trim = true ) {

        let string   = '';
        let charCode = null;

        for ( let i = 0 ; i < length ; i++ ) {
            charCode = this.getUint8();

            if ( charCode === 0 ) {
                continue
            }

            string += String.fromCharCode( charCode );
        }

        if ( trim ) {
            string = string.trim();
        }

        return string

    }

    getArrayBuffer ( size ) {

        const offset = this._getAndUpdateOffsetBy( size );
        return this._dataView.buffer.slice( offset, offset + size )

    }

}

/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @class TDataBaseManager
 * @classdesc The base class of database managers. Give the basic interface about database call.
 *
 * @requires {@link HttpVerb}
 * @requires {@link ResponseType}
 * @requires {@link HttpStatusCode}
 * @requires {@link TOrchestrator}
 * @requires {@link TStore}
 *
 * @example Todo
 *
 */

class IdGenerator {

    constructor () {
        this._id = 0;
    }

    get id () {
        this._id += 1;
        return this._id
    }

}

const Generate = new IdGenerator();

const RequestType = iteeUtils.toEnum( {
    CreateOne:   0,
    CreateMany:  1,
    ReadOne:     2,
    ReadMany:    3,
    ReadWhere:   4,
    ReadAll:     5,
    UpdateOne:   6,
    UpdateMany:  7,
    UpdateWhere: 8,
    UpdateAll:   9,
    DeleteOne:   10,
    DeleteMany:  11,
    DeleteWhere: 12,
    DeleteAll:   13
} );

class TDataBaseManager {

    static get requestId () {
        TDataBaseManager._requestId++;
        return TDataBaseManager._requestId
    }

    /**
     *
     * @param parameters
     */
    constructor ( parameters = {} ) {

        const _parameters = {
            ...{
                basePath:               '/',
                responseType:           ResponseType.Json,
                bunchSize:              500,
                requestAggregationTime: 200,
                requestsConcurrency:    6,
                logger:                 DefaultLogger
            }, ...parameters
        };

        this.basePath               = _parameters.basePath;
        this.responseType           = _parameters.responseType;
        this.bunchSize              = _parameters.bunchSize;
        this.requestAggregationTime = _parameters.requestAggregationTime;
        this.requestsConcurrency    = _parameters.requestsConcurrency;
        this.logger                 = _parameters.logger;

        this._cache                = new TStore();
        this._waitingQueue         = [];
        this._aggregateQueue       = [];
        this._requestQueue         = [];
        this._processQueue         = [];
        this._aggregationTimeoutId = null;

        this._idToRequest = [];

    }

    get basePath () {
        return this._basePath
    }

    set basePath ( value ) {

        if ( iteeValidators.isNull( value ) ) { throw new TypeError( 'Base path cannot be null ! Expect a non empty string.' ) }
        if ( iteeValidators.isUndefined( value ) ) { throw new TypeError( 'Base path cannot be undefined ! Expect a non empty string.' ) }
        if ( iteeValidators.isNotString( value ) ) { throw new TypeError( `Base path cannot be an instance of ${value.constructor.name} ! Expect a non empty string.` ) }
        if ( iteeValidators.isEmptyString( value ) ) { throw new TypeError( 'Base path cannot be empty ! Expect a non empty string.' ) }
        if ( iteeValidators.isBlankString( value ) ) { throw new TypeError( 'Base path cannot contain only whitespace ! Expect a non empty string.' ) }

        this._basePath = value;

    }

    get responseType () {
        return this._responseType
    }

    set responseType ( value ) {

        if ( iteeValidators.isNull( value ) ) { throw new Error( 'TDataBaseManager: responseType cannot be null !' ) }
        if ( iteeValidators.isNull( value ) ) { throw new TypeError( 'Response type cannot be null ! Expect a non empty string.' ) }
        if ( iteeValidators.isUndefined( value ) ) { throw new TypeError( 'Response type cannot be undefined ! Expect a non empty string.' ) }
        if ( !( value instanceof ResponseType ) ) { throw new TypeError( `Response type cannot be an instance of ${value.constructor.name} ! Expect a value from ResponseType enum.` ) }

        this._responseType = value;

    }

    get bunchSize () {
        return this._bunchSize
    }

    set bunchSize ( value ) {

        if ( iteeValidators.isNull( value ) ) { throw new TypeError( 'Bunch size cannot be null ! Expect a positive number.' ) }
        if ( iteeValidators.isUndefined( value ) ) { throw new TypeError( 'Bunch size cannot be undefined ! Expect a positive number.' ) }
        if ( iteeValidators.isNotNumber( value ) ) { throw new TypeError( `Bunch size cannot be an instance of ${value.constructor.name} ! Expect a positive number.` ) }
        if ( !iteeValidators.isNumberPositive( value ) ) { throw new TypeError( `Bunch size cannot be lower or equal to zero ! Expect a positive number.` ) }

        this._bunchSize = value;

    }

    get requestAggregationTime () {
        return this._requestAggregationTime
    }

    set requestAggregationTime ( value ) {

        if ( iteeValidators.isNull( value ) ) {
            throw new TypeError( 'Requests aggregation time cannot be null ! Expect a positive number.' )
        }

        if ( iteeValidators.isUndefined( value ) ) {
            throw new TypeError( 'Requests aggregation time cannot be undefined ! Expect a positive number.' )
        }

        if ( iteeValidators.isNotNumber( value ) ) {
            throw new TypeError( `Requests aggregation time cannot be an instance of ${value.constructor.name} ! Expect a positive number.` )
        }

        if ( iteeValidators.isNumberNegative( value ) ) {
            throw new TypeError( 'Requests aggregation time cannot be lower or equal to zero ! Expect a positive number.' )
        }

        this._requestAggregationTime = value;

    }

    get requestsConcurrency () {
        return this._requestsConcurrency
    }

    set requestsConcurrency ( value ) {

        if ( iteeValidators.isNull( value ) ) {
            throw new TypeError( 'Minimum of simultaneous request cannot be null ! Expect a positive number.' )
        }

        if ( iteeValidators.isUndefined( value ) ) {
            throw new TypeError( 'Minimum of simultaneous request cannot be undefined ! Expect a positive number.' )
        }

        if ( iteeValidators.isNotNumber( value ) ) {
            throw new TypeError( `Minimum of simultaneous request cannot be an instance of ${value.constructor.name} ! Expect a positive number.` )
        }

        if ( iteeValidators.isZero( value ) || iteeValidators.isNumberNegative( value ) ) {
            throw new TypeError( 'Minimum of simultaneous request cannot be lower or equal to zero ! Expect a positive number.' )
        }

        this._requestsConcurrency = value;

    }

    get logger () {
        return this._logger
    }

    set logger ( value ) {

        if ( iteeValidators.isNull( value ) ) { throw new TypeError( 'Progress manager cannot be null ! Expect an instance of TProgressManager.' ) }
        if ( iteeValidators.isUndefined( value ) ) { throw new TypeError( 'Progress manager cannot be undefined ! Expect an instance of TProgressManager.' ) }
        if ( !( value instanceof TLogger ) ) { throw new TypeError( `Progress manager cannot be an instance of ${value.constructor.name} ! Expect an instance of TProgressManager.` ) }

        this._logger = value;

    }

    setBasePath ( value ) {

        this.basePath = value;
        return this

    }

    setResponseType ( value ) {

        this.responseType = value;
        return this

    }

    setBunchSize ( value ) {

        this.bunchSize = value;
        return this

    }

    setRequestAggregationTime ( value ) {

        this.requestAggregationTime = value;
        return this

    }

    setRequestsConcurrency ( value ) {

        this.requestsConcurrency = value;
        return this

    }

    setLogger ( value ) {

        this.logger = value;
        return this

    }

    aggregateQueue () {

        clearTimeout( this._aggregationTimeoutId );

        this._aggregationTimeoutId = setTimeout( () => {

            const datasToRequest = this._idToRequest;
            let idBunch          = [];
            for ( let idIndex = datasToRequest.length - 1 ; idIndex >= 0 ; idIndex-- ) {

                idBunch.push( datasToRequest.pop() );

                if ( idBunch.length === this._bunchSize || idIndex === 0 ) {

                    this._requestQueue.push( {
                        _id:        `readMany_${Generate.id}`,
                        _timeStart: new Date(),
                        _type:      RequestType.ReadMany,
                        method:     HttpVerb.Read.value,
                        url:        this._basePath,
                        data:       {
                            ids: idBunch
                        },
                        responseType: this._responseType
                    } );

                    idBunch = [];
                }

            }

            this.processQueue.call( this );

        }, this._requestAggregationTime );

    }

    processQueue () {

        while ( this._requestQueue.length > 0 && this._processQueue.length < this._requestsConcurrency ) {

            const requestSkull = this._requestQueue.pop();
            this._processQueue.push( requestSkull );

            const request              = new XMLHttpRequest();
            request.onloadstart        = _onLoadStart.bind( this );
            request.onload             = this._onLoad.bind( this,
                requestSkull,
                this._onEnd.bind( this, requestSkull, requestSkull.onLoad ),
                this._onProgress.bind( this, requestSkull.onProgress ),
                this._onError.bind( this, requestSkull, requestSkull.onError )
            );
            request.onloadend          = _onLoadEnd.bind( this );
            request.onprogress         = this._onProgress.bind( this, requestSkull.onProgress );
            request.onreadystatechange = _onReadyStateChange.bind( this );
            request.onabort            = _onAbort.bind( this );
            request.onerror            = this._onError.bind( this, requestSkull, requestSkull.onError );
            request.ontimeout          = _onTimeout.bind( this );
            request.open( requestSkull.method, requestSkull.url, true );
            request.setRequestHeader( 'Content-Type', 'application/json' );
            request.setRequestHeader( 'Accept', 'application/json' );
            request.responseType = requestSkull.responseType.value;

            const dataToSend = ( requestSkull.data && requestSkull.responseType === ResponseType.Json ) ? JSON.stringify( requestSkull.data ) : requestSkull.data;
            request.send( dataToSend );

        }

        function _onLoadStart ( loadStartEvent ) { this.logger.progress( loadStartEvent ); }

        function _onLoadEnd ( loadEndEvent ) { this.logger.progress( loadEndEvent ); }

        function _onReadyStateChange ( readyStateEvent ) { this.logger.debug( readyStateEvent ); }

        function _onAbort ( abortEvent ) { this.logger.error( abortEvent ); }

        function _onTimeout ( timeoutEvent ) { this.logger.error( timeoutEvent ); }

    }

    // Publics
    /**
     * @function
     * @memberOf TDataBaseManager.prototype
     * @description The create method allow to create a new ressource on the server. Providing a single object that match a database schema, or an array of them.
     *
     * @param {object|array.<object>} data - The data to send for create new objects.
     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
     */
    create ( data, onLoadCallback, onProgressCallback, onErrorCallback ) {

        if ( iteeValidators.isArray( data ) && iteeValidators.isNotEmptyArray( data ) ) {

            if ( iteeValidators.isArrayOfSingleElement( data ) ) {

                this._createOne( data[ 0 ], onLoadCallback, onProgressCallback, onErrorCallback );

            } else {

                this._createMany( data, onLoadCallback, onProgressCallback, onErrorCallback );

            }

        } else if ( iteeValidators.isObject( data ) && iteeValidators.isNotEmptyObject( data ) ) {

            this._createOne( data, onLoadCallback, onProgressCallback, onErrorCallback );

        } else {

            onErrorCallback( 'TDataBaseManager.create: Invalid data type, expect object or array of objects.' );

        }

    }

    /**
     * @function
     * @memberOf TDataBaseManager.prototype
     * @description The read method allow to retrieve data from the server, using a single id or an array of them.
     *
     * @param {string|array.<string>} condition - The ids of objects to retrieve.
     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
     */
    read ( condition, projection, onLoadCallback, onProgressCallback, onErrorCallback ) {

        if ( iteeValidators.isString( condition ) && iteeValidators.isNotEmptyString( condition ) && iteeValidators.isNotBlankString( condition ) ) {

            this._readOne( condition, projection, onLoadCallback, onProgressCallback, onErrorCallback );

        } else if ( iteeValidators.isArray( condition ) && iteeValidators.isNotEmptyArray( condition ) ) {

            if ( iteeValidators.isArrayOfSingleElement( condition ) ) {

                this._readOne( condition[ 0 ], projection, onLoadCallback, onProgressCallback, onErrorCallback );

            } else {

                this._readMany( condition, projection, onLoadCallback, onProgressCallback, onErrorCallback );

            }

        } else if ( iteeValidators.isObject( condition ) ) {

            if ( iteeValidators.isEmptyObject( condition ) ) {

                this._readAll( projection, onLoadCallback, onProgressCallback, onErrorCallback );

            } else {

                this._readWhere( condition, projection, onLoadCallback, onProgressCallback, onErrorCallback );

            }

        } else {

            onErrorCallback( 'TDataBaseManager.read: Invalid data type, expect string, object or array of objects.' );

        }

    }

    /**
     * @function
     * @memberOf TDataBaseManager.prototype
     * @description The update method allow to update data on the server, using a single id or an array of them, and a corresponding object about the data to update.
     *
     * @param {string|array.<string>} condition - The ids of objects to update.
     * @param {object} update - The update data ( need to match the related database schema ! ). In case of multiple ids they will be updated with the same given data.
     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
     */
    update ( condition, update, onLoadCallback, onProgressCallback, onErrorCallback ) {

        if ( iteeValidators.isNotDefined( update ) ) {
            onErrorCallback( 'TDataBaseManager.update: Update data cannot be null or undefined !' );
            return
        }

        if ( iteeValidators.isNotObject( update ) ) {
            onErrorCallback( 'TDataBaseManager.update: Invalid update data type. Expect an object.' );
            return
        }

        if ( iteeValidators.isString( condition ) && iteeValidators.isNotEmptyString( condition ) && iteeValidators.isNotBlankString( condition ) ) {

            this._updateOne( condition, update, onLoadCallback, onProgressCallback, onErrorCallback );

        } else if ( iteeValidators.isArray( condition ) && iteeValidators.isNotEmptyArray( condition ) ) {

            if ( iteeValidators.isArrayOfSingleElement( condition ) ) {

                this._updateOne( condition[ 0 ], update, onLoadCallback, onProgressCallback, onErrorCallback );

            } else {

                this._updateMany( condition, update, onLoadCallback, onProgressCallback, onErrorCallback );

            }

        } else if ( iteeValidators.isObject( condition ) ) {

            if ( iteeValidators.isEmptyObject( condition ) ) {

                this._updateAll( update, onLoadCallback, onProgressCallback, onErrorCallback );

            } else {

                this._updateWhere( condition, update, onLoadCallback, onProgressCallback, onErrorCallback );

            }

        } else {

            onErrorCallback( 'TDataBaseManager.update: Invalid data type, expect string, object or array of objects.' );

        }

    }

    /**
     * @function
     * @memberOf TDataBaseManager.prototype
     * @description The delete method allow to remove data from the server, using a single id or an array of them.
     *
     * @param {string|array.<string>|object|null} condition - The ids of objects to delete.
     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
     */
    delete ( condition, onLoadCallback, onProgressCallback, onErrorCallback ) {

        if ( iteeValidators.isString( condition ) && iteeValidators.isNotEmptyString( condition ) && iteeValidators.isNotBlankString( condition ) ) {

            this._deleteOne( condition, onLoadCallback, onProgressCallback, onErrorCallback );

        } else if ( iteeValidators.isArray( condition ) && iteeValidators.isNotEmptyArray( condition ) ) {

            if ( iteeValidators.isArrayOfSingleElement( condition ) ) {

                this._deleteOne( condition[ 0 ], onLoadCallback, onProgressCallback, onErrorCallback );

            } else {

                this._deleteMany( condition, onLoadCallback, onProgressCallback, onErrorCallback );

            }

        } else if ( iteeValidators.isObject( condition ) ) {

            if ( iteeValidators.isEmptyObject( condition ) ) {

                this._deleteAll( onLoadCallback, onProgressCallback, onErrorCallback );

            } else {

                this._deleteWhere( condition, onLoadCallback, onProgressCallback, onErrorCallback );

            }

        } else {

            onErrorCallback( 'TDataBaseManager.delete: Invalid data type, expect null, string, object or array of objects.' );

        }

    }

    // Privates

    //// Events

    /**
     * @private
     * @function
     * @memberOf TDataBaseManager.prototype
     * @description The private _onLoad method allow to process the server response in an abstract way to check against error and wrong status code.
     * It will bind user callback on each type of returns, and dispatch in sub methods in function of the response type.
     *
     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
     * @param {object} loadEvent - The server response object to parse.
     */
    _onLoad ( request, onLoadCallback, onProgressCallback, onErrorCallback, loadEvent ) {

        const target       = loadEvent.target;
        const status       = target.status;
        const response     = target.response;
        const responseType = target.responseType;

        switch ( status ) {

            // 100
            //            case HttpStatusCode.Continue.value:
            //            case HttpStatusCode.SwitchingProtocols.value:
            //            case HttpStatusCode.Processing.value:

            // 200
            case HttpStatusCode.Ok.value:
                this._dispatchResponse( response, responseType, onLoadCallback, onProgressCallback, onErrorCallback );
                break
            //            case HttpStatusCode.Created.value:
            //            case HttpStatusCode.Accepted.value:

            case HttpStatusCode.NonAuthoritativeInformation.value:
            case HttpStatusCode.NoContent.value:
            case HttpStatusCode.ResetContent.value:
            case HttpStatusCode.PartialContent.value:
            case HttpStatusCode.MultiStatus.value:
            case HttpStatusCode.AlreadyReported.value:
            case HttpStatusCode.ContentDifferent.value:
            case HttpStatusCode.IMUsed.value:
            case HttpStatusCode.MultipleChoices.value:
            case HttpStatusCode.MovedPermanently.value:
            case HttpStatusCode.Found.value:
            case HttpStatusCode.SeeOther.value:
            case HttpStatusCode.NotModified.value:
            case HttpStatusCode.UseProxy.value:
            case HttpStatusCode.Unused.value:
            case HttpStatusCode.TemporaryRedirect.value:
            case HttpStatusCode.PermanentRedirect.value:
            case HttpStatusCode.TooManyRedirects.value:
            case HttpStatusCode.BadRequest.value:
            case HttpStatusCode.Unauthorized.value:
            case HttpStatusCode.PaymentRequired.value:
            case HttpStatusCode.Forbidden.value:
            case HttpStatusCode.NotFound.value:
            case HttpStatusCode.MethodNotAllowed.value:
            case HttpStatusCode.NotAcceptable.value:
            case HttpStatusCode.ProxyAuthenticationRequired.value:
            case HttpStatusCode.RequestTimeOut.value:
            case HttpStatusCode.Conflict.value:
            case HttpStatusCode.Gone.value:
            case HttpStatusCode.LengthRequired.value:
            case HttpStatusCode.PreconditionFailed.value:
            case HttpStatusCode.RequestEntityTooLarge.value:
            case HttpStatusCode.RequestRangeUnsatisfiable.value:
            case HttpStatusCode.ExpectationFailed.value:
            case HttpStatusCode.ImATeapot.value:
            case HttpStatusCode.BadMapping.value:
            case HttpStatusCode.UnprocessableEntity.value:
            case HttpStatusCode.Locked.value:
            case HttpStatusCode.MethodFailure.value:
            case HttpStatusCode.UnorderedCollection.value:
            case HttpStatusCode.UpgradeRequired.value:
            case HttpStatusCode.PreconditionRequired.value:
            case HttpStatusCode.TooManyRequests.value:
            case HttpStatusCode.RequestHeaderFieldsTooLarge.value:
            case HttpStatusCode.NoResponse.value:
            case HttpStatusCode.RetryWith.value:
            case HttpStatusCode.BlockedByWindowsParentalControls.value:
            case HttpStatusCode.UnavailableForLegalReasons.value:
            case HttpStatusCode.UnrecoverableError.value:
            case HttpStatusCode.SSLCertificateError.value:
            case HttpStatusCode.SSLCertificateRequired.value:
            case HttpStatusCode.HTTPRequestSentToHTTPSPort.value:
            case HttpStatusCode.ClientClosedRequest.value:
            case HttpStatusCode.InternalServerError.value:
            case HttpStatusCode.NotImplemented.value:
            case HttpStatusCode.BadGateway.value:
            case HttpStatusCode.ServiceUnavailable.value:
            case HttpStatusCode.GatewayTimeOut.value:
            case HttpStatusCode.HTTPVersionNotSupported.value:
            case HttpStatusCode.VariantAlsoNegotiates.value:
            case HttpStatusCode.InsufficientStorage.value:
            case HttpStatusCode.LoopDetected.value:
            case HttpStatusCode.BandwidthLimitExceeded.value:
            case HttpStatusCode.NotExtended.value:
            case HttpStatusCode.NetworkAuthenticationRequired.value:
            case HttpStatusCode.UnknownError.value:
            case HttpStatusCode.WebServerIsDown.value:
            case HttpStatusCode.ConnectionTimedOut.value:
            case HttpStatusCode.OriginIsUnreachable.value:
            case HttpStatusCode.ATimeoutOccured.value:
            case HttpStatusCode.SSLHandshakeFailed.value:
            case HttpStatusCode.InvalidSSLCertificate.value:
            case HttpStatusCode.RailgunError.value:
                onErrorCallback( response );
                break

            default:
                throw new RangeError( `Unmanaged HttpStatusCode: ${status}` )

        }

    }

    /**
     * @private
     * @function
     * @memberOf TDataBaseManager.prototype
     * @description The private _onProgress method will handle all progress event from server and submit them to the logger if exist else to the user onProgressCallback
     *
     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
     * @param {object} progressEvent - The server progress event.
     */
    _onProgress ( onProgressCallback, progressEvent ) {

        if ( iteeValidators.isDefined( this.logger ) ) {

            this.logger.progress( progressEvent, onProgressCallback );

        } else if ( iteeValidators.isDefined( onProgressCallback ) ) {

            onProgressCallback( progressEvent );

        }

    }

    /**
     * @private
     * @function
     * @memberOf TDataBaseManager.prototype
     * @description The private _onError method will handle all error event from server and submit them to the logger if exist else to the user onErrorCallback
     *
     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
     * @param {object} errorEvent - A server error event
     */
    _onError ( request, onErrorCallback, errorEvent ) {

        this._closeRequest( request );

        if ( iteeValidators.isDefined( this.logger ) ) {

            this.logger.error( errorEvent, onErrorCallback );

        } else if ( iteeValidators.isDefined( onErrorCallback ) ) {

            onErrorCallback( errorEvent );

        }

    }

    _onEnd ( request, onLoadCallback, response ) {

        const type = request._type;

        switch ( type ) {

            case RequestType.ReadOne:
            case RequestType.ReadMany:
                this._updateCache( response );
                this._updateWaitingQueue();
                break

            case RequestType.ReadWhere:
            case RequestType.ReadAll:
                this._updateCache( response );
                this._updateWaitingQueue();
                onLoadCallback( response );
                break

            case RequestType.CreateOne:
            case RequestType.CreateMany:
            case RequestType.UpdateOne:
            case RequestType.UpdateMany:
            case RequestType.UpdateWhere:
            case RequestType.UpdateAll:
            case RequestType.DeleteOne:
            case RequestType.DeleteMany:
            case RequestType.DeleteWhere:
            case RequestType.DeleteAll:
                onLoadCallback( response );
                break

            default:
                throw new RangeError( `Invalid request type: ${type}` )

        }

        this._closeRequest( request );

    }

    //// Data parsing
    // Expect that methods were reimplemented when TDataBaseManager is inherited

    // Dispatch response to the correct handler in function of response type
    _dispatchResponse ( response, responseType, onLoadCallback, onProgressCallback, onErrorCallback ) {

        switch ( responseType ) {

            case ResponseType.ArrayBuffer.value:
                this._onArrayBuffer(
                    response,
                    onLoadCallback,
                    onProgressCallback,
                    onErrorCallback
                );
                break

            case ResponseType.Blob.value:
                this._onBlob(
                    response,
                    onLoadCallback,
                    onProgressCallback,
                    onErrorCallback
                );
                break

            case ResponseType.Json.value:
                this._onJson(
                    response,
                    onLoadCallback,
                    onProgressCallback,
                    onErrorCallback
                );
                break

            case ResponseType.DOMString.value:
            case ResponseType.Default.value:
                this._onText(
                    response,
                    onLoadCallback,
                    onProgressCallback,
                    onErrorCallback
                );
                break

            default:
                throw new Error( `Unknown response type: ${responseType}` )

        }

    }

    /**
     * Will remove the request from the process queue
     * @param request
     * @private
     */
    _closeRequest ( request ) {

        this._processQueue.splice( this._processQueue.indexOf( request ), 1 );

        if ( Window.Itee && Window.Itee.Debug ) {

            const diff    = new Date().valueOf() - request._timeStart.valueOf();
            const message = `${this.constructor.name} close request [${request._id}] on ${diff}ms.` +
                `Waiting queue: ${this._waitingQueue.length}` +
                `Request queue: ${this._requestQueue.length}` +
                `Process queue: ${this._processQueue.length}` +
                `==========================`;
            this.logger.debug( message );

        }

        this.processQueue();

    }

    _retrieveCachedValues ( ids ) {

        let results      = {};
        let underRequest = [];
        let toRequest    = [];

        for ( let idIndex = 0, numberOfIds = ids.length ; idIndex < numberOfIds ; idIndex++ ) {

            const id          = ids[ idIndex ];
            const cachedValue = this._cache.get( id );

            if ( iteeValidators.isDefined( cachedValue ) ) {
                results[ id ] = cachedValue;
            } else if ( iteeValidators.isNull( cachedValue ) ) { // In request
                underRequest.push( id );
            } else {
                toRequest.push( id );
            }

        }

        return {
            results,
            underRequest,
            toRequest
        }

    }

    _updateCache ( datas ) {

        if ( iteeValidators.isNull( datas ) ) { throw new TypeError( 'Data cannot be null ! Expect an array of object.' ) }
        if ( iteeValidators.isUndefined( datas ) ) { throw new TypeError( 'Data cannot be undefined ! Expect an array of object.' ) }

        let _datas = {};
        if ( iteeValidators.isArray( datas ) ) {

            for ( let key in datas ) {
                _datas[ datas[ key ]._id ] = datas[ key ];
            }

        } else {

            _datas = datas;

        }

        for ( let [ id, data ] of Object.entries( _datas ) ) {

            const cachedResult = this._cache.get( id );

            if ( iteeValidators.isNull( cachedResult ) ) {
                this._cache.add( id, data, true );
            } else if ( iteeValidators.isUndefined( cachedResult ) ) {
                this.logger.warn( 'Cache was not pre-allocated with null value.' );
                this._cache.add( id, data );
            } else {
                this.logger.error( 'Cached value already exist !' );
            }

        }

    }

    _updateWaitingQueue () {

        const haveNoRequestToProcess = ( this._requestQueue.length === 0 && this._processQueue.length === 0 );

        for ( let requestIndex = this._waitingQueue.length - 1 ; requestIndex >= 0 ; requestIndex-- ) {

            const demand = this._waitingQueue[ requestIndex ];

            // Update requested datas
            for ( let dataIndex = demand.underRequest.length - 1 ; dataIndex >= 0 ; dataIndex-- ) {

                const id           = demand.underRequest[ dataIndex ];
                const cachedResult = this._cache.get( id );

                if ( iteeValidators.isNotDefined( cachedResult ) ) { continue }

                // Assign the cached value
                demand.results[ id ] = cachedResult;

                // Remove the requested object that is now added
                demand.underRequest.splice( demand.underRequest.indexOf( id ), 1 );

            }

            // Check if request is now fullfilled
            const demandIsComplet = ( demand.underRequest.length === 0 );
            if ( demandIsComplet ) {

                this._waitingQueue.splice( requestIndex, 1 );
                demand.onLoadCallback( demand.results );

            } else if ( !demandIsComplet && haveNoRequestToProcess /* && haveTryAgainManyTimesButFail */ ) {

                this.logger.warn( 'Incomplet demand but empty request/process queue' );
                this._waitingQueue.splice( requestIndex, 1 );
                demand.onLoadCallback( demand.results );

            }

        }

    }

    /**
     * @private
     * @abstract
     * @function
     * @memberOf TDataBaseManager.prototype
     * @description The abstract private _onArrayBuffer method must be overridden in case the parser expect an array buffer as input data.
     *
     * @param {ArrayBuffer} data - The retrieved data to parse.
     * @param {function} onSuccess - The onLoad callback, which is call when parser parse with success the data.
     * @param {function} onProgress - The onProgress callback, which is call during the parsing.
     * @param {function} onError - The onError callback, which is call when parser throw an error during parsing.
     */
    // eslint-disable-next-line no-unused-vars
    _onArrayBuffer ( data, onSuccess, onProgress, onError ) {}

    /**
     * @private
     * @abstract
     * @function
     * @memberOf TDataBaseManager.prototype
     * @description The abstract private _onBlob method must be overridden in case the parser expect a blob as input data.
     *
     * @param {Blob} data - The retrieved data to parse.
     * @param {function} onSuccess - The onLoad callback, which is call when parser parse with success the data.
     * @param {function} onProgress - The onProgress callback, which is call during the parsing.
     * @param {function} onError - The onError callback, which is call when parser throw an error during parsing.
     */
    // eslint-disable-next-line no-unused-vars
    _onBlob ( data, onSuccess, onProgress, onError ) {}

    /**
     * @private
     * @abstract
     * @function
     * @memberOf TDataBaseManager.prototype
     * @description The abstract private _onJson method must be overridden in case the parser expect json as input data.
     *
     * @param {json} data - The retrieved data to parse.
     * @param {function} onSuccess - The onLoad callback, which is call when parser parse with success the data.
     * @param {function} onProgress - The onProgress callback, which is call during the parsing.
     * @param {function} onError - The onError callback, which is call when parser throw an error during parsing.
     */
    // eslint-disable-next-line no-unused-vars
    _onJson ( data, onSuccess, onProgress, onError ) {}

    /**
     * @private
     * @abstract
     * @function
     * @memberOf TDataBaseManager.prototype
     * @description The abstract private _onText method must be overridden in case the parser expect a string/text as input data.
     *
     * @param {string} data - The retrieved data to parse.
     * @param {function} onSuccess - The onLoad callback, which is call when parser parse with success the data.
     * @param {function} onProgress - The onProgress callback, which is call during the parsing.
     * @param {function} onError - The onError callback, which is call when parser throw an error during parsing.
     */
    // eslint-disable-next-line no-unused-vars
    _onText ( data, onSuccess, onProgress, onError ) {}

    // REST Api calls
    /**
     * @private
     * @function
     * @memberOf TDataBaseManager.prototype
     * @description The private _create method allow to format a server request to create objects with the given data and get creation result with given callbacks.
     *
     * @param {object} data - The data to send.
     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
     */
    _createOne ( data, onLoadCallback, onProgressCallback, onErrorCallback ) {

        this._requestQueue.push( {
            _id:          `createOne_${Generate.id}`,
            _timeStart:   new Date(),
            _type:        RequestType.CreateOne,
            method:       HttpVerb.Create.value,
            url:          this._basePath,
            data:         data,
            onLoad:       onLoadCallback,
            onProgress:   onProgressCallback,
            onError:      onErrorCallback,
            responseType: this._responseType
        } );

        this.processQueue();

    }

    _createMany ( datas, onLoadCallback, onProgressCallback, onErrorCallback ) {

        this._requestQueue.push( {
            _id:          `createMany_${Generate.id}`,
            _timeStart:   new Date(),
            _type:        RequestType.CreateMany,
            method:       HttpVerb.Create.value,
            url:          this._basePath,
            data:         datas,
            onLoad:       onLoadCallback,
            onProgress:   onProgressCallback,
            onError:      onErrorCallback,
            responseType: this._responseType
        } );

        this.processQueue();

    }

    /**
     * @private
     * @function
     * @memberOf TDataBaseManager.prototype
     * @description The private _updateOne method will format a server request to get a single object with the given id.
     *
     * @param {string} id - The object's id of the object to retrieve.
     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
     */
    _readOne ( id, projection, onLoadCallback, onProgressCallback, onErrorCallback ) {

        // Filter requested values by cached values
        const datas = this._retrieveCachedValues( [ id ] );

        // retrieveLocalStorageValues...

        // getDatabaseValues()

        if ( datas.toRequest.length === 0 ) {

            if ( datas.underRequest.length === 0 ) {

                onLoadCallback( datas.results );

            } else {

                datas[ 'onLoadCallback' ] = onLoadCallback;
                datas[ 'onProgressCallback' ] = onProgressCallback;
                datas[ 'onErrorCallback' ] = onErrorCallback;
                this._waitingQueue.push( datas );

            }

        } else {

            datas[ 'onLoadCallback' ] = onLoadCallback;
            datas[ 'onProgressCallback' ] = onProgressCallback;
            datas[ 'onErrorCallback' ] = onErrorCallback;
            this._waitingQueue.push( datas );

            try {
                this._cache.add( id, null );
                datas.underRequest.push( id );
                datas.toRequest.splice( datas.toRequest.indexOf( id ), 1 );
            } catch ( error ) {
                this.logger.error( error );
            }

            this._idToRequest.push( id );
            this.aggregateQueue();

        }

    }

    /**
     * @private
     * @function
     * @memberOf TDataBaseManager.prototype
     * @description The private _readMany method will format a server request to get objects with id in the ids array.
     *
     * @param {array.<string>} ids - The ids of objects to retrieve.
     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
     */
    _readMany ( ids, projection, onLoadCallback, onProgressCallback, onErrorCallback ) {

        // Filter requested values by cached values
        const datas = this._retrieveCachedValues( ids );

        // retrieveLocalStorageValues...

        // getDatabaseValues()

        if ( datas.toRequest.length === 0 ) {

            if ( datas.underRequest.length === 0 ) {

                onLoadCallback( datas.results );

            } else {

                datas[ 'onLoadCallback' ] = onLoadCallback;
                datas[ 'onProgressCallback' ] = onProgressCallback;
                datas[ 'onErrorCallback' ] = onErrorCallback;
                this._waitingQueue.push( datas );

            }

        } else {

            datas[ 'onLoadCallback' ] = onLoadCallback;
            datas[ 'onProgressCallback' ] = onProgressCallback;
            datas[ 'onErrorCallback' ] = onErrorCallback;
            this._waitingQueue.push( datas );

            const datasToRequest = datas.toRequest;
            let id               = undefined;
            for ( let idIndex = datasToRequest.length - 1 ; idIndex >= 0 ; idIndex-- ) {

                id = datasToRequest[ idIndex ];

                // Prepare entry for id to request
                try {
                    this._cache.add( id, null );
                    datas.underRequest.push( id );
                    datas.toRequest.splice( datas.toRequest.indexOf( id ), 1 );
                } catch ( error ) {
                    this.logger.error( error );
                }

                this._idToRequest.push( id );

            }

            this.aggregateQueue();

        }

    }

    _readWhere ( query, projection, onLoadCallback, onProgressCallback, onErrorCallback ) {

        //        // Filter requested values by cached values
        //                const datas = {
        //                    results: {},
        //                    underRequest: [],
        //                    toRequest: []
        //                }
        //
        //        datas[ 'onLoadCallback' ] = onLoadCallback
        //        this._waitingQueue.push( datas )

        this._requestQueue.push( {
            _id:        `readWhere_${Generate.id}`,
            _timeStart: new Date(),
            _type:      RequestType.ReadWhere,
            method:     HttpVerb.Read.value,
            url:        this._basePath,
            data:       {
                query,
                projection
            },
            onLoad:       onLoadCallback,
            onProgress:   onProgressCallback,
            onError:      onErrorCallback,
            responseType: this._responseType
        } );

        this.processQueue();

    }

    _readAll ( projection, onLoadCallback, onProgressCallback, onErrorCallback ) {

        //        const datas = {
        //            results: {},
        //            underRequest: [],
        //            toRequest: []
        //        }
        //
        //        datas[ 'onLoadCallback' ] = onLoadCallback
        //        this._waitingQueue.push( datas )

        const query = {};

        this._requestQueue.push( {
            _id:        `readAll_${Generate.id}`,
            _timeStart: new Date(),
            _type:      RequestType.ReadAll,
            method:     HttpVerb.Read.value,
            url:        this._basePath,
            data:       {
                query,
                projection
            },
            onLoad:       onLoadCallback,
            onProgress:   onProgressCallback,
            onError:      onErrorCallback,
            responseType: this._responseType
        } );

        this.processQueue();

    }

    /**
     * @private
     * @function
     * @memberOf TDataBaseManager.prototype
     * @description The private _updateOne method will format a server request to update a single object with the given id.
     *
     * @param {string} id - The object's id of the object to update.
     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
     */
    _updateOne ( id, update, onLoadCallback, onProgressCallback, onErrorCallback ) {

        this._requestQueue.push( {
            _id:        `updateOne_${Generate.id}`,
            _timeStart: new Date(),
            _type:      RequestType.UpdateOne,
            method:     HttpVerb.Update.value,
            url:        `${this._basePath}/${id}`,
            data:       {
                update
            },
            onLoad:       onLoadCallback,
            onProgress:   onProgressCallback,
            onError:      onErrorCallback,
            responseType: this._responseType
        } );

        this.processQueue();

    }

    /**
     * @private
     * @function
     * @memberOf TDataBaseManager.prototype
     * @description The private _updateMany method will format a server request to update objects with id in the ids array.
     *
     * @param {array.<string>} ids - The ids of objects to update.
     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
     */
    _updateMany ( ids, update, onLoadCallback, onProgressCallback, onErrorCallback ) {

        this._requestQueue.push( {
            _id:        `updateMany_${Generate.id}`,
            _timeStart: new Date(),
            _type:      RequestType.UpdateMany,
            method:     HttpVerb.Update.value,
            url:        this._basePath,
            data:       {
                ids,
                update
            },
            onLoad:       onLoadCallback,
            onProgress:   onProgressCallback,
            onError:      onErrorCallback,
            responseType: this._responseType
        } );

        this.processQueue();

    }

    _updateWhere ( query, update, onLoadCallback, onProgressCallback, onErrorCallback ) {

        this._requestQueue.push( {
            _id:        `updateWhere_${Generate.id}`,
            _timeStart: new Date(),
            _type:      RequestType.UpdateWhere,
            method:     HttpVerb.Update.value,
            url:        this._basePath,
            data:       {
                query,
                update
            },
            onLoad:       onLoadCallback,
            onProgress:   onProgressCallback,
            onError:      onErrorCallback,
            responseType: this._responseType
        } );

        this.processQueue();

    }

    _updateAll ( update, onLoadCallback, onProgressCallback, onErrorCallback ) {

        const query = {};

        this._requestQueue.push( {
            _id:        `updateAll_${Generate.id}`,
            _timeStart: new Date(),
            _type:      RequestType.UpdateAll,
            method:     HttpVerb.Update.value,
            url:        this._basePath,
            data:       {
                query,
                update
            },
            onLoad:       onLoadCallback,
            onProgress:   onProgressCallback,
            onError:      onErrorCallback,
            responseType: this._responseType
        } );

        this.processQueue();

    }

    /**
     * @private
     * @function
     * @memberOf TDataBaseManager.prototype
     * @description The private _deleteOne method will format a server request to delete a single object with the given id.
     *
     * @param {string} id - The object's id of the object to delete.
     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
     */
    _deleteOne ( id, onLoadCallback, onProgressCallback, onErrorCallback ) {

        this._requestQueue.push( {
            _id:          `deleteOne_${Generate.id}`,
            _timeStart:   new Date(),
            _type:        RequestType.DeleteOne,
            method:       HttpVerb.Delete.value,
            url:          `${this._basePath}/${id}`,
            data:         null,
            onLoad:       onLoadCallback,
            onProgress:   onProgressCallback,
            onError:      onErrorCallback,
            responseType: this._responseType
        } );

        this.processQueue();

    }

    /**
     * @private
     * @function
     * @memberOf TDataBaseManager.prototype
     * @description The private _deleteMany method will format a server request to delete objects with id in the ids array.
     *
     * @param {array.<string>} ids - The ids of objects to delete.
     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
     */
    _deleteMany ( ids, onLoadCallback, onProgressCallback, onErrorCallback ) {

        this._requestQueue.push( {
            _id:        `deleteMany_${Generate.id}`,
            _timeStart: new Date(),
            _type:      RequestType.DeleteMany,
            method:     HttpVerb.Delete.value,
            url:        this._basePath,
            data:       {
                ids
            },
            onLoad:       onLoadCallback,
            onProgress:   onProgressCallback,
            onError:      onErrorCallback,
            responseType: this._responseType
        } );

        this.processQueue();

    }

    _deleteWhere ( query, onLoadCallback, onProgressCallback, onErrorCallback ) {

        this._requestQueue.push( {
            _id:        `deleteWhere_${Generate.id}`,
            _timeStart: new Date(),
            _type:      RequestType.DeleteWhere,
            method:     HttpVerb.Delete.value,
            url:        this._basePath,
            data:       {
                query
            },
            onLoad:       onLoadCallback,
            onProgress:   onProgressCallback,
            onError:      onErrorCallback,
            responseType: this._responseType
        } );

        this.processQueue();

    }

    _deleteAll ( onLoadCallback, onProgressCallback, onErrorCallback ) {

        const query = {};

        this._requestQueue.push( {
            _id:        `deleteAll_${Generate.id}`,
            _timeStart: new Date(),
            _type:      RequestType.DeleteAll,
            method:     HttpVerb.Delete.value,
            url:        this._basePath,
            data:       {
                query
            },
            onLoad:       onLoadCallback,
            onProgress:   onProgressCallback,
            onError:      onErrorCallback,
            responseType: this._responseType
        } );

        this.processQueue();

    }

}

// Static stuff

TDataBaseManager._requestId = 0;

TDataBaseManager._requests = {
    waitingQueue: {},
    toProcess:    {
        create: {},
        read:   {},
        update: {},
        delete: {}
    },
    underProcess: {
        create: {},
        read:   {},
        update: {},
        delete: {}
    },
    processed: {
        create: {},
        read:   {},
        update: {},
        delete: {}
    }
};

/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */

//
//const TIdFactoryType = Object.freeze( {
//    Number: 0,
//    String: 1,
//    Uuid:   2,
//    includes ( key ) {
//        return isNotUndefined( TIdFactoryType[ key ] )
//    },
//    availablesTypes () {
//        return [ 'Number', 'String', 'UUID' ]
//    }
//} )

const TIdFactoryType = Object.freeze( Object.defineProperties( {}, {
    Number: {
        value:      0,
        enumerable: true
    },
    String: {
        value:      1,
        enumerable: true
    },
    Uuid: {
        value:      2,
        enumerable: true
    },
    includes: {
        value: function includes ( key ) {
            return Object.values( this ).includes( key )
        }
    },
    types: {
        value: function types () {
            return Object.keys( this )
        }
    }

} ) );

class TIdFactory {

    constructor ( type = TIdFactoryType.Number, base = null ) {

        this.type = type;
        this.base = base;

        this._counter = 0;

    }

    get type () {
        return this._type
    }

    set type ( value ) {

        if ( iteeValidators.isNull( value ) ) { throw new Error( `Type cannot be null ! Expect an value from TIdFactoryType enum: ${TIdFactoryType.types()}` ) }
        if ( iteeValidators.isUndefined( value ) ) { throw new Error( `Type cannot be undefined ! Expect an value from TIdFactoryType enum: ${TIdFactoryType.types()}` ) }
        if ( !TIdFactoryType.includes( value ) ) { throw new Error( `Invalide type ! Expect an value from TIdFactoryType enum: ${TIdFactoryType.types()}` ) }

        this._type = value;
    }

    get base () {
        return this._base
    }

    set base ( value ) {

        if ( iteeValidators.isUndefined( value ) ) { throw new Error( 'Base cannot be undefined ! Expect an instance of Object3D.' ) }

        if ( ( this._type === TIdFactoryType.Number ) && iteeValidators.isNotNumber( value ) ) { throw new Error( 'Invalide Base ! It does not match the type.' ) }
        if ( ( this._type === TIdFactoryType.String ) && iteeValidators.isNotString( value ) ) { throw new Error( 'Invalide Base ! It does not match the type.' ) }
        //        if( (this._type === TIdFactoryType.Uuid) && isNotUuid( value ) ) { throw new Error( 'Invalide Base ! It does not match the type.' ) }

        this._base = value;
    }

    setType ( value ) {

        this.type = value;
        return this

    }

    setBase ( value ) {

        this.base = value;
        return this

    }

    createId () {
        return this._base + this._counter++
    }

}

exports.Byte = Byte;
exports.DefaultLogger = DefaultLogger;
exports.Endianness = Endianness;
exports.FileFormat = FileFormat;
exports.HttpStatusCode = HttpStatusCode;
exports.HttpVerb = HttpVerb;
exports.Keys = Keys;
exports.MimeType = MimeType;
exports.Mouse = Mouse;
exports.ResponseType = ResponseType;
exports.TAbstractFactory = TAbstractFactory;
exports.TBinaryReader = TBinaryReader;
exports.TCloningFactory = TCloningFactory;
exports.TDataBaseManager = TDataBaseManager;
exports.TIdFactory = TIdFactory;
exports.TIdFactoryType = TIdFactoryType;
exports.TInstancingFactory = TInstancingFactory;
exports.TKeyboardController = TKeyboardController;
exports.TLogger = TLogger;
exports.TMouseController = TMouseController;
exports.TStore = TStore;
//# sourceMappingURL=itee-client.cjs.js.map
