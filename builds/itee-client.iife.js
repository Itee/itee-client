console.log('Itee.Client v8.1.2 - Standalone')
this.Itee = this.Itee || {};
this.Itee.Client = (function (exports, iteeUtils, iteeValidators, iteeCore) {
	'use strict';

	if( iteeValidators === undefined ) { console.error('Itee.Client need Itee.Validators to be defined first. Please check your scripts loading order.') }
	if( iteeUtils === undefined ) { console.error('Itee.Client need Itee.Utils to be defined first. Please check your scripts loading order.') }
	if( iteeCore === undefined ) { console.error('Itee.Client need Itee.Core to be defined first. Please check your scripts loading order.') }


	/**
	 * A freezed javascript object used like an enum.
	 * @typedef {object} Enum
	 * @constant
	 * @example
	 * var Meal = toEnum( {
	 *     Food: 'Tartiflette',
	 *     Drink: 'Saint-Emilion',
	 *     Dessert: 'Mousse au chocolat'
	 * } )
	 *
	 * if( Foo.includes('Tartiflette') {
	 *     // Happy
	 * }
	 *
	 * var myDrink = 'coke'
	 * if( myDrink === Meal.Drink ) {
	 *
	 * } else {
	 *     // Your life is a pain
	 * }
	 *
	 * var MealTypes = Meal.types
	 * // ['Tartiflette', 'Saint-Emilion', 'Mousse au chocolat' ]
	 *
	 */

	/**
	 * @typedef {Enum} FileFormat
	 * @property {String} Asc="asc" - The ascii file format
	 * @property {String} Dae="dae" - The dae file format
	 * @property {String} Dbf="dbf" - The dbf file format
	 * @property {String} Fbx="fbx" - The fbx file format
	 * @property {String} Mtl="mtl" - The material file format
	 * @property {String} Json="json" - The json file format
	 * @property {String} Obj="obj" - The object file format
	 * @property {String} Shp="shp" - The shape file format
	 * @property {String} Stl="stl" - The stereolithographie file format
	 *
	 * @constant
	 * @type {FileFormat}
	 * @description The FileFormat Enum give some commonly used file format in 3d context
	 */
	const FileFormat = iteeUtils.toEnum( {
	    Asc:  { value: 'asc' },
	    Dae:  { value: 'dae' },
	    Dbf:  { value: 'dbf' },
	    Fbx:  { value: 'fbx' },
	    Mtl:  { value: 'mtl' },
	    Json: { value: 'json' },
	    Obj:  { value: 'obj' },
	    Shp:  { value: 'shp' },
	    Stl:  { value: 'stl' }
	} );

	/**
	 * @typedef {Enum} HttpStatusCode
	 * @property {number} Continue=100 - Waiting for the continuation of the request.
	 * @property {number} SwitchingProtocols=101 - The requester has asked the server to switch protocols and the server has agreed to do so.
	 * @property {number} Processing=102 - WebDAV: Processing in progress (prevents the client from exceeding the limited waiting time).
	 * @property {number} Ok=200 - Query successfully processed.
	 * @property {number} Created=201 - Query successfully processed and a document was created.
	 * @property {number} Accepted=202 - Query processed, but without guarantee of result.
	 * @property {number} NonAuthoritativeInformation=203 - Information returned, but generated by an uncertified source.
	 * @property {number} NoContent=204 - Query successfully processed but no information returned.
	 * @property {number} ResetContent=205 - Query successfully processed, the current page can be cleared.
	 * @property {number} PartialContent=206 - Only part of the resource has been transmitted.
	 * @property {number} MultiStatus=207 - WebDAV: Multiple Response.
	 * @property {number} AlreadyReported=208 - WebDAV: The document was previously sent to this collection.
	 * @property {number} ContentDifferent=210 - WebDAV: The copy of the client-side resource differs from that of the server (content or properties).
	 * @property {number} IMUsed=226 - The server has completed the request for the resource, and the response is a representation of the result of one or more instance manipulations applied to the
	 *     current instance.
	 * @property {number} MultipleChoices=300 - The requested URI refers to multiple resources.
	 * @property {number} MovedPermanently=301 - Document moved permanently.
	 * @property {number} Found=302 - Document moved temporarily.
	 * @property {number} SeeOther=303 - The answer to this query is elsewhere.
	 * @property {number} NotModified=304 - Document not modified since the last request.
	 * @property {number} UseProxy=305 - The request must be re-addressed to the proxy.
	 * @property {number} Unused=306 - Code used by an older version of RFC 2616, now reserved.
	 * @property {number} TemporaryRedirect=307 - The request must be temporarily redirected to the specified URI.
	 * @property {number} PermanentRedirect=308 - The request must be redirected permanently to the specified URI.
	 * @property {number} TooManyRedirects=310 - The request must be redirected too many times, or is the victim of a redirection loop.
	 * @property {number} BadRequest=400 - The syntax of the query is wrong.
	 * @property {number} Unauthorized=401 - Authentication is required to access the resource.
	 * @property {number} PaymentRequired=402 - Payment required to access the resource.
	 * @property {number} Forbidden=403 - The server understood the request, but refuses to execute it. Unlike error 401, authenticating will not make any difference. On servers where authentication is
	 *     required, this usually means that authentication has been accepted but access rights do not allow the client to access the resource.
	 * @property {number} NotFound=404 - Resource not found.
	 * @property {number} MethodNotAllowed=405 - Unauthorized request method.
	 * @property {number} NotAcceptable=406 - The requested resource is not available in a format that would respect the "Accept" headers of the request.
	 * @property {number} ProxyAuthenticationRequired=407 - Access to the authorized resource by identification with the proxy.
	 * @property {number} RequestTimeOut=408 - Waiting time for an elapsed client request.
	 * @property {number} Conflict=409 - The request can not be processed in the current state.
	 * @property {number} Gone=410 - The resource is no longer available and no redirection address is known.
	 * @property {number} LengthRequired=411 - The length of the request has not been specified.
	 * @property {number} PreconditionFailed=412 - Preconditions sent by the query unverified.
	 * @property {number} RequestEntityTooLarge=413 - Abandoned processing due to excessive request
	 * @property {number} RequestURITooLong=414 - URI too long
	 * @property {number} UnsupportedMediaType=415 - Unsupported query format for a given method and resource.
	 * @property {number} RequestRangeUnsatisfiable=416 - Invalid "range" request header fields.
	 * @property {number} ExpectationFailed=417 - Expected behavior and defined in the header of the unsatisfactory request.
	 * @property {number} ImATeapot=418 - "I am a teapot". This code is defined in RFC 2324 dated April 1, 1998, Hyper Text Coffee Pot Control Protocol.
	 * @property {number} BadMapping=421 - The request was sent to a server that is not able to produce a response (for example, because a connection has been reused).
	 * @property {number} UnprocessableEntity=422 - WebDAV: The entity provided with the request is incomprehensible or incomplete.
	 * @property {number} Locked=423 - WebDAV: The operation can not take place because the resource is locked.
	 * @property {number} MethodFailure=424 - WebDAV: A method of the transaction failed.
	 * @property {number} UnorderedCollection=425 - WebDAV RFC 3648. This code is defined in the WebDAV Advanced Collections Protocol draft , but is absent from the Web Distributed Authoring and
	 *     Versioning (WebDAV) Ordered Collections Protocol.
	 * @property {number} UpgradeRequired=426 - RFC 2817 The client should change protocol, for example to TLS / 1.0 .
	 * @property {number} PreconditionRequired=428 - RFC 6585 The request must be conditional.
	 * @property {number} TooManyRequests=429 - RFC 6585 The client has issued too many requests within a given time.
	 * @property {number} RequestHeaderFieldsTooLarge=431 - RFC 6585 HTTP headers issued exceed the maximum size allowed by the server.
	 * @property {number} NoResponse=444 - Indicates that the server did not return any information to the client and closed the connection.
	 * @property {number} RetryWith=449 - Code defined by Microsoft . The request should be returned after performing an action.
	 * @property {number} BlockedByWindowsParentalControls=450 - Code defined by Microsoft. This error is generated when Windows Parental Control tools are enabled and block access to the page.
	 * @property {number} UnavailableForLegalReasons=451 - This error code indicates that the requested resource is inaccessible for legal reasons
	 * @property {number} UnrecoverableError=456 - WebDAV: Fatal error.
	 * @property {number} SSLCertificateError=495 - An extension of the 400 Bad Request error, used when the client provided an invalid certificate.
	 * @property {number} SSLCertificateRequired=496 - An extension of the 400 Bad Request error, used when a required client certificate is not provided.
	 * @property {number} HTTPRequestSentToHTTPSPort=497 - An extension of the 400 Bad Request error, used when the client sends an HTTP request to port 443 normally intended for HTTPS requests.
	 * @property {number} ClientClosedRequest=499 - The client closed the connection before receiving the response. This error occurs when the processing is too long on the server side.
	 * @property {number} InternalServerError=500 - Internal server error.
	 * @property {number} NotImplemented=501 - Functionality claimed not supported by the server.
	 * @property {number} BadGateway=502 - Wrong response sent to an intermediate server by another server.
	 * @property {number} ServiceUnavailable=503 - Service temporarily unavailable or under maintenance.
	 * @property {number} GatewayTimeOut=504 - Waiting time for a response from a server to an intermediate server that has elapsed.
	 * @property {number} HTTPVersionNotSupported=505 - HTTP version not managed by the server.
	 * @property {number} VariantAlsoNegotiates=506 - RFC 2295: Negotiation Error. Transparent content negociation.
	 * @property {number} InsufficientStorage=507 - WebDAV: Insufficient space to modify properties or build the collection.
	 * @property {number} LoopDetected=508 - WebDAV: Loop in a Resource Match
	 * @property {number} BandwidthLimitExceeded=509 - Used by many servers to indicate a quota overrun.
	 * @property {number} NotExtended=510 - RFC 2774: The request does not respect the policy for accessing extended HTTP resources.
	 * @property {number} NetworkAuthenticationRequired=511 - RFC 6585: The client must authenticate to access the network. Used by captive portals to redirect clients to the authentication page.
	 * @property {number} UnknownError=520 - Error 520 is used as a wildcard response when the origin server returns an unexpected result.
	 * @property {number} WebServerIsDown=521 - The server has refused the connection from Cloudflare.
	 * @property {number} ConnectionTimedOut=522 - Cloudflare could not negotiate a TCP handshake with the origin server.
	 * @property {number} OriginIsUnreachable=523 - Cloudflare failed to reach the origin server. This can occur if DNS server name resolution fails.
	 * @property {number} ATimeoutOccured=524 - Cloudflare established a TCP connection with the origin server but did not receive an HTTP response before the login timeout.
	 * @property {number} SSLHandshakeFailed=525 - Cloudflare could not negotiate SSL / TLS handshake with the origin server.
	 * @property {number} InvalidSSLCertificate=526 - Cloudflare could not validate the SSL certificate presented by the origin server.
	 * @property {number} RailgunError=527 - Error 527 indicates that the request has timed out or failed after the WAN connection was established.
	 *
	 * @constant
	 * @type {HttpStatusCode}
	 * @description HttpStatusCode contains all http status code available to check and process correctly server response.
	 * @see {@link https://en.wikipedia.org/wiki/List_of_HTTP_status_codes} for further information.
	 */
	const HttpStatusCode = iteeUtils.toEnum( {

	    // 100
	    Continue:           { value: 100 },
	    SwitchingProtocols: { value: 101 },
	    Processing:         { value: 102 },

	    // 200
	    Ok:                          { value: 200 },
	    Created:                     { value: 201 },
	    Accepted:                    { value: 202 },
	    NonAuthoritativeInformation: { value: 203 },
	    NoContent:                   { value: 204 },
	    ResetContent:                { value: 205 },
	    PartialContent:              { value: 206 },
	    MultiStatus:                 { value: 207 },
	    AlreadyReported:             { value: 208 },
	    ContentDifferent:            { value: 210 },
	    IMUsed:                      { value: 226 },

	    // 300
	    MultipleChoices:   { value: 300 },
	    MovedPermanently:  { value: 301 },
	    Found:             { value: 302 },
	    SeeOther:          { value: 303 },
	    NotModified:       { value: 304 },
	    UseProxy:          { value: 305 },
	    Unused:            { value: 306 },
	    TemporaryRedirect: { value: 307 },
	    PermanentRedirect: { value: 308 },
	    TooManyRedirects:  { value: 310 },

	    // 400
	    BadRequest:                       { value: 400 },
	    Unauthorized:                     { value: 401 },
	    PaymentRequired:                  { value: 402 },
	    Forbidden:                        { value: 403 },
	    NotFound:                         { value: 404 },
	    MethodNotAllowed:                 { value: 405 },
	    NotAcceptable:                    { value: 406 },
	    ProxyAuthenticationRequired:      { value: 407 },
	    RequestTimeOut:                   { value: 408 },
	    Conflict:                         { value: 409 },
	    Gone:                             { value: 410 },
	    LengthRequired:                   { value: 411 },
	    PreconditionFailed:               { value: 412 },
	    RequestEntityTooLarge:            { value: 413 },
	    RequestRangeUnsatisfiable:        { value: 416 },
	    ExpectationFailed:                { value: 417 },
	    ImATeapot:                        { value: 418 },
	    BadMapping:                       { value: 421 },
	    UnprocessableEntity:              { value: 422 },
	    Locked:                           { value: 423 },
	    MethodFailure:                    { value: 424 },
	    UnorderedCollection:              { value: 425 },
	    UpgradeRequired:                  { value: 426 },
	    PreconditionRequired:             { value: 428 },
	    TooManyRequests:                  { value: 429 },
	    RequestHeaderFieldsTooLarge:      { value: 431 },
	    NoResponse:                       { value: 444 },
	    RetryWith:                        { value: 449 },
	    BlockedByWindowsParentalControls: { value: 450 },
	    UnavailableForLegalReasons:       { value: 451 },
	    UnrecoverableError:               { value: 456 },
	    SSLCertificateError:              { value: 495 },
	    SSLCertificateRequired:           { value: 496 },
	    HTTPRequestSentToHTTPSPort:       { value: 497 },
	    ClientClosedRequest:              { value: 499 },

	    // 500
	    InternalServerError:           { value: 500 },
	    NotImplemented:                { value: 501 },
	    BadGateway:                    { value: 502 },
	    ServiceUnavailable:            { value: 503 },
	    GatewayTimeOut:                { value: 504 },
	    HTTPVersionNotSupported:       { value: 505 },
	    VariantAlsoNegotiates:         { value: 506 },
	    InsufficientStorage:           { value: 507 },
	    LoopDetected:                  { value: 508 },
	    BandwidthLimitExceeded:        { value: 509 },
	    NotExtended:                   { value: 510 },
	    NetworkAuthenticationRequired: { value: 511 },
	    UnknownError:                  { value: 520 },
	    WebServerIsDown:               { value: 521 },
	    ConnectionTimedOut:            { value: 522 },
	    OriginIsUnreachable:           { value: 523 },
	    ATimeoutOccured:               { value: 524 },
	    SSLHandshakeFailed:            { value: 525 },
	    InvalidSSLCertificate:         { value: 526 },
	    RailgunError:                  { value: 527 }

	} );

	/**
	 * @typedef {Enum} HttpVerb
	 * @property {String} Create="PUT" - Corresponding to the create http verb for an itee server, namely "PUT".
	 * @property {String} Read="POST" - Corresponding to the read http verb for an itee server, namely "POST".
	 * @property {String} Update="PATCH" - Corresponding to the update http verb for an itee server, namely "PATCH".
	 * @property {String} Delete="DELETE" - Corresponding to the delete http verb for an itee server, namely "DELETE".
	 *
	 * @constant
	 * @type {HttpVerb}
	 * @description HttpVerb contains the CRUD actions with corresponding http verb to request an itee server.
	 * @see {@link https://en.wikipedia.org/wiki/Create,_read,_update_and_delete} for further information.
	 */
	const HttpVerb = iteeUtils.toEnum( {
	    Create: { value: 'PUT' },
	    Read:   { value: 'POST' },
	    Update: { value: 'PATCH' },
	    Delete: { value: 'DELETE' }
	} );

	/**
	 * @typedef {Enum} Keys
	 * @property {Number} BACKSPACE=8 - The backspace key code
	 * @property {Number} TAB=9 - The tab key code
	 * @property {Number} ENTER=13 - The enter key code
	 * @property {Number} Etc...=* - All the rest
	 *
	 * @constant
	 * @type {Keys}
	 * @description Keys contains common keyboard key values, this allow to write semantic code instead of integer when dealing with key codes.
	 */
	const Keys = iteeUtils.toEnum( {
	    BACKSPACE:            { value: 8 },
	    TAB:                  { value: 9 },
	    ENTER:                { value: 13 },
	    SHIFT:                { value: 16 },
	    CTRL:                 { value: 17 },
	    ALT:                  { value: 18 },
	    PAUSE:                { value: 19 },
	    CAPS_LOCK:            { value: 20 },
	    ESCAPE:               { value: 27 },
	    SPACE:                { value: 32 },
	    PAGE_UP:              { value: 33 },
	    PAGE_DOWN:            { value: 34 },
	    END:                  { value: 35 },
	    HOME:                 { value: 36 },
	    LEFT_ARROW:           { value: 37 },
	    UP_ARROW:             { value: 38 },
	    RIGHT_ARROW:          { value: 39 },
	    DOWN_ARROW:           { value: 40 },
	    INSERT:               { value: 45 },
	    DELETE:               { value: 46 },
	    ZERO:                 { value: 48 },
	    ONE:                  { value: 49 },
	    TWO:                  { value: 50 },
	    THREE:                { value: 51 },
	    FOUR:                 { value: 52 },
	    FIVE:                 { value: 53 },
	    SIX:                  { value: 54 },
	    SEVEN:                { value: 55 },
	    HEIGHT:               { value: 56 },
	    NINE:                 { value: 57 },
	    A:                    { value: 65 },
	    B:                    { value: 66 },
	    C:                    { value: 67 },
	    D:                    { value: 68 },
	    E:                    { value: 69 },
	    F:                    { value: 70 },
	    G:                    { value: 71 },
	    H:                    { value: 72 },
	    I:                    { value: 73 },
	    J:                    { value: 74 },
	    K:                    { value: 75 },
	    L:                    { value: 76 },
	    M:                    { value: 77 },
	    N:                    { value: 78 },
	    O:                    { value: 79 },
	    P:                    { value: 80 },
	    Q:                    { value: 81 },
	    R:                    { value: 82 },
	    S:                    { value: 83 },
	    T:                    { value: 84 },
	    U:                    { value: 85 },
	    V:                    { value: 86 },
	    W:                    { value: 87 },
	    X:                    { value: 88 },
	    Y:                    { value: 89 },
	    Z:                    { value: 90 },
	    LEFT_WINDOW_KEY:      { value: 91 },
	    RIGHT_WINDOW_KEY:     { value: 92 },
	    SELECT_KEY:           { value: 93 },
	    NUMPAD_0:             { value: 96 },
	    NUMPAD_1:             { value: 97 },
	    NUMPAD_2:             { value: 98 },
	    NUMPAD_3:             { value: 99 },
	    NUMPAD_4:             { value: 100 },
	    NUMPAD_5:             { value: 101 },
	    NUMPAD_6:             { value: 102 },
	    NUMPAD_7:             { value: 103 },
	    NUMPAD_8:             { value: 104 },
	    NUMPAD_9:             { value: 105 },
	    MULTIPLY:             { value: 106 },
	    ADD:                  { value: 107 },
	    SUBSTRACT:            { value: 109 },
	    DECIMAL_POINT:        { value: 110 },
	    DIVIDE:               { value: 111 },
	    F1:                   { value: 112 },
	    F2:                   { value: 113 },
	    F3:                   { value: 114 },
	    F4:                   { value: 115 },
	    F5:                   { value: 116 },
	    F6:                   { value: 117 },
	    F7:                   { value: 118 },
	    F8:                   { value: 119 },
	    F9:                   { value: 120 },
	    F10:                  { value: 121 },
	    F11:                  { value: 122 },
	    F12:                  { value: 123 },
	    NUM_LOCK:             { value: 144 },
	    SCROLL_LOCK:          { value: 145 },
	    SEMICOLON:            { value: 186 },
	    EQUAL:                { value: 187 },
	    COMMA:                { value: 188 },
	    DASH:                 { value: 189 },
	    PERIODE:              { value: 190 },
	    SLASH:                { value: 191 },
	    GRAVE_ACCENT:         { value: 192 },
	    OPEN_SQUARE_BRACKET:  { value: 219 },
	    BACKSLASH:            { value: 220 },
	    CLOSE_SQUARE_BRACKET: { value: 221 },
	    SINGLE_QUOTE:         { value: 222 }
	} );

	/**
	 * @typedef {Enum} MimeType
	 * @property {Number} ...
	 *
	 * @constant
	 * @type {MimeType}
	 * @description Todo...
	 */
	const MimeType = iteeUtils.toEnum( {} );

	/**
	 * @typedef {Enum} Mouse
	 * @property {Number} Wheel=-1 - The enter key code
	 * @property {Number} Left=0 - The enter key code
	 * @property {Number} Middle=1 - The enter key code
	 * @property {Number} Right=2 - The enter key code
	 *
	 * @constant
	 * @type {Mouse}
	 * @description This Mouse Enum expose 4 common state of mouse button values (Wheel, Left, Middle and Right), this allow to write semantic code instead of integer when dealing with mouse button codes.
	 */
	const Mouse = iteeUtils.toEnum( {
	    Wheel:  { value: -1 },
	    Left:   { value: 0 },
	    Middle: { value: 1 },
	    Right:  { value: 2 }
	} );

	/**
	 * @typedef {Enum} ResponseType
	 * @property {String} ArrayBuffer="arraybuffer" - The "arraybuffer" server response type.
	 * @property {String} Blob="blob" - The "blob" server response type.
	 * @property {String} Document="document" - The "document" server response type.
	 * @property {String} Json="json" - The "json" server response type.
	 * @property {String} DOMString="text" - The "text" server response type.
	 * @property {String} Default="text" - The "" server response type ( equivalent to DOMString ).
	 *
	 * @constant
	 * @type {ResponseType}
	 * @description ResponseType allow to filter wich type of response is recieved from the server.
	 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType} for further information.
	 */
	const ResponseType = iteeUtils.toEnum( {
	    ArrayBuffer: { value: 'arraybuffer' },
	    Blob:        { value: 'blob' },
	    Document:    { value: 'document' },
	    Json:        { value: 'json' },
	    DOMString:   { value: 'text' },
	    Default:     { value: '' }
	} );

	/**
	 * @class
	 * @classdesc TStore is a simple javascript object whose purpose is to store some ket/value data to future usage. It could be enable/disable.
	 *
	 * @example {@lang javascript}
	 * var cache = new TCache()
	 * cache.add( 'foo', 'bar' )
	 * TLogger.log( cache.get('foo') ) // 'bar'
	 *
	 * @author [Tristan Valcke]{@link https://github.com/Itee}
	 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
	 */
	class TStore {

	    /**
	     *
	     * @param value
	     * @param validators
	     * @private
	     */
	    static _validate ( value, validators ) {

	        for ( let validatorIndex = 0, numberOfValidators = validators.length ; validatorIndex < numberOfValidators ; validatorIndex++ ) {

	            let validator = validators[ validatorIndex ];

	            if ( !validator.validator( value ) ) {

	                const error = validator.error;
	                if ( iteeValidators.isString( error ) ) {
	                    throw new TypeError( error )
	                } else if ( iteeValidators.isFunction( error ) ) {
	                    throw new TypeError( error( value ) )
	                } else {
	                    throw new TypeError( `${ value } is invalid.` )
	                }

	            }

	        }

	    }
	    /**
	     * @constructor
	     * @param {Object} [parameters={}]
	     * @param {Object} [parameters.collection={}]
	     * @param {Boolean} [parameters.allowOverride=false]
	     * @param {Array.<function>} [parameters.keyValidators=[]]
	     * @param {Array.<function>} [parameters.valueValidators=[]]
	     */
	    constructor ( parameters = {} ) {

	        const _parameters = {
	            ...{
	                collection:      {},
	                allowOverride:   false,
	                keyValidators:   [],
	                valueValidators: []
	            }, ...parameters
	        };

	        this.collection      = _parameters.collection;
	        this.allowOverride   = _parameters.allowOverride;
	        this.keyValidators   = _parameters.keyValidators;
	        this.valueValidators = _parameters.valueValidators;

	    }
	    /**
	     *
	     * @return {{}}
	     */
	    get collection () {

	        return this._collection

	    }
	    set collection ( value ) {

	        const memberName = 'Collection';
	        const expect     = 'Expect an object.';

	        if ( iteeValidators.isNull( value ) ) { throw new TypeError( `${ memberName } cannot be null ! ${ expect }` ) }
	        if ( iteeValidators.isUndefined( value ) ) { throw new TypeError( `${ memberName } cannot be undefined ! ${ expect }` ) }
	        if ( iteeValidators.isNotObject( value ) ) { throw new TypeError( `${ memberName } cannot be an instance of ${ value.constructor.name } ! ${ expect }` ) }

	        this._collection = value;

	    }
	    /**
	     *
	     * @return {*}
	     */
	    get allowOverride () {

	        return this._allowOverride

	    }
	    set allowOverride ( value ) {

	        const memberName = 'Allow override';
	        const expect     = 'Expect a boolean.';

	        if ( iteeValidators.isNull( value ) ) { throw new TypeError( `${ memberName } cannot be null ! ${ expect }` ) }
	        if ( iteeValidators.isUndefined( value ) ) { throw new TypeError( `${ memberName } cannot be undefined ! ${ expect }` ) }
	        if ( iteeValidators.isNotBoolean( value ) ) { throw new TypeError( `${ memberName } cannot be an instance of ${ value.constructor.name } ! ${ expect }` ) }

	        this._allowOverride = value;

	    }
	    /**
	     *
	     * @return {*}
	     */
	    get keyValidators () {

	        return this._keyValidators

	    }
	    set keyValidators ( value ) {

	        const memberName = 'Keys validators';
	        const expect     = 'Expect an array of TValidator or an empty array.';

	        if ( iteeValidators.isNull( value ) ) { throw new TypeError( `${ memberName } cannot be null ! ${ expect }` ) }
	        if ( iteeValidators.isUndefined( value ) ) { throw new TypeError( `${ memberName } cannot be undefined ! ${ expect }` ) }
	        if ( iteeValidators.isNotArray( value ) ) { throw new TypeError( `${ memberName } cannot be an instance of ${ value.constructor.name } ! ${ expect }` ) }

	        this._keyValidators = value;

	    }
	    /**
	     *
	     * @return {*}
	     */
	    get valueValidators () {
	        return this._valueValidators
	    }
	    set valueValidators ( value ) {

	        const memberName = 'Values validators';
	        const expect     = 'Expect an array of TValidator or an empty array.';

	        if ( iteeValidators.isNull( value ) ) { throw new TypeError( `${ memberName } cannot be null ! ${ expect }` ) }
	        if ( iteeValidators.isUndefined( value ) ) { throw new TypeError( `${ memberName } cannot be undefined ! ${ expect }` ) }
	        if ( iteeValidators.isNotArray( value ) ) { throw new TypeError( `${ memberName } cannot be an instance of ${ value.constructor.name } ! ${ expect }` ) }

	        this._valueValidators = value;

	    }
	    /**
	     *
	     * @return {string[]}
	     */
	    get keys () {

	        return Object.keys( this._collection )

	    }
	    /**
	     *
	     * @return {unknown[] | any[]}
	     */
	    get values () {

	        return Object.values( this._collection )

	    }
	    /**
	     *
	     * @param value
	     * @return {TStore} The current instance (this)
	     */
	    setCollection ( value ) {

	        this.collection = value;
	        return this

	    }

	    /**
	     *
	     * @param value
	     * @return {TStore} The current instance (this)
	     */
	    setAllowOverride ( value ) {

	        this.allowOverride = value;
	        return this

	    }

	    /**
	     *
	     * @param value
	     * @return {TStore} The current instance (this)
	     */
	    setKeyValidators ( value ) {

	        this.keyValidators( value );
	        return this

	    }

	    /**
	     *
	     * @param value
	     * @return {TStore} The current instance (this)
	     */
	    setValueValidators ( value ) {

	        this.valueValidators( value );
	        return this

	    }

	    /**
	     * Allow to add new key value pair, the key cannot be null, undefined, or an empty string.
	     * In case the key already exist, the value will be overwritten if force params is true or this
	     * allow overriding else it throw an TypeError.
	     *
	     * @param {*} key
	     * @param {*} value
	     * @param {Boolean} force
	     * @return {TStore} The current instance (this)
	     */
	    add ( key, value, force = false ) {

	        if ( this.contain( key ) && ( !this._allowOverride && !force ) ) {
	            throw new TypeError( `Item with key (${ key }) already exist in collection !` )
	        }

	        TStore._validate( key, this._keyValidators );
	        TStore._validate( value, this._valueValidators );

	        this._collection[ key ] = value;

	        return this

	    }

	    /**
	     *
	     * @param key
	     * @return {boolean}
	     */
	    contain ( key ) {

	        return iteeValidators.isNotUndefined( this._collection[ key ] )

	    }

	    /**
	     * Return the value associated to the key.
	     *
	     * @param key
	     * @returns {*}
	     */
	    get ( key ) {

	        return this._collection[ key ]

	    }

	    /**
	     * Remove to value from the cache. Does nothing if the key does not exist.
	     *
	     * @param key
	     * @return {TStore} The current instance (this)
	     */
	    remove ( key ) {

	        delete this._collection[ key ];

	        return this

	    }

	    /**
	     * Clear the cache and reset collection to an empty object.
	     * @return {TStore} The current instance (this)
	     */
	    clear () {

	        this._collection = {};

	        return this

	    }

	}

	/**
	 * @class
	 * @classdesc The abstract class to create factory
	 * @abstract
	 * @extends TStore
	 *
	 * @author [Tristan Valcke]{@link https://github.com/Itee}
	 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
	 */
	class TAbstractFactory extends TStore {

	    /**
	     * @constructor
	     * @param parameters
	     */
	    constructor ( parameters = {} ) {

	        const _parameters = { ...{}, ...parameters };

	        super( _parameters );

	    }


	    /**
	     * The create factory method. It allow to automate Class creation by constructor key, and parameters to pass for initialized the instance.
	     * @abstract
	     * @param {*} key
	     * @param parameters
	     */
	    // eslint-disable-next-line no-unused-vars
	    create ( key, ...parameters ) {

	        // Need to be reimplemented

	    }

	}

	/**
	 * @class
	 * @classdesc The TCloningFactory is a kind a factory that performe instanciation by cloning a base instance.
	 * @extends TAbstractFactory
	 *
	 * @author [Tristan Valcke]{@link https://github.com/Itee}
	 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
	 */
	class TCloningFactory extends TAbstractFactory {

	    /**
	     * @param parameters
	     */
	    constructor ( parameters = {} ) {

	        const _parameters = { ...{}, ...parameters };

	        super( _parameters );

	    }

	    /**
	     *
	     * @param key
	     * @param parameters
	     * @returns {*}
	     */
	    create ( key, ...parameters ) {
	        super.create( key, ...parameters );

	        return this.get( key ).clone( ...parameters )

	    }
	}

	/**
	 * @class
	 * @classdesc The TInstancingFactory is a kind a factory that performe instanciation based on registred constructor.
	 * @extends TAbstractFactory
	 *
	 * @author [Tristan Valcke]{@link https://github.com/Itee}
	 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
	 */
	class TInstancingFactory extends TAbstractFactory {

	    /**
	     * The ctor description
	     * @param parameters
	     */
	    constructor ( parameters = {} ) {

	        const _parameters = { ...{}, ...parameters };

	        super( _parameters );

	    }

	    /**
	     *
	     * @param key
	     * @param parameters
	     * @returns {*}
	     */
	    create ( key, ...parameters ) {
	        super.create( key, ...parameters );

	        return new this.get( key )( ...parameters )

	    }

	}

	/* eslint-env browser */

	/**
	 * @class
	 * @classdesc TKeyboardController allow single source of thruth for keyboard state checking (based on Lee Stemkoski work).
	 * See TKeyboardController.k object data below for names of keys whose state can be polled
	 *
	 * @author [Tristan Valcke]{@link https://github.com/Itee}
	 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
	 * @example {@lang javascript}
	 * // (1) create a global variable:
	 * var keyboard = new TKeyboardController();
	 *
	 * // (2) during main loop:
	 * keyboard.update();
	 *
	 * // (3) check state of keys:
	 * keyboard.down("A")    -- true for one update cycle after key is pressed
	 * keyboard.pressed("A") -- true as long as key is being pressed
	 * keyboard.up("A")      -- true for one update cycle after key is released
	 */
	class TKeyboardController {

	    /**
	     *
	     * @param keyCode
	     * @return {string}
	     */
	    static keyName ( keyCode ) {
	        return ( TKeyboardController.k[ keyCode ] !== null ) ?
	            TKeyboardController.k[ keyCode ] :
	            String.fromCharCode( keyCode )
	    }
	    /**
	     *
	     * @param event
	     */
	    static onKeyUp ( event ) {
	        var key = TKeyboardController.keyName( event.keyCode );
	        if ( TKeyboardController.status[ key ] ) {
	            TKeyboardController.status[ key ].pressed = false;
	        }
	    }
	    /**
	     *
	     * @param event
	     */
	    static onKeyDown ( event ) {
	        var key = TKeyboardController.keyName( event.keyCode );
	        if ( !TKeyboardController.status[ key ] ) {
	            TKeyboardController.status[ key ] = {
	                down:              false,
	                pressed:           false,
	                up:                false,
	                updatedPreviously: false
	            };
	        }
	    }
	    /**
	     *
	     * @param parameters
	     */
	    // eslint-disable-next-line no-unused-vars
	    constructor ( parameters = {} ) {

	        //         const _parameters = {
	        //             ...{},
	        //             ...parameters
	        //         }

	        // bind keyEvents
	        document.addEventListener( 'keydown', TKeyboardController.onKeyDown, false );
	        document.addEventListener( 'keyup', TKeyboardController.onKeyUp, false );

	    }
	    /**
	     *
	     */
	    update () {
	        for ( var key in TKeyboardController.status ) {
	            // insure that every keypress has "down" status exactly once
	            if ( !TKeyboardController.status[ key ].updatedPreviously ) {
	                TKeyboardController.status[ key ].down              = true;
	                TKeyboardController.status[ key ].pressed           = true;
	                TKeyboardController.status[ key ].updatedPreviously = true;
	            } else { // updated previously
	                TKeyboardController.status[ key ].down = false;
	            }

	            // key has been flagged as "up" since last update
	            if ( TKeyboardController.status[ key ].up ) {
	                delete TKeyboardController.status[ key ];
	                continue // move on to next key
	            }

	            if ( !TKeyboardController.status[ key ].pressed ) // key released
	            {
	                TKeyboardController.status[ key ].up = true;
	            }
	        }
	    }

	    /**
	     *
	     * @param keyName
	     * @return {*}
	     */
	    down ( keyName ) {
	        return ( TKeyboardController.status[ keyName ] && TKeyboardController.status[ keyName ].down )
	    }

	    /**
	     *
	     * @param keyName
	     * @return {*|pressed|boolean}
	     */
	    pressed ( keyName ) {
	        return ( TKeyboardController.status[ keyName ] && TKeyboardController.status[ keyName ].pressed )
	    }

	    /**
	     *
	     * @param keyName
	     * @return {*}
	     */
	    up ( keyName ) {
	        return ( TKeyboardController.status[ keyName ] && TKeyboardController.status[ keyName ].up )
	    }

	    /**
	     *
	     */
	    debug () {
	        var list = 'Keys active: ';
	        for ( var arg in TKeyboardController.status ) {
	            list += ' ' + arg;
	        }
	        iteeCore.DefaultLogger.log( list );
	    }

	}

	/**
	 *
	 * @type {Keys}
	 */
	TKeyboardController.k = Keys;

	/**
	 *
	 * @type {{}}
	 */
	TKeyboardController.status = {};

	/* eslint-env browser */

	/**
	 * @class
	 * @classdesc TMouseController allow single source of thruth for mouse state checking
	 * @author [Tristan Valcke]{@link https://github.com/Itee}
	 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
	 * @example
	 * (1) create a global variable:
	 *      var keyboard = new TKeyboardController();
	 * (2) during main loop:
	 *       keyboard.update();
	 * (3) check state of keys:
	 *       keyboard.down("A")    -- true for one update cycle after key is pressed
	 *       keyboard.pressed("A") -- true as long as key is being pressed
	 *       keyboard.up("A")      -- true for one update cycle after key is released
	 *
	 *  See TKeyboardController.k object data below for names of keys whose state can be polled
	 */
	class TMouseController {

	    /**
	     * @constructor
	     */
	    constructor ( /*parameters = {}*/ ) {

	    }

	}

	/* eslint-env browser */

	/**
	 * @typedef {Enum} Endianness
	 * @property {Boolean} Little=true - The Little endianess
	 * @property {Number} Big=false - The Big endianess
	 *
	 * @constant
	 * @type {Endianness}
	 * @description Endianness enum allow semantic usage.
	 */
	const Endianness = iteeUtils.toEnum( {
	    Little: true,
	    Big:    false
	} );

	/**
	 * @typedef {Enum} Byte
	 * @property {Number} One=1 - Octet
	 * @property {Number} Two=2 - Doublet
	 * @property {Number} Four=4 - Quadlet
	 * @property {Number} Height=8 - Octlet
	 *
	 * @constant
	 * @type {Byte}
	 * @description Byte allow semantic meaning of quantity of bytes based on power of two.
	 */
	const Byte = iteeUtils.toEnum( {
	    One:   1,
	    Two:   2,
	    Four:  4,
	    Eight: 8
	} );


	/**
	 * @class
	 * @classdesc TBinaryReader is design to perform fast binary read/write
	 *
	 * @author [Tristan Valcke]{@link https://github.com/Itee}
	 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
	 */
	class TBinaryReader {

	    /**
	     * @constructor
	     * @param [parameters]
	     * @param parameters.buffer
	     * @param parameters.offset
	     * @param parameters.length
	     * @param parameters.endianness
	     */
	    constructor ( parameters = {} ) {

	        const _parameters = {
	            ...{
	                buffer:     new ArrayBuffer( 0 ),
	                offset:     0,
	                length:     0,
	                endianness: Endianness.Little
	            },
	            ...parameters
	        };

	        this.buffer = _parameters.buffer;
	        //        this.offset     = _parameters.offset
	        //        this.length     = _parameters.length
	        this.endianness = _parameters.endianness;

	        // For bit reading use same approche than byte
	        this._bits = {
	            buffer: null,
	            offset: 0,
	            length: 0
	        };

	        this._updateDataView();

	    }

	    /**
	     *
	     * @returns {*}
	     */
	    get buffer () {
	        return this._buffer
	    }

	    set buffer ( value ) {

	        const memberName = 'Buffer';
	        const expect     = 'Expect an instance of ArrayBuffer.';

	        if ( iteeValidators.isNull( value ) ) { throw new TypeError( `${ memberName } cannot be null ! ${ expect }` ) }
	        if ( iteeValidators.isUndefined( value ) ) { throw new TypeError( `${ memberName } cannot be undefined ! ${ expect }` ) }
	        if ( iteeValidators.isNotArrayBuffer( value ) ) { throw new TypeError( `${ memberName } cannot be an instance of ${ value.constructor.name } ! ${ expect }` ) }

	        this._buffer = value;
	        this._offset = 0;
	        this._length = value.byteLength;

	        this._updateDataView();

	    }

	    /**
	     *
	     * @returns {*}
	     */
	    get offset () {
	        return this._offset
	    }

	    set offset ( value ) {

	        const memberName = 'Offset';
	        const expect     = 'Expect a number.';

	        if ( iteeValidators.isNull( value ) ) { throw new TypeError( `${ memberName } cannot be null ! ${ expect }` ) }
	        if ( iteeValidators.isUndefined( value ) ) { throw new TypeError( `${ memberName } cannot be undefined ! ${ expect }` ) }
	        if ( iteeValidators.isNotNumber( value ) ) { throw new TypeError( `${ memberName } cannot be an instance of ${ value.constructor.name } ! ${ expect }` ) }

	        this._offset = value;

	        this._updateDataView();

	    }

	    get length () {
	        return this._length
	    }

	    /**
	     *
	     * @param value
	     */
	    set length ( value ) {

	        const memberName = 'Length';
	        const expect     = 'Expect a number.';

	        if ( iteeValidators.isNull( value ) ) { throw new TypeError( `${ memberName } cannot be null ! ${ expect }` ) }
	        if ( iteeValidators.isUndefined( value ) ) { throw new TypeError( `${ memberName } cannot be undefined ! ${ expect }` ) }
	        if ( iteeValidators.isNotNumber( value ) ) { throw new TypeError( `${ memberName } cannot be an instance of ${ value.constructor.name } ! ${ expect }` ) }

	        this._length = value;

	        this._updateDataView();

	    }

	    /**
	     *
	     * @returns {*}
	     */
	    get endianness () {
	        return this._endianness
	    }

	    set endianness ( value ) {

	        const memberName = 'Endianness';
	        const expect     = 'Expect a boolean.';

	        if ( iteeValidators.isNull( value ) ) { throw new TypeError( `${ memberName } cannot be null ! ${ expect }` ) }
	        if ( iteeValidators.isUndefined( value ) ) { throw new TypeError( `${ memberName } cannot be undefined ! ${ expect }` ) }
	        if ( iteeValidators.isNotBoolean( value ) ) { throw new TypeError( `${ memberName } cannot be an instance of ${ value.constructor.name } ! ${ expect }` ) }

	        this._endianness = value;
	    }

	    /**
	     *
	     * @param buffer
	     * @param offset
	     * @param length
	     * @returns {TBinaryReader}
	     */
	    setBuffer ( buffer, offset, length ) {

	        this.buffer = buffer;
	        this.offset = offset || 0;
	        this.length = length || buffer.byteLength;

	        return this

	    }

	    /**
	     *
	     * @param value
	     * @returns {TBinaryReader}
	     */
	    setOffset ( value ) {

	        this.offset = value;
	        return this

	    }

	    /**
	     *
	     * @param value
	     * @returns {TBinaryReader}
	     */
	    setLength ( value ) {

	        this.length = value;
	        return this

	    }

	    /**
	     *
	     * @param endianess
	     * @returns {TBinaryReader}
	     */
	    setEndianess ( endianess ) {

	        this.endianness = endianess;
	        return this

	    }

	    /**
	     *
	     * @param increment
	     * @returns {*}
	     * @private
	     */
	    _getAndUpdateOffsetBy ( increment ) {

	        const currentOffset = this._offset;
	        this._offset += increment;
	        return currentOffset

	    }

	    /**
	     *
	     * @private
	     */
	    _updateDataView () {

	        this._dataView = new DataView( this._buffer, this._offset, this._length );

	    }

	    /**
	     *
	     * @returns {boolean}
	     */
	    isEndOfFile () {

	        return ( this._offset === this._length )

	    }

	    // Bits

	    _isNullBitBuffer () {

	        return this._bits.buffer === null

	    }
	    _nextBit () {
	        this._bits.offset += 1;
	    }
	    _isEndOfBitBuffer () {

	        return this._bits.offset === this._bits.length

	    }
	    _isOutOfRangeBitOffset( offset ) {
	        return offset > this._bits.length
	    }
	    _readBit8() {
	        this._bits.buffer = this.getUint8();
	        this._bits.length = 8;
	        this._bits.offset = 0;
	    }
	    _readBit16() {
	        this._bits.buffer = this.getUint16();
	        this._bits.length = 16;
	        this._bits.offset = 0;
	    }
	    _readBit32() {
	        this._bits.buffer = this.getUint32();
	        this._bits.length = 32;
	        this._bits.offset = 0;
	    }
	    _getBitAt ( bitOffset ) {

	        return ( this._bits.buffer & ( 1 << bitOffset ) ) === 0 ? 0 : 1

	    }
	    _resetBits () {
	        this._bits.buffer = null;
	        this._bits.length = 0;
	        this._bits.offset = 0;
	    }

	    skipBitOffsetTo ( bitOffset ) {
	        //todo is positive bitoffset

	        // In case we start directly by a skip offset try to determine which kind of data is expected
	        if ( this._isNullBitBuffer() ) {

	            if (bitOffset <= 8) {

	                this._readBit8();

	            } else if (8 < bitOffset && bitOffset <= 16 ){

	                this._readBit16();

	            } else if (16 < bitOffset && bitOffset <= 32 ){

	                this._readBit32();

	            } else {

	                throw new RangeError( 'You cannot skip more than 32 bits. Please use skipOffsetOf instead !' )

	            }

	        }
	        else if ( this._isOutOfRangeBitOffset(bitOffset) ) { throw new RangeError( 'Bit offset is out of range of the current bits field.' ) }

	        this._bits.offset = bitOffset;
	        if(this._isEndOfBitBuffer()) {
	            this._resetBits();
	        }

	    }

	    skipBitOffsetOf ( nBits ) {

	        this.skipBitOffsetTo(this._bits.offset + nBits);

	    }

	    getBit8 ( moveNext = true ) {

	        if ( this._isNullBitBuffer() ) {
	            this._readBit8();
	        }

	        const bitValue = this._getBitAt( this._bits.offset );

	        if ( moveNext ) {
	            this._nextBit();
	            if ( this._isEndOfBitBuffer() ) {
	                this._resetBits();
	            }
	        }

	        return bitValue

	    }

	    getBits8 ( numberOfBitToRead, moveNext = true ) {

	        const currentOffset = this._bits.offset;

	        let bits = 0;

	        // In last turn avoid bits reset if move next is false,
	        // else the skipBitOffset will be based on reseted/null bit buffer
	        for ( let i = 0 ; i < numberOfBitToRead ; i++ ) {
	            if ( i === numberOfBitToRead - 1 ) {
	                bits |= ( this.getBit8( moveNext ) << i );
	            } else {
	                bits |= ( this.getBit8() << i );
	            }
	        }

	        if ( !moveNext ) {
	            this.skipBitOffsetTo( currentOffset );
	        }

	        return bits

	    }

	    getBit16 ( moveNext = true ) {

	        if ( this._isNullBitBuffer() ) {
	            this._readBit16();
	        }

	        const bitValue = this._getBitAt( this._bits.offset );

	        if ( moveNext ) {
	            this._nextBit();
	            if ( this._isEndOfBitBuffer() ) {
	                this._resetBits();
	            }
	        }

	        return bitValue

	    }

	    getBits16 ( numberOfBitToRead, moveNext = true ) {

	        const currentOffset = this._bits.offset;

	        let bits = 0;

	        // In last turn avoid bits reset if move next is false,
	        // else the skipBitOffset will be based on reseted/null bit buffer
	        for ( let i = 0 ; i < numberOfBitToRead ; i++ ) {
	            if ( i === numberOfBitToRead - 1 ) {
	                bits |= ( this.getBit16( moveNext ) << i );
	            } else {
	                bits |= ( this.getBit16() << i );
	            }
	        }

	        if ( !moveNext ) {
	            this.skipBitOffsetTo( currentOffset );
	        }

	        return bits

	    }

	    getBit32 ( moveNext = true ) {

	        if ( this._isNullBitBuffer() ) {
	            this._readBit32();
	        }

	        const bitValue = this._getBitAt( this._bits.offset );

	        if ( moveNext ) {
	            this._nextBit();
	            if ( this._isEndOfBitBuffer() ) {
	                this._resetBits();
	            }
	        }

	        return bitValue

	    }

	    getBits32 ( numberOfBitToRead, moveNext = true ) {

	        const currentOffset = this._bits.offset;

	        let bits = 0;

	        // In last turn avoid bits reset if move next is false,
	        // else the skipBitOffset will be based on reseted/null bit buffer
	        for ( let i = 0 ; i < numberOfBitToRead ; i++ ) {
	            if ( i === numberOfBitToRead - 1 ) {
	                bits |= ( this.getBit32( moveNext ) << i );
	            } else {
	                bits |= ( this.getBit32() << i );
	            }
	        }

	        if ( !moveNext ) {
	            this.skipBitOffsetTo( currentOffset );
	        }

	        return bits

	    }

	    // Bytes

	    /**
	     *
	     * @param offset
	     */
	    skipOffsetTo ( offset ) {

	        this._offset = offset;

	    }

	    /**
	     *
	     * @param nBytes
	     */
	    skipOffsetOf ( nBytes ) {

	        this._offset += nBytes;

	    }

	    /**
	     *
	     * @returns {boolean}
	     */
	    getBoolean ( moveNext = true ) {

	        return ( ( this.getUint8( moveNext ) & 1 ) === 1 )

	    }

	    /**
	     *
	     * @param length
	     * @param moveNext
	     * @returns {Array}
	     */
	    getBooleanArray ( length, moveNext = true ) {

	        const currentOffset = this._offset;
	        const array         = [];

	        for ( let i = 0 ; i < length ; i++ ) {

	            array.push( this.getBoolean() );

	        }

	        if ( !moveNext ) {
	            this._offset = currentOffset;
	        }

	        return array

	    }

	    /**
	     *
	     * @returns {number}
	     */
	    getInt8 ( moveNext = true ) {

	        const offset = ( moveNext ) ? this._getAndUpdateOffsetBy( Byte.One ) : this._offset;
	        return this._dataView.getInt8( offset )

	    }

	    /**
	     *
	     * @param length
	     * @param moveNext
	     * @returns {Array}
	     */
	    getInt8Array ( length, moveNext = true ) {

	        const currentOffset = this._offset;
	        const array         = [];

	        for ( let i = 0 ; i < length ; i++ ) {

	            array.push( this.getInt8() );

	        }

	        if ( !moveNext ) {
	            this._offset = currentOffset;
	        }

	        return array

	    }

	    /**
	     *
	     * @returns {number}
	     */
	    getUint8 ( moveNext = true ) {

	        const offset = ( moveNext ) ? this._getAndUpdateOffsetBy( Byte.One ) : this._offset;
	        return this._dataView.getUint8( offset )

	    }

	    /**
	     *
	     * @param length
	     * @param moveNext
	     * @returns {Array}
	     */
	    getUint8Array ( length, moveNext = true ) {

	        const currentOffset = this._offset;
	        const array         = [];

	        for ( let i = 0 ; i < length ; i++ ) {

	            array.push( this.getUint8() );

	        }

	        if ( !moveNext ) {
	            this._offset = currentOffset;
	        }

	        return array

	    }

	    /**
	     *
	     * @returns {number}
	     */
	    getInt16 ( moveNext = true ) {

	        const offset = ( moveNext ) ? this._getAndUpdateOffsetBy( Byte.Two ) : this._offset;
	        return this._dataView.getInt16( offset, this._endianness )

	    }

	    /**
	     *
	     * @param length
	     * @param moveNext
	     * @returns {Array}
	     */
	    getInt16Array ( length, moveNext = true ) {

	        const currentOffset = this._offset;
	        const array         = [];

	        for ( let i = 0 ; i < length ; i++ ) {

	            array.push( this.getInt16() );

	        }

	        if ( !moveNext ) {
	            this._offset = currentOffset;
	        }

	        return array

	    }

	    /**
	     *
	     * @returns {number}
	     */
	    getUint16 ( moveNext = true ) {

	        const offset = ( moveNext ) ? this._getAndUpdateOffsetBy( Byte.Two ) : this._offset;
	        return this._dataView.getUint16( offset, this._endianness )

	    }

	    /**
	     *
	     * @param length
	     * @param moveNext
	     * @returns {Array}
	     */
	    getUint16Array ( length, moveNext = true ) {

	        const currentOffset = this._offset;
	        const array         = [];

	        for ( let i = 0 ; i < length ; i++ ) {

	            array.push( this.getUint16() );

	        }

	        if ( !moveNext ) {
	            this._offset = currentOffset;
	        }

	        return array

	    }

	    /**
	     *
	     * @returns {number}
	     */
	    getInt32 ( moveNext = true ) {

	        const offset = ( moveNext ) ? this._getAndUpdateOffsetBy( Byte.Four ) : this._offset;
	        return this._dataView.getInt32( offset, this._endianness )

	    }

	    /**
	     *
	     * @param length
	     * @param moveNext
	     * @returns {Array}
	     */
	    getInt32Array ( length, moveNext = true ) {

	        const currentOffset = this._offset;
	        const array         = [];

	        for ( let i = 0 ; i < length ; i++ ) {

	            array.push( this.getInt32() );

	        }

	        if ( !moveNext ) {
	            this._offset = currentOffset;
	        }

	        return array

	    }

	    /**
	     *
	     * @returns {number}
	     */
	    getUint32 ( moveNext = true ) {

	        const offset = ( moveNext ) ? this._getAndUpdateOffsetBy( Byte.Four ) : this._offset;
	        return this._dataView.getUint32( offset, this._endianness )

	    }

	    /**
	     *
	     * @param length
	     * @param moveNext
	     * @returns {Array}
	     */
	    getUint32Array ( length, moveNext = true ) {

	        const currentOffset = this._offset;
	        const array         = [];

	        for ( let i = 0 ; i < length ; i++ ) {

	            array.push( this.getUint32() );

	        }

	        if ( !moveNext ) {
	            this._offset = currentOffset;
	        }

	        return array

	    }

	    /**
	     *
	     * @returns {number}
	     */
	    getInt64 ( moveNext = true ) {

	        // From THREE.FBXLoader
	        // JavaScript doesn't support 64-bit integer so attempting to calculate by ourselves.
	        // 1 << 32 will return 1 so using multiply operation instead here.
	        // There'd be a possibility that this method returns wrong value if the value
	        // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
	        // TODO: safely handle 64-bit integer

	        let low  = null;
	        let high = null;

	        if ( this._endianness === Endianness.Little ) {

	            if ( moveNext ) {
	                low  = this.getUint32();
	                high = this.getUint32();
	            } else {
	                const currentOffset = this._offset;
	                low                 = this.getUint32();
	                high                = this.getUint32();
	                this.skipOffsetTo( currentOffset );
	            }

	        } else {

	            if ( moveNext ) {
	                high = this.getUint32();
	                low  = this.getUint32();
	            } else {
	                const currentOffset = this._offset;
	                high                = this.getUint32();
	                low                 = this.getUint32();
	                this.skipOffsetTo( currentOffset );
	            }

	        }

	        // calculate negative value
	        if ( high & 0x80000000 ) {

	            high = ~high & 0xFFFFFFFF;
	            low  = ~low & 0xFFFFFFFF;

	            if ( low === 0xFFFFFFFF ) {
	                high = ( high + 1 ) & 0xFFFFFFFF;
	            }

	            low = ( low + 1 ) & 0xFFFFFFFF;

	            return -( high * 0x100000000 + low )

	        }

	        return high * 0x100000000 + low

	    }

	    /**
	     *
	     * @param length
	     * @param moveNext
	     * @returns {Array}
	     */
	    getInt64Array ( length, moveNext = true ) {

	        const currentOffset = this._offset;
	        const array         = [];

	        for ( let i = 0 ; i < length ; i++ ) {

	            array.push( this.getInt64() );

	        }

	        if ( !moveNext ) {
	            this._offset = currentOffset;
	        }

	        return array

	    }


	    /**
	     *
	     * @returns {number}
	     */
	    getUint64 ( moveNext = true ) {
	        // Note: see getInt64() comment

	        let low  = null;
	        let high = null;

	        if ( this._endianness === Endianness.Little ) {

	            if ( moveNext ) {
	                low  = this.getUint32();
	                high = this.getUint32();
	            } else {
	                const currentOffset = this._offset;
	                low                 = this.getUint32();
	                high                = this.getUint32();
	                this.skipOffsetTo( currentOffset );
	            }

	        } else {

	            if ( moveNext ) {
	                high = this.getUint32();
	                low  = this.getUint32();
	            } else {
	                const currentOffset = this._offset;
	                high                = this.getUint32();
	                low                 = this.getUint32();
	                this.skipOffsetTo( currentOffset );
	            }

	        }

	        return high * 0x100000000 + low

	    }

	    /**
	     *
	     * @param length
	     * @param moveNext
	     * @returns {Array}
	     */
	    getUint64Array ( length, moveNext = true ) {

	        const currentOffset = this._offset;
	        const array         = [];

	        for ( let i = 0 ; i < length ; i++ ) {

	            array.push( this.getUint64() );

	        }

	        if ( !moveNext ) {
	            this._offset = currentOffset;
	        }

	        return array

	    }

	    /**
	     *
	     * @returns {number}
	     */
	    getFloat32 ( moveNext = true ) {

	        const offset = ( moveNext ) ? this._getAndUpdateOffsetBy( Byte.Four ) : this._offset;
	        return this._dataView.getFloat32( offset, this._endianness )

	    }

	    /**
	     *
	     * @param length
	     * @param moveNext
	     * @returns {Array}
	     */
	    getFloat32Array ( length, moveNext = true ) {

	        const currentOffset = this._offset;
	        const array         = [];

	        for ( let i = 0 ; i < length ; i++ ) {

	            array.push( this.getFloat32() );

	        }

	        if ( !moveNext ) {
	            this._offset = currentOffset;
	        }

	        return array

	    }

	    /**
	     *
	     * @return {number}
	     */
	    getFloat64 ( moveNext = true ) {

	        const offset = ( moveNext ) ? this._getAndUpdateOffsetBy( Byte.Eight ) : this._offset;
	        return this._dataView.getFloat64( offset, this._endianness )

	    }

	    /**
	     *
	     * @param length
	     * @param moveNext
	     * @returns {Array}
	     */
	    getFloat64Array ( length, moveNext = true ) {

	        const currentOffset = this._offset;
	        const array         = [];

	        for ( let i = 0 ; i < length ; i++ ) {

	            array.push( this.getFloat64() );

	        }

	        if ( !moveNext ) {
	            this._offset = currentOffset;
	        }

	        return array

	    }

	    /**
	     *
	     * @returns {string}
	     */
	    getChar ( moveNext = true ) {

	        return String.fromCharCode( this.getUint8( moveNext ) )

	    }

	    /**
	     *
	     * @param length
	     * @param moveNext
	     * @return {string}
	     */
	    getString ( length, moveNext = true ) {

	        const currentOffset = this._offset;
	        let string          = '';

	        for ( let i = 0 ; i < length ; i++ ) {
	            string += String.fromCharCode( this.getUint8() );
	        }

	        if ( !moveNext ) {
	            this._offset = currentOffset;
	        }

	        return string

	    }

	    /**
	     *
	     * @param size
	     * @returns {ArrayBuffer}
	     */
	    getArrayBuffer ( size ) {

	        const offset = this._getAndUpdateOffsetBy( size );
	        return this._dataView.buffer.slice( offset, offset + size )

	    }

	}

	/**
	 * @author [Tristan Valcke]{@link https://github.com/Itee}
	 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
	 *
	 * @class TDataBaseManager
	 * @classdesc The base class of database managers. Give the basic interface about database call.
	 *
	 * @requires {@link HttpVerb}
	 * @requires {@link ResponseType}
	 * @requires {@link HttpStatusCode}
	 * @requires {@link TOrchestrator}
	 * @requires {@link TStore}
	 *
	 * @example Todo
	 *
	 */


	/**
	 * @deprecated
	 */
	class IdGenerator {

	    constructor () {
	        this._id = 0;
	    }

	    get id () {
	        this._id += 1;
	        return this._id
	    }

	}

	const Generate = new IdGenerator();

	/**
	 *
	 * @type {ReadonlyArray<unknown>}
	 */
	const RequestType = iteeUtils.toEnum( {
	    CreateOne:   0,
	    CreateMany:  1,
	    ReadOne:     2,
	    ReadMany:    3,
	    ReadWhere:   4,
	    ReadAll:     5,
	    UpdateOne:   6,
	    UpdateMany:  7,
	    UpdateWhere: 8,
	    UpdateAll:   9,
	    DeleteOne:   10,
	    DeleteMany:  11,
	    DeleteWhere: 12,
	    DeleteAll:   13
	} );

	/**
	 * @class
	 */
	class TDataBaseManager {

	    /**
	     *
	     * @returns {number}
	     */
	    static get requestId () {
	        TDataBaseManager._requestId++;
	        return TDataBaseManager._requestId
	    }
	    /**
	     *
	     * @param parameters
	     */
	    constructor ( parameters = {} ) {

	        const _parameters = {
	            ...{
	                basePath:               '/',
	                responseType:           ResponseType.Json,
	                bunchSize:              500,
	                requestAggregationTime: 200,
	                requestsConcurrency:    6,
	                logger:                 iteeCore.DefaultLogger
	            }, ...parameters
	        };

	        this.basePath               = _parameters.basePath;
	        this.responseType           = _parameters.responseType;
	        this.bunchSize              = _parameters.bunchSize;
	        this.requestAggregationTime = _parameters.requestAggregationTime;
	        this.requestsConcurrency    = _parameters.requestsConcurrency;
	        this.logger                 = _parameters.logger;

	        this._cache                = new TStore();
	        this._waitingQueue         = [];
	        this._aggregateQueue       = [];
	        this._requestQueue         = [];
	        this._processQueue         = [];
	        this._aggregationTimeoutId = null;

	        this._idToRequest = [];

	    }
	    /**
	     *
	     * @returns {*}
	     */
	    get basePath () {
	        return this._basePath
	    }

	    set basePath ( value ) {

	        if ( iteeValidators.isNull( value ) ) { throw new TypeError( 'Base path cannot be null ! Expect a non empty string.' ) }
	        if ( iteeValidators.isUndefined( value ) ) { throw new TypeError( 'Base path cannot be undefined ! Expect a non empty string.' ) }
	        if ( iteeValidators.isNotString( value ) ) { throw new TypeError( `Base path cannot be an instance of ${ value.constructor.name } ! Expect a non empty string.` ) }
	        if ( iteeValidators.isEmptyString( value ) ) { throw new TypeError( 'Base path cannot be empty ! Expect a non empty string.' ) }
	        if ( iteeValidators.isBlankString( value ) ) { throw new TypeError( 'Base path cannot contain only whitespace ! Expect a non empty string.' ) }

	        this._basePath = value;

	    }

	    /**
	     *
	     * @returns {*}
	     */
	    get responseType () {
	        return this._responseType
	    }

	    set responseType ( value ) {

	        if ( iteeValidators.isNull( value ) ) { throw new Error( 'TDataBaseManager: responseType cannot be null !' ) }
	        if ( iteeValidators.isNull( value ) ) { throw new TypeError( 'Response type cannot be null ! Expect a non empty string.' ) }
	        if ( iteeValidators.isUndefined( value ) ) { throw new TypeError( 'Response type cannot be undefined ! Expect a non empty string.' ) }
	        //        if ( !( value instanceof ResponseType ) ) { throw new TypeError( `Response type cannot be an instance of ${value.constructor.name} ! Expect a value from ResponseType enum.` ) }

	        this._responseType = value;

	    }

	    /**
	     *
	     * @returns {*}
	     */
	    get bunchSize () {
	        return this._bunchSize
	    }

	    set bunchSize ( value ) {

	        if ( iteeValidators.isNull( value ) ) { throw new TypeError( 'Bunch size cannot be null ! Expect a positive number.' ) }
	        if ( iteeValidators.isUndefined( value ) ) { throw new TypeError( 'Bunch size cannot be undefined ! Expect a positive number.' ) }
	        if ( iteeValidators.isNotNumber( value ) ) { throw new TypeError( `Bunch size cannot be an instance of ${ value.constructor.name } ! Expect a positive number.` ) }
	        if ( !iteeValidators.isNumberPositive( value ) ) { throw new TypeError( `Bunch size cannot be lower or equal to zero ! Expect a positive number.` ) }

	        this._bunchSize = value;

	    }

	    /**
	     *
	     * @returns {*}
	     */
	    get requestAggregationTime () {
	        return this._requestAggregationTime
	    }

	    set requestAggregationTime ( value ) {

	        if ( iteeValidators.isNull( value ) ) {
	            throw new TypeError( 'Requests aggregation time cannot be null ! Expect a positive number.' )
	        }

	        if ( iteeValidators.isUndefined( value ) ) {
	            throw new TypeError( 'Requests aggregation time cannot be undefined ! Expect a positive number.' )
	        }

	        if ( iteeValidators.isNotNumber( value ) ) {
	            throw new TypeError( `Requests aggregation time cannot be an instance of ${ value.constructor.name } ! Expect a positive number.` )
	        }

	        if ( iteeValidators.isNumberNegative( value ) ) {
	            throw new TypeError( 'Requests aggregation time cannot be lower or equal to zero ! Expect a positive number.' )
	        }

	        this._requestAggregationTime = value;

	    }

	    /**
	     *
	     * @returns {*}
	     */
	    get requestsConcurrency () {
	        return this._requestsConcurrency
	    }

	    set requestsConcurrency ( value ) {

	        if ( iteeValidators.isNull( value ) ) {
	            throw new TypeError( 'Minimum of simultaneous request cannot be null ! Expect a positive number.' )
	        }

	        if ( iteeValidators.isUndefined( value ) ) {
	            throw new TypeError( 'Minimum of simultaneous request cannot be undefined ! Expect a positive number.' )
	        }

	        if ( iteeValidators.isNotNumber( value ) ) {
	            throw new TypeError( `Minimum of simultaneous request cannot be an instance of ${ value.constructor.name } ! Expect a positive number.` )
	        }

	        if ( iteeValidators.isZero( value ) || iteeValidators.isNumberNegative( value ) ) {
	            throw new TypeError( 'Minimum of simultaneous request cannot be lower or equal to zero ! Expect a positive number.' )
	        }

	        this._requestsConcurrency = value;

	    }

	    /**
	     *
	     * @returns {TLogger}
	     */
	    get logger () {
	        return this._logger
	    }

	    set logger ( value ) {

	        if ( iteeValidators.isNull( value ) ) { throw new TypeError( 'Progress manager cannot be null ! Expect an instance of TProgressManager.' ) }
	        if ( iteeValidators.isUndefined( value ) ) { throw new TypeError( 'Progress manager cannot be undefined ! Expect an instance of TProgressManager.' ) }
	        if ( !( value instanceof iteeCore.TLogger ) ) { throw new TypeError( `Progress manager cannot be an instance of ${ value.constructor.name } ! Expect an instance of TProgressManager.` ) }

	        this._logger = value;

	    }

	    /**
	     *
	     * @param value
	     * @returns {TDataBaseManager}
	     */
	    setBasePath ( value ) {

	        this.basePath = value;
	        return this

	    }

	    /**
	     *
	     * @param value
	     * @returns {TDataBaseManager}
	     */
	    setResponseType ( value ) {

	        this.responseType = value;
	        return this

	    }

	    /**
	     *
	     * @param value
	     * @returns {TDataBaseManager}
	     */
	    setBunchSize ( value ) {

	        this.bunchSize = value;
	        return this

	    }

	    /**
	     *
	     * @param value
	     * @returns {TDataBaseManager}
	     */
	    setRequestAggregationTime ( value ) {

	        this.requestAggregationTime = value;
	        return this

	    }

	    /**
	     *
	     * @param value
	     * @returns {TDataBaseManager}
	     */
	    setRequestsConcurrency ( value ) {

	        this.requestsConcurrency = value;
	        return this

	    }

	    /**
	     *
	     * @param value
	     * @returns {TDataBaseManager}
	     */
	    setLogger ( value ) {

	        this.logger = value;
	        return this

	    }

	    /**
	     *
	     */
	    aggregateQueue () {

	        clearTimeout( this._aggregationTimeoutId );

	        this._aggregationTimeoutId = setTimeout( () => {

	            const datasToRequest = this._idToRequest;
	            let idBunch          = [];
	            for ( let idIndex = datasToRequest.length - 1 ; idIndex >= 0 ; idIndex-- ) {

	                idBunch.push( datasToRequest.pop() );

	                if ( idBunch.length === this._bunchSize || idIndex === 0 ) {

	                    this._requestQueue.push( {
	                        _id:        `readMany_${ Generate.id }`,
	                        _timeStart: new Date(),
	                        _type:      RequestType.ReadMany,
	                        method:     HttpVerb.Read.value,
	                        url:        this._basePath,
	                        data:       {
	                            ids: idBunch
	                        },
	                        responseType: this._responseType
	                    } );

	                    idBunch = [];
	                }

	            }

	            this.processQueue.call( this );

	        }, this._requestAggregationTime );

	    }

	    /**
	     *
	     */
	    processQueue () {

	        while ( this._requestQueue.length > 0 && this._processQueue.length < this._requestsConcurrency ) {

	            const requestSkull = this._requestQueue.pop();
	            this._processQueue.push( requestSkull );

	            const request              = new XMLHttpRequest();
	            request.onloadstart        = _onLoadStart.bind( this );
	            request.onload             = this._onLoad.bind( this,
	                requestSkull,
	                this._onEnd.bind( this, requestSkull, requestSkull.onLoad ),
	                this._onProgress.bind( this, requestSkull.onProgress ),
	                this._onError.bind( this, requestSkull, requestSkull.onError )
	            );
	            request.onloadend          = _onLoadEnd.bind( this );
	            request.onprogress         = this._onProgress.bind( this, requestSkull.onProgress );
	            request.onreadystatechange = _onReadyStateChange.bind( this );
	            request.onabort            = _onAbort.bind( this );
	            request.onerror            = this._onError.bind( this, requestSkull, requestSkull.onError );
	            request.ontimeout          = _onTimeout.bind( this );
	            request.open( requestSkull.method, requestSkull.url, true );
	            request.setRequestHeader( 'Content-Type', 'application/json' );
	            request.setRequestHeader( 'Accept', 'application/json' );
	            request.responseType = requestSkull.responseType.value;

	            const dataToSend = ( requestSkull.data && requestSkull.responseType === ResponseType.Json ) ? JSON.stringify( requestSkull.data ) : requestSkull.data;
	            request.send( dataToSend );

	        }

	        function _onLoadStart ( loadStartEvent ) { this.logger.progress( loadStartEvent ); }

	        function _onLoadEnd ( loadEndEvent ) { this.logger.progress( loadEndEvent ); }

	        function _onReadyStateChange ( readyStateEvent ) { this.logger.debug( readyStateEvent ); }

	        function _onAbort ( abortEvent ) { this.logger.error( abortEvent ); }

	        function _onTimeout ( timeoutEvent ) { this.logger.error( timeoutEvent ); }

	    }

	    // Publics
	    /**
	     * The create method allow to create a new ressource on the server. Providing a single object that match a database schema, or an array of them.
	     *
	     * @param {object|array.<object>} data - The data to send for create new objects.
	     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
	     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
	     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
	     */
	    create ( data, onLoadCallback, onProgressCallback, onErrorCallback ) {

	        if ( iteeValidators.isArray( data ) && iteeValidators.isNotEmptyArray( data ) ) {

	            if ( iteeValidators.isArrayOfSingleElement( data ) ) {

	                this._createOne( data[ 0 ], onLoadCallback, onProgressCallback, onErrorCallback );

	            } else {

	                this._createMany( data, onLoadCallback, onProgressCallback, onErrorCallback );

	            }

	        } else if ( iteeValidators.isObject( data ) && iteeValidators.isNotEmptyObject( data ) ) {

	            this._createOne( data, onLoadCallback, onProgressCallback, onErrorCallback );

	        } else {

	            onErrorCallback( 'TDataBaseManager.create: Invalid data type, expect object or array of objects.' );

	        }

	    }

	    /**
	     * The read method allow to retrieve data from the server, using a single id or an array of them.
	     *
	     * @param {string|array.<string>} condition - The ids of objects to retrieve.
	     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
	     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
	     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
	     */
	    read ( condition, projection, onLoadCallback, onProgressCallback, onErrorCallback ) {

	        if ( iteeValidators.isString( condition ) && iteeValidators.isNotEmptyString( condition ) && iteeValidators.isNotBlankString( condition ) ) {

	            this._readOne( condition, projection, onLoadCallback, onProgressCallback, onErrorCallback );

	        } else if ( iteeValidators.isArray( condition ) && iteeValidators.isNotEmptyArray( condition ) ) {

	            if ( iteeValidators.isArrayOfSingleElement( condition ) ) {

	                this._readOne( condition[ 0 ], projection, onLoadCallback, onProgressCallback, onErrorCallback );

	            } else {

	                this._readMany( condition, projection, onLoadCallback, onProgressCallback, onErrorCallback );

	            }

	        } else if ( iteeValidators.isObject( condition ) ) {

	            if ( iteeValidators.isEmptyObject( condition ) ) {

	                this._readAll( projection, onLoadCallback, onProgressCallback, onErrorCallback );

	            } else {

	                this._readWhere( condition, projection, onLoadCallback, onProgressCallback, onErrorCallback );

	            }

	        } else {

	            onErrorCallback( 'TDataBaseManager.read: Invalid data type, expect string, object or array of objects.' );

	        }

	    }

	    /**
	     * The update method allow to update data on the server, using a single id or an array of them, and a corresponding object about the data to update.
	     *
	     * @param {string|array.<string>} condition - The ids of objects to update.
	     * @param {object} update - The update data ( need to match the related database schema ! ). In case of multiple ids they will be updated with the same given data.
	     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
	     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
	     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
	     */
	    update ( condition, update, onLoadCallback, onProgressCallback, onErrorCallback ) {

	        if ( iteeValidators.isNotDefined( update ) ) {
	            onErrorCallback( 'TDataBaseManager.update: Update data cannot be null or undefined !' );
	            return
	        }

	        if ( iteeValidators.isNotObject( update ) ) {
	            onErrorCallback( 'TDataBaseManager.update: Invalid update data type. Expect an object.' );
	            return
	        }

	        if ( iteeValidators.isString( condition ) && iteeValidators.isNotEmptyString( condition ) && iteeValidators.isNotBlankString( condition ) ) {

	            this._updateOne( condition, update, onLoadCallback, onProgressCallback, onErrorCallback );

	        } else if ( iteeValidators.isArray( condition ) && iteeValidators.isNotEmptyArray( condition ) ) {

	            if ( iteeValidators.isArrayOfSingleElement( condition ) ) {

	                this._updateOne( condition[ 0 ], update, onLoadCallback, onProgressCallback, onErrorCallback );

	            } else {

	                this._updateMany( condition, update, onLoadCallback, onProgressCallback, onErrorCallback );

	            }

	        } else if ( iteeValidators.isObject( condition ) ) {

	            if ( iteeValidators.isEmptyObject( condition ) ) {

	                this._updateAll( update, onLoadCallback, onProgressCallback, onErrorCallback );

	            } else {

	                this._updateWhere( condition, update, onLoadCallback, onProgressCallback, onErrorCallback );

	            }

	        } else {

	            onErrorCallback( 'TDataBaseManager.update: Invalid data type, expect string, object or array of objects.' );

	        }

	    }

	    /**
	     * The delete method allow to remove data from the server, using a single id or an array of them.
	     *
	     * @param {string|array.<string>|object|null} condition - The ids of objects to delete.
	     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
	     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
	     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
	     */
	    delete ( condition, onLoadCallback, onProgressCallback, onErrorCallback ) {

	        if ( iteeValidators.isString( condition ) && iteeValidators.isNotEmptyString( condition ) && iteeValidators.isNotBlankString( condition ) ) {

	            this._deleteOne( condition, onLoadCallback, onProgressCallback, onErrorCallback );

	        } else if ( iteeValidators.isArray( condition ) && iteeValidators.isNotEmptyArray( condition ) ) {

	            if ( iteeValidators.isArrayOfSingleElement( condition ) ) {

	                this._deleteOne( condition[ 0 ], onLoadCallback, onProgressCallback, onErrorCallback );

	            } else {

	                this._deleteMany( condition, onLoadCallback, onProgressCallback, onErrorCallback );

	            }

	        } else if ( iteeValidators.isObject( condition ) ) {

	            if ( iteeValidators.isEmptyObject( condition ) ) {

	                this._deleteAll( onLoadCallback, onProgressCallback, onErrorCallback );

	            } else {

	                this._deleteWhere( condition, onLoadCallback, onProgressCallback, onErrorCallback );

	            }

	        } else {

	            onErrorCallback( 'TDataBaseManager.delete: Invalid data type, expect null, string, object or array of objects.' );

	        }

	    }

	    // Privates

	    //// Events

	    /**
	     * The private _onLoad method allow to process the server response in an abstract way to check against error and wrong status code.
	     * It will bind user callback on each type of returns, and dispatch in sub methods in function of the response type.
	     *
	     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
	     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
	     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
	     * @param {object} loadEvent - The server response object to parse.
	     * @private
	     */
	    _onLoad ( request, onLoadCallback, onProgressCallback, onErrorCallback, loadEvent ) {

	        const target       = loadEvent.target;
	        const status       = target.status;
	        const response     = target.response;
	        const responseType = target.responseType;

	        switch ( status ) {

	            // 100
	            //            case HttpStatusCode.Continue.value:
	            //            case HttpStatusCode.SwitchingProtocols.value:
	            //            case HttpStatusCode.Processing.value:

	            // 200
	            case HttpStatusCode.Ok.value:
	                this._dispatchResponse( response, responseType, onLoadCallback, onProgressCallback, onErrorCallback );
	                break
	            //            case HttpStatusCode.Created.value:
	            //            case HttpStatusCode.Accepted.value:

	            case HttpStatusCode.NonAuthoritativeInformation.value:
	            case HttpStatusCode.NoContent.value:
	            case HttpStatusCode.ResetContent.value:
	            case HttpStatusCode.PartialContent.value:
	            case HttpStatusCode.MultiStatus.value:
	            case HttpStatusCode.AlreadyReported.value:
	            case HttpStatusCode.ContentDifferent.value:
	            case HttpStatusCode.IMUsed.value:
	            case HttpStatusCode.MultipleChoices.value:
	            case HttpStatusCode.MovedPermanently.value:
	            case HttpStatusCode.Found.value:
	            case HttpStatusCode.SeeOther.value:
	            case HttpStatusCode.NotModified.value:
	            case HttpStatusCode.UseProxy.value:
	            case HttpStatusCode.Unused.value:
	            case HttpStatusCode.TemporaryRedirect.value:
	            case HttpStatusCode.PermanentRedirect.value:
	            case HttpStatusCode.TooManyRedirects.value:
	            case HttpStatusCode.BadRequest.value:
	            case HttpStatusCode.Unauthorized.value:
	            case HttpStatusCode.PaymentRequired.value:
	            case HttpStatusCode.Forbidden.value:
	            case HttpStatusCode.NotFound.value:
	            case HttpStatusCode.MethodNotAllowed.value:
	            case HttpStatusCode.NotAcceptable.value:
	            case HttpStatusCode.ProxyAuthenticationRequired.value:
	            case HttpStatusCode.RequestTimeOut.value:
	            case HttpStatusCode.Conflict.value:
	            case HttpStatusCode.Gone.value:
	            case HttpStatusCode.LengthRequired.value:
	            case HttpStatusCode.PreconditionFailed.value:
	            case HttpStatusCode.RequestEntityTooLarge.value:
	            case HttpStatusCode.RequestRangeUnsatisfiable.value:
	            case HttpStatusCode.ExpectationFailed.value:
	            case HttpStatusCode.ImATeapot.value:
	            case HttpStatusCode.BadMapping.value:
	            case HttpStatusCode.UnprocessableEntity.value:
	            case HttpStatusCode.Locked.value:
	            case HttpStatusCode.MethodFailure.value:
	            case HttpStatusCode.UnorderedCollection.value:
	            case HttpStatusCode.UpgradeRequired.value:
	            case HttpStatusCode.PreconditionRequired.value:
	            case HttpStatusCode.TooManyRequests.value:
	            case HttpStatusCode.RequestHeaderFieldsTooLarge.value:
	            case HttpStatusCode.NoResponse.value:
	            case HttpStatusCode.RetryWith.value:
	            case HttpStatusCode.BlockedByWindowsParentalControls.value:
	            case HttpStatusCode.UnavailableForLegalReasons.value:
	            case HttpStatusCode.UnrecoverableError.value:
	            case HttpStatusCode.SSLCertificateError.value:
	            case HttpStatusCode.SSLCertificateRequired.value:
	            case HttpStatusCode.HTTPRequestSentToHTTPSPort.value:
	            case HttpStatusCode.ClientClosedRequest.value:
	            case HttpStatusCode.InternalServerError.value:
	            case HttpStatusCode.NotImplemented.value:
	            case HttpStatusCode.BadGateway.value:
	            case HttpStatusCode.ServiceUnavailable.value:
	            case HttpStatusCode.GatewayTimeOut.value:
	            case HttpStatusCode.HTTPVersionNotSupported.value:
	            case HttpStatusCode.VariantAlsoNegotiates.value:
	            case HttpStatusCode.InsufficientStorage.value:
	            case HttpStatusCode.LoopDetected.value:
	            case HttpStatusCode.BandwidthLimitExceeded.value:
	            case HttpStatusCode.NotExtended.value:
	            case HttpStatusCode.NetworkAuthenticationRequired.value:
	            case HttpStatusCode.UnknownError.value:
	            case HttpStatusCode.WebServerIsDown.value:
	            case HttpStatusCode.ConnectionTimedOut.value:
	            case HttpStatusCode.OriginIsUnreachable.value:
	            case HttpStatusCode.ATimeoutOccured.value:
	            case HttpStatusCode.SSLHandshakeFailed.value:
	            case HttpStatusCode.InvalidSSLCertificate.value:
	            case HttpStatusCode.RailgunError.value:
	                onErrorCallback( response );
	                break

	            default:
	                throw new RangeError( `Unmanaged HttpStatusCode: ${ status }` )

	        }

	    }

	    /**
	     * The private _onProgress method will handle all progress event from server and submit them to the logger if exist else to the user onProgressCallback
	     *
	     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
	     * @param {object} progressEvent - The server progress event.
	     * @private
	     */
	    _onProgress ( onProgressCallback, progressEvent ) {

	        if ( iteeValidators.isDefined( this.logger ) ) {

	            this.logger.progress( progressEvent, onProgressCallback );

	        } else if ( iteeValidators.isDefined( onProgressCallback ) ) {

	            onProgressCallback( progressEvent );

	        }

	    }

	    /**
	     * The private _onError method will handle all error event from server and submit them to the logger if exist else to the user onErrorCallback
	     *
	     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
	     * @param {object} errorEvent - A server error event
	     * @private
	     */
	    _onError ( request, onErrorCallback, errorEvent ) {

	        this._closeRequest( request );

	        if ( iteeValidators.isDefined( this.logger ) ) {

	            this.logger.error( errorEvent, onErrorCallback );

	        } else if ( iteeValidators.isDefined( onErrorCallback ) ) {

	            onErrorCallback( errorEvent );

	        }

	    }

	    /**
	     * The private _onEnd method is call after all other callback and perform request type checking in view to upadte cache, waitingqueue and callback if needed,
	     * to finally close the request
	     *
	     * @param request
	     * @param onLoadCallback
	     * @param response
	     * @private
	     */
	    _onEnd ( request, onLoadCallback, response ) {

	        const type = request._type;

	        switch ( type ) {

	            case RequestType.ReadOne:
	            case RequestType.ReadMany:
	                this._updateCache( response );
	                this._updateWaitingQueue();
	                break

	            case RequestType.ReadWhere:
	            case RequestType.ReadAll:
	                this._updateCache( response );
	                this._updateWaitingQueue();
	                onLoadCallback( response );
	                break

	            case RequestType.CreateOne:
	            case RequestType.CreateMany:
	            case RequestType.UpdateOne:
	            case RequestType.UpdateMany:
	            case RequestType.UpdateWhere:
	            case RequestType.UpdateAll:
	            case RequestType.DeleteOne:
	            case RequestType.DeleteMany:
	            case RequestType.DeleteWhere:
	            case RequestType.DeleteAll:
	                onLoadCallback( response );
	                break

	            default:
	                throw new RangeError( `Invalid request type: ${ type }` )

	        }

	        this._closeRequest( request );

	    }

	    //// Data parsing
	    // Expect that methods were reimplemented when TDataBaseManager is inherited

	    /**
	     * Dispatch response to the correct handler in function of response type
	     *
	     * @param response
	     * @param responseType
	     * @param onLoadCallback
	     * @param onProgressCallback
	     * @param onErrorCallback
	     * @private
	     */
	    _dispatchResponse ( response, responseType, onLoadCallback, onProgressCallback, onErrorCallback ) {

	        switch ( responseType ) {

	            case ResponseType.ArrayBuffer.value:
	                this._onArrayBuffer(
	                    response,
	                    onLoadCallback,
	                    onProgressCallback,
	                    onErrorCallback
	                );
	                break

	            case ResponseType.Blob.value:
	                this._onBlob(
	                    response,
	                    onLoadCallback,
	                    onProgressCallback,
	                    onErrorCallback
	                );
	                break

	            case ResponseType.Json.value:
	                this._onJson(
	                    response,
	                    onLoadCallback,
	                    onProgressCallback,
	                    onErrorCallback
	                );
	                break

	            case ResponseType.DOMString.value:
	            case ResponseType.Default.value:
	                this._onText(
	                    response,
	                    onLoadCallback,
	                    onProgressCallback,
	                    onErrorCallback
	                );
	                break

	            default:
	                throw new Error( `Unknown response type: ${ responseType }` )

	        }

	    }

	    /**
	     * Will remove the request from the process queue
	     *
	     * @param request
	     * @private
	     */
	    _closeRequest ( request ) {

	        this._processQueue.splice( this._processQueue.indexOf( request ), 1 );

	        if ( Window.Itee && Window.Itee.Debug ) {

	            const diff    = new Date().valueOf() - request._timeStart.valueOf();
	            const message = `${ this.constructor.name } close request [${ request._id }] on ${ diff }ms.` +
	                `Waiting queue: ${ this._waitingQueue.length }` +
	                `Request queue: ${ this._requestQueue.length }` +
	                `Process queue: ${ this._processQueue.length }` +
	                `==========================`;
	            this.logger.debug( message );

	        }

	        this.processQueue();

	    }

	    /**
	     *
	     * @param ids
	     * @returns {Object}
	     * @private
	     */
	    _retrieveCachedValues ( ids ) {

	        let results      = {};
	        let underRequest = [];
	        let toRequest    = [];

	        for ( let idIndex = 0, numberOfIds = ids.length ; idIndex < numberOfIds ; idIndex++ ) {

	            const id          = ids[ idIndex ];
	            const cachedValue = this._cache.get( id );

	            if ( iteeValidators.isDefined( cachedValue ) ) {
	                results[ id ] = cachedValue;
	            } else if ( iteeValidators.isNull( cachedValue ) ) { // In request
	                underRequest.push( id );
	            } else {
	                toRequest.push( id );
	            }

	        }

	        return {
	            results,
	            underRequest,
	            toRequest
	        }

	    }

	    /**
	     *
	     * @param datas
	     * @private
	     */
	    _updateCache ( datas ) {

	        if ( iteeValidators.isNull( datas ) ) { throw new TypeError( 'Data cannot be null ! Expect an array of object.' ) }
	        if ( iteeValidators.isUndefined( datas ) ) { throw new TypeError( 'Data cannot be undefined ! Expect an array of object.' ) }

	        let _datas = {};
	        if ( iteeValidators.isArray( datas ) ) {

	            for ( let key in datas ) {
	                _datas[ datas[ key ]._id ] = datas[ key ];
	            }

	        } else {

	            _datas = datas;

	        }

	        for ( let [ id, data ] of Object.entries( _datas ) ) {

	            const cachedResult = this._cache.get( id );

	            if ( iteeValidators.isNull( cachedResult ) ) {
	                this._cache.add( id, data, true );
	            } else if ( iteeValidators.isUndefined( cachedResult ) ) {
	                this.logger.warn( 'Cache was not pre-allocated with null value.' );
	                this._cache.add( id, data );
	            } else {
	                this.logger.error( 'Cached value already exist !' );
	            }

	        }

	    }

	    /**
	     *
	     * @private
	     */
	    _updateWaitingQueue () {

	        const haveNoRequestToProcess = ( this._requestQueue.length === 0 && this._processQueue.length === 0 );

	        for ( let requestIndex = this._waitingQueue.length - 1 ; requestIndex >= 0 ; requestIndex-- ) {

	            const demand = this._waitingQueue[ requestIndex ];

	            // Update requested datas
	            for ( let dataIndex = demand.underRequest.length - 1 ; dataIndex >= 0 ; dataIndex-- ) {

	                const id           = demand.underRequest[ dataIndex ];
	                const cachedResult = this._cache.get( id );

	                if ( iteeValidators.isNotDefined( cachedResult ) ) { continue }

	                // Assign the cached value
	                demand.results[ id ] = cachedResult;

	                // Remove the requested object that is now added
	                demand.underRequest.splice( demand.underRequest.indexOf( id ), 1 );

	            }

	            // Check if request is now fullfilled
	            const demandIsComplet = ( demand.underRequest.length === 0 );
	            if ( demandIsComplet ) {

	                this._waitingQueue.splice( requestIndex, 1 );
	                demand.onLoadCallback( demand.results );

	            } else if ( !demandIsComplet && haveNoRequestToProcess /* && haveTryAgainManyTimesButFail */ ) {

	                this.logger.warn( 'Incomplet demand but empty request/process queue' );
	                this._waitingQueue.splice( requestIndex, 1 );
	                demand.onLoadCallback( demand.results );

	            } else ;

	        }

	    }

	    /**
	     * The abstract private _onArrayBuffer method must be overridden in case the parser expect an array buffer as input data.
	     *
	     * @private
	     * @abstract
	     * @param {ArrayBuffer} data - The retrieved data to parse.
	     * @param {function} onSuccess - The onLoad callback, which is call when parser parse with success the data.
	     * @param {function} onProgress - The onProgress callback, which is call during the parsing.
	     * @param {function} onError - The onError callback, which is call when parser throw an error during parsing.
	     */
	    // eslint-disable-next-line no-unused-vars
	    _onArrayBuffer ( data, onSuccess, onProgress, onError ) {}

	    /**
	     * The abstract private _onBlob method must be overridden in case the parser expect a blob as input data.
	     *
	     * @private
	     * @abstract
	     * @param {Blob} data - The retrieved data to parse.
	     * @param {function} onSuccess - The onLoad callback, which is call when parser parse with success the data.
	     * @param {function} onProgress - The onProgress callback, which is call during the parsing.
	     * @param {function} onError - The onError callback, which is call when parser throw an error during parsing.
	     */
	    // eslint-disable-next-line no-unused-vars
	    _onBlob ( data, onSuccess, onProgress, onError ) {}

	    /**
	     * The abstract private _onJson method must be overridden in case the parser expect json as input data.
	     *
	     * @private
	     * @abstract
	     * @param {json} data - The retrieved data to parse.
	     * @param {function} onSuccess - The onLoad callback, which is call when parser parse with success the data.
	     * @param {function} onProgress - The onProgress callback, which is call during the parsing.
	     * @param {function} onError - The onError callback, which is call when parser throw an error during parsing.
	     */
	    // eslint-disable-next-line no-unused-vars
	    _onJson ( data, onSuccess, onProgress, onError ) {}

	    /**
	     * The abstract private _onText method must be overridden in case the parser expect a string/text as input data.
	     *
	     * @private
	     * @abstract
	     * @param {string} data - The retrieved data to parse.
	     * @param {function} onSuccess - The onLoad callback, which is call when parser parse with success the data.
	     * @param {function} onProgress - The onProgress callback, which is call during the parsing.
	     * @param {function} onError - The onError callback, which is call when parser throw an error during parsing.
	     */
	    // eslint-disable-next-line no-unused-vars
	    _onText ( data, onSuccess, onProgress, onError ) {}

	    // REST Api calls
	    /**
	     * The private _create method allow to format a server request to create objects with the given data and get creation result with given callbacks.
	     *
	     * @private
	     * @param {object} data - The data to send.
	     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
	     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
	     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
	     */
	    _createOne ( data, onLoadCallback, onProgressCallback, onErrorCallback ) {

	        this._requestQueue.push( {
	            _id:          `createOne_${ Generate.id }`,
	            _timeStart:   new Date(),
	            _type:        RequestType.CreateOne,
	            method:       HttpVerb.Create.value,
	            url:          this._basePath,
	            data:         data,
	            onLoad:       onLoadCallback,
	            onProgress:   onProgressCallback,
	            onError:      onErrorCallback,
	            responseType: this._responseType
	        } );

	        this.processQueue();

	    }

	    /**
	     *
	     * @param datas
	     * @param onLoadCallback
	     * @param onProgressCallback
	     * @param onErrorCallback
	     * @private
	     */
	    _createMany ( datas, onLoadCallback, onProgressCallback, onErrorCallback ) {

	        this._requestQueue.push( {
	            _id:          `createMany_${ Generate.id }`,
	            _timeStart:   new Date(),
	            _type:        RequestType.CreateMany,
	            method:       HttpVerb.Create.value,
	            url:          this._basePath,
	            data:         datas,
	            onLoad:       onLoadCallback,
	            onProgress:   onProgressCallback,
	            onError:      onErrorCallback,
	            responseType: this._responseType
	        } );

	        this.processQueue();

	    }

	    /**
	     * The private _updateOne method will format a server request to get a single object with the given id.
	     *
	     * @private
	     * @param {string} id - The object's id of the object to retrieve.
	     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
	     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
	     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
	     */
	    _readOne ( id, projection, onLoadCallback, onProgressCallback, onErrorCallback ) {

	        // Filter requested values by cached values
	        const datas = this._retrieveCachedValues( [ id ] );

	        // retrieveLocalStorageValues...

	        // getDatabaseValues()

	        if ( datas.toRequest.length === 0 ) {

	            if ( datas.underRequest.length === 0 ) {

	                onLoadCallback( datas.results );

	            } else {

	                datas[ 'onLoadCallback' ]     = onLoadCallback;
	                datas[ 'onProgressCallback' ] = onProgressCallback;
	                datas[ 'onErrorCallback' ]    = onErrorCallback;
	                this._waitingQueue.push( datas );

	            }

	        } else {

	            datas[ 'onLoadCallback' ]     = onLoadCallback;
	            datas[ 'onProgressCallback' ] = onProgressCallback;
	            datas[ 'onErrorCallback' ]    = onErrorCallback;
	            this._waitingQueue.push( datas );

	            try {
	                this._cache.add( id, null );
	                datas.underRequest.push( id );
	                datas.toRequest.splice( datas.toRequest.indexOf( id ), 1 );
	            } catch ( error ) {
	                this.logger.error( error );
	            }

	            this._idToRequest.push( id );
	            this.aggregateQueue();

	        }

	    }

	    /**
	     * The private _readMany method will format a server request to get objects with id in the ids array.
	     *
	     * @private
	     * @param {array.<string>} ids - The ids of objects to retrieve.
	     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
	     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
	     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
	     */
	    _readMany ( ids, projection, onLoadCallback, onProgressCallback, onErrorCallback ) {

	        // Filter requested values by cached values
	        const datas = this._retrieveCachedValues( ids );

	        // retrieveLocalStorageValues...

	        // getDatabaseValues()

	        if ( datas.toRequest.length === 0 ) {

	            if ( datas.underRequest.length === 0 ) {

	                onLoadCallback( datas.results );

	            } else {

	                datas[ 'onLoadCallback' ]     = onLoadCallback;
	                datas[ 'onProgressCallback' ] = onProgressCallback;
	                datas[ 'onErrorCallback' ]    = onErrorCallback;
	                this._waitingQueue.push( datas );

	            }

	        } else {

	            datas[ 'onLoadCallback' ]     = onLoadCallback;
	            datas[ 'onProgressCallback' ] = onProgressCallback;
	            datas[ 'onErrorCallback' ]    = onErrorCallback;
	            this._waitingQueue.push( datas );

	            const datasToRequest = datas.toRequest;
	            let id               = undefined;
	            for ( let idIndex = datasToRequest.length - 1 ; idIndex >= 0 ; idIndex-- ) {

	                id = datasToRequest[ idIndex ];

	                // Prepare entry for id to request
	                try {
	                    this._cache.add( id, null );
	                    datas.underRequest.push( id );
	                    datas.toRequest.splice( datas.toRequest.indexOf( id ), 1 );
	                } catch ( error ) {
	                    this.logger.error( error );
	                }

	                this._idToRequest.push( id );

	            }

	            this.aggregateQueue();

	        }

	    }

	    /**
	     *
	     * @param query
	     * @param projection
	     * @param onLoadCallback
	     * @param onProgressCallback
	     * @param onErrorCallback
	     * @private
	     */
	    _readWhere ( query, projection, onLoadCallback, onProgressCallback, onErrorCallback ) {

	        //        // Filter requested values by cached values
	        //                const datas = {
	        //                    results: {},
	        //                    underRequest: [],
	        //                    toRequest: []
	        //                }
	        //
	        //        datas[ 'onLoadCallback' ] = onLoadCallback
	        //        this._waitingQueue.push( datas )

	        this._requestQueue.push( {
	            _id:        `readWhere_${ Generate.id }`,
	            _timeStart: new Date(),
	            _type:      RequestType.ReadWhere,
	            method:     HttpVerb.Read.value,
	            url:        this._basePath,
	            data:       {
	                query,
	                projection
	            },
	            onLoad:       onLoadCallback,
	            onProgress:   onProgressCallback,
	            onError:      onErrorCallback,
	            responseType: this._responseType
	        } );

	        this.processQueue();

	    }

	    /**
	     *
	     * @param projection
	     * @param onLoadCallback
	     * @param onProgressCallback
	     * @param onErrorCallback
	     * @private
	     */
	    _readAll ( projection, onLoadCallback, onProgressCallback, onErrorCallback ) {

	        //        const datas = {
	        //            results: {},
	        //            underRequest: [],
	        //            toRequest: []
	        //        }
	        //
	        //        datas[ 'onLoadCallback' ] = onLoadCallback
	        //        this._waitingQueue.push( datas )

	        const query = {};

	        this._requestQueue.push( {
	            _id:        `readAll_${ Generate.id }`,
	            _timeStart: new Date(),
	            _type:      RequestType.ReadAll,
	            method:     HttpVerb.Read.value,
	            url:        this._basePath,
	            data:       {
	                query,
	                projection
	            },
	            onLoad:       onLoadCallback,
	            onProgress:   onProgressCallback,
	            onError:      onErrorCallback,
	            responseType: this._responseType
	        } );

	        this.processQueue();

	    }

	    /**
	     * The private _updateOne method will format a server request to update a single object with the given id.
	     *
	     * @param {string} id - The object's id of the object to update.
	     * @param update
	     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
	     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
	     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
	     * @private
	     */
	    _updateOne ( id, update, onLoadCallback, onProgressCallback, onErrorCallback ) {

	        this._requestQueue.push( {
	            _id:        `updateOne_${ Generate.id }`,
	            _timeStart: new Date(),
	            _type:      RequestType.UpdateOne,
	            method:     HttpVerb.Update.value,
	            url:        `${ this._basePath }/${ id }`,
	            data:       {
	                update
	            },
	            onLoad:       onLoadCallback,
	            onProgress:   onProgressCallback,
	            onError:      onErrorCallback,
	            responseType: this._responseType
	        } );

	        this.processQueue();

	    }

	    /**
	     * The private _updateMany method will format a server request to update objects with id in the ids array.
	     *
	     * @param {array.<string>} ids - The ids of objects to update.
	     * @param update
	     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
	     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
	     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
	     * @private
	     */
	    _updateMany ( ids, update, onLoadCallback, onProgressCallback, onErrorCallback ) {

	        this._requestQueue.push( {
	            _id:        `updateMany_${ Generate.id }`,
	            _timeStart: new Date(),
	            _type:      RequestType.UpdateMany,
	            method:     HttpVerb.Update.value,
	            url:        this._basePath,
	            data:       {
	                ids,
	                update
	            },
	            onLoad:       onLoadCallback,
	            onProgress:   onProgressCallback,
	            onError:      onErrorCallback,
	            responseType: this._responseType
	        } );

	        this.processQueue();

	    }

	    /**
	     *
	     * @param query
	     * @param update
	     * @param onLoadCallback
	     * @param onProgressCallback
	     * @param onErrorCallback
	     * @private
	     */
	    _updateWhere ( query, update, onLoadCallback, onProgressCallback, onErrorCallback ) {

	        this._requestQueue.push( {
	            _id:        `updateWhere_${ Generate.id }`,
	            _timeStart: new Date(),
	            _type:      RequestType.UpdateWhere,
	            method:     HttpVerb.Update.value,
	            url:        this._basePath,
	            data:       {
	                query,
	                update
	            },
	            onLoad:       onLoadCallback,
	            onProgress:   onProgressCallback,
	            onError:      onErrorCallback,
	            responseType: this._responseType
	        } );

	        this.processQueue();

	    }

	    /**
	     *
	     * @param update
	     * @param onLoadCallback
	     * @param onProgressCallback
	     * @param onErrorCallback
	     * @private
	     */
	    _updateAll ( update, onLoadCallback, onProgressCallback, onErrorCallback ) {

	        const query = {};

	        this._requestQueue.push( {
	            _id:        `updateAll_${ Generate.id }`,
	            _timeStart: new Date(),
	            _type:      RequestType.UpdateAll,
	            method:     HttpVerb.Update.value,
	            url:        this._basePath,
	            data:       {
	                query,
	                update
	            },
	            onLoad:       onLoadCallback,
	            onProgress:   onProgressCallback,
	            onError:      onErrorCallback,
	            responseType: this._responseType
	        } );

	        this.processQueue();

	    }

	    /**
	     * The private _deleteOne method will format a server request to delete a single object with the given id.
	     *
	     * @param {string} id - The object's id of the object to delete.
	     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
	     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
	     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
	     * @private
	     */
	    _deleteOne ( id, onLoadCallback, onProgressCallback, onErrorCallback ) {

	        this._requestQueue.push( {
	            _id:          `deleteOne_${ Generate.id }`,
	            _timeStart:   new Date(),
	            _type:        RequestType.DeleteOne,
	            method:       HttpVerb.Delete.value,
	            url:          `${ this._basePath }/${ id }`,
	            data:         null,
	            onLoad:       onLoadCallback,
	            onProgress:   onProgressCallback,
	            onError:      onErrorCallback,
	            responseType: this._responseType
	        } );

	        this.processQueue();

	    }

	    /**
	     * The private _deleteMany method will format a server request to delete objects with id in the ids array.
	     *
	     * @param {array.<string>} ids - The ids of objects to delete.
	     * @param {function} onLoadCallback - The onLoad callback, which is call when server respond with success to the request.
	     * @param {function} onProgressCallback - The onProgress callback, which is call during the response incoming.
	     * @param {function} onErrorCallback - The onError callback, which is call when server respond with an error to the request.
	     * @private
	     */
	    _deleteMany ( ids, onLoadCallback, onProgressCallback, onErrorCallback ) {

	        this._requestQueue.push( {
	            _id:        `deleteMany_${ Generate.id }`,
	            _timeStart: new Date(),
	            _type:      RequestType.DeleteMany,
	            method:     HttpVerb.Delete.value,
	            url:        this._basePath,
	            data:       {
	                ids
	            },
	            onLoad:       onLoadCallback,
	            onProgress:   onProgressCallback,
	            onError:      onErrorCallback,
	            responseType: this._responseType
	        } );

	        this.processQueue();

	    }

	    /**
	     *
	     * @param query
	     * @param onLoadCallback
	     * @param onProgressCallback
	     * @param onErrorCallback
	     * @private
	     */
	    _deleteWhere ( query, onLoadCallback, onProgressCallback, onErrorCallback ) {

	        this._requestQueue.push( {
	            _id:        `deleteWhere_${ Generate.id }`,
	            _timeStart: new Date(),
	            _type:      RequestType.DeleteWhere,
	            method:     HttpVerb.Delete.value,
	            url:        this._basePath,
	            data:       {
	                query
	            },
	            onLoad:       onLoadCallback,
	            onProgress:   onProgressCallback,
	            onError:      onErrorCallback,
	            responseType: this._responseType
	        } );

	        this.processQueue();

	    }

	    /**
	     *
	     * @param onLoadCallback
	     * @param onProgressCallback
	     * @param onErrorCallback
	     * @private
	     */
	    _deleteAll ( onLoadCallback, onProgressCallback, onErrorCallback ) {

	        const query = {};

	        this._requestQueue.push( {
	            _id:        `deleteAll_${ Generate.id }`,
	            _timeStart: new Date(),
	            _type:      RequestType.DeleteAll,
	            method:     HttpVerb.Delete.value,
	            url:        this._basePath,
	            data:       {
	                query
	            },
	            onLoad:       onLoadCallback,
	            onProgress:   onProgressCallback,
	            onError:      onErrorCallback,
	            responseType: this._responseType
	        } );

	        this.processQueue();

	    }

	}

	// Static stuff
	/**
	 *
	 * @type {number}
	 * @private
	 */
	TDataBaseManager._requestId = 0;

	/**
	 *
	 * @type {Object}
	 * @private
	 */
	TDataBaseManager._requests = {
	    /**
	     * The global waiting queue to process
	     */
	    waitingQueue: {},
	    /**
	     * The objects not requested yet
	     */
	    toProcess:    {
	        create: {},
	        read:   {},
	        update: {},
	        delete: {}
	    },
	    /**
	     * The object currently under request
	     */
	    underProcess: {
	        create: {},
	        read:   {},
	        update: {},
	        delete: {}
	    },
	    /**
	     * The objects already processed
	     */
	    processed: {
	        create: {},
	        read:   {},
	        update: {},
	        delete: {}
	    }
	};

	/**
	 * @deprecated
	 * @type {ReadonlyArray<unknown>}
	 */
	const TIdFactoryType = iteeUtils.toEnum( {
	    Number: 0,
	    String: 1,
	    Uuid:   2
	} );

	/**
	 * @deprecated
	 */
	class TIdFactory {

	    constructor ( type = TIdFactoryType.Number, base = null ) {

	        this.type = type;
	        this.base = base;

	        this._counter = 0;

	    }

	    get type () {
	        return this._type
	    }

	    set type ( value ) {

	        if ( iteeValidators.isNull( value ) ) { throw new Error( `Type cannot be null ! Expect an value from TIdFactoryType enum: ${ TIdFactoryType.types() }` ) }
	        if ( iteeValidators.isUndefined( value ) ) { throw new Error( `Type cannot be undefined ! Expect an value from TIdFactoryType enum: ${ TIdFactoryType.types() }` ) }
	        if ( !TIdFactoryType.includes( value ) ) { throw new Error( `Invalide type ! Expect an value from TIdFactoryType enum: ${ TIdFactoryType.types() }` ) }

	        this._type = value;
	    }

	    get base () {
	        return this._base
	    }

	    set base ( value ) {

	        if ( iteeValidators.isUndefined( value ) ) { throw new Error( 'Base cannot be undefined ! Expect an instance of Object3D.' ) }

	        if ( ( this._type === TIdFactoryType.Number ) && iteeValidators.isNotNumber( value ) ) { throw new Error( 'Invalide Base ! It does not match the type.' ) }
	        if ( ( this._type === TIdFactoryType.String ) && iteeValidators.isNotString( value ) ) { throw new Error( 'Invalide Base ! It does not match the type.' ) }
	        //        if( (this._type === TIdFactoryType.Uuid) && isNotUuid( value ) ) { throw new Error( 'Invalide Base ! It does not match the type.' ) }

	        this._base = value;
	    }

	    setType ( value ) {

	        this.type = value;
	        return this

	    }

	    setBase ( value ) {

	        this.base = value;
	        return this

	    }

	    createId () {
	        return this._base + this._counter++
	    }

	}

	// Unique ID creation requires a high quality random # generator. In the browser we therefore
	// require the crypto API and do not support built-in fallback to lower quality random number
	// generators (like Math.random()).
	var getRandomValues;
	var rnds8 = new Uint8Array(16);
	function rng() {
	  // lazy load so that environments that need to polyfill have a chance to do so
	  if (!getRandomValues) {
	    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
	    // find the complete implementation of crypto (msCrypto) on IE11.
	    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

	    if (!getRandomValues) {
	      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
	    }
	  }

	  return getRandomValues(rnds8);
	}

	var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

	function validate(uuid) {
	  return typeof uuid === 'string' && REGEX.test(uuid);
	}

	/**
	 * Convert array of 16 byte values to UUID string format of the form:
	 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
	 */

	var byteToHex = [];

	for (var i = 0; i < 256; ++i) {
	  byteToHex.push((i + 0x100).toString(16).substr(1));
	}

	function stringify(arr) {
	  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	  // Note: Be careful editing this code!  It's been tuned for performance
	  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
	  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
	  // of the following:
	  // - One or more input array values don't map to a hex octet (leading to
	  // "undefined" in the uuid)
	  // - Invalid input values for the RFC `version` or `variant` fields

	  if (!validate(uuid)) {
	    throw TypeError('Stringified UUID is invalid');
	  }

	  return uuid;
	}

	function v4(options, buf, offset) {
	  options = options || {};
	  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

	  rnds[6] = rnds[6] & 0x0f | 0x40;
	  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

	  if (buf) {
	    offset = offset || 0;

	    for (var i = 0; i < 16; ++i) {
	      buf[offset + i] = rnds[i];
	    }

	    return buf;
	  }

	  return stringify(rnds);
	}

	/**
	 * @author [Tristan Valcke]{@link https://github.com/Itee}
	 */

	/**
	 * @typedef {Object} WebAPIMessageSerialized
	 * @property {string} id
	 * @property {string} type
	 */

	/**
	 * @class
	 * @classdesc The base class for all web api message
	 */
	class WebAPIMessage {

	    /**
	     * @static
	     * @type {boolean}
	     */
	    static isWebAPIMessage = true

	    /**
	     *
	     * @param {string} type
	     */
	    constructor ( type ) {
	        this._id  = v4();
	        this.type = type;
	    }

	    /**
	     *
	     */
	    get id () {
	        return this._id
	    }

	    /**
	     *
	     * @returns {string}
	     */
	    get type () {
	        return this._type
	    }

	    set type ( value ) {
	        if ( iteeValidators.isNotString( value ) ) { throw new ReferenceError( 'WebAPIMessage type cannot be null or undefined !' )}
	        if ( iteeValidators.isEmptyString( value ) ) { throw new TypeError( 'WebAPIMessage type cannot be an empty string !' )}

	        this._type = value;
	    }

	    /**
	     *
	     * @returns {{id: String, type: String}}
	     */
	    toJSON () {

	        return {
	            id:   this.id,
	            type: this.type
	        }

	    }

	}

	/**
	 * @typedef {Object} WebAPIMessageDataSerialized
	 * @property {object} data
	 * @instance
	 */

	/**
	 * @class
	 * @classdesc The web api message for serializable data transfert
	 * @extends WebAPIMessage
	 * @author [Tristan Valcke]{@link https://github.com/Itee}
	 */
	class WebAPIMessageData extends WebAPIMessage {

	    /**
	     * @static
	     * @type {boolean}
	     */
	    static isWebAPIMessageData = true

	    /**
	     *
	     * @param data
	     */
	    constructor ( data ) {
	        super( '_data' );

	        this.data = data;
	    }

	    /**
	     *
	     * @returns {{data: *}}
	     */
	    toJSON () {

	        return {
	            ...super.toJSON(),
	            ...{
	                data: JSON.stringify( this.data )
	            }
	        }

	    }

	}

	/**
	 * @author [Tristan Valcke]{@link https://github.com/Itee}
	 */

	class WebAPIMessageError extends WebAPIMessage {

	    static isWebAPIMessageError = true
	    // Utils
	    static isError ( value ) {
	        return value instanceof Error || iteeValidators.isObject( value ) && ( iteeValidators.isDefined( value.name ) || iteeValidators.isDefined( value.message ) || iteeValidators.isDefined( value.stack ) )
	    }
	    /**
	     *
	     * @param error
	     */
	    constructor ( error ) {
	        super( '_error' );

	        /**
	         * The internal error to send
	         * @type {{stack: string, name: string, message: string}}
	         */
	        this.error = error;
	    }
	    get error () {
	        return this._error
	    }
	    set error ( value ) {
	        if ( iteeValidators.isNotDefined( value ) ) { throw new ReferenceError( `Expect a string, or Error like. But got value of '${ typeof value }' type: ${ JSON.stringify( value, null, 4 ) }` ) }

	        if ( iteeValidators.isString( value ) ) {

	            this._error = {
	                name:    'UnknownError',
	                message: value
	            };

	        } else if ( WebAPIMessageError.isError( value ) ) {

	            this._error = {
	                name:    value.name,
	                message: value.message,
	                stack:   value.stack
	            };

	        } else {

	            throw new TypeError( `Expect a string, or Error like. But got value of '${ typeof value }' type: ${ JSON.stringify( value, null, 4 ) }` )

	        }

	    }

	    // Serialization
	    /**
	     *
	     * @returns {{id: String, type: String, name: String, stack: String, message: String}}
	     */
	    toJSON () {

	        return {
	            ...super.toJSON(),
	            ...{
	                error: this.error
	            }
	        }

	    }

	}

	/**
	 * @author [Tristan Valcke]{@link https://github.com/Itee}
	 */

	/**
	 * @class
	 * @classdesc Internal ready message to broadcast for prevent bad or dead messager
	 */
	class WebAPIMessageReady extends WebAPIMessage {

	    /**
	     * @static
	     * @type {boolean}
	     */
	    static isWebAPIMessageReady = true

	    /**
	     *
	     */
	    constructor ( parameters = {} ) {
	        super( '_ready' );

	        const _parameters = {
	            ...{
	                isBind: false
	            },
	            ...parameters
	        };

	        this.isBind = _parameters.isBind;
	    }

	    get isBind () {
	        return this._isBind
	    }

	    set isBind ( value ) {
	        if ( iteeValidators.isNotDefined( value ) ) { throw new ReferenceError( 'WebAPIMessageReady isBind cannot be null or undefined ! Expect a boolean value.' )}
	        if ( iteeValidators.isNotBoolean( value ) ) { throw new TypeError( 'WebAPIMessageReady isBind expect a boolean value.' )}

	        this._isBind = value;
	    }

	    /**
	     *
	     * @returns {{id: String, type: String, isBind: Boolean}}
	     */
	    toJSON () {

	        return {
	            ...super.toJSON(),
	            ...{
	                isBind: this.isBind
	            }
	        }

	    }
	}

	/**
	 * @author [Tristan Valcke]{@link https://github.com/Itee}
	 */

	/**
	 * @class
	 * @classdesc Special message to request a distant method and expect result.
	 */
	class WebAPIMessageRequest extends WebAPIMessage {

	    /**
	     * @static
	     * @type {boolean}
	     */
	    static isWebAPIMessageRequest = true

	    /**
	     *
	     * @param method
	     * @param parameters
	     */
	    constructor ( method, parameters = [] ) {
	        super( '_request' );

	        this.method     = method;
	        this.parameters = parameters;
	    }

	    /**
	     *
	     * @returns {String}
	     */
	    get method () {
	        return this._method
	    }

	    /**
	     *
	     * @param value {String}
	     */
	    set method ( value ) {
	        if ( iteeValidators.isNotDefined( value ) ) { throw new ReferenceError( 'Expect a string that represent a api method name, but got undefined or null value.' ) }
	        if ( iteeValidators.isNotString( value ) ) { throw new TypeError( `Expect a string that represent a api method name, but got value of '${ typeof value }' type: ${ JSON.stringify( value, null, 4 ) }` ) }
	        if ( iteeValidators.isEmptyString( value ) || iteeValidators.isBlankString( value ) ) { throw new TypeError( 'Expect a string that represent a api method name, but got empty or blank string.' ) }

	        this._method = value;
	    }

	    /**
	     *
	     * @returns {Array<*>}
	     */
	    get parameters () {
	        return this._parameters
	    }

	    /**
	     *
	     * @param value {Array<*>}
	     */
	    set parameters ( value ) {
	        if ( iteeValidators.isNotArray( value ) ) { throw new TypeError( `Expect an array of parameters, but got value of '${ typeof value }' type: ${ JSON.stringify( value, null, 4 ) }` ) }

	        this._parameters = value;
	    }

	    /**
	     *
	     * @returns {{method: String, parameters: Array<*>}}
	     */
	    toJSON () {

	        return {
	            ...super.toJSON(),
	            ...{
	                method:     this.method,
	                parameters: this.parameters
	            }
	        }

	    }

	}

	/**
	 * @author [Tristan Valcke]{@link https://github.com/Itee}
	 */

	/**
	 * @class
	 * @classdesc The message response to a message request
	 */
	class WebAPIMessageResponse extends WebAPIMessage {

	    /**
	     *
	     * @type {boolean}
	     */
	    static isWebApiMessageResponse = true

	    /**
	     *
	     * @param request
	     * @param result
	     */
	    constructor ( request, result ) {
	        super( '_response' );

	        this.request = request;
	        this.result  = result;
	    }

	    /**
	     *
	     * @returns {*}
	     */
	    get request () {
	        return this._request
	    }

	    set request ( value ) {
	        if ( iteeValidators.isNull( value ) ) { return }
	        if ( iteeValidators.isUndefined( value ) ) { return }

	        this._request = value;
	    }

	    /**
	     *
	     * @returns {*}
	     */
	    get result () {
	        return this._result
	    }

	    set result ( value ) {
	        this._result = value;
	    }

	    /**
	     *
	     * @returns {{result: *, request: *}}
	     */
	    toJSON () {

	        return {
	            ...super.toJSON(),
	            ...{
	                request: this.request,
	                result:  this.result
	            }
	        }

	    }

	}

	/**
	 * @author [Tristan Valcke]{@link https://github.com/Itee}
	 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
	 */

	class WebAPIOrigin {

	    constructor ( parameters = {} ) {

	        const _parameters = {
	            ...{
	                uri:            '',
	                allowedMethods: [ '*' ],
	                window:         null,
	                messageQueue:   [],
	                isReachable:    true,
	                isReady:        false
	            },
	            ...parameters,
	            ...{
	                id: iteeValidators.isDefined( parameters.id ) ? parameters.id : v4()
	            }
	        };

	        this._id            = _parameters.id;
	        this.uri            = _parameters.uri;
	        this.allowedMethods = _parameters.allowedMethods; // Todo: use Set instead
	        this.window         = _parameters.window;
	        this.isReachable    = _parameters.isReachable;
	        this.isReady        = _parameters.isReady;
	        this.messageQueue   = _parameters.messageQueue;

	    }

	    /**
	     *
	     */
	    get id () {
	        return this._id
	    }

	    get uri () {
	        return this._uri
	    }
	    set uri ( value ) {
	        if ( iteeValidators.isNotDefined( value ) ) { throw new ReferenceError( 'WebAPIOrigin uri cannot be null or undefined !' )}
	        if ( iteeValidators.isNotString( value ) ) { throw new TypeError( `WebAPIOrigin uri expect to be a string. Got '${ typeof value }' !` )}
	        if ( iteeValidators.isEmptyString( value ) ) { throw new RangeError( 'WebAPIOrigin uri cannot be an empty string !' )}

	        this._uri = value;
	    }
	    get allowedMethods () {
	        return this._allowedMethods
	    }
	    set allowedMethods ( value ) {
	        if ( iteeValidators.isNotDefined( value ) ) { throw new ReferenceError( 'WebAPIOrigin methods cannot be null or undefined ! Expect an array of method name.' )}
	        if ( iteeValidators.isNotArray( value ) ) { throw new TypeError( `WebAPIOrigin methods expect to be an array of method name (string).Got '${ typeof value }' !` )}
	        if ( iteeValidators.isEmptyArray( value ) ) { throw new RangeError( 'WebAPIOrigin methods cannot be an empty array ! Expect an array of method name.' )}

	        this._allowedMethods = value;
	    }
	    get window () {
	        return this._window
	    }
	    set window ( value ) {
	        //        if ( isNotDefined( value ) ) { throw new ReferenceError( 'WebAPIOrigin window cannot be null or undefined ! Expect a Window object.' )}
	        //        if ( isDefined( value ) && !( value instanceof Window ) ) { throw new TypeError( `WebAPIOrigin window expect to be a Window. Got '${ typeof value }' !` )}

	        this._window = value;
	    }
	    get isReady () {
	        return this._isReady
	    }
	    set isReady ( value ) {
	        if ( iteeValidators.isNotDefined( value ) ) { throw new ReferenceError( 'WebAPIOrigin isReady cannot be null or undefined !' )}
	        if ( iteeValidators.isNotBoolean( value ) ) { throw new TypeError( `WebAPIOrigin isReady expect a Boolean. Got '${ typeof value }' !` )}

	        this._isReady = value;
	    }
	    get isReachable () {
	        return this._isReachable
	    }
	    set isReachable ( value ) {
	        if ( iteeValidators.isNotDefined( value ) ) { throw new ReferenceError( 'WebAPIOrigin isReachable cannot be null or undefined !' )}
	        if ( iteeValidators.isNotBoolean( value ) ) { throw new TypeError( `WebAPIOrigin isReachable expect a Boolean. Got '${ typeof value }' !` )}

	        this._isReachable = value;
	    }
	    get messageQueue () {
	        return this._messageQueue
	    }
	    set messageQueue ( value ) {
	        this._messageQueue = value;
	    }
	    setUri ( value ) {
	        this.uri = value;
	        return this
	    }
	    setAllowedMethods ( arrayOfMethodNames ) {
	        this.allowedMethods = arrayOfMethodNames;
	        return this
	    }
	    addAllowedMethod ( methodName ) {
	        if ( !this.allowedMethods.includes( methodName ) ) {
	            this.allowedMethods.push( methodName );
	        }
	        return this
	    }
	    removeAllowedMethod ( methodName ) {
	        const index = this.allowedMethods.indexOf( methodName );
	        if ( index >= 0 ) {
	            this.allowedMethods.slice( index, methodName );
	        }
	        return this
	    }
	    setWindow ( value ) {
	        this.window = value;
	        return this
	    }
	    setReadyState ( value ) {
	        this.isReady = value;
	        return this
	    }
	    setReachableState ( value ) {
	        this.isReachable = value;
	        return this
	    }
	}

	/**
	 * @author [Tristan Valcke]{@link https://github.com/Itee}
	 */

	/**
	 * A POJO object containg datas about a distant source to allow
	 * @typedef {Object} AllowedOrigin
	 * @property {string} id - The id to reference this origin as a human readable string
	 * @property {string} uri - The uri of the origin to allow
	 * @property {Array<String>} methods - An array of methods names that are allowed for this origins. To allow all methods use '*', in case no methods string were provide the origin won't be able to do
	 *     anything.
	 */

	/**
	 * @class
	 * @classdesc The abstract class to use standardized webapi.
	 * @abstract
	 */
	class WebAPI {

	    /**
	     * @constructor
	     * @param {Object} parameters - An object containing all parameters to pass through the inheritance chain to initialize this instance
	     * @param {Boolean} [parameters.allowAnyOrigins=false] - A boolean to allow or not any origins calls
	     * @param {Array<AllowedOrigin>} [parameters.allowedOrigins=[]] - An array containing configured allowed origins
	     * @param {Number} [parameters.requestTimeout=2000] - The request timeout before throw an error
	     */
	    constructor ( parameters = {} ) {

	        const _parameters = {
	            ...{
	                logger:               iteeCore.DefaultLogger,
	                allowedOrigins:       [],
	                requestTimeout:       2000,
	                methods:              this,
	                broadcastReadyOnInit: true
	            },
	            ...parameters
	        };

	        // Private stuff
	        this._localOriginUri  = window.location.origin;
	        this._awaitingRequest = new Map();

	        // Listen message from Window
	        window.addEventListener( 'message', this._onMessage.bind( this ), false );

	        // Public stuff
	        this.logger         = _parameters.logger;
	        this.allowedOrigins = _parameters.allowedOrigins;
	        this.requestTimeout = _parameters.requestTimeout;
	        this.methods        = _parameters.methods;

	        // Initiate connection to all origins
	        if ( _parameters.broadcastReadyOnInit ) {
	            this._broadcastReadyMessage();
	        }
	    }

	    /**
	     *
	     * @returns {TLogger}
	     */
	    get logger () {
	        return this._logger
	    }
	    /**
	     *
	     * @param value {TLogger}
	     */
	    set logger ( value ) {
	        if ( iteeValidators.isNull( value ) ) { throw new ReferenceError( `[${ this._localOriginUri }]: The logger cannot be null, expect a TLogger.` )}
	        if ( iteeValidators.isUndefined( value ) ) { throw new ReferenceError( `[${ this._localOriginUri }]: The logger cannot be undefined, expect a TLogger.` )}
	        if ( !value.isLogger ) { throw new ReferenceError( `[${ this._localOriginUri }]: The logger cannot be undefined, expect a TLogger.` )}

	        this._logger = value;
	    }
	    /**
	     *
	     * @returns {Array<WebAPIOrigin>}
	     */
	    get allowedOrigins () {
	        return this._allowedOrigins
	    }
	    /**
	     *
	     * @param value {Array<WebAPIOrigin>}
	     */
	    set allowedOrigins ( value ) {

	        this._allowedOrigins  = [];
	        const _allowedOrigins = iteeUtils.toArray( value );

	        // Special case for any origin
	        if ( _allowedOrigins.includes( '*' ) ) {
	            this.logger.warn( `[${ this._localOriginUri }]: This webApi is allowed for all origin and could lead to security concerne !` );
	            this._allowedOrigins.push( '*' );
	            return
	        }

	        // Create WebApiOrigin based on provided settings
	        for ( let allowedOrigin of _allowedOrigins ) {

	            const origin = new WebAPIOrigin( {
	                id:      allowedOrigin.id,
	                uri:     allowedOrigin.uri,
	                methods: allowedOrigin.methods,
	                window:  this._getOriginWindow( allowedOrigin.uri )
	            } );
	            this._allowedOrigins.push( origin );

	        }

	    }
	    /**
	     *
	     * @returns {Number}
	     */
	    get requestTimeout () {
	        return this._requestTimeout
	    }
	    /**
	     *
	     * @param value {Number}
	     */
	    set requestTimeout ( value ) {
	        if ( iteeValidators.isNull( value ) ) { throw new ReferenceError( `[${ this._localOriginUri }]: The request timeout cannot be null, expect to be 0 or a positive number.` )}
	        if ( iteeValidators.isUndefined( value ) ) { throw new ReferenceError( `[${ this._localOriginUri }]: The request timeout cannot be undefined, expect to be 0 or a positive number.` )}
	        if ( iteeValidators.isNotNumber( value ) ) { throw new ReferenceError( `[${ this._localOriginUri }]: The request timeout expect to be 0 or a positive number.` )}
	        if ( iteeValidators.isNumberNegative( value ) && !iteeValidators.isZero( value ) ) { throw new ReferenceError( `[${ this._localOriginUri }]: The request timeout expect to be 0 or a positive number.` )}

	        this._requestTimeout = value;
	    }
	    /**
	     *
	     * @returns {Array<Function>}
	     */
	    get methods () {
	        return this._methods
	    }
	    /**
	     *
	     * @param value Array<Function>
	     */
	    set methods ( value ) {
	        if ( iteeValidators.isNull( value ) ) { throw new ReferenceError( `[${ this._localOriginUri }]: The methods cannot be null, expect any keyed collection of function.` )}
	        if ( iteeValidators.isUndefined( value ) ) { throw new ReferenceError( `[${ this._localOriginUri }]: The methods cannot be undefined, expect any keyed collection of function.` )}
	        // Todo: isNotObject && isNotMap && isNotSet && isNotApi

	        this._methods = value;
	    }
	    /**
	     *
	     * @param value {TLogger}
	     * @returns {AbstractWebAPI}
	     */
	    setLogger ( value ) {
	        this.logger = value;
	        return this
	    }
	    /**
	     *
	     * @param value {Array<WebAPIOrigin>}
	     * @returns {AbstractWebAPI}
	     */
	    setAllowedOrigins ( value ) {
	        this.allowedOrigins = value;
	        return this
	    }
	    /**
	     *
	     * @param value {Number}
	     * @returns {AbstractWebAPI}
	     */
	    setRequestTimeout ( value ) {
	        this.requestTimeout = value;
	        return this
	    }
	    /**
	     *
	     * @param value Array<Function>
	     * @returns {AbstractWebAPI}
	     */
	    setMethods ( value ) {
	        this.methods = value;
	        return this
	    }

	    // Validators

	    /**
	     *
	     * @returns {boolean}
	     * @private
	     */
	    _isInIframe () {

	        try {
	            return window.self !== window.top
	        } catch ( e ) {
	            return true
	        }

	    }

	    /**
	     *
	     * @returns {boolean}
	     * @private
	     */
	    _isNotAllowedForAllOrigins () {

	        return !this._allowedOrigins.includes( '*' )
	        //        return !this.allowAnyOrigins
	    }

	    /**
	     *
	     * @param originURI
	     * @returns {boolean}
	     * @private
	     */
	    _isNotAllowedOrigin ( originURI ) {

	        return !this._allowedOrigins
	                    .filter( origin => origin !== '*' )
	                    .map( origin => origin.uri )
	                    .includes( originURI )

	    }

	    /**
	     *
	     * @param originURI
	     * @returns {boolean}
	     * @private
	     */
	    _isSameOrigin ( originURI ) {
	        return this._localOriginUri === originURI
	    }

	    /**
	     *
	     * @param origin {WebAPIOrigin}
	     * @returns {boolean}
	     * @private
	     */
	    _isNotAllowedForAllMethods ( origin ) {
	        return ( origin.allowedMethods.indexOf( '*' ) === -1 )
	    }

	    /**
	     *
	     * @param origin {WebAPIOrigin}
	     * @param methodName {string}
	     * @returns {boolean}
	     * @private
	     */
	    _isNotAllowedMethod ( origin, methodName ) {
	        return ( origin.allowedMethods.indexOf( methodName ) === -1 )
	    }

	    /**
	     *
	     * @param methodName
	     * @returns {boolean}
	     * @private
	     */
	    _methodNotExist ( methodName ) {
	        return iteeValidators.isNotDefined( this.methods[ methodName ] )
	    }

	    // Utils

	    /**
	     *
	     * @param propertyName
	     * @param value
	     * @returns {WebAPIOrigin}
	     * @private
	     */
	    _getAllowedOriginBy ( propertyName, value ) {
	        return this.allowedOrigins.find( origin => origin[ propertyName ] === value )
	    }

	    /**
	     *
	     * @param originURI
	     * @returns {Window}
	     * @private
	     */
	    _getOriginWindow ( originURI ) {

	        let originWindow;

	        if ( this._isInIframe() ) {

	            originWindow = window.parent;

	        } else {

	            const frames = document.getElementsByTagName( 'iframe' );
	            const frame  = Array.from( frames ).find( iframe => iframe.src.includes( originURI ) );
	            if ( iteeValidators.isNotDefined( frame ) ) {
	                this.logger.warn( `[${ this._localOriginUri }]: Unable to find iframe element for [${ originURI }] URI !` );
	                originWindow = null;
	            } else {
	                originWindow = frame.contentWindow;
	            }

	        }

	        return originWindow

	    }

	    /**
	     *
	     * @param origin {WebAPIOrigin}
	     * @private
	     */
	    _processMessageQueueOf ( origin ) {

	        const messageQueue = origin.messageQueue;
	        for ( let messageIndex = messageQueue.length - 1 ; messageIndex >= 0 ; messageIndex-- ) {
	            this.postMessageTo( origin.id, messageQueue.shift() );
	        }

	    }

	    /**
	     *
	     * @private
	     */
	    _broadcastReadyMessage () {

	        const ready       = new WebAPIMessageReady();
	        let checkInterval = 250;

	        const broadcast = () => {

	            const unreadyOrigins = this.allowedOrigins.filter( origin => !origin.isReady && origin.isReachable );
	            if ( iteeValidators.isEmptyArray( unreadyOrigins ) ) {
	                return
	            }

	            for ( let unreadyOrigin of unreadyOrigins ) {
	                this.postReadyTo( unreadyOrigin.id, ready );
	            }

	            checkInterval += checkInterval;
	            setTimeout( broadcast, checkInterval );

	        };
	        broadcast();

	    }

	    // Messaging

	    /**
	     *
	     * @param event
	     * @returns {Promise<void>}
	     * @private
	     */
	    async _onMessage ( event ) {

	        // Is allowed origin
	        if ( this._isNotAllowedForAllOrigins() && this._isNotAllowedOrigin( event.origin ) ) {
	            this.logger.warn( `[${ this._localOriginUri }]: An unallowed origin [${ event.origin }] try to access the web api.` );
	            return
	        }

	        // Is self ?
	        if ( this._isSameOrigin( event.origin ) ) {
	            this.logger.warn( `[${ this._localOriginUri }]: A local origin try to access the web api... 
                or... Am i talking to myself  ?
                Said i (${ iteeValidators.isString( event.data ) ? event.data : JSON.stringify( event.data ) }) ?
                Hummm... Ehhooo ! Who's there ?
            ` );
	            return
	        }

	        // In case we are not in embbeded iframe or the origin is not an iframe set the origin window as the source event
	        let origin = this._getAllowedOriginBy( 'uri', event.origin );
	        if ( iteeValidators.isNotDefined( origin ) ) {

	            // If we are here, we are called by an unknown origin but we are allowed for all. So create a new one
	            origin = new WebAPIOrigin( {
	                uri:    event.origin,
	                window: event.source
	            } );
	            this.allowedOrigins.push( origin );

	        } else if ( iteeValidators.isNull( origin.window ) ) {

	            origin.window = event.source;

	        }

	        const eventData = event.data;
	        const message   = iteeValidators.isObject( eventData ) ? eventData : JSON.parse( eventData );
	        if ( iteeValidators.isNotDefined( message ) ) {
	            this.logger.error( `[${ this._localOriginUri }]: Recieve null or undefined message from [${ origin.uri }] ! Expect a json object.` );
	            return
	        }

	        await this._dispatchMessageFrom( origin, message );

	    }

	    /**
	     *
	     * @param origin
	     * @param message
	     * @private
	     */
	    async _dispatchMessageFrom ( origin, message ) {

	        this.logger.log( `[${ this._localOriginUri }]: Recieve message of type '${ message.type }' from [${ origin.uri }].` );

	        switch ( message.type ) {

	            case '_ready':
	                this._onReadyFrom( origin, message );
	                break

	            case '_request':
	                await this._onRequestFrom( origin, message );
	                break

	            case '_response':
	                this._onResponseFrom( origin, message );
	                break

	            case '_data':
	                this.onDataFrom( origin, message );
	                break

	            case '_error':
	                this.onErrorFrom( origin, message );
	                break

	            default:
	                this.onMessageFrom( origin, message );

	        }

	    }

	    /**
	     *
	     * @param origin
	     * @param message
	     */
	    _onReadyFrom ( origin, message ) {

	        if ( !origin.isReady ) {
	            origin.isReady = true;

	            // Avoid some ping-pong ready message
	            if ( !message.isBind ) {
	                const ready = new WebAPIMessageReady( { isBind: true } );
	                this.postMessageTo( origin.id, ready, true );
	            }
	        }

	        this._processMessageQueueOf( origin );

	    }

	    /**
	     *
	     * @param origin
	     * @param request
	     */
	    async _onRequestFrom ( origin, request ) {

	        let message;
	        const methodName = request.method;
	        const parameters = request.parameters;

	        if ( this._isNotAllowedForAllMethods( origin ) && this._isNotAllowedMethod( origin, methodName ) ) {

	            this.logger.error( `[${ this._localOriginUri }]: Origin [${ origin.uri }] try to access an unallowed method named '${ methodName }'.` );
	            message = new WebAPIMessageError( new RangeError( `Trying to access an unallowed method named '${ methodName }'.` ) );

	        } else if ( this._methodNotExist( methodName ) ) {

	            this.logger.error( `[${ this._localOriginUri }]: Origin [${ origin.uri }] try to access an unexisting method named '${ methodName }'.` );
	            message = new WebAPIMessageError( new RangeError( `Trying to access an unexisting method named '${ methodName }'.` ) );

	        } else {

	            try {
	                const result = await this.methods[ methodName ]( ...parameters );
	                message      = new WebAPIMessageData( result );
	            } catch ( error ) {
	                message = new WebAPIMessageError( error );
	            }

	        }

	        // To avoid unnecessary client timeout we need to respond with error or data in any case
	        this.postResponseTo( origin.id, request, message );

	    }

	    /**
	     *
	     * @param origin
	     * @param response
	     */
	    _onResponseFrom ( origin, response ) {

	        const requestId = response.request.id;
	        if ( !this._awaitingRequest.has( requestId ) ) { return }

	        const request = this._awaitingRequest.get( requestId );
	        this._awaitingRequest.delete( requestId );

	        clearTimeout( request.timeoutId );

	        const result = response.result;
	        if ( iteeValidators.isDefined( result ) ) {

	            if ( result.type === '_error' ) {
	                request.reject( result.error );
	            } else if ( result.type === '_data' ) {
	                request.resolve( result.data );
	            } else {
	                request.resolve( result );
	            }

	        } else {
	            request.resolve();
	        }

	    }

	    /**
	     *
	     * @param origin
	     * @param message
	     * @private
	     */
	    // eslint-disable-next-line no-unused-vars
	    onErrorFrom ( origin, message ) {
	        // Need to be reimplemented if needed
	        this.logger.error( `[${ this._localOriginUri }]: the origin [${ origin.uri }] send error => ${ JSON.stringify( message.error, null, 4 ) }. Need you to reimplement this method ?` );
	    }

	    /**
	     *
	     * @param origin
	     * @param message
	     */
	    // eslint-disable-next-line no-unused-vars
	    onDataFrom ( origin, message ) {
	        // Need to be reimplemented if needed
	        this.logger.log( `[${ this._localOriginUri }]: the origin [${ origin.uri }] send data => ${ JSON.stringify( message.data, null, 4 ) }. Need you to reimplement this method ?` );
	    }

	    /**
	     *
	     * @param origin
	     * @param message
	     */
	    // eslint-disable-next-line no-unused-vars
	    onMessageFrom ( origin, message ) {
	        // Need to be reimplemented if needed
	        this.logger.log( `[${ this._localOriginUri }]: the origin [${ origin.uri }] send custom message => ${ JSON.stringify( message, null, 4 ) }. Need you to reimplement this method ?` );
	    }

	    // Send

	    /**
	     *
	     * @param originId
	     * @param ready
	     */
	    postReadyTo ( originId, ready ) {

	        const _ready = ( ready && ready.constructor.isWebAPIMessageReady ) ? ready : new WebAPIMessageReady();
	        this.postMessageTo( originId, _ready, true );

	    }

	    /**
	     *
	     * @param originId
	     * @param request
	     * @param params
	     * @returns {Promise<unknown>}
	     */
	    postRequestTo ( originId, request, ...params ) {

	        const _request = ( request && request.constructor.isWebAPIMessageRequest ) ? request : new WebAPIMessageRequest( request, params );

	        return new Promise( ( resolve, reject ) => {

	            try {

	                this._awaitingRequest.set( _request.id, {
	                    request:   _request,
	                    resolve:   resolve,
	                    reject:    reject,
	                    timeoutId: setTimeout( () => {
	                        this._awaitingRequest.delete( _request.id );
	                        reject( new Error( `Request timeout for ${ JSON.stringify( _request, null, 4 ) }` ) );
	                        //Todo send abort to avoid future return that won't be processed
	                    }, this.requestTimeout )
	                } );

	                this.postMessageTo( originId, _request );

	            } catch ( error ) {

	                reject( error );

	            }

	        } )

	    }

	    /**
	     *
	     * @param originId
	     * @param request
	     * @param reponse
	     */
	    postResponseTo ( originId, request, reponse ) {

	        const _response = ( reponse && reponse.constructor.isWebAPIMessageResponse ) ? reponse : new WebAPIMessageResponse( request, reponse );
	        this.postMessageTo( originId, _response );

	    }

	    /**
	     *
	     * @param originId
	     * @param error {WebAPIMessageError|String}
	     */
	    postErrorTo ( originId, error ) {

	        const _error = ( error && error.constructor.isWebAPIMessageError ) ? error : new WebAPIMessageError( error );
	        this.postMessageTo( originId, _error );

	    }

	    /**
	     *
	     * @param originId
	     * @param data
	     */
	    postDataTo ( originId, data ) {

	        const _data = ( data && data.constructor.isWebAPIMessageData ) ? data : new WebAPIMessageData( data );
	        this.postMessageTo( originId, _data );

	    }

	    /**
	     *
	     * @param originId
	     * @param message
	     * @param force
	     */
	    postMessageTo ( originId, message, force = false ) {

	        if ( iteeValidators.isNotDefined( originId ) ) { throw new ReferenceError( `[${ this._localOriginUri }]: Unable to post message to null or undefined origin id !` ) }
	        if ( iteeValidators.isNotDefined( message ) ) { throw new ReferenceError( `[${ this._localOriginUri }]: Unable to post null or undefined message !` ) }

	        const origin = this._getAllowedOriginBy( 'id', originId );
	        if ( iteeValidators.isNotDefined( origin ) ) { throw new ReferenceError( `[${ this._localOriginUri }]: Unable to retrieved origin with id: ${ originId }` ) }

	        try {

	            if ( !force && !origin.isReady ) {

	                this.logger.warn( `[${ this._localOriginUri }]: Origin [${ origin.uri }] is not ready yet !` );
	                origin.messageQueue.push( message );

	            } else if ( force && !origin.window ) {

	                this.logger.error( `[${ this._localOriginUri }]: Origin [${ origin.uri }] is unreachable !` );
	                //                origin.isUnreachable = true
	                origin.messageQueue.push( message );

	            } else {

	                this.logger.log( `[${ this._localOriginUri }]: Send message of type '${ message.type }' to [${ origin.uri }]` );
	                origin.window.postMessage( JSON.stringify( message ), origin.uri );

	            }

	        } catch ( error ) {

	            this.logger.error( error );

	        }

	    }

	}

	/**
	 * @author [Tristan Valcke]{@link https://github.com/Itee}
	 */

	/**
	 * @class
	 */
	class WebAPIMessageProgress extends WebAPIMessage {

	    static isWebAPIMessageProgress = true

	    /**
	     *
	     * @param loaded
	     * @param total
	     */
	    constructor ( loaded = 0, total = 0 ) {
	        super( '_progress' );

	        this.lengthComputable = false;
	        this.loaded           = loaded;
	        this.total            = total;
	    }

	    /**
	     *
	     * @returns {*}
	     */
	    get loaded () {
	        return this._loaded
	    }

	    set loaded ( value ) {
	        this._loaded = value;
	        this._checkIfLengthComputable();
	    }

	    /**
	     *
	     * @returns {*}
	     */
	    get total () {
	        return this._total
	    }

	    set total ( value ) {
	        this._total = value;
	        this._checkIfLengthComputable();
	    }

	    /**
	     *
	     * @private
	     */
	    _checkIfLengthComputable () {

	        this.lengthComputable = false;

	        if (
	            this._total > 0 &&
	            this._total < Number.MAX_SAFE_INTEGER &&
	            this._loaded >= 0 &&
	            this._loaded < Number.MAX_SAFE_INTEGER
	        ) {
	            this.lengthComputable = true;
	        }

	    }

	    /**
	     *
	     * @returns {{loaded: *, lengthComputable: boolean, total: *}}
	     */
	    toJSON () {

	        return {
	            ...super.toJSON(),
	            ...{
	                lengthComputable: this.lengthComputable,
	                loaded:           this.loaded,
	                total:            this.total
	            }
	        }

	    }

	}

	/**
	 * @author [Tristan Valcke]{@link https://github.com/Itee}
	 */

	class WorkerMessage {

	    static isWorkerMessage = true

	    constructor ( type ) {

	        this.type = type;

	    }

	    get type () {
	        return this._type
	    }

	    set type ( type ) {
	        this._type = type;
	    }

	    toJSON () {

	        return {
	            type: this.type
	        }

	    }

	}

	/**
	 * @author [Tristan Valcke]{@link https://github.com/Itee}
	 */

	class WorkerMessageData extends WorkerMessage {

	    static isWorkerMessageData = true

	    constructor ( type, buffer ) {
	        super( type );

	        this.buffer = buffer;
	    }

	    toJSON () {

	        return {
	            ...super.toJSON(),
	            ...{
	                buffer: this.buffer
	            }
	        }

	    }

	}

	/**
	 * @author [Tristan Valcke]{@link https://github.com/Itee}
	 */

	class WorkerMessageError extends WorkerMessage {

	    static isWorkerMessageError = true

	    constructor ( error ) {
	        super( 'error' );

	        this.message = error.message;
	        this.stack   = error.stack;
	    }

	    toJSON () {

	        return {
	            ...super.toJSON(),
	            ...{
	                message: this.message,
	                stack:   this.stack
	            }
	        }

	    }

	}

	/**
	 * @author [Tristan Valcke]{@link https://github.com/Itee}
	 */

	class WorkerMessageProgress extends WorkerMessage {

	    static isWorkerMessageProgress = true

	    constructor ( loaded = 0, total = 0 ) {
	        super( 'progress' );

	        this.lengthComputable = false;
	        this.loaded           = loaded;
	        this.total            = total;
	    }

	    get loaded () {
	        return this._loaded
	    }

	    set loaded ( value ) {
	        this._loaded = value;
	        this._checkIfLengthComputable();
	    }

	    get total () {
	        return this._total
	    }

	    set total ( value ) {
	        this._total = value;
	        this._checkIfLengthComputable();
	    }

	    _checkIfLengthComputable () {

	        this.lengthComputable = false;

	        if (
	            this._total > 0 &&
	            this._total < Number.MAX_SAFE_INTEGER &&
	            this._loaded >= 0 &&
	            this._loaded < Number.MAX_SAFE_INTEGER
	        ) {
	            this.lengthComputable = true;
	        }

	    }

	    toJSON () {

	        return {
	            ...super.toJSON(),
	            ...{
	                lengthComputable: this.lengthComputable,
	                loaded:           this.loaded,
	                total:            this.total
	            }
	        }

	    }

	}

	/**
	 * @author [Tristan Valcke]{@link https://github.com/Itee}
	 */

	/**
	 * @class
	 * @classdesc Base worker interface that allow messaging between callee and caller
	 */
	class AbstractWorker {

	    /**
	     *
	     * @param progress
	     */
	    postProgress ( progress ) {

	        if ( progress.isWorkerMessageProgress ) {
	            postMessage( progress.toJSON() );
	        } else {
	            postMessage( new WorkerMessageProgress( progress.loaded, progress.total ).toJSON() );
	        }

	    }

	    /**
	     *
	     * @param error
	     */
	    postError ( error ) {

	        if ( error.isWorkerMessageError ) {
	            postMessage( error.toJSON() );
	        } else {
	            postMessage( new WorkerMessageError( error ).toJSON() );
	        }

	    }

	    /**
	     *
	     * @param type
	     * @param arrayBuffer
	     */
	    postData ( type, arrayBuffer ) {

	        if ( iteeValidators.isArray( arrayBuffer ) ) {
	            postMessage( new WorkerMessageData( type, arrayBuffer ).toJSON(), [ ...arrayBuffer ] );
	        } else if ( iteeValidators.isArrayBuffer( arrayBuffer ) ) {
	            postMessage( new WorkerMessageData( type, arrayBuffer ).toJSON(), [ arrayBuffer ] );
	        } else {
	            throw new TypeError( `AbstractWorker.postData: Unable to post data of type [${ type }].` )
	        }

	    }

	    /**
	     *
	     * @param message
	     * @returns {boolean}
	     */
	    onMessage ( message ) {

	        if ( iteeValidators.isNotDefined( message ) ) {
	            this.postError( new Error( 'Message event cannot be null or undefined !' ) );
	            return true
	        }

	        const data = message.data;
	        if ( iteeValidators.isNotDefined( data ) ) {
	            this.postError( new Error( 'Message data cannot be null or undefined !' ) );
	            return true
	        }

	        const dataType = data.type;
	        if ( iteeValidators.isNotDefined( dataType ) ) {
	            this.postError( new Error( 'Message data type cannot be null or undefined !' ) );
	            return true
	        }

	        if ( data.type === 'methodCall' ) {

	            const methodName = data.method;
	            if ( iteeValidators.isNotDefined( methodName ) ) {
	                this.postError( new Error( 'Message of type "methodCall" cannot have null, undefined or empty name !' ) );
	                return true
	            }

	            if ( iteeValidators.isNotString( methodName ) ) {
	                this.postError( new Error( 'Message of type "methodCall" expect name to be a string !' ) );
	                return true
	            }

	            if ( iteeValidators.isEmptyString( methodName ) ) {
	                this.postError( new Error( 'Message of type "methodCall" expect name to be a non empty string !' ) );
	                return true
	            }

	            const methodParameters = data.parameters || [];
	            if ( iteeValidators.isNotArray( methodParameters ) ) {
	                this.postError( new Error( 'Message of type "methodCall" expect parameters to be an array !' ) );
	                return true
	            }

	            this._invoke( methodName, methodParameters );
	            return true

	        }

	    }

	    /**
	     *
	     * @param name
	     * @param parameters
	     * @private
	     */
	    _invoke ( name, parameters = [] ) {

	        try {

	            const result = this[ name ]( ...parameters );
	            if ( result ) {
	                postMessage( {
	                    type:   name,
	                    result: result
	                } );
	            }

	        } catch ( error ) {
	            this.postError( error );
	        }

	    }

	}

	/**
	 * @author [Tristan Valcke]{@link https://github.com/Itee}
	 */

	class WorkerMessageMethodCall extends WorkerMessage {

	    static isWorkerMessageMethodCall = true

	    constructor ( method, parameters = [] ) {
	        super( 'methodCall' );

	        this.method     = method;
	        this.parameters = parameters;
	    }

	    get method () {
	        return this._method
	    }

	    set method ( value ) {
	        if ( iteeValidators.isNull( value ) ) { return }
	        if ( iteeValidators.isUndefined( value ) ) { return }
	        if ( iteeValidators.isNotString( value ) ) { return }

	        this._method = value;
	    }

	    get parameters () {
	        return this._parameters
	    }

	    set parameters ( value ) {
	        if ( iteeValidators.isNotArray( value ) ) { return }

	        this._parameters = value;
	    }

	    toJSON () {

	        return {
	            ...super.toJSON(),
	            ...{
	                method:     this.method,
	                parameters: this.parameters
	            }
	        }

	    }

	}

	exports.AbstractWorker = AbstractWorker;
	exports.Byte = Byte;
	exports.Endianness = Endianness;
	exports.FileFormat = FileFormat;
	exports.HttpStatusCode = HttpStatusCode;
	exports.HttpVerb = HttpVerb;
	exports.Keys = Keys;
	exports.MimeType = MimeType;
	exports.Mouse = Mouse;
	exports.ResponseType = ResponseType;
	exports.TAbstractFactory = TAbstractFactory;
	exports.TBinaryReader = TBinaryReader;
	exports.TCloningFactory = TCloningFactory;
	exports.TDataBaseManager = TDataBaseManager;
	exports.TIdFactory = TIdFactory;
	exports.TIdFactoryType = TIdFactoryType;
	exports.TInstancingFactory = TInstancingFactory;
	exports.TKeyboardController = TKeyboardController;
	exports.TMouseController = TMouseController;
	exports.TStore = TStore;
	exports.WebAPI = WebAPI;
	exports.WebAPIMessage = WebAPIMessage;
	exports.WebAPIMessageData = WebAPIMessageData;
	exports.WebAPIMessageError = WebAPIMessageError;
	exports.WebAPIMessageProgress = WebAPIMessageProgress;
	exports.WebAPIMessageReady = WebAPIMessageReady;
	exports.WebAPIMessageRequest = WebAPIMessageRequest;
	exports.WebAPIMessageResponse = WebAPIMessageResponse;
	exports.WorkerMessage = WorkerMessage;
	exports.WorkerMessageData = WorkerMessageData;
	exports.WorkerMessageError = WorkerMessageError;
	exports.WorkerMessageMethodCall = WorkerMessageMethodCall;
	exports.WorkerMessageProgress = WorkerMessageProgress;

	Object.defineProperty(exports, '__esModule', { value: true });

	return exports;

})({}, Itee.Utils, Itee.Validators, Itee.Core);
//# sourceMappingURL=itee-client.iife.js.map
